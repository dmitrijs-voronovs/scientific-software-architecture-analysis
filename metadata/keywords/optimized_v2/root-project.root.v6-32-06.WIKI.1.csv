quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," THttpEngine(const THttpEngine&); virtual~THttpEngine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpEngine.html:1281,Error,Error,1281,root/html534/THttpEngine.html,https://root.cern,https://root.cern/root/html534/THttpEngine.html,1,['Error'],['Error']
Availability," TInetAddress(); TInetAddress(const TInetAddress& adr); virtual~TInetAddress(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInetAddress.html:1396,error,error,1396,root/html528/TInetAddress.html,https://root.cern,https://root.cern/root/html528/TInetAddress.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TInterpreter.; Definition at line 8500 of file TCling.cxx. ◆ BaseClassInfo_Offset(). Longptr_t TCling::BaseClassInfo_Offset ; (; BaseClassInfo_t * ; toBaseClassInfo, . void * ; address, . bool ; isDerivedObject . ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8508 of file TCling.cxx. ◆ BaseClassInfo_Property(). Long_t TCling::BaseClassInfo_Property ; (; BaseClassInfo_t * ; bcinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8529 of file TCling.cxx. ◆ BaseClassInfo_Tagnum(). Longptr_t TCling::BaseClassInfo_Tagnum ; (; BaseClassInfo_t * ; bcinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8545 of file TCling.cxx. ◆ BaseClassInfo_TmpltName(). const char * TCling::BaseClassInfo_TmpltName ; (; BaseClassInfo_t * ; bcinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 8571 of file TCling.cxx. ◆ Calc(). Longptr_t TCling::Calc ; (; const char * ; line, . EErrorCode * ; error = nullptr . ). finalvirtual . Directly execute an executable statement (e.g. ; ""func()"", ""3+5"", etc. however not declarations, like ""Int_t x;""). ; Implements TInterpreter.; Definition at line 3585 of file TCling.cxx. ◆ CallFunc_Delete(). void TCling::CallFunc_Delete ; (; CallFunc_t * ; func); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7843 of file TCling.cxx. ◆ CallFunc_Exec() [1/2]. void TCling::CallFunc_Exec ; (; CallFunc_t * ; func, . void * ; address . ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7850 of file TCling.cxx. ◆ CallFunc_Exec() [2/2]. void TCling::CallFunc_Exec ; (; CallFunc_t * ; func, . void * ; address, . TInterpreterValue & ; val . ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7858 of file TCling.cxx. ◆ CallFunc_ExecDouble(). Double_t TCling::CallFunc_ExecDouble ; (; CallFunc_t * ; func, . void * ; address . ); const. finalvirtual . Reimplemented from TInterpreter.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:58732,error,error,58732,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['error'],['error']
Availability," TInterpreter::BaseClassInfo_Nextvirtual int BaseClassInfo_Next(BaseClassInfo_t *, int) constDefinition TInterpreter.h:445; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::SetClassAutoloadingint SetClassAutoloading(int a) constDefinition TInterpreter.h:265; TInterpreter::GenerateDictionaryvirtual Int_t GenerateDictionary(const char *classes, const char *includes=nullptr, const char *options=nullptr)=0; TInterpreter::TypedefInfo_Propertyvirtual Long_t TypedefInfo_Property(TypedefInfo_t *) constDefinition TInterpreter.h:546; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Double_t) const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::CallFunc_SetFuncProtovirtual void CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const std::vector< TypeInfo_t * > &proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const =0; TInterpreter::GetSharedLibDepsvirtual const char * GetSharedLibDeps(const char *lib, bool tryDyld=false)=0; TInterpreter::GetFunctionvirtual DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname)=0; TInterpreter::Executevoid Execute(TMethod *method, TObjArray *params, int *error=nullptr) override=0Execute method on this object with parameters stored in the TObjArray.; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::GetIncludePathvirtual const char * GetIncludePath()=0; TInterpreter::CodeCompletevirtual void CodeComplete(const std::string &, size_t &, std::vector< std::string > &)Definition TInterpreter.h:279; TInterpreter::TypedefInfo_IsValidvirtual Bool_t TypedefInfo_IsValid(TypedefInfo_t *) constDefinition TInterpreter.h:544; TInterpreter::AutoLoadvirtual Int_t AutoLoad(const std::type_info &typeinfo, Bool_t knowDictNotLoaded=kFALSE)=0; TInterpreter::TypeInfo_Namevirtual const char * TypeInfo_Name(TypeInfo_t *) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:47434,error,error,47434,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['error'],['error']
Availability," TKDTreeBinning(UInt_t dataSize, UInt_t dataDim, Double_t* data, UInt_t nBins = 100, bool adjustBinEdges = false); virtual~TKDTreeBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::Dist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKDTreeBinning.html:2264,Error,Error,2264,root/html532/TKDTreeBinning.html,https://root.cern,https://root.cern/root/html532/TKDTreeBinning.html,2,['Error'],['Error']
Availability," TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* remov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TObject.html:17086,error,error,17086,root/html534/TObject.html,https://root.cern,https://root.cern/root/html534/TObject.html,6,['error'],['error']
Availability," TKeyMapFile(); TKeyMapFile(const char* name, const char* classname, TMapFile* mapfile); virtual~TKeyMapFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKeyMapFile.html:1566,Error,Error,1566,root/html532/TKeyMapFile.html,https://root.cern,https://root.cern/root/html532/TKeyMapFile.html,2,['Error'],['Error']
Availability," TLDAPEntry(const char* dn); TLDAPEntry(const TLDAPEntry& e); virtual~TLDAPEntry(); voidTObject::AbstractMethod(const char* method) const; voidAddAttribute(const TLDAPAttribute& attr); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAttribute(const char* name); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPAttribute*GetAttribute() const; TLDAPAttribute*GetAttribute(const char* name) const; Int_tGetCount() const; const char*GetDn() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLDAPEntry.html:1278,Error,Error,1278,root/html532/TLDAPEntry.html,https://root.cern,https://root.cern/root/html532/TLDAPEntry.html,1,['Error'],['Error']
Availability," TLeaf(); TLeaf(TBranch* parent, const char* name, const char* type); virtual~TLeaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeaf.html:1387,error,error,1387,root/html528/TLeaf.html,https://root.cern,https://root.cern/root/html528/TLeaf.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TLeafB(); TLeafB(const TLeafB&); TLeafB(TBranch* parent, const char* name, const char* type); virtual~TLeafB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafB.html:1249,Error,Error,1249,root/html532/TLeafB.html,https://root.cern,https://root.cern/root/html532/TLeafB.html,2,['Error'],['Error']
Availability," TLeafC(); TLeafC(const TLeafC&); TLeafC(TBranch* parent, const char* name, const char* type); virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafC.html:1247,Error,Error,1247,root/html532/TLeafC.html,https://root.cern,https://root.cern/root/html532/TLeafC.html,2,['Error'],['Error']
Availability," TLeafD(); TLeafD(const TLeafD&); TLeafD(TBranch* parent, const char* name, const char* type); virtual~TLeafD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafD.html:1256,Error,Error,1256,root/html532/TLeafD.html,https://root.cern,https://root.cern/root/html532/TLeafD.html,2,['Error'],['Error']
Availability," TLeafElement(); TLeafElement(const TLeafElement&); TLeafElement(TBranch* parent, const char* name, Int_t id, Int_t type); virtual~TLeafElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafElement.html:1372,Error,Error,1372,root/html532/TLeafElement.html,https://root.cern,https://root.cern/root/html532/TLeafElement.html,2,['Error'],['Error']
Availability," TLeafF(); TLeafF(const TLeafF&); TLeafF(TBranch* parent, const char* name, const char* type); virtual~TLeafF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafF.html:1256,Error,Error,1256,root/html532/TLeafF.html,https://root.cern,https://root.cern/root/html532/TLeafF.html,2,['Error'],['Error']
Availability," TLeafI(); TLeafI(const TLeafI&); TLeafI(TBranch* parent, const char* name, const char* type); virtual~TLeafI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafI.html:1243,Error,Error,1243,root/html532/TLeafI.html,https://root.cern,https://root.cern/root/html532/TLeafI.html,2,['Error'],['Error']
Availability," TLeafL(); TLeafL(const TLeafL&); TLeafL(TBranch* parent, const char* name, const char* type); virtual~TLeafL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafL.html:1249,Error,Error,1249,root/html532/TLeafL.html,https://root.cern,https://root.cern/root/html532/TLeafL.html,2,['Error'],['Error']
Availability," TLeafO(); TLeafO(const TLeafO&); TLeafO(TBranch* parent, const char* name, const char* type); virtual~TLeafO(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafO.html:1239,Error,Error,1239,root/html532/TLeafO.html,https://root.cern,https://root.cern/root/html532/TLeafO.html,2,['Error'],['Error']
Availability," TLeafObject(); TLeafObject(const TLeafObject&); TLeafObject(TBranch* parent, const char* name, const char* type); virtual~TLeafObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafObject.html:1300,Error,Error,1300,root/html532/TLeafObject.html,https://root.cern,https://root.cern/root/html532/TLeafObject.html,2,['Error'],['Error']
Availability," TLeafS(); TLeafS(const TLeafS&); TLeafS(TBranch* parent, const char* name, const char* type); virtual~TLeafS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafS.html:1249,Error,Error,1249,root/html532/TLeafS.html,https://root.cern,https://root.cern/root/html532/TLeafS.html,2,['Error'],['Error']
Availability," TLibraryDocInfo(); TLibraryDocInfo(const char* lib); TLibraryDocInfo(const TLibraryDocInfo&); ~TLibraryDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLibraryDocInfo.html:1322,Error,Error,1322,root/html532/TLibraryDocInfo.html,https://root.cern,https://root.cern/root/html532/TLibraryDocInfo.html,2,['Error'],['Error']
Availability," TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLinearMinimizer.html:1358,Error,ErrorDef,1358,root/html534/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html,2,['Error'],"['ErrorDef', 'Errors']"
Availability," TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLinearMinimizer.html:1334,Error,ErrorDef,1334,root/html532/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html532/TLinearMinimizer.html,2,['Error'],"['ErrorDef', 'Errors']"
Availability," TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLockFile.html:1569,error,error,1569,root/html528/TLockFile.html,https://root.cern,https://root.cern/root/html528/TLockFile.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TMVA::DNN::applyWeightsBackwards ; (; ItSource ; itCurrBegin, . ItSource ; itCurrEnd, . ItWeight ; itWeight, . ItPrev ; itPrevBegin, . ItPrev ; itPrevEnd . ). ◆ applyWeightsBackwards() [2/2]. template<bool HasDropOut, typename ItSource , typename ItWeight , typename ItPrev , typename ItDrop > . void TMVA::DNN::applyWeightsBackwards ; (; ItSource ; itCurrBegin, . ItSource ; itCurrEnd, . ItWeight ; itWeight, . ItPrev ; itPrevBegin, . ItPrev ; itPrevEnd, . ItDrop ; itDrop . ). apply weights backwards (for backprop); for no drop out, provide (&bool = true) to itDrop such that *itDrop becomes ""true"" ; itDrop correlates with itPrev (to be in agreement with ""applyWeights"" where it correlates with itSources (same node as itTarget here in applyBackwards) ; Definition at line 118 of file NeuralNet.icc. ◆ backward(). template<typename LAYERDATA > . void TMVA::DNN::backward ; (; LAYERDATA & ; prevLayerData, . LAYERDATA & ; currLayerData . ). backward application of the weights (back-propagation of the error) ; Definition at line 572 of file NeuralNet.icc. ◆ computeRegularization(). template<EnumRegularization Regularization> . double TMVA::DNN::computeRegularization ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . compute the regularization (L1, L2) ; Definition at line 209 of file NeuralNet.icc. ◆ computeRegularization< EnumRegularization::L1 >(). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L1 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 219 of file NeuralNet.icc. ◆ computeRegularization< EnumRegularization::L2 >(). template<> . double TMVA::DNN::computeRegularization< EnumRegularization::L2 > ; (; double ; weight, . const double & ; factorWeightDecay . ). inline . Definition at line 226 of file NeuralNet.icc. ◆ crossEntropy(). template<typename ItProbability , typename ItTruth , typename ItDelta , typename ItInvActFnc > . double TMVA::DNN::crossEntropy ; (; ItProbability ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:26080,error,error,26080,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['error'],['error']
Availability," TMVA::MethodMLP::ComputeDEDw ; (; ). private . Definition at line 697 of file MethodMLP.cxx. ◆ ComputeEstimator(). Double_t TMVA::MethodMLP::ComputeEstimator ; (; std::vector< Double_t > & ; parameters). this function is called by GeneticANN for GA optimization ; Definition at line 1393 of file MethodMLP.cxx. ◆ DecaySynapseWeights(). void TMVA::MethodMLP::DecaySynapseWeights ; (; Bool_t ; lateEpoch). private . decay synapse weights in last 10 epochs, lower learning rate even more to find a good minimum ; Definition at line 1208 of file MethodMLP.cxx. ◆ DeclareOptions(). void TMVA::MethodMLP::DeclareOptions ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; know options:. TrainingMethod <string> Training method available values are:; BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs; BPMode <string> Back-propagation learning mode available values are:; sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events . Reimplemented from TMVA::MethodANNBase.; Definition at line 195 of file MethodMLP.cxx. ◆ DeclFileName(). static const char * TMVA::MethodMLP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 219 of file MethodMLP.h. ◆ DerivDir(). Double_t TMVA::MethodMLP::DerivDir ; (; TMatrixD & ; Dir). private . Definition at line 825 of file MethodMLP.cxx. ◆ EstimatorFunction(). Double_t TMVA::MethodMLP::EstimatorFunction ; (; std::vector< Double_t > & ; parameters). virtual . interface to the estimate ; Implements TMVA::IFitterTarget.; Definition at line 1385 of file MethodMLP.cxx. ◆ GeneticMinimize(). void TMVA::MethodMLP::GeneticMinimize ; (; ). private . create genetics class similar t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:41969,avail,available,41969,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['avail'],['available']
Availability," TMacro(); TMacro(const TMacro&); TMacro(const char* name, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMacro.html:2315,Error,Error,2315,root/html532/TMacro.html,https://root.cern,https://root.cern/root/html532/TMacro.html,2,['Error'],['Error']
Availability," TMacro.h:31; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; mTMarker mDefinition textangle.C:8. Definition at line 31 of file TMacro.h. Public Member Functions;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual Longptr_t Exec (const char *params=nullptr, Int_t *error=nullptr);  Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save macro source on stream out. ;  ; virtual void SaveSource (const char *filename);  Save macro source in filename. ;  ; virtual void SetParams (const char *params=nullptr);  Set default parameters to execute this macro. ;  ; void Streamer (TBuffer &) ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:2600,error,error,2600,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['error'],['error']
Availability," TMarker(); TMarker(const TMarker& marker); TMarker(Double_t x, Double_t y, Int_t marker); virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMarker.html:1417,Error,Error,1417,root/html532/TMarker.html,https://root.cern,https://root.cern/root/html532/TMarker.html,1,['Error'],['Error']
Availability," TMarker(); TMarker(const TMarker& marker); TMarker(Double_t x, Double_t y, Int_t marker); virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMarker.html:1436,Error,Error,1436,root/html534/TMarker.html,https://root.cern,https://root.cern/root/html534/TMarker.html,1,['Error'],['Error']
Availability," TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::GhbarCconstexpr Double_t GhbarC()inDefinition TMath.h:158; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; TMath::HbarUncertaintyconstexpr Double_t HbarUncertainty()uncertainty.Definition TMath.h:225; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; TMath::ErfcInverseDouble_t ErfcInverse(Double_t x)Returns the inverse of the complementary error function.Definition TMath.cxx:242; TMath::SinHDouble_t SinH(Double_t)Returns the hyperbolic sine of `x.Definition TMath.h:606; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; TMath::LimitsDefinition TMath.h:407; TMath::Limits::Minstatic T Min()Returns maximum representation for type T.Definition TMath.h:925; TMath::Limits::Epsilonstatic T Epsilon()Returns minimum double representation.Definition TMath.h:941; TMath::Limits::Maxstatic T Max()Returns minimum double representation.Definition TMath.h:933; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincTMath.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:73474,error,error,73474,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['error'],['error']
Availability," TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208Double_t TMath::ErfInverse(Double_t x); 209{; 210 Int_t kMaxit = 50;; 211 Double_t kEps = 1e-14;; 212 Double_t kConst = 0.8862269254527579; // sqrt(pi)/2.0; 213 ; 214 if(TMath::Abs(x) <= kEps) return kConst*x;; 215 ; 216 // Newton iterations; 217 Double_t erfi, derfi, y0,y1,dy0,dy1;; 218 if(TMath::Abs(x) < 1.0) {; 219 erfi = kConst*TMath::Abs(x);; 220 y0 = TMath::Erf(0.9*erfi);; 221 derfi = 0.1*erfi;; 222 for (Int_t iter=0; iter<kMaxit; iter++) {; 223 y1 = 1. - TMath::Erfc(erfi);; 224 dy1 = TMath::Abs(x) - y1;; 225 if (TMath::Abs(dy1) < kEps) {if (x < 0) return -erfi; else return erfi;}; 226 dy0 = y1 - y0;; 227 derfi *= dy1/dy0;; 228 y0 = y1;; 229 erfi += derfi;; 230 if(TMath::Abs(derfi/erfi) < kEps) {if (x < 0) return -erfi; else return erfi;}; 231 }; 232 }; 233 return 0; //did not converge; 234}; 235",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:6089,error,error,6089,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability," TMemStatShow(); TMemStatShow(const TMemStatShow&); virtual~TMemStatShow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemStatShow.html:1232,Error,Error,1232,root/html532/TMemStatShow.html,https://root.cern,https://root.cern/root/html532/TMemStatShow.html,2,['Error'],['Error']
Availability," TMethod(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethod.html:1456,Error,Error,1456,root/html532/TMethod.html,https://root.cern,https://root.cern/root/html532/TMethod.html,1,['Error'],['Error']
Availability," TMethod(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethod.html:1495,Error,Error,1495,root/html534/TMethod.html,https://root.cern,https://root.cern/root/html534/TMethod.html,1,['Error'],['Error']
Availability," TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethodArg.html:1477,Error,Error,1477,root/html532/TMethodArg.html,https://root.cern,https://root.cern/root/html532/TMethodArg.html,1,['Error'],['Error']
Availability," TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethodArg.html:1516,Error,Error,1516,root/html534/TMethodArg.html,https://root.cern,https://root.cern/root/html534/TMethodArg.html,1,['Error'],['Error']
Availability," TMinuit2TraceObject(int parNumber = -1); TMinuit2TraceObject(const TMinuit2TraceObject&); virtual~TMinuit2TraceObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuit2TraceObject.html:1276,Error,Error,1276,root/html534/TMinuit2TraceObject.html,https://root.cern,https://root.cern/root/html534/TMinuit2TraceObject.html,1,['Error'],['Error']
Availability," TMinuit::mnhelp for the full list of available commands See also the complete documentation of all the available commands; Returns the status of the execution:; 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command . Definition at line 626 of file TMinuit.cxx. ◆ Contour(). TObject * TMinuit::Contour ; (; Int_t ; npoints = 10, . Int_t ; pa1 = 0, . Int_t ; pa2 = 1 . ). virtual . Creates a TGraph object describing the n-sigma contour of a TMinuit fit. ; The contour of the parameters pa1 and pa2 is calculated using npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints) The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set to n^2. The fcn function has to be set before the routine is called.; The TGraph object is created via the interpreter. The user must cast it to a TGraph*. Note that the TGraph is created with npoints+1 in order to close the contour (setting last point equal to first point).; You can find an example in $ROOTSYS/tutorials/fit/fitcont.C ; Definition at line 653 of file TMinuit.cxx. ◆ DeclFileName(). static const char * TMinuit::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 268 of file TMinuit.h. ◆ DefineParameter(). Int_t TMinuit::DefineParameter ; (; Int_t ; parNo, . const char * ; name, . Double_t ; initVal, . Double_t ; initErr, . Double_t ; lowerLimit, . Double_t ; upperLimit . ). virtual . Define a parameter. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:39448,error,errors,39448,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['errors']
Availability," TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolFixVariable(unsigned int); virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual boolGetVariableSettings(unsigned int, ROOT::Fit::ParameterSettings&) const; virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; virtual boolIsFixedVariable(unsigned int) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuitMinimizer.html:1283,Error,ErrorDef,1283,root/html534/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html534/TMinuitMinimizer.html,2,['Error'],"['ErrorDef', 'Errors']"
Availability," TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::Mini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:1283,Error,ErrorDef,1283,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,2,['Error'],"['ErrorDef', 'Errors']"
Availability," TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMixture.html:1347,Error,Error,1347,root/html532/TMixture.html,https://root.cern,https://root.cern/root/html532/TMixture.html,2,['Error'],['Error']
Availability," TModuleDocInfo(const char* name, TModuleDocInfo* super, const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TModuleDocInfo.html:1929,Error,Error,1929,root/html532/TModuleDocInfo.html,https://root.cern,https://root.cern/root/html532/TModuleDocInfo.html,2,['Error'],['Error']
Availability," TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMonaLisaText.html:1905,Error,Error,1905,root/html532/TMonaLisaText.html,https://root.cern,https://root.cern/root/html532/TMonaLisaText.html,1,['Error'],['Error']
Availability," TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaValue.html:2000,error,error,2000,root/html530/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html530/TMonaLisaValue.html,4,"['Error', 'error']","['Error', 'error']"
Availability," TMutex(Bool_t recursive = kFALSE); virtual~TMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tTVirtualMutex::Acquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t recursive = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMutex.html:1381,Error,Error,1381,root/html532/TMutex.html,https://root.cern,https://root.cern/root/html532/TMutex.html,2,['Error'],['Error']
Availability," TMySQLResult(void* result); TMySQLResult(const TMySQLResult&); virtual~TMySQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMySQLResult.html:1246,Error,Error,1246,root/html532/TMySQLResult.html,https://root.cern,https://root.cern/root/html532/TMySQLResult.html,2,['Error'],['Error']
Availability," TMySQLRow(const TMySQLRow&); TMySQLRow(void* result, ULong_t rowHandle); virtual~TMySQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMySQLRow.html:1241,Error,Error,1241,root/html532/TMySQLRow.html,https://root.cern,https://root.cern/root/html532/TMySQLRow.html,2,['Error'],['Error']
Availability," TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); virtual~TMySQLStatement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTSQLStatement::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static ULong_tGetAllocSizeLimit(); virtual Bool_tGetBinary(Int_t npar, void*& mem, Long_t& size); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMySQLStatement.html:1404,Error,Error,1404,root/html534/TMySQLStatement.html,https://root.cern,https://root.cern/root/html534/TMySQLStatement.html,1,['Error'],['Error']
Availability," TNamed(); TNamed(const TNamed& named); TNamed(const char* name, const char* title); TNamed(const TString& name, const TString& title); virtual~TNamed(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNamed.html:1517,Error,Error,1517,root/html532/TNamed.html,https://root.cern,https://root.cern/root/html532/TNamed.html,2,['Error'],['Error']
Availability," TNamed(const char* name, const char* title); TNamed(const TString& name, const TString& title); virtual~TNamed(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNamed.html:1646,error,error,1646,root/html528/TNamed.html,https://root.cern,https://root.cern/root/html528/TNamed.html,6,['error'],['error']
Availability," TNetFileStager(const char* stager = """"); TNetFileStager(const TNetFileStager&); virtual~TNetFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFileStager.html:1275,Error,Error,1275,root/html532/TNetFileStager.html,https://root.cern,https://root.cern/root/html532/TNetFileStager.html,2,['Error'],['Error']
Availability," TNetXNGFileStager(const char* url = """"); TNetXNGFileStager(const TNetXNGFileStager&); virtual~TNetXNGFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFileStager.html:1392,Error,Error,1392,root/html534/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html534/TNetXNGFileStager.html,1,['Error'],['Error']
Availability," TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); virtual~TNeuron(); voidTObject::AbstractMethod(const char* method) const; voidAddInLayer(TNeuron*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNeuron.html:2017,Error,Error,2017,root/html532/TNeuron.html,https://root.cern,https://root.cern/root/html532/TNeuron.html,2,['Error'],['Error']
Availability," TObjArray * SQLObjectsInfo (Long64_t keyid);  Produce array of TSQLObjectInfo objects for all objects, belong to that key Array should be deleted by calling function afterwards. ;  ; TSQLResult * SQLQuery (const char *cmd, Int_t flag=0, Bool_t *res=nullptr);  Submits query to SQL server. ;  ; const char * SQLRawIdColumn () const;  ; Bool_t SQLRollback ();  Rollback all SQL operations, done after start transaction. ;  ; const char * SQLSmallTextType () const;  ; Int_t SQLSmallTextTypeLimit () const;  ; Bool_t SQLStartTransaction ();  Start SQL transaction. ;  ; TSQLStatement * SQLStatement (const char *cmd, Int_t bufsize=1000);  Produces SQL statement for currently conected DB server. ;  ; const char * SQLStrIdColumn () const;  ; Bool_t SQLTestTable (const char *tablename);  Test, if table of specified name exists. ;  ; const char * SQLValueQuote () const;  ; Long64_t StoreObjectInTables (Long64_t keyid, const void *obj, const TClass *cl);  Store object in database. Return stored object id or -1 if error. ;  ; Int_t StreamKeysForDirectory (TDirectory *dir, Bool_t doupdate, Long64_t specialkeyid=-1, TKeySQL **specialkey=nullptr);  read keys for specified directory (when update == kFALSE) or update value for modified keys when update == kTRUE Returns number of successfully read keys or -1 if error ;  ; Int_t SysClose (Int_t) final;  Interface to system close. All arguments like in POSIX close(). ;  ; Int_t SysOpen (const char *, Int_t, UInt_t) final;  Interface to system open. All arguments like in POSIX open(). ;  ; Int_t SysRead (Int_t, void *, Int_t) final;  Interface to system read. All arguments like in POSIX read(). ;  ; Long64_t SysSeek (Int_t, Long64_t, Int_t) final;  Interface to system lseek. ;  ; Int_t SysStat (Int_t, Long_t *, Long64_t *, Long_t *, Long_t *) final;  Return file stat information. ;  ; Int_t SysSync (Int_t) final;  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; Int_t SysWrite (Int_t, const void *, Int_t) final;  Interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:47692,error,error,47692,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['error'],['error']
Availability," TObjArray* SQLObjectsInfo(Long64_t keyid); Produce array of TSQLObjectInfo objects for all objects, belong to that key; Array should be deleted by calling function afterwards. TSQLResult* GetNormalClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request result for specified objid from normal classtable. TSQLResult* GetNormalClassDataAll(Long64_t minobjid, Long64_t maxobjid, TSQLClassInfo* sqlinfo); return data for several objects from the range from normal class table. TSQLResult* GetBlobClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable. TSQLStatement* GetBlobClassDataStmt(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable; Data returned in form of statement, where direct access to values are possible. Long64_t StoreObjectInTables(Long64_t keyid, const void* obj, const TClass* cl); Store object in database. Return stored object id or -1 if error. const char* SQLCompatibleType(Int_t typ) const; returns sql type name which is most closer to ROOT basic type; typ should be from TVirtualStreamerInfo:: constansts like TVirtualStreamerInfo::kInt. const char* SQLIntType() const; return SQL integer type. Long64_t DirCreateEntry(TDirectory* ); Create entry for directory in database. Int_t DirReadKeys(TDirectory* ); Read directory list of keys from database. void DirWriteKeys(TDirectory* ); Write directory keys list to database. void DirWriteHeader(TDirectory* ); Update dir header in the file. void Streamer(TBuffer& ); streamer for TSQLFile class; stores only data for TDirectory. Int_t SysOpen(const char* , Int_t , UInt_t ); Interface to basic system I/O routines, suppressed. { return 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:46508,error,error,46508,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,6,['error'],['error']
Availability," TObjArray* SQLObjectsInfo(Long64_t keyid); Produce array of TSQLObjectInfo objects for all objects, belong to that key; Array should be deleted by calling function afterwards. TSQLResult* GetNormalClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request result for specified objid from normal classtable. TSQLResult* GetNormalClassDataAll(Long64_t minobjid, Long64_t maxobjid, TSQLClassInfo* sqlinfo); return data for several objects from the range from normal class table. TSQLResult* GetBlobClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable. TSQLStatement* GetBlobClassDataStmt(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable; Data returned in form of statement, where direct access to values are possible. Long64_t StoreObjectInTables(Long64_t keyid, const void* obj, const TClass* cl); Store object in database. Return stored object id or -1 if error. const char* SQLCompatibleType(Int_t typ) const; returns sql type name which is most closer to ROOT basic type; typ should be from TVirtualStreamerInfo:: constansts like TVirtualStreamerInfo::kInt. const char* SQLIntType() const; return SQL integer type. Long64_t DirCreateEntry(TDirectory* ); Create entry for directory in database. Int_t DirReadKeys(TDirectory* ); Read directory list of keys from database. void DirWriteKeys(TDirectory* ); Write directory keys list to database. void DirWriteHeader(TDirectory* ); Update dir header in the file. void Streamer(TBuffer& b); streamer for TSQLFile class; stores only data for TDirectory. Int_t SysOpen(const char* , Int_t , UInt_t ); Interface to basic system I/O routines, suppressed. { return 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:45768,error,error,45768,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,3,['error'],['error']
Availability," TObjString(const char* s = """"); TObjString(const TObjString& s); virtual~TObjString(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjString.html:1396,error,error,1396,root/html528/TObjString.html,https://root.cern,https://root.cern/root/html528/TObjString.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TObject *obj) const overrideTCollectionvirtual; Compress()TObjArrayvirtual; Contains(const char *name) constTCollectioninline; Contains(const TObject *obj) constTCollectioninline; Copy(TObject &object) constTObjectvirtual; DeclFileName()TObjArrayinlinestatic; Delete(Option_t *option="""") overrideTObjArrayvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""") overrideTCollectionvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() const overrideTCollectionvirtual; EDeprecatedStatusBits enum nameTObject; EmptyGarbageCollection()TCollectionstatic; end() constTCollectioninline; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTCollectionprotected; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Expand(Int_t newSize)TObjArrayvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fContTObjArrayprotected; fgCurrentCollectionTCollectionprivatestatic; fgDtorOnlyTObjectprivatestatic; fgEmptyingGarbageTCollectionprivatestatic; fgGarbageCollectionTCollectionprivatestatic; fgGarbageStackTCollectionprivatestatic; fgObjectStatTObjectprivatestatic; FindObject(const char *name) const overrideTObjArrayvirtual; FindObject(const TObject *obj) const overrideTObjArrayvirtual; First() const overrideTObjArrayvirtual; fLastTObjArrayprotected; fLowerBoundTObjArrayprotected; fNameTCollectionprotected; fSizeTCollectionprotected; fSortedTSeqCollectionprotected; fUniqueIDTObjectprivate; GarbageCollect(TObject *obj)TCollectionstatic; GetAbsLast() constTObjArrayprotected; GetCollectionEntryName(TObject *entry) constTCollectionprotectedvirtual; GetCurrentCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray-members.html:2612,error,error,2612,doc/master/classTObjArray-members.html,https://root.cern,https://root.cern/doc/master/classTObjArray-members.html,2,['error'],['error']
Availability," TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:1631,error,error,1631,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,12,['error'],['error']
Availability," TObject();; 112 TObject(const TObject &object);; 113 TObject &operator=(const TObject &rhs);; 114 virtual ~TObject();; 115 ; 116 virtual void AppendPad(Option_t *option="""");; 117 virtual void Browse(TBrowser *b);; 118 virtual const char *ClassName() const;; 119 virtual void Clear(Option_t * /*option*/ ="""") { }; 120 ULong_t CheckedHash(); // Not virtual; 121 virtual TObject *Clone(const char *newname="""") const;; 122 virtual Int_t Compare(const TObject *obj) const;; 123 virtual void Copy(TObject &object) const;; 124 virtual void Delete(Option_t *option=""""); // *MENU*; 125 virtual Int_t DistancetoPrimitive(Int_t px, Int_t py);; 126 virtual void Draw(Option_t *option="""");; 127 virtual void DrawClass() const; // *MENU*; 128 virtual TObject *DrawClone(Option_t *option="""") const; // *MENU*; 129 virtual void Dump() const; // *MENU*; 130 virtual void Execute(const char *method, const char *params, Int_t *error = nullptr);; 131 virtual void Execute(TMethod *method, TObjArray *params, Int_t *error = nullptr);; 132 virtual void ExecuteEvent(Int_t event, Int_t px, Int_t py);; 133 virtual TObject *FindObject(const char *name) const;; 134 virtual TObject *FindObject(const TObject *obj) const;; 135 virtual Option_t *GetDrawOption() const;; 136 virtual UInt_t GetUniqueID() const;; 137 virtual const char *GetName() const;; 138 virtual const char *GetIconName() const;; 139 virtual Option_t *GetOption() const { return """"; }; 140 virtual char *GetObjectInfo(Int_t px, Int_t py) const;; 141 virtual const char *GetTitle() const;; 142 virtual Bool_t HandleTimer(TTimer *timer);; 143 Bool_t HasInconsistentHash() const;; 144 virtual ULong_t Hash() const;; 145 virtual Bool_t InheritsFrom(const char *classname) const;; 146 virtual Bool_t InheritsFrom(const TClass *cl) const;; 147 virtual void Inspect() const; // *MENU*; 148 virtual Bool_t IsFolder() const;; 149 virtual Bool_t IsEqual(const TObject *obj) const;; 150 virtual Bool_t IsSortable() const { return kFALSE; }; 151 ; 152 R__ALWAYS_INLINE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:5381,error,error,5381,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['error'],['error']
Availability," TObject* obj, const char* name = 0, const char* title = 0); TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); virtual~TKeyXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKeyXML.html:1578,Error,Error,1578,root/html532/TKeyXML.html,https://root.cern,https://root.cern/root/html532/TKeyXML.html,2,['Error'],['Error']
Availability," TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:22904,error,error,22904,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['error'],['error']
Availability," TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Last changed: root/netxng:$Id$ » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFileStager.html:7586,error,errors,7586,root/html602/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html602/TNetXNGFileStager.html,4,['error'],['errors']
Availability," TObject::(anonymous)TObject::kZombie. protected:. TMonitor*fAllMonitormonitor activity on all valid slave sockets; TList*fAvailablePackageslist of available packages; TList*fBadSlavesdead slaves (subset of all slaves); Long64_tfBytesReadynumber of bytes staged; Int_tfCollectTimeoutTimeout for (some) collect actions; TStringfConfDirdirectory containing cluster config information; TStringfConfFilefile containing config information; TStringfDataPoolUrldefault data pool entry point URL; Bool_tfDataReadytrue if data is ready to be analyzed; Bool_tfDynamicStartupare the workers started dynamically?; TList*fEnabledPackageslist of enabled packages; TStringfImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*fManagermanager to which this session belongs (if any); Bool_tfMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Float_tfPrepTimePreparation time; Int_tfProtocolremote PROOF server protocol version number; TProof::EQueryModefQueryModedefault query mode; TStopwatchfQuerySTWStopwatch to measure query times; TList*fRunningDSetsTemporary datasets used for async running; TSelector*fSelectorSelector to be processed, if any; TProofMgr::EServTypefServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*fSlaveslist of all slave servers as in config file; TList*fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tfTotalBytesnumber of bytes to be analyzed; TUrlfUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlaveskActive; static TProof::ESlaveskAll; static TProof::ESlaveskAllUnique; static TProof::ESlaveskUnique. private:. TMonitor*fActiveMonitormonitor activity",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:28470,avail,available,28470,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['avail'],['available']
Availability," TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tf3DStyle3D style (0 - normal, kRaisedFrame - raised, kSunkenFrame - sunken); Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; Bool_tfDisabledif kTRUE label looks disabled (shaded text); UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGFont*fFontfont to draw label; Bool_tfHasOwnFontkTRUE - font defined locally, kFALSE - globally; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMBottommargin bottom; Int_tfMLeftmargin left; Int_tfMRightmargin right; Int_tfMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing label; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTFlagstext flags (see TGFont.h ETextLayoutFlags); UInt_tfTHeighttext height; TGTextLayout*fTLayouttext layout ; Int_tfTModetext alignment; UInt_tfTWidthtext width; TGString*fTextlabel text; Bool_tfTextChangedhas text changed; UInt_tTGFrame::fWidthframe width; Int_tfWrapLengthwrap length; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLabel.html:16653,mask,mask,16653,root/html528/TGLabel.html,https://root.cern,https://root.cern/root/html528/TGLabel.html,6,['mask'],['mask']
Availability," TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:7161,error,error,7161,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,4,['error'],['error']
Availability," TObject::ResetBit ; (; UInt_t ; f). inline . Definition at line 198 of file TObject.h. ◆ SaveAs(). void TObject::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. virtual . Save this object in the file specified by filename. . if ""filename"" contains "".root"" the object is saved in filename as root binary file.; if ""filename"" contains "".xml"" the object is saved in filename as a xml ascii file.; if ""filename"" contains "".cc"" the object is saved in filename as C code independant from ROOT. The code is generated via SavePrimitive(). Specific code should be implemented in each object to handle this option. Like in TF1::SavePrimitive().; otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via SavePrimitive(). The ""option"" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.; The function is available via the object context menu. . Reimplemented in TSpline, TFolder, TGeoVolume, TClassTree, TPad, TPaveClass, TGObject, TSpline3, TSpline5, ROOT::Experimental::XRooFit::xRooNode, TTreePerfStats, TVirtualPad, TGraph, and TH1.; Definition at line 686 of file TObject.cxx. ◆ SavePrimitive(). void TObject::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). virtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented in TGeoTessellated, TGraphEdge, TGraphNode, TGeoIdentity, TStyle, TCurlyArc, TCurlyLine, TGedMarkerSelect, TGedPatternSelect, TGColorSelect, TGFont, TGVerticalLayout, TGHorizontalLayout, TGRowLayout, TGColumnLayout, TGMatrixLayout, TGTileLayout, TGListLayout, TGListDetailsLayout, TGTextLBEntry, TGNumberEntryField, TGNumberEntry, TGTableLayoutHints, TGTableLayout, TGTextEdit, TGTextView, TGXYLayoutHints, TGXYLayout, TRootContainer, TGHtml, TEfficiency, TExec, TMacro, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoBoolNode, TGeoUnion, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:86613,avail,available,86613,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['avail'],['available']
Availability," TObject::ResetBit ; (; UInt_t ; f). inline . Definition at line 198 of file TObject.h. ◆ SaveAs(). void TObject::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. virtual . Save this object in the file specified by filename. . if ""filename"" contains "".root"" the object is saved in filename as root binary file.; if ""filename"" contains "".xml"" the object is saved in filename as a xml ascii file.; if ""filename"" contains "".cc"" the object is saved in filename as C code independant from ROOT. The code is generated via SavePrimitive(). Specific code should be implemented in each object to handle this option. Like in TF1::SavePrimitive().; otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via SavePrimitive(). The ""option"" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.; The function is available via the object context menu. . Reimplemented in TSpline, TFolder, TGeoVolume, TClassTree, TPad, TPaveClass, TGObject, TSpline3, TSpline5, ROOT::Experimental::XRooFit::xRooNode, TTreePerfStats, TVirtualPad, TGraph, and TH1.; Definition at line 692 of file TObject.cxx. ◆ SavePrimitive(). void TObject::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). virtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented in TGeoTessellated, TGraphEdge, TGraphNode, TGeoIdentity, TStyle, TCurlyArc, TCurlyLine, TGedMarkerSelect, TGedPatternSelect, TGColorSelect, TGFont, TGVerticalLayout, TGHorizontalLayout, TGRowLayout, TGColumnLayout, TGMatrixLayout, TGTileLayout, TGListLayout, TGListDetailsLayout, TGTextLBEntry, TGNumberEntryField, TGNumberEntry, TGTableLayoutHints, TGTableLayout, TGTextEdit, TGTextView, TGXYLayoutHints, TGXYLayout, TRootContainer, TGHtml, TEfficiency, TExec, TMacro, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoBoolNode, TGeoUnion, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:85851,avail,available,85851,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['avail'],['available']
Availability," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:142344,error,error,142344,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['error'],['error']
Availability," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1074; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:142520,error,error,142520,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['error'],['error']
Availability," TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObjectRefSpy.html:1537,Error,Error,1537,root/html532/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html532/TObjectRefSpy.html,2,['Error'],['Error']
Availability," TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObjectSpy.html:1525,Error,Error,1525,root/html532/TObjectSpy.html,https://root.cern,https://root.cern/root/html532/TObjectSpy.html,2,['Error'],['Error']
Availability," TOutputListSelectorDataMap(TSelector* sel = 0); TOutputListSelectorDataMap(const TOutputListSelectorDataMap&); virtual~TOutputListSelectorDataMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TOutputListSelectorDataMap*FindInList(TCollection* coll); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TOutputListSelectorDataMap.html:1427,Error,Error,1427,root/html532/TOutputListSelectorDataMap.html,https://root.cern,https://root.cern/root/html532/TOutputListSelectorDataMap.html,2,['Error'],['Error']
Availability," TPBHandleDSType(TPBHandleDSType::EHandleDSType type = kReleaseCache); TPBHandleDSType(const TPBHandleDSType&); virtual~TPBHandleDSType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPBHandleDSType.html:1318,Error,Error,1318,root/html532/TPBHandleDSType.html,https://root.cern,https://root.cern/root/html532/TPBHandleDSType.html,2,['Error'],['Error']
Availability," TPBHistType(TPBHistType::EHistType type = kHist1D); TPBHistType(const TPBHistType&); virtual~TPBHistType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPBHistType.html:1276,Error,Error,1276,root/html532/TPBHistType.html,https://root.cern,https://root.cern/root/html532/TPBHistType.html,2,['Error'],['Error']
Availability," TPBReadType(TPBReadType::EReadType type = kReadOpt); TPBReadType(const TPBReadType&); virtual~TPBReadType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPBReadType.html:1277,Error,Error,1277,root/html532/TPBReadType.html,https://root.cern,https://root.cern/root/html532/TPBReadType.html,2,['Error'],['Error']
Availability," TPackageDescription(); TPackageDescription(const TPackageDescription&); ~TPackageDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPackageDescription.html:1344,Error,Error,1344,root/html532/TPackageDescription.html,https://root.cern,https://root.cern/root/html532/TPackageDescription.html,2,['Error'],['Error']
Availability," TPacketizerFile(TList* workers, Long64_t, TList* input, TProofProgressStatus* st = 0); virtual~TPacketizerFile(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPacketizerFile.html:1520,Error,Error,1520,root/html532/TPacketizerFile.html,https://root.cern,https://root.cern/root/html532/TPacketizerFile.html,1,['Error'],['Error']
Availability," TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPair.html:1633,error,error,1633,root/html530/TPair.html,https://root.cern,https://root.cern/root/html530/TPair.html,7,"['Error', 'error']","['Error', 'error']"
Availability," TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPair.html:1631,error,error,1631,root/html528/TPair.html,https://root.cern,https://root.cern/root/html528/TPair.html,1,['error'],['error']
Availability," TParameter<bool>(); TParameter<bool>(const TParameter<bool>&); TParameter<bool>(const char* name, const bool& val); TParameter<bool>(const char* name, const bool& val, char mergemode); virtual~TParameter<bool>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParameter_bool_.html:1471,Error,Error,1471,root/html532/TParameter_bool_.html,https://root.cern,https://root.cern/root/html532/TParameter_bool_.html,2,['Error'],['Error']
Availability," TParameter<float>(); TParameter<float>(const TParameter<float>&); TParameter<float>(const char* name, const float& val); TParameter<float>(const char* name, const float& val, char mergemode); virtual~TParameter<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParameter_float_.html:1483,Error,Error,1483,root/html532/TParameter_float_.html,https://root.cern,https://root.cern/root/html532/TParameter_float_.html,2,['Error'],['Error']
Availability," TParameter<float>(const char* name, const float& val); virtual~TParameter<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const float&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TParameter_float_.html:1550,error,error,1550,root/html528/TParameter_float_.html,https://root.cern,https://root.cern/root/html528/TParameter_float_.html,1,['error'],['error']
Availability," TParameter<int>(); TParameter<int>(const TParameter<int>&); TParameter<int>(const char* name, const int& val); TParameter<int>(const char* name, const int& val, char mergemode); virtual~TParameter<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParameter_int_.html:1459,Error,Error,1459,root/html532/TParameter_int_.html,https://root.cern,https://root.cern/root/html532/TParameter_int_.html,2,['Error'],['Error']
Availability," TParameter<long>(); TParameter<long>(const TParameter<long>&); TParameter<long>(const char* name, const long& val); TParameter<long>(const char* name, const long& val, char mergemode); virtual~TParameter<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParameter_long_.html:1471,Error,Error,1471,root/html532/TParameter_long_.html,https://root.cern,https://root.cern/root/html532/TParameter_long_.html,2,['Error'],['Error']
Availability," TParticleClassPDG(const char* name = 0); virtual~TParticleClassPDG(); voidTObject::AbstractMethod(const char* method) const; voidAddParticle(TObject* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TObjArray*GetListOfParticles(); virtual const char*TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParticleClassPDG.html:1274,Error,Error,1274,root/html532/TParticleClassPDG.html,https://root.cern,https://root.cern/root/html532/TParticleClassPDG.html,2,['Error'],['Error']
Availability," TPerfEvent(TTimeStamp* offset = 0); TPerfEvent(const TPerfEvent&); virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfEvent.html:1429,error,error,1429,root/html528/TPerfEvent.html,https://root.cern,https://root.cern/root/html528/TPerfEvent.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TPosixCondition(TMutexImp* m); TPosixCondition(const TPosixCondition&); virtual~TPosixCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPosixCondition.html:1352,Error,Error,1352,root/html532/TPosixCondition.html,https://root.cern,https://root.cern/root/html532/TPosixCondition.html,2,['Error'],['Error']
Availability," TPosixMutex(Bool_t recursive = kFALSE); TPosixMutex(const TPosixMutex&); virtual~TPosixMutex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPosixMutex.html:1289,Error,Error,1289,root/html532/TPosixMutex.html,https://root.cern,https://root.cern/root/html532/TPosixMutex.html,2,['Error'],['Error']
Availability, TProcessID(); virtual~TProcessID(); voidTObject::AbstractMethod(const char* method) const; static TProcessID*AddProcessID(); virtual voidTO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProcessID.html:2808,Error,Error,2808,root/html532/TProcessID.html,https://root.cern,https://root.cern/root/html532/TProcessID.html,2,['Error'],['Error']
Availability," TProcessID*TProcessID::AddProcessID(); UInt_tAddUUID(const char* uuids); UInt_tAddUUID(TUUID& uuid, TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); static UInt_tTProcessID::AssignID(TObject* obj); virtual voidTObject::Browse(TBrowser* b); voidTProcessID::CheckInit(); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidTProcessID::Cleanup(); virtual voidTProcessID::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTProcessID::DecrementCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObjString*FindUUID(UInt_t number) const; TBits*GetActive() const; Int_tTProcessID::GetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; static UInt_tTProcessID::GetNProcessIDs(); static UInt_tTProcessID::GetObjectCount(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObjArray*TProcessID::GetObjects() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProcessUUID.html:2635,Error,Error,2635,root/html532/TProcessUUID.html,https://root.cern,https://root.cern/root/html532/TProcessUUID.html,4,['Error'],['Error']
Availability," TProfile2D, TH2Poly, and TProfile2Poly.; Definition at line 93 of file TH2.h. ◆ GetBinContent() [5/5]. Double_t TH2::GetBinContent ; (; Int_t ; binx, . Int_t ; biny, . Int_t ;  . ); const. inlineoverridevirtual . Reimplemented from TH1.; Reimplemented in TProfile2D, TH2Poly, and TProfile2Poly.; Definition at line 94 of file TH2.h. ◆ GetBinErrorLow() [1/2]. Double_t TH1::GetBinErrorLow ; (; Int_t ; bin); const. virtual . Return lower error associated to bin number bin. ; The error will depend on the statistic option used will return the binContent - lower interval value ; Reimplemented from TH1.; Definition at line 271 of file TH1.cxx. ◆ GetBinErrorLow() [2/2]. virtual Double_t TH2::GetBinErrorLow ; (; Int_t ; binx, . Int_t ; biny . ). inlinevirtual . Definition at line 97 of file TH2.h. ◆ GetBinErrorUp() [1/2]. Double_t TH1::GetBinErrorUp ; (; Int_t ; bin); const. virtual . Return upper error associated to bin number bin. ; The error will depend on the statistic option used will return the binContent - upper interval value ; Reimplemented from TH1.; Definition at line 272 of file TH1.cxx. ◆ GetBinErrorUp() [2/2]. virtual Double_t TH2::GetBinErrorUp ; (; Int_t ; binx, . Int_t ; biny . ). inlinevirtual . Definition at line 98 of file TH2.h. ◆ GetBinWithContent2(). Double_t TH2::GetBinWithContent2 ; (; Double_t ; c, . Int_t & ; binx, . Int_t & ; biny, . Int_t ; firstxbin = 1, . Int_t ; lastxbin = -1, . Int_t ; firstybin = 1, . Int_t ; lastybin = -1, . Double_t ; maxdiff = 0 . ); const. virtual . compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff = abs(cell_content-c) <= maxdiff In case several cells in the specified range with diff=0 are found the first cell found is returned in binx,biny. ; In case several cells in the specified range satisfy diff <=maxdiff the cell with the smallest difference is returned in binx,biny. In all cases the function returns the smallest difference.; NOTE1: if firstxbin < 0, firstxbin is set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:83203,error,error,83203,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['error'],['error']
Availability," TProfile2D::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturn bin error of a Profile2D histogram.Definition TProfile2D.cxx:881; TProfile2D::Approximatestatic void Approximate(Bool_t approx=kTRUE)Static function, set the fgApproximate flag.Definition TProfile2D.cxx:277; TProfile2D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile2D.h:35; TProfile2D::fZminDouble_t fZminLower limit in Z (if set)Definition TProfile2D.h:36; TProfile2D::RebinXTProfile2D * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis.Definition TProfile2D.cxx:1837; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile2D.h:41; TProfile2D::GetB2Double_t * GetB2()Definition TProfile2D.h:64; TProfile2D::Classstatic TClass * Class(); TProfile2D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile2D.cxx:1514; TProfile2D::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TProfile2D.cxx:1389; TProfile2D::RebinYTProfile2D * RebinY(Int_t ngroup=2, const char *newname="""") overrideRebin only the Y axis.Definition TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:88686,error,errors,88686,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['errors']
Availability," TProfile::BuildOptions ; (; Double_t ; ymin, . Double_t ; ymax, . Option_t * ; option . ). Set Profile histogram structure and options. ; Parameters. [in]yminminimum value allowed for y ; [in]ymaxmaximum value allowed for y if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf) ; [in]optionthis is the option for the computation of the y error of the profile ( TProfile::GetBinError ) possible values for the options are:; ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N) where S(Y) is the standard deviation (RMS) of the Y data in the bin and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ) (i.e the errors are the standard error on the bin content of the profile); 's' Errors are the standard deviation of Y, S(Y); 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default) The only difference is only when the standard deviation in Y is zero. In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is 1./SQRT(12*N). This approximation assumes that the Y values are integer (e.g. ADC counts) and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j W is obtained as from TProfile::GetBinEntries(ibin) This errors corresponds to the standard deviation of weighted mean where each measurement Y is uncorrelated and has an error sigma, which is expressed in the weight used to fill the Profile: w = 1/sigma^2 The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ). In the case of Profile filled weights and with TProfile::Sumw2() called, STD(Y) is the standard deviation of the weighted sample Y and N is in this case the number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); If a bin has N data points all with the same value Y (especi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:64929,error,error,64929,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,2,['error'],['error']
Availability," TProfileHelper::BuildArray(this);; 1322}; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Set the buffer size in units of 8 bytes (double).; 1326 ; 1327void TProfile3D::SetBuffer(Int_t buffersize, Option_t *); 1328{; 1329 if (fBuffer) {; 1330 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:50908,error,error,50908,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability," TProfileHelper::BuildArray(this);; 1951}; 1952 ; 1953////////////////////////////////////////////////////////////////////////////////; 1954/// Set the buffer size in units of 8 bytes (double).; 1955 ; 1956void TProfile2D::SetBuffer(Int_t buffersize, Option_t *); 1957{; 1958 if (fBuffer) {; 1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:71999,error,error,71999,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability," TProof* proof, Int_t stype, const char* workdir, const char* msd); virtual~TXSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTSlave::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TSlave::GetArchCompiler() const; Long64_tTSlave::GetBytesRead() const; Float_tTSlave::GetCpuTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TSlave::GetGroup() const; virtual const char*TObject::GetIconName() const; const char*TSlave::GetImage() const; TFileHandler*TSlave::GetInputHandler() const; const char*TSlave::GetMsd() const; virtual const char*TSlave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSlave.html:1504,Error,Error,1504,root/html532/TXSlave.html,https://root.cern,https://root.cern/root/html532/TXSlave.html,2,['Error'],['Error']
Availability," TProof.; Definition at line 58 of file TProofSuperMaster.h. ◆ Process() [4/8]. Long64_t TProofSuperMaster::Process ; (; TDSet * ; set, . const char * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process a data set (TDSet) using the specified selector (.C) file. ; Entry- or event-lists should be set in the data set object using TDSet::SetEntryList. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProof.; Definition at line 229 of file TProofSuperMaster.cxx. ◆ Process() [5/8]. Long64_t TProofSuperMaster::Process ; (; TDSet * ; dset, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). inlineoverridevirtual . Process a data set (TDSet) using the specified selector object. ; Entry- or event-lists should be set in the data set object using TDSet::SetEntryList. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProof.; Definition at line 61 of file TProofSuperMaster.h. ◆ Process() [6/8]. Long64_t TProofSuperMaster::Process ; (; TFileCollection * ; fc, . const char * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). inlineoverridevirtual . Process a data set (TFileCollection) using the specified selector (.C) file or TSelector object. ; The default tree is analyzed (i.e. the first one found). To specify another tree, the default tree can be changed using TFileCollection::SetDefaultMetaData . The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProof.; Definition at line 51 of file TProofSuperMaster.h. ◆ Process() [7/8]. Long64_t TProofSuperMaster::Process ; (; TFileCollection * ; fc, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). inlineoverridevirtual . Process ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofSuperMaster.html:50384,error,error,50384,doc/master/classTProofSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofSuperMaster.html,1,['error'],['error']
Availability," TProofBenchDataSet(TProof* proof = 0); TProofBenchDataSet(const TProofBenchDataSet&); virtual~TProofBenchDataSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCopyFiles(const char* dset, const char* destdir); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBenchDataSet.html:1383,Error,Error,1383,root/html532/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html532/TProofBenchDataSet.html,2,['Error'],['Error']
Availability," TProofDesc(const char* tag = 0, const char* alias = 0, const char* url = 0, Int_t id = -1, Int_t remid = -1, Int_t status = kIdle, TProof* p = 0); virtual~TProofDesc(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDesc.html:1539,Error,Error,1539,root/html532/TProofDesc.html,https://root.cern,https://root.cern/root/html532/TProofDesc.html,2,['Error'],['Error']
Availability," TProofDrawEntryList(); virtual~TProofDrawEntryList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawEntryList.html:1377,Error,Error,1377,root/html532/TProofDrawEntryList.html,https://root.cern,https://root.cern/root/html532/TProofDrawEntryList.html,2,['Error'],['Error']
Availability," TProofDrawEventList(); virtual~TProofDrawEventList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawEventList.html:1377,Error,Error,1377,root/html532/TProofDrawEventList.html,https://root.cern,https://root.cern/root/html532/TProofDrawEventList.html,2,['Error'],['Error']
Availability," TProofDrawGraph(); ~TProofDrawGraph(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawGraph.html:1350,Error,Error,1350,root/html532/TProofDrawGraph.html,https://root.cern,https://root.cern/root/html532/TProofDrawGraph.html,2,['Error'],['Error']
Availability," TProofDrawHist(); ~TProofDrawHist(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawHist.html:1335,Error,Error,1335,root/html532/TProofDrawHist.html,https://root.cern,https://root.cern/root/html532/TProofDrawHist.html,2,['Error'],['Error']
Availability," TProofDrawListOfGraphs(); ~TProofDrawListOfGraphs(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawListOfGraphs.html:1385,Error,Error,1385,root/html532/TProofDrawListOfGraphs.html,https://root.cern,https://root.cern/root/html532/TProofDrawListOfGraphs.html,2,['Error'],['Error']
Availability," TProofDrawListOfPolyMarkers3D(); ~TProofDrawListOfPolyMarkers3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawListOfPolyMarkers3D.html:1420,Error,Error,1420,root/html532/TProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/root/html532/TProofDrawListOfPolyMarkers3D.html,2,['Error'],['Error']
Availability," TProofDrawPolyMarker3D(); ~TProofDrawPolyMarker3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawPolyMarker3D.html:1385,Error,Error,1385,root/html532/TProofDrawPolyMarker3D.html,https://root.cern,https://root.cern/root/html532/TProofDrawPolyMarker3D.html,2,['Error'],['Error']
Availability," TProofDrawProfile(); ~TProofDrawProfile(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawProfile.html:1350,Error,Error,1350,root/html532/TProofDrawProfile.html,https://root.cern,https://root.cern/root/html532/TProofDrawProfile.html,2,['Error'],['Error']
Availability," TProofDrawProfile2D(); ~TProofDrawProfile2D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawProfile2D.html:1360,Error,Error,1360,root/html532/TProofDrawProfile2D.html,https://root.cern,https://root.cern/root/html532/TProofDrawProfile2D.html,2,['Error'],['Error']
Availability," TProofLogElem(const TProofLogElem&); TProofLogElem(const char* ord, const char* url, TProofLog* logger); virtual~TProofLogElem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplay(Int_t from = 0, Int_t to = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLogElem.html:1333,Error,Error,1333,root/html532/TProofLogElem.html,https://root.cern,https://root.cern/root/html532/TProofLogElem.html,2,['Error'],['Error']
Availability," TProofMonSenderML(const TProofMonSenderML&); TProofMonSenderML(const char* serv, const char* tag, const char* id = 0, const char* subid = 0, const char* opt = """"); virtual~TProofMonSenderML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMonSenderML.html:1394,Error,Error,1394,root/html532/TProofMonSenderML.html,https://root.cern,https://root.cern/root/html532/TProofMonSenderML.html,2,['Error'],['Error']
Availability," TProofNodeInfo(); TProofNodeInfo(const char* str); TProofNodeInfo(const TProofNodeInfo& nodeInfo); virtual~TProofNodeInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssign(const TProofNodeInfo& n); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TString&GetConfig() const; virtual Option_t*TObject::GetDra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofNodeInfo.html:1445,Error,Error,1445,root/html532/TProofNodeInfo.html,https://root.cern,https://root.cern/root/html532/TProofNodeInfo.html,2,['Error'],['Error']
Availability," TProofNodes(TProof* proof); TProofNodes(const TProofNodes&); virtual~TProofNodes(); voidTObject::AbstractMethod(const char* method) const; Int_tActivateWorkers(Int_t nwrks); Int_tActivateWorkers(const char* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMap*GetMapOfActiveNodes() const; TMap*GetMapOfNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofNodes.html:1326,Error,Error,1326,root/html532/TProofNodes.html,https://root.cern,https://root.cern/root/html532/TProofNodes.html,2,['Error'],['Error']
Availability," TProofPerfAnalysis(TTree* tree, const char* title = """"); TProofPerfAnalysis(const char* perffile, const char* title = """", const char* treename = ""PROOF_PerfStats""); virtual~TProofPerfAnalysis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventDist(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFileDist(Bool_t writedet = kFALSE); voidFileProcPlot(const char* fn, const char* out = 0); voidFileRatePlot(const char* fns = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPerfAnalysis.html:1380,Error,Error,1380,root/html534/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html534/TProofPerfAnalysis.html,1,['Error'],['Error']
Availability," TProofProgressStatus* st); virtual~TPacketizerMulti(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerMulti.html:1791,Error,Error,1791,root/html534/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html534/TPacketizerMulti.html,1,['Error'],['Error']
Availability," TProofQueryResult(); TProofQueryResult(const TProofQueryResult&); virtual~TProofQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTQueryResult::Browse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTQueryResult::GetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTQueryResult::GetEnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofQueryResult.html:1310,Error,Error,1310,root/html532/TProofQueryResult.html,https://root.cern,https://root.cern/root/html532/TProofQueryResult.html,2,['Error'],['Error']
Availability," TProofResourcesStatic(); TProofResourcesStatic(const TProofResourcesStatic&); TProofResourcesStatic(const char* confDir, const char* fileName); virtual~TProofResourcesStatic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofResourcesStatic.html:1833,Error,Error,1833,root/html532/TProofResourcesStatic.html,https://root.cern,https://root.cern/root/html532/TProofResourcesStatic.html,2,['Error'],['Error']
Availability," TPySelector(TTree* = 0, PyObject* self = 0); virtual~TPySelector(); virtual voidAbort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPySelector.html:2596,Error,Error,2596,root/html532/TPySelector.html,https://root.cern,https://root.cern/root/html532/TPySelector.html,2,['Error'],['Error']
Availability," TPythia6Decayer(); TPythia6Decayer(const TPythia6Decayer&); virtual~TPythia6Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPythia6Decayer.html:1511,Error,Error,1511,root/html532/TPythia6Decayer.html,https://root.cern,https://root.cern/root/html532/TPythia6Decayer.html,1,['Error'],['Error']
Availability," TPythia8(const TPythia8&); virtual~TPythia8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGenerator::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGenerator::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventListing() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGenerator::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*TGenerator::GetListOfParticles() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; Int_tTGenerator::GetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTGenerator::GetParameter(const char*) const; virtual TParticle*TGenerator::GetParticle(Int_t i) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia8.html:4005,error,error,4005,root/html528/TPythia8.html,https://root.cern,https://root.cern/root/html528/TPythia8.html,6,['error'],['error']
Availability," TPythia8Decayer(); TPythia8Decayer(const TPythia8Decayer&); virtual~TPythia8Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t pdg, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPythia8Decayer.html:1281,Error,Error,1281,root/html532/TPythia8Decayer.html,https://root.cern,https://root.cern/root/html532/TPythia8Decayer.html,2,['Error'],['Error']
Availability," TQMimeTypes(const char* iconPath, const char* file); virtual~TQMimeTypes(); voidTObject::AbstractMethod(const char* method) const; voidAddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQMimeTypes.html:1543,Error,Error,1543,root/html532/TQMimeTypes.html,https://root.cern,https://root.cern/root/html532/TQMimeTypes.html,2,['Error'],['Error']
Availability," TQpProbDens(); TQpProbDens(const TQpProbDens& another); TQpProbDens(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbDens(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpProbDens.html:1288,Error,Error,1288,root/html532/TQpProbDens.html,https://root.cern,https://root.cern/root/html532/TQpProbDens.html,2,['Error'],['Error']
Availability," TQpProbSparse(); TQpProbSparse(const TQpProbSparse& another); TQpProbSparse(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbSparse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpProbSparse.html:1306,Error,Error,1306,root/html532/TQpProbSparse.html,https://root.cern,https://root.cern/root/html532/TQpProbSparse.html,2,['Error'],['Error']
Availability," TQueryDescription(); TQueryDescription(const TQueryDescription&); ~TQueryDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQueryDescription.html:1354,Error,Error,1354,root/html532/TQueryDescription.html,https://root.cern,https://root.cern/root/html532/TQueryDescription.html,2,['Error'],['Error']
Availability," TQueryResult(); TQueryResult(const TQueryResult&); virtual~TQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetEndTime() const; Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQueryResult.html:1368,error,error,1368,root/html528/TQueryResult.html,https://root.cern,https://root.cern/root/html528/TQueryResult.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TRWLock(); virtual~TRWLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRWLock.html:1415,error,error,1415,root/html528/TRWLock.html,https://root.cern,https://root.cern/root/html528/TRWLock.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TRandom::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TRandom.h. ◆ DeclFileName(). static const char * TRandom::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 59 of file TRandom.h. ◆ Exp(). Double_t TRandom::Exp ; (; Double_t ; tau). virtual . Returns an exponential deviate. ; exp( -t/tau ) . Definition at line 252 of file TRandom.cxx. ◆ Gaus(). Double_t TRandom::Gaus ; (; Double_t ; mean = 0, . Double_t ; sigma = 1 . ). virtual . Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigma. ; Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger This is one of the fastest existing method for generating normal random variables. It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia) implemented for example in GSL and available in the MathMore library.; REFERENCE: - W. Hoermann and G. Derflinger (1990): The ACR Method for generating normal random variables, OR Spektrum 12 (1990), 181-185.; Implementation taken from UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien ; Definition at line 275 of file TRandom.cxx. ◆ GetSeed(). UInt_t TRandom::GetSeed ; (; ); const. virtual . Get the random generator seed. ; WarningMight not be the initial seed!; Note that this function returns the given seed only when using as random generator engine TRandom itself, which is an LCG generator and it has as seed (state) only one 32 bit word. In case of the other generators GetSeed will return one of the state elements and not the given seed. See the documentation of the corresponding generator used (for example TRandom3::GetSeed() when using TRandom3 or gRandom. If one needs to save the generator seed in order to be used later for obtaining reproducible numbers, one s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom.html:27443,avail,available,27443,doc/master/classTRandom.html,https://root.cern,https://root.cern/doc/master/classTRandom.html,1,['avail'],['available']
Availability," TRealData(); TRealData(const char* name, Long_t offset, TDataMember* datamember); virtual~TRealData(); voidTObject::AbstractMethod(const char* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRealData.html:1635,Error,Error,1635,root/html532/TRealData.html,https://root.cern,https://root.cern/root/html532/TRealData.html,2,['Error'],['Error']
Availability," TRecCmdEvent(); TRecCmdEvent(const TRecCmdEvent&); ~TRecCmdEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecCmdEvent.html:1333,error,error,1333,root/html528/TRecCmdEvent.html,https://root.cern,https://root.cern/root/html528/TRecCmdEvent.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRefTable.html:2520,Error,Error,2520,root/html532/TRefTable.html,https://root.cern,https://root.cern/root/html532/TRefTable.html,2,['Error'],['Error']
Availability," TRemoteObject(); TRemoteObject(const TRemoteObject&); TRemoteObject(const char* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRemoteObject.html:1679,Error,Error,1679,root/html532/TRemoteObject.html,https://root.cern,https://root.cern/root/html532/TRemoteObject.html,1,['Error'],['Error']
Availability," TRemoteObject(); TRemoteObject(const TRemoteObject&); TRemoteObject(const char* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRemoteObject.html:1678,Error,Error,1678,root/html534/TRemoteObject.html,https://root.cern,https://root.cern/root/html534/TRemoteObject.html,1,['Error'],['Error']
Availability," TRint::Terminatevirtual void Terminate(int status) overrideTerminate the application.Definition TRint.cxx:722; TRint::fPromptchar fPrompt[64]Definition TRint.h:37; TRint::TabCompletionHookInt_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out) overrideForward tab completion request to our TTabCom::Hook().Definition TRint.cxx:827; TRint::GetPromptvirtual char * GetPrompt()Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"".Definition TRint.cxx:575; TRint::HandleExceptionvoid HandleException(Int_t sig) overrideHandle signals (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException)...Definition TRint.cxx:704; TRint::~TRintvirtual ~TRint()Destructor.Definition TRint.cxx:316; TRint::PrintLogovirtual void PrintLogo(Bool_t lite=kFALSE)Print the ROOT logo on standard output.Definition TRint.cxx:512; TRint::ExecLogonvoid ExecLogon()Execute logon macro's.Definition TRint.cxx:341; TRint::ProcessRemoteLongptr_t ProcessRemote(const char *line, Int_t *error=nullptr) overrideProcess the content of a line starting with "".R"" (already stripped-off) The format is [user@]host[:di...Definition TRint.cxx:768; TRint::fBackslashContinueBool_t fBackslashContinueDefinition TRint.h:41; TRint::fDefaultPromptTString fDefaultPromptDefinition TRint.h:35; TRint::fNonContinuePromptTString fNonContinuePromptDefinition TRint.h:36; TRint::fCaughtSignalInt_t fCaughtSignalDefinition TRint.h:39; TRint::fNcmdInt_t fNcmdDefinition TRint.h:34; TRint::TRintTRint(const TRint &)=delete; TRint::fInputHandlerTFileHandler * fInputHandlerDefinition TRint.h:40; TSignalHandlerDefinition TSysEvtHandler.h:127; TSignalHandler::Addvoid Add() overrideAdd signal handler to system signal handler list.Definition TSysEvtHandler.cxx:168; TSignalHandler::GetSignalESignals GetSignal() constDefinition TSysEvtHandler.h:141; TSignalHandler::fDelayInt_t fDelayDefinition TSysEvtHandler.h:132; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:39423,error,error,39423,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['error'],['error']
Availability," TRootHelpDialog, TGRecorder, TProofProgressLog, TNewChainDlg, TNewQueryDlg, TUploadDataSetDlg, TSessionServerFrame, TSessionFrame, TSessionQueryFrame, TSessionOutputFrame, TSessionInputFrame, TSessionViewer, and TTreeViewer. ◆ StreamerNVirtual(). void TGFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 283 of file TGFrame.h. ◆ UnmapWindow(). void TGFrame::UnmapWindow ; (; ). inlineoverridevirtual . unmap window ; Reimplemented from TGWindow.; Definition at line 206 of file TGFrame.h. Member Data Documentation. ◆ fBackground. Pixel_t TGFrame::fBackground. protected . frame background color ; Definition at line 95 of file TGFrame.h. ◆ fBorderWidth. Int_t TGFrame::fBorderWidth. protected . frame border width ; Definition at line 93 of file TGFrame.h. ◆ fDNDState. Int_t TGFrame::fDNDState. protected . EDNDFlags. ; Definition at line 97 of file TGFrame.h. ◆ fEventMask. UInt_t TGFrame::fEventMask. protected . currently active event mask ; Definition at line 96 of file TGFrame.h. ◆ fFE. TGFrameElement* TGFrame::fFE. protected . pointer to frame element ; Definition at line 98 of file TGFrame.h. ◆ fgBckgndGC. const TGGC * TGFrame::fgBckgndGC = nullptr. staticprotected . Definition at line 109 of file TGFrame.h. ◆ fgBlackGC. const TGGC * TGFrame::fgBlackGC = nullptr. staticprotected . Definition at line 105 of file TGFrame.h. ◆ fgBlackPixel. Pixel_t TGFrame::fgBlackPixel = 0. staticprotected . Definition at line 104 of file TGFrame.h. ◆ fgDbw. Window_t TGFrame::fgDbw = 0. staticprotected . Definition at line 113 of file TGFrame.h. ◆ fgDbx. Int_t TGFrame::fgDbx = 0. staticprotected . Definition at line 112 of file TGFrame.h. ◆ fgDby. Int_t TGFrame::fgDby = 0. staticprotected . Definition at line 112 of file TGFrame.h. ◆ fgDefaultFrameBackground. Pixel_t TGFrame::fgDefaultFrameBackground = 0. staticprotected . Definition at line 101 of file TGFrame.h. ◆ fgDefaultSelectedBackground. Pixel_t TGFrame::fgDefaultSelectedBackground = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFrame.html:62780,mask,mask,62780,doc/master/classTGFrame.html,https://root.cern,https://root.cern/doc/master/classTGFrame.html,1,['mask'],['mask']
Availability," TSQLClassColumnInfo(); TSQLClassColumnInfo(const TSQLClassColumnInfo&); TSQLClassColumnInfo(const char* name, const char* sqlname, const char* sqltype); virtual~TSQLClassColumnInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLClassColumnInfo.html:1651,Error,Error,1651,root/html532/TSQLClassColumnInfo.html,https://root.cern,https://root.cern/root/html532/TSQLClassColumnInfo.html,2,['Error'],['Error']
Availability," TSQLClassInfo(); TSQLClassInfo(const TSQLClassInfo&); TSQLClassInfo(Long64_t classid, const char* classname, Int_t version); virtual~TSQLClassInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Int_tFindColumn(const char* name, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLClassInfo.html:1599,Error,Error,1599,root/html532/TSQLClassInfo.html,https://root.cern,https://root.cern/root/html532/TSQLClassInfo.html,2,['Error'],['Error']
Availability," TSQLFile is ""InnoDB"". For more detailes see MySQL docs. void SetUseTransactions(Int_t mode = kTransactionsAuto); Defines usage of transactions statements for writing objects data to database.; kTransactionsOff=0 - no transaction operation are allowed; kTransactionsAuto=1 - automatic mode. Each write operation,; produced by TSQLFile, will be supplied by START TRANSACTION and COMMIT calls.; If any error happen, ROLLBACK will returns database to previous state; kTransactionsUser=2 - transactions are delegated to user. Methods; StartTransaction(), Commit() and Rollback() should be called by user.; Default UseTransactions option is kTransactionsAuto. Bool_t StartTransaction(); Start user transaction.; This can be usesfull, when big number of objects should be stored in; data base and commitment required only if all operations were succesfull.; In that case in the end of all operations method Commit() should be; called. If operation on user-level is looks like not successfull,; method Rollback() will return database data and TSQLFile instance to; previous state.; In MySQL not all tables types support transaction mode of operation.; See SetTablesType() method for details . Bool_t Commit(); Commit transaction, started by StartTransaction() call.; Only after that call data will be written and visible on database side. Bool_t Rollback(); Rollback all operations, done after StartTransaction() call.; Database should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLFile.html:36838,Rollback,Rollback,36838,root/html532/TSQLFile.html,https://root.cern,https://root.cern/root/html532/TSQLFile.html,1,['Rollback'],['Rollback']
Availability," TSQLFile is ""InnoDB"". For more detailes see MySQL docs. void SetUseTransactions(Int_t mode = kTransactionsAuto); Defines usage of transactions statements for writing objects data to database.; kTransactionsOff=0 - no transaction operation are allowed; kTransactionsAuto=1 - automatic mode. Each write operation,; produced by TSQLFile, will be supplied by START TRANSACTION and COMMIT calls.; If any error happen, ROLLBACK will returns database to previous state; kTransactionsUser=2 - transactions are delegated to user. Methods; StartTransaction(), Commit() and Rollback() should be called by user.; Default UseTransactions option is kTransactionsAuto. Bool_t StartTransaction(); Start user transaction.; This can be usesfull, when big number of objects should be stored in; data base and commitment required only if all operations were successful.; In that case in the end of all operations method Commit() should be; called. If operation on user-level is looks like not successfull,; method Rollback() will return database data and TSQLFile instance to; previous state.; In MySQL not all tables types support transaction mode of operation.; See SetTablesType() method for details . Bool_t Commit(); Commit transaction, started by StartTransaction() call.; Only after that call data will be written and visible on database side. Bool_t Rollback(); Rollback all operations, done after StartTransaction() call.; Database should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:37121,Rollback,Rollback,37121,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,3,['Rollback'],['Rollback']
Availability," TSQLMonitoringWriter(const char* serv, const char* user, const char* pass, const char* table); virtual~TSQLMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLMonitoringWriter.html:1331,Error,Error,1331,root/html532/TSQLMonitoringWriter.html,https://root.cern,https://root.cern/root/html532/TSQLMonitoringWriter.html,2,['Error'],['Error']
Availability," TSQLObjectDataPool(); TSQLObjectDataPool(const TSQLObjectDataPool&); TSQLObjectDataPool(TSQLClassInfo* info, TSQLResult* data); virtual~TSQLObjectDataPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLObjectDataPool.html:1608,Error,Error,1608,root/html532/TSQLObjectDataPool.html,https://root.cern,https://root.cern/root/html532/TSQLObjectDataPool.html,2,['Error'],['Error']
Availability," TSQLObjectInfo(); TSQLObjectInfo(const TSQLObjectInfo&); TSQLObjectInfo(Long64_t objid, const char* classname, Version_t version); virtual~TSQLObjectInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLObjectInfo.html:1620,Error,Error,1620,root/html532/TSQLObjectInfo.html,https://root.cern,https://root.cern/root/html532/TSQLObjectInfo.html,2,['Error'],['Error']
Availability," TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:1150,error,errors,1150,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,4,['error'],['errors']
Availability," TScatter::GetSize ; (; ); const. inline . Get the array of marker sizes. ; Definition at line 54 of file TScatter.h. ◆ GetXaxis(). TAxis * TScatter::GetXaxis ; (; ); const. Get the scatter's x axis. ; Definition at line 191 of file TScatter.cxx. ◆ GetYaxis(). TAxis * TScatter::GetYaxis ; (; ); const. Get the scatter's y axis. ; Definition at line 201 of file TScatter.cxx. ◆ GetZaxis(). TAxis * TScatter::GetZaxis ; (; ); const. Get the scatter's z axis. ; Definition at line 211 of file TScatter.cxx. ◆ IsA(). TClass * TScatter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 73 of file TScatter.h. ◆ Paint(). void TScatter::Paint ; (; Option_t * ; chopt = """"). overridevirtual . Paint this scatter plot with its current attributes. ; Reimplemented from TObject.; Definition at line 221 of file TScatter.cxx. ◆ Print(). void TScatter::Print ; (; Option_t * ; chopt = """"); const. overridevirtual . Print graph and errors values. ; Reimplemented from TNamed.; Definition at line 231 of file TScatter.cxx. ◆ SavePrimitive(). void TScatter::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save primitive as a C++ statement(s) on output stream out. ; Reimplemented from TObject.; Definition at line 260 of file TScatter.cxx. ◆ SetHistogram(). void TScatter::SetHistogram ; (; TH2F * ; h). inline . Definition at line 67 of file TScatter.h. ◆ SetMargin(). void TScatter::SetMargin ; (; Double_t ; margin). Set the margin around the plot in %. ; Definition at line 247 of file TScatter.cxx. ◆ SetMaxMarkerSize(). void TScatter::SetMaxMarkerSize ; (; Double_t ; max). inline . Set the largest marker size used to paint the markers. ; Definition at line 64 of file TScatter.h. ◆ SetMinMarkerSize(). void TScatter::SetMinMarkerSize ; (; Double_t ; min). inline . Set the smallest marker size used to paint the markers. ; Definition at line 65 of file TScatter.h. ◆ Streamer(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTScatter.html:24962,error,errors,24962,doc/master/classTScatter.html,https://root.cern,https://root.cern/doc/master/classTScatter.html,1,['error'],['errors']
Availability," TSecContextCleanup(const TSecContextCleanup&); TSecContextCleanup(Int_t port, Int_t proto, Int_t type); virtual~TSecContextCleanup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSecContextCleanup.html:1355,Error,Error,1355,root/html532/TSecContextCleanup.html,https://root.cern,https://root.cern/root/html532/TSecContextCleanup.html,2,['Error'],['Error']
Availability," TSelVerifyDataSet(); TSelVerifyDataSet(TTree*); virtual~TSelVerifyDataSet(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelVerifyDataSet.html:1397,Error,Error,1397,root/html534/TSelVerifyDataSet.html,https://root.cern,https://root.cern/root/html534/TSelVerifyDataSet.html,1,['Error'],['Error']
Availability," TSelectorDraw(); virtual~TSelectorDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorDraw.html:1345,Error,Error,1345,root/html532/TSelectorDraw.html,https://root.cern,https://root.cern/root/html532/TSelectorDraw.html,2,['Error'],['Error']
Availability," TSelectorScalar(const TSelectorScalar&); TSelectorScalar(const char* name = """", Long64_t val = 0); virtual~TSelectorScalar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTParameter<Long64_t>::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorScalar.html:1528,Error,Error,1528,root/html532/TSelectorScalar.html,https://root.cern,https://root.cern/root/html532/TSelectorScalar.html,2,['Error'],['Error']
Availability," TSemaphore(UInt_t initial = 1); virtual~TSemaphore(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSemaphore.html:1393,error,error,1393,root/html528/TSemaphore.html,https://root.cern,https://root.cern/root/html528/TSemaphore.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TSessionDescription(); TSessionDescription(const TSessionDescription&); ~TSessionDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionDescription.html:1368,Error,Error,1368,root/html532/TSessionDescription.html,https://root.cern,https://root.cern/root/html532/TSessionDescription.html,2,['Error'],['Error']
Availability," TSlaveInfo(const TSlaveInfo&); TSlaveInfo(const char* ordinal = """", const char* host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); ~TSlaveInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSlaveInfo.html:1539,Error,Error,1539,root/html532/TSlaveInfo.html,https://root.cern,https://root.cern/root/html532/TSlaveInfo.html,2,['Error'],['Error']
Availability," TSpectrum2Fit(); TSpectrum2Fit(Int_t numberPeaks); TSpectrum2Fit(const TSpectrum2Fit&); virtual~TSpectrum2Fit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Fit.html:2012,Error,Error,2012,root/html532/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Fit.html,2,['Error'],['Error']
Availability," TSpectrum2Painter(const TSpectrum2Painter&); TSpectrum2Painter(TH2* h2, Int_t bs); virtual~TSpectrum2Painter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:1866,Error,Error,1866,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,2,['Error'],['Error']
Availability," TSpectrum2Transform(); TSpectrum2Transform(const TSpectrum2Transform&); TSpectrum2Transform(Int_t sizeX, Int_t sizeY); virtual~TSpectrum2Transform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Transform.html:2366,Error,Error,2366,root/html532/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Transform.html,2,['Error'],['Error']
Availability," TSpectrumFit(); TSpectrumFit(Int_t numberPeaks); TSpectrumFit(const TSpectrumFit&); virtual~TSpectrumFit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrumFit.html:1987,Error,Error,1987,root/html532/TSpectrumFit.html,https://root.cern,https://root.cern/root/html532/TSpectrumFit.html,2,['Error'],['Error']
Availability," TSpectrumTransform(); TSpectrumTransform(Int_t size); TSpectrumTransform(const TSpectrumTransform&); virtual~TSpectrumTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrumTransform.html:2329,Error,Error,2329,root/html532/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html532/TSpectrumTransform.html,2,['Error'],['Error']
Availability," TSplinePoly(); TSplinePoly(TSplinePoly const& other); TSplinePoly(Double_t x, Double_t y); ~TSplinePoly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetKnot(Double_t& x, Double_t&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSplinePoly.html:1303,Error,Error,1303,root/html532/TSplinePoly.html,https://root.cern,https://root.cern/root/html532/TSplinePoly.html,2,['Error'],['Error']
Availability," TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStatus.html:1414,Error,Error,1414,root/html532/TStatus.html,https://root.cern,https://root.cern/root/html532/TStatus.html,1,['Error'],['Error']
Availability," TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long_tGetResMemMax() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long_tGetVirtMemMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStatus.html:1543,error,error,1543,root/html530/TStatus.html,https://root.cern,https://root.cern/root/html530/TStatus.html,1,['error'],['error']
Availability," TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long_tGetResMemMax(Bool_t master = kFALSE) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long_tGetVirtMemMax(Bool_t master = kFALSE) const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStatus.html:1543,error,error,1543,root/html532/TStatus.html,https://root.cern,https://root.cern/root/html532/TStatus.html,2,['error'],['error']
Availability," TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStatus.html:1543,error,error,1543,root/html528/TStatus.html,https://root.cern,https://root.cern/root/html528/TStatus.html,1,['error'],['error']
Availability," TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatus.html:1420,Error,Error,1420,root/html534/TStatus.html,https://root.cern,https://root.cern/root/html534/TStatus.html,1,['Error'],['Error']
Availability," TStopwatch(); TStopwatch(const TStopwatch&); ~TStopwatch(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidContinue(); virtual voidTObject::Copy(TObject& object) const; Int_tCounter() const; Double_tCpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStopwatch.html:1334,Error,Error,1334,root/html532/TStopwatch.html,https://root.cern,https://root.cern/root/html532/TStopwatch.html,2,['Error'],['Error']
Availability," TStreamerArtificial(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); ~TStreamerArtificial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerArtificial.html:1378,Error,Error,1378,root/html532/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html532/TStreamerArtificial.html,2,['Error'],['Error']
Availability," TStreamerBase(); TStreamerBase(const char* name, const char* title, Int_t offset); virtual~TStreamerBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; Int_tGetBaseVersion(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerBase.html:1348,Error,Error,1348,root/html532/TStreamerBase.html,https://root.cern,https://root.cern/root/html532/TStreamerBase.html,1,['Error'],['Error']
Availability," TStreamerBase(); TStreamerBase(const char* name, const char* title, Int_t offset); virtual~TStreamerBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; UInt_tGetBaseCheckSum();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerBase.html:1348,Error,Error,1348,root/html534/TStreamerBase.html,https://root.cern,https://root.cern/root/html534/TStreamerBase.html,1,['Error'],['Error']
Availability," TStreamerBasicType(); TStreamerBasicType(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); virtual~TStreamerBasicType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCounter() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerBasicType.html:1438,Error,Error,1438,root/html532/TStreamerBasicType.html,https://root.cern,https://root.cern/root/html532/TStreamerBasicType.html,2,['Error'],['Error']
Availability," TStreamerElement(); TStreamerElement(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); virtual~TStreamerElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayDim() const; Int_tGetArrayLength() const; TClass*GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerElement.html:1317,Error,Error,1317,root/html532/TStreamerElement.html,https://root.cern,https://root.cern/root/html532/TStreamerElement.html,2,['Error'],['Error']
Availability," TStreamerObject(); TStreamerObject(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerObject.html:1418,Error,Error,1418,root/html532/TStreamerObject.html,https://root.cern,https://root.cern/root/html532/TStreamerObject.html,2,['Error'],['Error']
Availability," TStreamerObjectAny(); TStreamerObjectAny(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObjectAny(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArray",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerObjectAny.html:1432,Error,Error,1432,root/html532/TStreamerObjectAny.html,https://root.cern,https://root.cern/root/html532/TStreamerObjectAny.html,2,['Error'],['Error']
Availability," TStreamerObjectPointer(); TStreamerObjectPointer(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObjectPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerObjectPointer.html:1459,Error,Error,1459,root/html532/TStreamerObjectPointer.html,https://root.cern,https://root.cern/root/html532/TStreamerObjectPointer.html,2,['Error'],['Error']
Availability," TStreamerSTL(); TStreamerSTL(const char* name, const char* title, Int_t offset, const char* typeName, const char* trueType, Bool_t dmPointer); virtual~TStreamerSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerSTL.html:1381,Error,Error,1381,root/html532/TStreamerSTL.html,https://root.cern,https://root.cern/root/html532/TStreamerSTL.html,1,['Error'],['Error']
Availability," TStreamerString(); TStreamerString(const char* name, const char* title, Int_t offset); virtual~TStreamerString(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerString.html:1352,Error,Error,1352,root/html532/TStreamerString.html,https://root.cern,https://root.cern/root/html532/TStreamerString.html,2,['Error'],['Error']
Availability," TString & TSystem::GetLastErrorString ; (; ). protected . Return the thread local storage for the custom last error message. ; Definition at line 2102 of file TSystem.cxx. ◆ GetLastErrorString() [2/2]. const TString & TSystem::GetLastErrorString ; (; ); const. protected . Return the thread local storage for the custom last error message. ; Definition at line 2111 of file TSystem.cxx. ◆ GetLibraries(). const char * TSystem::GetLibraries ; (; const char * ; regexp = """", . const char * ; options = """", . Bool_t ; isRegexp = kTRUE . ). virtual . Return a space separated list of loaded shared libraries. ; Regexp is a wildcard expression, see TRegexp::MakeWildcard. This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of:; S: shared libraries loaded at the start of the executable, because they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; L: this option is ignored, and available for backward compatibility. . Reimplemented in TWinNTSystem.; Definition at line 2136 of file TSystem.cxx. ◆ GetLinkdefSuffix(). const char * TSystem::GetLinkdefSuffix ; (; ); const. virtual . Return the linkdef suffix chosen by the user for ACLiC. ; See TSystem::CompileMacro for more details. ; Definition at line 4001 of file TSystem.cxx. ◆ GetLinkedLibraries(). const char * TSystem::GetLinkedLibraries ; (; ). protectedvirtual . Get list of shared libraries loaded at the start of the executable. ; Returns 0 in case list cannot be obtained or in case of error. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2120 of file TSystem.cxx. ◆ GetLinkedLibs(). const char * TSystem::GetLinkedLibs ; (; ); const. virtual . Return the list of library linked to this executable. ; See TSystem::CompileMacro for more details. ; Definition at line 3992 of file TSystem.cxx. ◆ GetListOfFileHandlers(). virtual TSeqCollection * TSystem::GetListOfFileHandlers ; (; ); const. inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:61791,avail,available,61791,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['avail'],['available']
Availability," TString &strippedClass)TApplication; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TRint &)=deleteTRintprivate; TObject::operator=(const TObject &rhs)TObjectinline; Paint(Option_t *option="""")TObjectvirtual; ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)TApplicationprotectedstatic; Pop()TObjectvirtual; Print(Option_t *option="""") constTObjectvirtual; PrintLogo(Bool_t lite=kFALSE)TRintvirtual; ProcessFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)TApplicationvirtual; ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)TApplicationvirtual; ProcessLineNr(const char *filestem, const char *line, Int_t *error=nullptr)TRintprivate; ProcessRemote(const char *line, Int_t *error=nullptr) overrideTRintprivatevirtual; QuitOpt() constTApplicationinline; Raise()TApplicationinlinevirtual; Read(const char *name)TObjectvirtual; RecursiveRemove(TObject *obj)TObjectvirtual; RemoveIdleTimer()TApplicationvirtual; ResetBit(UInt_t f)TObjectinline; ReturnFromRun() constTApplicationinline; ReturnPressed(char *text)TApplicationvirtual; Run(Bool_t retrn=kFALSE) overrideTRintvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEchoMode(Bool_t mode) overrideTRintvirtual; SetIdleTimer(UInt_t idleTimeInSec, const char *command)TApplicationvirtual; SetObjectStat(Bool_t stat)TObjectstatic; SetPrompt(const char *newPrompt)TRintvirtual; SetReturnFromRun(Bool_t ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint-members.html:10013,error,error,10013,doc/master/classTRint-members.html,https://root.cern,https://root.cern/doc/master/classTRint-members.html,1,['error'],['error']
Availability," TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir). Double_t DerivDir(TMatrixD& Dir). Bool_t LineSearch(TMatrixD& Dir, vector<Double_t>& Buffer, Double_t* dError = 0). void SetDirWeight",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:22782,avail,available,22782,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,10,['avail'],['available']
Availability," TStructNode(const TStructNode&); TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); virtual~TStructNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructNode.html:1730,Error,Error,1730,root/html532/TStructNode.html,https://root.cern,https://root.cern/root/html532/TStructNode.html,2,['Error'],['Error']
Availability," TStructNodeProperty(const TStructNodeProperty&); TStructNodeProperty(const char* name, Int_t color); TStructNodeProperty(const char* name, Pixel_t pixel); virtual~TStructNodeProperty(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TColorGetColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructNodeProperty.html:1371,Error,Error,1371,root/html532/TStructNodeProperty.html,https://root.cern,https://root.cern/root/html532/TStructNodeProperty.html,2,['Error'],['Error']
Availability," TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:2570,error,error,2570,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,7,"['Error', 'error']","['Error', 'error']"
Availability," TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlignment() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; Int_tGetFontSize() const; virtual const char*TObject::GetIconName() const; TList*GetListOfLines() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); const char*GetSeparator() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocLatexDirective.html:2246,error,error,2246,root/html528/TDocLatexDirective.html,https://root.cern,https://root.cern/root/html528/TDocLatexDirective.html,10,['error'],['error']
Availability," TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocDirective.html:2431,error,error,2431,root/html528/TDocDirective.html,https://root.cern,https://root.cern/root/html528/TDocDirective.html,20,['error'],['error']
Availability," TSynapse(); TSynapse(const TSynapse&); TSynapse(TNeuron*, TNeuron*, Double_t w = 1); virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSynapse.html:1410,Error,Error,1410,root/html532/TSynapse.html,https://root.cern,https://root.cern/root/html532/TSynapse.html,2,['Error'],['Error']
Availability," TSynapses, for debugging ; Definition at line 303 of file TNeuron.cxx. ◆ PrintMessage(). void TMVA::TNeuron::PrintMessage ; (; EMsgType ; type, . TString ; message . ). private . print message, for debugging ; Definition at line 336 of file TNeuron.cxx. ◆ PrintPostLinks(). void TMVA::TNeuron::PrintPostLinks ; (; ); const. inline . Definition at line 119 of file TNeuron.h. ◆ PrintPreLinks(). void TMVA::TNeuron::PrintPreLinks ; (; ); const. inline . Definition at line 118 of file TNeuron.h. ◆ SetActivationEqn(). void TMVA::TNeuron::SetActivationEqn ; (; TActivation * ; activation). set activation equation ; Definition at line 160 of file TNeuron.cxx. ◆ SetBiasNeuron(). void TMVA::TNeuron::SetBiasNeuron ; (; ). inline . Definition at line 114 of file TNeuron.h. ◆ SetDEDw(). void TMVA::TNeuron::SetDEDw ; (; Double_t ; DEDw). inline . Definition at line 115 of file TNeuron.h. ◆ SetError(). void TMVA::TNeuron::SetError ; (; Double_t ; error). set error, this should only be done for an output neuron ; Definition at line 212 of file TNeuron.cxx. ◆ SetInputCalculator(). void TMVA::TNeuron::SetInputCalculator ; (; TNeuronInput * ; calculator). set input calculator ; Definition at line 151 of file TNeuron.cxx. ◆ SetInputNeuron(). void TMVA::TNeuron::SetInputNeuron ; (; ). inline . Definition at line 112 of file TNeuron.h. ◆ SetOutputNeuron(). void TMVA::TNeuron::SetOutputNeuron ; (; ). inline . Definition at line 113 of file TNeuron.h. ◆ Streamer(). virtual void TMVA::TNeuron::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::TNeuron::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 157 of file TNeuron.h. ◆ UpdateSynapsesBatch(). void TMVA::TNeuron::UpdateSynapsesBatch ; (; ). update and adjust the pre-synapses for each neuron (input neuron has no pre-synapse) this method should only be called in batch mode ; Definition at line 224 of file TNeur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TNeuron.html:19054,error,error,19054,doc/master/classTMVA_1_1TNeuron.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TNeuron.html,1,['error'],['error']
Availability," TSystemDirectory(); TSystemDirectory(const char* dirname, const char* path); virtual~TSystemDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSystemDirectory.html:1384,Error,Error,1384,root/html532/TSystemDirectory.html,https://root.cern,https://root.cern/root/html532/TSystemDirectory.html,2,['Error'],['Error']
Availability," TSystemFile&); TSystemFile(const char* filename, const char* dirname); virtual~TSystemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystemFile.html:1478,error,error,1478,root/html528/TSystemFile.html,https://root.cern,https://root.cern/root/html528/TSystemFile.html,6,['error'],['error']
Availability," TSystemFile(); TSystemFile(const TSystemFile&); TSystemFile(const char* filename, const char* dirname); virtual~TSystemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSystemFile.html:1349,Error,Error,1349,root/html532/TSystemFile.html,https://root.cern,https://root.cern/root/html532/TSystemFile.html,2,['Error'],['Error']
Availability," TTVRecord(); TTVRecord(const TTVRecord&); virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTVRecord.html:1306,error,error,1306,root/html530/TTVRecord.html,https://root.cern,https://root.cern/root/html530/TTVRecord.html,7,"['Error', 'error']","['Error', 'error']"
Availability," TTVSession(TTreeViewer* tv); TTVSession(const TTVSession&); virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTVSession.html:1246,Error,Error,1246,root/html532/TTVSession.html,https://root.cern,https://root.cern/root/html532/TTVSession.html,2,['Error'],['Error']
Availability," TTableMap(const TTable* table = 0); TTableMap(const TTableMap& map); virtual~TTableMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTable::iteratorBegin(); TTable::iteratorBegin() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTableMap.html:2368,Error,Error,2368,root/html532/TTableMap.html,https://root.cern,https://root.cern/root/html532/TTableMap.html,2,['Error'],['Error']
Availability," TToggle(); TToggle(const TToggle&); ~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TToggle.html:2095,error,error,2095,root/html528/TToggle.html,https://root.cern,https://root.cern/root/html528/TToggle.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TToggleGroup(); TToggleGroup(const TToggleGroup&); virtual~TToggleGroup(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(TToggle* t, Bool_t select = 1); virtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TToggleGroup.html:1434,Error,Error,1434,root/html532/TToggleGroup.html,https://root.cern,https://root.cern/root/html532/TToggleGroup.html,2,['Error'],['Error']
Availability," TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:69761,error,error,69761,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability," TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeDrawArgsParser.html:1369,Error,Error,1369,root/html532/TTreeDrawArgsParser.html,https://root.cern,https://root.cern/root/html532/TTreeDrawArgsParser.html,2,['Error'],['Error']
Availability," TTreeFormulaManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormulaManager.html:1507,error,error,1507,root/html528/TTreeFormulaManager.html,https://root.cern,https://root.cern/root/html528/TTreeFormulaManager.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TTreeIndex(); TTreeIndex(const TTree* T, const char* majorname, const char* minorname); virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:1370,Error,Error,1370,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,1,['Error'],['Error']
Availability," TTreeIndex(); TTreeIndex(const TTreeIndex&); TTreeIndex(const TTree* T, const char* majorname, const char* minorname); virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeIndex.html:1378,Error,Error,1378,root/html532/TTreeIndex.html,https://root.cern,https://root.cern/root/html532/TTreeIndex.html,1,['Error'],['Error']
Availability," TTreeProxy (see MakeProxy) and including the files in the proper location.; If the branch name can not be used a proper C++ symbol name, it will be modified as follow:; white spaces are removed; if the leading character is not a letter, an underscore is inserted; < and > are replace by underscores; * is replaced by st; & is replaced by rf. If a cutfilename is specified, for each entry, we execute if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute htemp(macrofilename());; The default for the histogram are the same as for TTreePlayer::DrawSelect ; Implements TVirtualTreePlayer.; Definition at line 303 of file TTreePlayer.cxx. ◆ DrawSelect(). Long64_t TTreePlayer::DrawSelect ; (; const char * ; varexp0, . const char * ; selection, . Option_t * ; option, . Long64_t ; nentries, . Long64_t ; firstentry . ). overridevirtual . Draw expression varexp for specified entries that matches the selection. ; Returns -1 in case of error or number of selected events in case of success.; See the documentation of TTree::Draw for the complete details. ; Implements TVirtualTreePlayer.; Definition at line 347 of file TTreePlayer.cxx. ◆ Fit(). Int_t TTreePlayer::Fit ; (; const char * ; formula, . const char * ; varexp, . const char * ; selection, . Option_t * ; option, . Option_t * ; goption, . Long64_t ; nentries, . Long64_t ; firstentry . ). overridevirtual . Fit a projected item(s) from a Tree. ; Returns -1 in case of error or number of selected events in case of success.; The formula is a TF1 expression.; See TTree::Draw for explanations of the other parameters.; By default the temporary histogram created is called htemp. If varexp contains >>hnew , the new histogram created is called hnew and it is kept in the current directory. Example: tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory.; xDouble_t x[n]Definition legend1.C:17; The function returns the status of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:22246,error,error,22246,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['error'],['error']
Availability," TTreeResult(); TTreeResult(Int_t nfields); TTreeResult(const TTreeResult&); virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeResult.html:1475,Error,Error,1475,root/html532/TTreeResult.html,https://root.cern,https://root.cern/root/html532/TTreeResult.html,2,['Error'],['Error']
Availability," TTreeRow(); TTreeRow(Int_t nfields); TTreeRow(Int_t nfields, const Int_t* fields, const char* row); virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeRow.html:1428,Error,Error,1428,root/html534/TTreeRow.html,https://root.cern,https://root.cern/root/html534/TTreeRow.html,1,['Error'],['Error']
Availability," TTreeRow(); TTreeRow(Int_t nfields); TTreeRow(const TTreeRow&); TTreeRow(Int_t nfields, const Int_t* fields, const char* row); virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeRow.html:1455,Error,Error,1455,root/html532/TTreeRow.html,https://root.cern,https://root.cern/root/html532/TTreeRow.html,1,['Error'],['Error']
Availability," TTreeSQL, TVirtualIndex, TVirtualTreePlayer, ROOT::Experimental::TTreeReaderFast, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, TChainIndex, TFileDrawMap, ROOT::Internal::TFriendProxyDescriptor, TSelectorDraw, TSelectorEntries, TTreeDrawArgsParser, TTreeFormula, TTreeFormulaManager, TTreeIndex, TTreePerfStats, TTreePlayer, TTreeReader, TParallelCoord, TParallelCoordRange, TParallelCoordSelect, TParallelCoordVar, TSpider, TTreeViewer, TTVRecord, TTVSession, iterplugin, h1analysis, h1analysisTreeReader, PyROOT::RegulatorCleanup, ROOT::Internal::TCheckHashRecursiveRemoveConsistency, and ROOT::Experimental::Internal::RKeyBlob.; Definition at line 894 of file TObject.cxx. ◆ StreamerNVirtual(). void TObject::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 243 of file TObject.h. ◆ SysError(). void TObject::SysError ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1007 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 807 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts stand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:115077,error,error,115077,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['error'],['error']
Availability," TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUri.html:1423,Error,Error,1423,root/html532/TUri.html,https://root.cern,https://root.cern/root/html532/TUri.html,2,['Error'],['Error']
Availability," TUrl(); TUrl(const TUrl& url); TUrl(const char* url, Bool_t defaultIsFile = kFALSE); virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUrl.html:1429,Error,Error,1429,root/html532/TUrl.html,https://root.cern,https://root.cern/root/html532/TUrl.html,2,['Error'],['Error']
Availability," TVector2(); TVector2(Double_t* s); TVector2(const TVector2&); TVector2(Double_t x0, Double_t y0); virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVector2.html:1269,Error,Error,1269,root/html532/TVector2.html,https://root.cern,https://root.cern/root/html532/TVector2.html,2,['Error'],['Error']
Availability," TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVectorT_double_.html:2737,Error,Error,2737,root/html532/TVectorT_double_.html,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html,4,['Error'],['Error']
Availability," TVirtualIndex, TVirtualTreePlayer, ROOT::Experimental::TTreeReaderFast, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, TChainIndex, TFileDrawMap, ROOT::Internal::TFriendProxyDescriptor, TSelectorDraw, TSelectorEntries, TTreeDrawArgsParser, TTreeFormula, TTreeFormulaManager, TTreeIndex, TTreePerfStats, TTreePlayer, TTreeReader, TParallelCoord, TParallelCoordRange, TParallelCoordSelect, TParallelCoordVar, TSpider, TTreeViewer, TTVRecord, TTVSession, iterplugin, h1analysis, h1analysisTreeReader, PyROOT::RegulatorCleanup, and ROOT::Internal::TCheckHashRecursiveRemoveConsistency.; Definition at line 888 of file TObject.cxx. ◆ StreamerNVirtual(). void TObject::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 243 of file TObject.h. ◆ SysError(). void TObject::SysError ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1001 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 801 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:116147,error,error,116147,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['error'],['error']
Availability," TVirtualMonitoringReader(const char* = """"); TVirtualMonitoringReader(const TVirtualMonitoringReader&); virtual~TVirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualMonitoringReader.html:1417,Error,Error,1417,root/html532/TVirtualMonitoringReader.html,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html,2,['Error'],['Error']
Availability," TVirtualMonitoringWriter(); TVirtualMonitoringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualMonitoringWriter.html:1346,Error,Error,1346,root/html532/TVirtualMonitoringWriter.html,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html,2,['Error'],['Error']
Availability," TVirtualX.; Definition at line 3073 of file TGWin32.cxx. ◆ SetDrawMode(). void TGWin32::SetDrawMode ; (; EDrawMode ; mode). overridevirtual . Set the drawing mode. ; mode : drawing mode mode=1 copy mode=2 xor mode=3 invert mode=4 set the suitable mode for cursor echo according to the vendor ; Reimplemented from TVirtualX.; Definition at line 3102 of file TGWin32.cxx. ◆ SetFillColor(). void TGWin32::SetFillColor ; (; Color_t ; cindex). overridevirtual . Set color index for fill areas. ; Reimplemented from TAttFill.; Definition at line 3132 of file TGWin32.cxx. ◆ SetFillStyle(). void TGWin32::SetFillStyle ; (; Style_t ; fstyle). overridevirtual . Set fill area style. ; fstyle : compound fill area interior style fstyle = 1000*interiorstyle + styleindex ; Reimplemented from TAttFill.; Definition at line 3166 of file TGWin32.cxx. ◆ SetForeground(). void TGWin32::SetForeground ; (; GContext_t ; gc, . ULong_t ; foreground . ). overridevirtual . Set foreground color in graphics context (shortcut for ChangeGC with only foreground mask set). ; Reimplemented from TVirtualX.; Definition at line 7072 of file TGWin32.cxx. ◆ SetIconName(). void TGWin32::SetIconName ; (; Window_t ; id, . char * ; name . ). overridevirtual . Set window icon name. ; Reimplemented from TVirtualX.; Definition at line 6512 of file TGWin32.cxx. ◆ SetIconPixmap(). void TGWin32::SetIconPixmap ; (; Window_t ; id, . Pixmap_t ; pic . ). overridevirtual . Set pixmap the WM can use when the window is iconized. ; Reimplemented from TVirtualX.; Definition at line 6522 of file TGWin32.cxx. ◆ SetInput(). void TGWin32::SetInput ; (; Int_t ; inp). private . Set input on or off. ; Definition at line 3225 of file TGWin32.cxx. ◆ SetInputFocus(). void TGWin32::SetInputFocus ; (; Window_t ; id). overridevirtual . Set keyboard input focus to window id. ; Reimplemented from TVirtualX.; Definition at line 6807 of file TGWin32.cxx. ◆ SetKeyAutoRepeat(). void TGWin32::SetKeyAutoRepeat ; (; Bool_t ; on = kTRUE). overridevirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:107633,mask,mask,107633,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['mask'],['mask']
Availability," TVirtualX.cxx. ◆ DrawPolyLine(). void TVirtualX::DrawPolyLine ; (; Int_t ; n, . TPoint * ; xy . ). virtual . Draws a line through all points in the list. ; Parameters. [in]nnumber of points ; [in]xylist of points . Reimplemented in TGQuartz, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 320 of file TVirtualX.cxx. ◆ DrawPolyMarker(). void TVirtualX::DrawPolyMarker ; (; Int_t ; n, . TPoint * ; xy . ). virtual . Draws ""n"" markers with the current attributes at position [x,y]. ; Parameters. [in]nnumber of markers to draw ; [in]xyan array of x,y marker coordinates . Reimplemented in TGQuartz, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 330 of file TVirtualX.cxx. ◆ DrawRectangle(). void TVirtualX::DrawRectangle ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). virtual . Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ; GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1913 of file TVirtualX.cxx. ◆ DrawSegments(). void TVirtualX::DrawSegments ; (; Drawable_t ; id, . GContext_t ; gc, . Segment_t * ; seg, . Int_t ; nseg . ). virtual . Draws multiple line segments. ; Each line is specified by a pair of points.; Parameters. [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-ori",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:73866,mask,mask,73866,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,2,['mask'],['mask']
Availability," TVirtualX::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). virtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1572 of file TVirtualX.cxx. ◆ ChangeWindowAttributes(). void TVirtualX::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). virtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1554 of file TVirtualX.cxx. ◆ CheckEvent(). Bool_t TVirtualX::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). virtual . Check if there is for window ""id"" an event of type ""type"". ; If there is it fills in the event structure and return true. If no such event return false. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1613 of file TVirtualX.cxx. ◆ Class(). static TClass * TVirtualX::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TVirtualX::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TVirtualX::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:53557,mask,mask,53557,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['mask']
Availability," TXMLAttr(const char* key, const char* value); virtual~TXMLAttr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLAttr.html:1413,error,error,1413,root/html528/TXMLAttr.html,https://root.cern,https://root.cern/root/html528/TXMLAttr.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TXMLDocument(_xmlDoc* doc); virtual~TXMLDocument(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; const char*Encoding() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLDocument.html:1469,error,error,1469,root/html528/TXMLDocument.html,https://root.cern,https://root.cern/root/html528/TXMLDocument.html,8,"['Error', 'error']","['Error', 'error']"
Availability," TXMLNode(_xmlNode* node, TXMLNode* parent = 0, TXMLNode* previous = 0); virtual~TXMLNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLNode.html:1506,Error,Error,1506,root/html532/TXMLNode.html,https://root.cern,https://root.cern/root/html532/TXMLNode.html,2,['Error'],['Error']
Availability," TXNetFileStager(const char* stager = """"); TXNetFileStager(const TXNetFileStager&); virtual~TXNetFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetFileStager.html:1279,Error,Error,1279,root/html532/TXNetFileStager.html,https://root.cern,https://root.cern/root/html532/TXNetFileStager.html,2,['Error'],['Error']
Availability," TZIPFile(const char* archive, const char* member, TFile* file); virtual~TZIPFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TArchiveFile::GetArchiveName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TArchiveMember*TArchiveFile::GetMember() const; Long64_tTArchiveFile::GetMemberFilePosition() const; Int_tTArchiveFile::GetMemberIndex() const; const char*TArchiveFile::GetMemberName() const; TObjArray*TArchiveFile::GetMembers() const; virtual const char*TObject::GetName() const; Int_tTArchiveFile::GetNumberOfMembers() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPFile.html:3397,error,error,3397,root/html528/TZIPFile.html,https://root.cern,https://root.cern/root/html528/TZIPFile.html,6,['error'],['error']
Availability," Tanh; Layer 4 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 128 , 1 ) Activation Function = Identity; : Using 11200 events for training and 2800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 1.171; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.66619 0.628056 0.587341 0.0468945 20605.2 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.605139 0.593298 0.586597 0.0468674 20632.5 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.581823 0.587355 0.586416 0.0468644 20639.4 0; : 4 | 0.575813 0.593823 0.586862 0.0466947 20615.8 1; : 5 Minimum Test error found - save the configuration ; : 5 | 0.572257 0.578309 0.587324 0.0469531 20608.1 0; : 6 | 0.567347 0.582461 0.586969 0.0467966 20615.6 1; : 7 Minimum Test error found - save the configuration ; : 7 | 0.564553 0.577241 0.588162 0.0470086 20578.3 0; : 8 | 0.56278 0.582039 0.588324 0.0468355 20565.5 1; : 9 | 0.559377 0.582454 0.588676 0.0469029 20554.7 2; : 10 | 0.55743 0.581686 0.590386 0.0469245 20490.9 3; : 11 | 0.555638 0.57854 0.591068 0.0469776 20467.2 4; : 12 | 0.556914 0.579893 0.589121 0.0470111 20542 5; : 13 | 0.553226 0.579356 0.590241 0.0470372 20500.6 6; : 14 Minimum Test error found - save the configuration ; : 14 | 0.551359 0.575116 0.590392 0.0472515 20503 0; : 15 | 0.550484 0.575412 0.59006 0.0471061 20510 1; : 16 Minimum Test error found - save the configuration ; : 16 | 0.548532 0.572184 0.591616 0.0473333 20460 0; : 17 | 0.544023 0.585132 0.591038 0.0471532 20474.9 1; : 18 | 0.543801 0.585958 0.59089 0.0471671 20481 2; : 19 | 0.543073 0.577544 0.59151 0.0472011 20459 3; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:24704,error,error,24704,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['error'],['error']
Availability," Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MinuitWrapper.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MinuitWrapper.html:19256,error,error,19256,root/html528/TMVA__MinuitWrapper.html,https://root.cern,https://root.cern/root/html528/TMVA__MinuitWrapper.html,1,['error'],['error']
Availability," Text angle in degrees.; The text angle of any class inheriting from TAttText can; be changed using the method SetTextAngle and retrieved using the; method GetTextAngle.; The following picture shows the text angle:. Picture; Source. {; TCanvas *Ta = new TCanvas(""Ta"",""Text angle"",0,0,300,326);; Ta->Range(0,0,1,1);; TLine *l = new TLine();; l->SetLineColor(kRed);; l->DrawLine(0.1,0.1,0.9,0.1);; l->DrawLine(0.1,0.1,0.9,0.9);; TMarker *m = new TMarker();; m->SetMarkerStyle(20);; m->SetMarkerColor(kBlue);; m->DrawMarker(0.1,0.1);; TArc *a = new TArc();; a->SetFillStyle(0);; a->SetLineColor(kBlue); a->SetLineStyle(3);; a->DrawArc(0.1, 0.1, 0.2, 0.,45.,""only"");; TText *tt = new TText(0.1,0.1,""Text angle is 45 degrees"");; tt->SetTextAlign(11); tt->SetTextSize(0.1);; tt->SetTextAngle(45);; tt->Draw();; TLatex *t1 = new TLatex(0.3,0.18,""45^{o}"");; t1->Draw();; return Ta;; }. Mnemonic constants are available:; <pre>; kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; </pre>; They allow to write:; <pre>; object->SetTextAlign(kHAlignLeft+kVAlignTop);; </pre>. Text Color; The text color is a color index (integer) pointing in the ROOT; color table.; The text color of any class inheriting from TAttText can; be changed using the method SetTextColor and retrieved using the; method GetTextColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Text colors"",0,0,500,200);; c->DrawColorTable();; return c;; }. Color transparency; SetTextColorAlpha(), allows to set a transparent color.; In the following example the text color of the text text; is set to blue with a transparency of 35%. The color kBlue; itself remains fully opaque. text->SetTextColorAlpha(kBlue, 0.35);. The transparency is available on all platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, PNG,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAttText.html:3316,avail,available,3316,root/html602/TAttText.html,https://root.cern,https://root.cern/root/html602/TAttText.html,4,['avail'],['available']
Availability," Text angle in degrees.; The text angle of any class inheriting from TAttText can; be changed using the method SetTextAngle and retrieved using the; method GetTextAngle.; The following picture shows the text angle:. Picture; Source. {; TCanvas *Ta = new TCanvas(""Ta"",""Text angle"",0,0,300,326);; Ta->Range(0,0,1,1);; TLine *l = new TLine();; l->SetLineColor(kRed);; l->DrawLine(0.1,0.1,0.9,0.1);; l->DrawLine(0.1,0.1,0.9,0.9);; TMarker *m = new TMarker();; m->SetMarkerStyle(20);; m->SetMarkerColor(kBlue);; m->DrawMarker(0.1,0.1);; TArc *a = new TArc();; a->SetFillStyle(0);; a->SetLineColor(kBlue); a->SetLineStyle(3);; a->DrawArc(0.1, 0.1, 0.2, 0.,45.,""only"");; TText *tt = new TText(0.1,0.1,""Text angle is 45 degrees"");; tt->SetTextAlign(11); tt->SetTextSize(0.1);; tt->SetTextAngle(45);; tt->Draw();; TLatex *t1 = new TLatex(0.3,0.18,""45^{o}"");; t1->Draw();; return Ta;; }. Mnemonic constants are available:; <pre>; kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; </pre>; They allow to write:; <pre>; object->SetTextAlign(kHAlignLeft+kVAlignTop);; </pre>. Text Color; The text color is a color index (integer) pointing in the ROOT; color table.; The text color of any class inheriting from TAttText can; be changed using the method SetTextColor and retrieved using the; method GetTextColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Text colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Color transparency; SetTextColorAlpha(), allows to set a transparent color.; In the following example the text color of the text text; is set to blue with a transparency of 35%. The color kBlue; itself remains fully opaque. . text->SetTextColorAlpha(kBlue, 0.35);. ; The transparency is available on all platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttText.html:3320,avail,available,3320,root/html534/TAttText.html,https://root.cern,https://root.cern/root/html534/TAttText.html,2,['avail'],['available']
Availability," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:11330,error,error,11330,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['error'],['error']
Availability," The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153015,error,errors,153015,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability," The default value is kAskUser.; The user will be asked to confirm overwriting dataset or files unless; specified opt provides the answer!; If kOverwriteNoFiles is set, then a pointer to TList must be passed as; skippedFiles argument. The function will add to this list TFileInfo; objects describing all files that existed on the cluster and were; not uploaded. Communication Summary; Client Master; |------------>DataSetName----------->|; |<-------kMESS_OK/kMESS_NOTOK<-------| (Name OK/file exist); (*)|-------> call RegisterDataSet ------->|; (*) - optional. Int_t UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Upload a set of files and save the list of files by name dataSetName.; The mask 'opt' is a combination of EUploadOpt:; kAppend (0x1) if set true files will be appended to; the dataset existing by given name; kOverwriteDataSet (0x2) if dataset with given name exited it; would be overwritten; kNoOverwriteDataSet (0x4) do not overwirte if the dataset exists; kOverwriteAllFiles (0x8) overwrite all files that may exist; kOverwriteNoFiles (0x10) overwrite none; kAskUser (0x0) ask user before overwriteng dataset/files; The default value is kAskUser.; The user will be asked to confirm overwriting dataset or files unless; specified opt provides the answer!; If kOverwriteNoFiles is set, then a pointer to TList must be passed as; skippedFiles argument. The function will add to this list TFileInfo; objects describing all files that existed on the cluster and were; not uploaded. Int_t UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Upload files listed in ""file"" to PROOF cluster.; Where file = name of file containing list of files and; dataset = dataset name and opt is a combination of EUploadOpt bits.; Each file description (line) can include wildcards.; Check TFileInfo compatibility. Bool_t RegisterDataSet(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:78715,mask,mask,78715,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['mask'],['mask']
Availability," The entered string is checked after Enter key was pressed. An error message shows up if the string is not accepted. The current prototype is limited and users have no freedom to enter file/user function names in this field.; ""Set Parameters"" button opens a dialog for parameters settings.; ""Fit Settings"" provides user interface elements related to the fitter. Currently there are two method choices: Chi-square and Binned Likelihood.; ""Linear Fit"" check button sets the use of Linear fitter is it is selected. Otherwise the option 'F' is applied if polN is selected. ""Robust"" number entry sets the robust value when fitting graphs. ""No Chi-square"" check button sets ON/OFF option 'C' - do not calculate Chi-square (for Linear fitter).; Fit options: ""Integral"" check button switch ON/OFF option 'I' - use integral of function instead of value in bin center. ""Best Errors"" sets ON/OFF option 'E' - better errors estimation using Minos technique. ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1, excluding empty bins and ignoring error bars. ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights equal to 1, including empty bins, error bars ignored. ""Use range"" sets ON/OFF option 'R' - fit only data within the specified function range with the slider. ""Improve fit results"" sets ON/OFF option 'M' - after minimum is found, search for a new one. ""Add to list"" sets On/Off option '+'- add function to the list without deleting the previous.; Draw options: ""SAME"" sets On/Off function drawing on the same pad. ""No drawing"" sets On/Off option '0'- do not draw function graphics. ""Do not store/draw"" sets On/Off option 'N'- do not store the function, do not draw it.; Sliders settings are used if option 'R' - use range is active. Users can change min/max values by pressing the left mouse button near to the left/right slider edges. It is possible o change both values simultaneously by pressing the left mouse button near to its center and moving it to a new desire position.; ""M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:2508,error,error,2508,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['error'],['error']
Availability," The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate.; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Int_t Merge(TCollection* list); Adds all graphs with erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphErrors.html:19118,error,errors,19118,root/html602/TGraphErrors.html,https://root.cern,https://root.cern/root/html602/TGraphErrors.html,4,['error'],['errors']
Availability," The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate.; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. void Print(Option_t* chopt = """") const; Print graph and e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:18629,error,errors,18629,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,2,['error'],['errors']
Availability," The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 206 const Float_t *exH, std::vector<std::vector<Float_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:8464,error,errors,8464,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability," The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& ); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TKey.html:17191,error,error,17191,root/html534/TKey.html,https://root.cern,https://root.cern/root/html534/TKey.html,6,['error'],['error']
Availability," The parameter ngroup is the number of variable size bins in the created profile; The array xbins must contain ngroup+1 elements that represent the low-edge; of the bins.; The data of the old bins are added to the new bin which contains the bin center; of the old bins. It is possible that information from the old binning are attached; to the under-/overflow bins of the new binning. examples: if hp is an existing TProfile with 100 bins; Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew. void RebinAxis(Double_t x, TAxis* axis); Profile histogram is resized along x axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old histogram to fill the rebinned histogram.; Takes into account errors (Sumw2) if any.; The bit kCanRebin must be set before invoking this function.; Ex: h->SetBit(TH1::kCanRebin);. void Reset(Option_t* option = """"); -*Reset contents of a Profile histogram; *-* =====================================. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void Scale(Double_t c1 = 1, Option_t* option = """"); *-*-*-*-*Multiply this profile by a constant c1*-*-*-*-*-*-*-*-*; *-* ======================================. this = c1*this. This function uses the services of TProfile::Add. void SetBinEntries(Int_t bin, Double_t w); Set the number of entries in bin*-*-*-; *-* ================================. void SetBins(Int_t nbins, Double_t xmin, Double_t xmax); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBins(Int_t nx, const Double_t* xbins); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBinsLength(Int_t n = -1); Set total number of bins in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:43965,error,errors,43965,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,2,['error'],['errors']
Availability," The parameter ngroup is the number of variable size bins in the created profile; The array xbins must contain ngroup+1 elements that represent the low-edge; of the bins.; The data of the old bins are added to the new bin which contains the bin center; of the old bins. It is possible that information from the old binning are attached; to the under-/overflow bins of the new binning. examples: if hp is an existing TProfile with 100 bins; Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew. void RebinAxis(Double_t x, TAxis* axis); Profile histogram is resized along x axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old histogram to fill the rebinned histogram.; Takes into account errors (Sumw2) if any.; The bit kCanRebin must be set before invoking this function.; Ex: h->SetBit(TH1::kCanRebin);. void Reset(Option_t* option = """"); -*Reset contents of a Profile histogram; *-* =====================================. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void Scale(Double_t c1 = 1, Option_t* option = """"); *-*-*-*-*Multiply this profile by a constant c1*-*-*-*-*-*-*-*-*; *-* ======================================. this = c1*this. This function uses the services of TProfile::Add. void SetBinEntries(Int_t bin, Double_t w); Set the number of entries in bin*-*-*-; *-* ================================. void SetBins(Int_t nbins, Double_t xmin, Double_t xmax); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBins(Int_t nx, const Double_t* xbins); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBuffer(Int_t buffersize, Option_t* option = """"); set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:41844,error,errors,41844,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,4,['error'],['errors']
Availability," The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:60627,error,errors,60627,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,2,['error'],['errors']
Availability," The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C) file; or TSelector object.; The default tree is analyzed (i.e. the first one found). To specify another; tree, the default tree can be changed using TFileCollection::SetDefaultMetaData .; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* dsetname, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Process a dataset which is stored on the master with name 'dsetname'.; The syntax for dsetname is name[#[dir/]objname], e.g.; ""mydset"" analysis of the first tree in the top dir of the dataset; named ""mydset""; ""mydset#T"" analysis tree ""T"" in the top dir of the dataset; named ""mydset""; ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset; named ""mydset""; ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the; dataset named ""mydset""; The component 'name' in its more general form contains also the group and; user name following ""/<group>/<user>/<dsname>"". Each of these components; can contain one or more wildcards '*', in which case all the datasets matching; the expression are added together as a global dataset (wildcard support has; been added in version 5.27/02).; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:52336,error,error,52336,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['error'],['error']
Availability," This code is pretty messy at the moment. ; Cleanup is needed. – NOT USED — ; Definition at line 964 of file RuleFitParams.cxx. ◆ ErrorRateRoc(). Double_t TMVA::RuleFitParams::ErrorRateRoc ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. This works but is less efficient than calculating the Risk using RiskPerf(). ; Definition at line 1107 of file RuleFitParams.cxx. ◆ ErrorRateRocRaw(). Double_t TMVA::RuleFitParams::ErrorRateRocRaw ; (; std::vector< Double_t > & ; sFsig, . std::vector< Double_t > & ; sFbkg . ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. ; Definition at line 1042 of file RuleFitParams.cxx. ◆ ErrorRateRocTst(). void TMVA::RuleFitParams::ErrorRateRocTst ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area.; See comment under ErrorRateRoc(). ; Definition at line 1155 of file RuleFitParams.cxx. ◆ EvaluateAverage(). void TMVA::RuleFitParams::EvaluateAverage ; (; UInt_t ; ind1, . UInt_t ; ind2, . std::vector< Double_t > & ; avsel, . std::vector< Double_t > & ; avrul . ). protected . evaluate the average of each variable and f(x) in the given range ; Definition at line 208 of file RuleFitParams.cxx. ◆ EvaluateAveragePath(). void TMVA::RuleFitParams::EvaluateAveragePath ; (; ). inlineprotected . Definition at line 177 of file RuleFitParams.h. ◆ EvaluateAveragePerf(). void TMVA::RuleFitParams::EvaluateAveragePerf ; (; ). inlineprotected . Definition at line 180 of file RuleFitParams.h. ◆ FillCoefficients(). void TMVA::RuleFitParams::FillCoefficients ; (; ). protected . helper function to store the rule coefficients in local arrays ; Definition at line 868 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:11263,error,error,11263,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['error'],['error']
Availability," This function uses the services of TH1::Add. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. One can scale an histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram. If option contains ""width"" the bin contents and errors are divided; by the bin width. void SetDefaultBufferSize(Int_t buffersize = 1000); static function to set the default buffer size for automatic histograms.; When an histogram is created with one of its axis lower limit greater; or equal to its upper limit, the function SetBuffer is automatically; called with the default buffer size. void SetDefaultSumw2(Bool_t sumw2 = kTRUE); static function.; When this static function is called with sumw2=kTRUE, all new; histograms will automatically activate the storage; of the sum of squares of errors, ie TH1::Sumw2 is automatically called. void SetTitle(const char* title); Change (i.e. set) the title. if title is in the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt, the x axis title to stringx,; the y axis title to stringy, and the z axis title to stringz.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". void SmoothArray(Int_t NN, Double_t* XX, Int_t ntimes = 1); smooth array xx, translation of Hbook routine hsmoof.F; based on algorithm 353QH twice presented by J. Friedman; in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974. void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this histogram.; if option contains ""R"" smoothing is applied only to the bins; defined in the X axis range (default is to smooth all bins); Bin contents are replaced by their smooth values.; Errors (if any) are not modified.; the smoothing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:98328,error,errors,98328,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['error'],['errors']
Availability," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:17228,toler,tolerance,17228,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,2,['toler'],['tolerance']
Availability," To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1 ; Reimplemented from TH1.; Definition at line 83 of file TProfile3D.h. ◆ SetBins() [6/7]. void TProfile3D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). inlineoverrideprivatevirtual . Redefine x axis parameters. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 77 of file TProfile3D.h. ◆ SetBins() [7/7]. void TProfile3D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax . ). inlineoverrideprivatevirtual . Redefine x and y axis parameters. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 81 of file TProfile3D.h. ◆ SetBinsLength(). void TProfile3D::SetBinsLength ; (; Int_t ; n = -1). overridevirtual . Set total number of bins including under/overflow. ; Reallocate bin contents array ; Reimplemented from TH3D.; Definition at line 1318 of file TProfile3D.cxx. ◆ SetBuffer(). void TProfile3D::SetBuffer ; (; Int_t ; buffersize, . Option_t * ; opt = """" . ). overridevirtual . Set the buffer size in units of 8 bytes (double). ; Reimplemented from TH1.; Definition at line 1327 of file TProfile3D.cxx. ◆ SetErrorOption(). void TProfile3D::SetErrorOption ; (; Option_t * ; option = """"). virtual . Set option to compute profile3D errors. ; The computation of the bin errors is based on the parameter option:; ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T), i.e. the standard error of the bin contents. Note that if TProfile3D:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:102217,error,errors,102217,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,2,['error'],['errors']
Availability," Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:41984,error,errors,41984,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,2,['error'],['errors']
Availability," TypeList<>, const RColumnReadersInfo &, const std::string &=""nominal"");  ; unsigned int GetColumnWidth (const std::vector< std::string > &names, const unsigned int minColumnSpace=8u);  Get optimal column width for printing a table given the names and the desired minimal space between columns. ;  ; std::string GetDataSourceLabel (const ROOT::RDF::RNode &node);  ; std::vector< std::string > GetFilterNames (const std::shared_ptr< RLoopManager > &loopManager);  ; std::string GetLeafTypeName (TLeaf *leaf, const std::string &colName);  ; unsigned int GetNSlots ();  ; template<std::size_t N, typename... Ts> ; decltype(auto) GetNthElement (Ts &&...args);  ; std::vector< std::string > GetValidatedArgTypes (const ColumnNames_t &colNames, const RColumnRegister &colRegister, TTree *tree, RDataSource *ds, const std::string &context, bool vector2RVec);  ; ColumnNames_t GetValidatedColumnNames (RLoopManager &lm, const unsigned int nColumns, const ColumnNames_t &columns, const RColumnRegister &colRegister, RDataSource *ds);  Given the desired number of columns and the user-provided list of columns: ;  ; template<typename dtype > ; ULong64_t GetVectorAddress (std::vector< dtype > &p);  ; Long64_t InterpreterCalc (const std::string &code, const std::string &context="""");  Jit code in the interpreter with TInterpreter::Calc, throw in case of errors. ;  ; void InterpreterDeclare (const std::string &code);  Declare code in the interpreter via the TInterpreter::Declare method, throw in case of errors. ;  ; bool IsInternalColumn (std::string_view colName);  Whether custom column with name colName is an ""internal"" column such as rdfentry_ or rdfslot_. ;  ; bool IsStrInVec (const std::string &str, const std::vector< std::string > &vec);  ; std::string JitBuildAction (const ColumnNames_t &cols, std::shared_ptr< RDFDetail::RNodeBase > *prevNode, const std::type_info &helperArgType, const std::type_info &at, void *helperArgOnHeap, TTree *tree, const unsigned int nSlots, const RColumnRegister &c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:12786,error,errors,12786,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['error'],['errors']
Availability," UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t ctxInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtualXInd(Int_t ctxInd); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLManager.html:2146,error,error,2146,root/html528/TGLManager.html,https://root.cern,https://root.cern/root/html528/TGLManager.html,10,['error'],['error']
Availability," UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t devInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t devInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtualXInd(Int_t devInd); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TX11GLManager.html:1626,error,error,1626,root/html528/TX11GLManager.html,https://root.cern,https://root.cern/root/html528/TX11GLManager.html,10,['error'],['error']
Availability," UInt_t* widths, TImage* tile); Fill spans with tile image. void CropSpans(UInt_t npt, TPoint* ppt, UInt_t* widths); Crop spans. void CopyArea(TImage* dst, Int_t xsrc, Int_t ysrc, UInt_t w, UInt_t h, Int_t xdst = 0, Int_t ydst = 0, Int_t gfunc = 3, TImage::EColorChan chan = kAllChan); Copy source region to the destination image. Copy is done according; to specified function:. enum EGraphicsFunction {; kGXclear = 0, // 0; kGXand, // src AND dst; kGXandReverse, // src AND NOT dst; kGXcopy, // src (default); kGXandInverted, // NOT src AND dst; kGXnoop, // dst; kGXxor, // src XOR dst; kGXor, // src OR dst; kGXnor, // NOT src AND NOT dst; kGXequiv, // NOT src XOR dst; kGXinvert, // NOT dst; kGXorReverse, // src OR NOT dst; kGXcopyInverted, // NOT src; kGXorInverted, // NOT src OR dst; kGXnand, // NOT src OR NOT dst; kGXset // 1; };. void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, UInt_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array of ARGB32 colors. Draw a cell array. The drawing is done with the pixel presicion; if (X2-X1)/NX (or Y) is not a exact pixel number the position of; the top rigth corner may be wrong. UInt_t AlphaBlend(UInt_t bot, UInt_t top); Return alphablended value computed from bottom and top pixel values. const ASVisual * GetVisual(); Return visual. Bool_t GetPolygonSpans(UInt_t npt, TPoint* ppt, UInt_t* nspans, TPoint** firstPoint, UInt_t** firstWidth); The code is based on Xserver/mi/mipolycon.c; ""Copyright 1987, 1998 The Open Group"". void FillPolygon(UInt_t npt, TPoint* ppt, const char* col = ""#000000"", const char* stipple = 0, UInt_t w = 16, UInt_t h = 16); Fill a convex polygon with background color or bitmap.; For non convex polygon one must use DrawFillArea method. void FillPolygon(UInt_t npt, TPoint* ppt, TImage* tile); Fill a convex polygon with background image.; For non convex polygon one must use DrawFillArea method. void CropPolygon(UInt_t npt, TPoint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:40367,down,down,40367,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,11,['down'],['down']
Availability," ULong64_tGetSocketBytesSent(); Int_tGetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:4404,error,error,4404,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['error'],['error']
Availability," ULong64_tGetSocketBytesSent(); Int_tGetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:4511,error,error,4511,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['error'],['error']
Availability," ULong64_tGetSocketBytesSent(); Int_tGetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSocket.html:4115,error,error,4115,root/html602/TSocket.html,https://root.cern,https://root.cern/root/html602/TSocket.html,4,['error'],['error']
Availability," Use when you need to calculate a selection's efficiency from two histograms, one containing all entries, and one containing the subset of these entries that pass the selection, and when you have a parametrization available for the efficiency as a function of the variable(s) under consideration.; A very common problem when estimating efficiencies is that of error estimation: when no other information is available than the total number of events N and the selected number n, the best estimate for the selection efficiency p is n/N. Standard binomial statistics dictates that the uncertainty (this presupposes sufficiently high statistics that an approximation by a normal distribution is reasonable) on p, given N, is ; \[; \sqrt{\frac{p(1-p)}{N}}; \]. However, when p is estimated as n/N, fluctuations from the true p to its estimate become important, especially for low numbers of events, and giving rise to biased results.; When fitting a parametrized efficiency, these problems can largely be overcome, as a hypothesized true efficiency is available by construction. Even so, simply using the corresponding uncertainty still presupposes that Gaussian errors yields a reasonable approximation. When using, instead of binned efficiency histograms, the original numerator and denominator histograms, a binned maximum likelihood can be constructed as the product of bin-by-bin binomial probabilities to select n out of N events. Assuming that a correct parametrization of the efficiency is provided, this construction in general yields less biased results (and is much less sensitive to binning details).; A generic use of this method is given below (note that the method works for 2D and 3D histograms as well):; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:1452,avail,available,1452,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['avail'],['available']
Availability," Uses residHist() and sets normalize=true. ; Definition at line 185 of file RooPlot.h. ◆ remove(). void RooPlot::remove ; (; const char * ; name = nullptr, . bool ; deleteToo = true . ). Remove object with given name, or last object added if no name is given. ; Definition at line 868 of file RooPlot.cxx. ◆ residHist(). RooHist * RooPlot::residHist ; (; const char * ; histname = nullptr, . const char * ; curvename = nullptr, . bool ; normalize = false, . bool ; useAverage = true . ); const. Return a RooHist (derives from TGraphAsymErrors) containing the residuals of a histogram. ; The plotting range of the graph is adapted to the plotting range of the current plot.; Parameters. histnameName of the data histogram. Passing an empty string or nullptr will create residuals of the last-plotted histogram. ; curvenameName of the curve to compare to data. Passing an empty string or nullptr will create residuals of the last-plotted curve. ; normalizeIf true, the residuals are divided by the error of the histogram, effectively returning a pull histogram. ; useAverageIf true, the histogram is compared with the curve averaged in each bin. Otherwise, the curve is evaluated at the bin centres, which is not accurate for strongly curved distributions. . Definition at line 1101 of file RooPlot.cxx. ◆ setAddDirectoryStatus(). bool RooPlot::setAddDirectoryStatus ; (; bool ; flag). static . Configure whether new instances of RooPlot will add themselves to gDirectory. ; Like TH1::AddDirectory(). ; Definition at line 78 of file RooPlot.cxx. ◆ SetAxisColor(). void RooPlot::SetAxisColor ; (; Color_t ; color = 1, . Option_t * ; axis = ""X"" . ). See alsoTH1::SetAxisColor() ; Definition at line 1276 of file RooPlot.cxx. ◆ SetAxisRange(). void RooPlot::SetAxisRange ; (; double ; xmin, . double ; xmax, . Option_t * ; axis = ""X"" . ). See alsoTH1::SetAxisRange() ; Definition at line 1278 of file RooPlot.cxx. ◆ SetBarOffset(). void RooPlot::SetBarOffset ; (; Float_t ; offset = 0.25). See alsoTH1::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPlot.html:46310,error,error,46310,doc/master/classRooPlot.html,https://root.cern,https://root.cern/doc/master/classRooPlot.html,1,['error'],['error']
Availability," Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2860 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation indicates no preference and copies the original order of 'obs' into 'orderedObs' ; Reimplemented in RooIntegralMorph, and RooCachedPdf.; Definition at line 3694 of file RooAbsReal.cxx. ◆ printEvalErrors(). void RooAbsReal::printEvalErrors ; (; std::ostream & ; os = std::cout, . Int_t ; maxPerNode = 10000000 . ). static . Print all outstanding logged evaluation error on the given ostream. ; If maxPerNode is zero, only the number of errors for each source (object with unique name) is listed. If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown per source of errors. A truncation message is shown if there were more errors logged than shown. ; Definition at line 3582 of file RooAbsReal.cxx. ◆ printMultiline(). void RooAbsReal::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Structure printing. ; Reimplemented from RooAbsArg.; Reimplemented in RooGenericPdf, RooResolutionModel, RooAbsRealLValue, RooFormulaVar, RooRealIntegral, and RooRealVar.; Definition at line 455 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:141335,error,error,141335,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability," V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Example of using TUnfold:. imagine a 2-dimensional histogram is filled, named A; y-axis: generated quantity (e.g. 10 bins); x-axis: reconstructed quantity (e.g. 20 bin); The data are filled in a 1-dimensional histogram, named y; Note1: ALWAYS choose a higher number of bins on the reconstructed side; as compared to the generated size!; Note2: the events which are generated but not reconstructed; have to be added to the appropriate overflow bins of A; Note3: make sure all bins have sufficient statistics and their error is; non-zero. By default, bins with zero error are simply skipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:4279,error,error,4279,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,4,['error'],['error']
Availability," Value returned is standard deviation of sample standard deviation.; Note that it is an approximated value which is valid only in the case that the; original data distribution is Normal. The correct one would require; the 4-th momentum value, which cannot be accurately estimated from an histogram since; the x-information for all entries is not kept. Double_t GetSkewness(Int_t axis = 1) const; For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensioned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:106869,error,error,106869,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,12,['error'],['error']
Availability," Value returned is standard deviation of sample standard deviation.; Note that it is an approximated value which is valid only in the case that the; original data distribution is Normal. The correct one would require; the 4-th momentum value, which cannot be accurately estimated from an histogram since; the x-information for all entries is not kept. Double_t GetSkewness(Int_t axis = 1) const; For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensioned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/StdDev is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:113838,error,error,113838,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,4,['error'],['error']
Availability," VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableValues (const double *x);  set the values of all existing variables (array must be dimensioned to the size of the existing parameters) ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool UseStaticMinuit (bool on=true);  static function to switch on/off usage of static global TMinuit instance (gMinuit) By default it is used (i.e. ;  . Protected Member Functions; bool CheckMinuitInstance () const;  check TMinuit instance ;  ; bool CheckVarIndex (unsigned int ivar) const;  check parameter ;  ; void DoClear ();  reset ;  ; void DoReleaseFixParameter (int ivar);  release a parameter that is fixed when it is redefined ;  ; void InitTMinuit (int ndim);  initialize the TMinuit instance ;  ; void RetrieveErrorMatrix ();  retrieve error matrix from TMinuit ;  ; void RetrieveParams ();  retrieve minimum parameters and errors from TMinuit ;  . Static Protected Member Functions; static void Fcn (int &, double *, double &f, double *, int);  implementation of FCN for Minuit ;  ; static void FcnGrad (int &, double *g, double &f, double *, int);  implementation of FCN for Minuit when user provided gradient is used ;  . Private Attributes; std::vector< double > fCovar;  ; unsigned int fDim;  ; std::vector< double > fErrors;  ; bool fMinosRun;  ; int fMinosStatus = -1;  ; TMinuit * fMinuit;  ; std::vector< double > fParams;  ; ROOT::Minuit::EMinimizerType fType;  ; bool fUsed;  . Static Private Attributes; static TMinuit * fgMinuit = nullptr;  ; static bool fgUsed = false;  ; static bool fgUseStaticMinuit = true;  . Additional Inherited Members;  Protected Attributes inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuitMinimizer.html:10904,error,error,10904,doc/master/classTMinuitMinimizer.html,https://root.cern,https://root.cern/doc/master/classTMinuitMinimizer.html,2,['error'],"['error', 'errors']"
Availability," Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual void AddWeightsXMLTo (void *parent) const =0;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false)=0;  get all the MVA values for the events of the current Data type ;  ; void PyRunString (TString code, TString errorMessage=""Failed to run python code"", int start=256);  Execute Python code from string. ;  ; virtual void ReadModelFromFile ()=0;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *wghtnode)=0;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; const TString & GetOriginalVarName (Int_t ivar) const;  ; const TString & GetWeightFileDir () const;  ; Bool_t HasTrainingTree () const;  ; Bool_t Help () const;  ; Bool_t IgnoreEventsWithNegWeightsInTraining () const;  ; Bool_t IsConstructedFromWeightFile () con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html:24294,error,errorMessage,24294,doc/master/classTMVA_1_1PyMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html,1,['error'],['errorMessage']
Availability," Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCondition.html:6651,error,error,6651,root/html534/TCondition.html,https://root.cern,https://root.cern/root/html534/TCondition.html,4,['error'],['error']
Availability," Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCondition.html:7112,error,error,7112,root/html604/TCondition.html,https://root.cern,https://root.cern/root/html604/TCondition.html,4,['error'],['error']
Availability," Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondition.html:7112,error,error,7112,root/html602/TCondition.html,https://root.cern,https://root.cern/root/html602/TCondition.html,4,['error'],['error']
Availability," Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 100 , Width = 50 ) Output = ( 1 , 100 , 50 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 50 , Width = 10 ) Output = ( 1 , 100 , 10 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 10 , Width = 4 ) Output = ( 1 , 100 , 4 ) Activation Function = Identity; : Using 3200 events for training and 800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.691476; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.605916 0.542204 0.0761789 0.00657979 45977.6 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.512732 0.499825 0.0771995 0.00657724 45311.5 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.477495 0.458718 0.0776312 0.00665553 45085.9 0; : 4 Minimum Test error found - save the configuration ; : 4 | 0.438338 0.418147 0.0780597 0.00669006 44837 0; : 5 Minimum Test error found - save the configuration ; : 5 | 0.407569 0.391703 0.0786075 0.00678976 44557.2 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.387736 0.373696 0.0792581 0.00678916 44156.9 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.373399 0.360485 0.0791536 0.00677002 44208.9 0; : 8 Minimum Test error found - save the configuration ; : 8 | 0.362792 0.352336 0.0796639 0.00682572 43933 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.353594 0.340526 0.0805399 0.00700876 43519 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.345712 0.336826 0.080966 0.0069933 43259.2 0; : 11 Minimum Test error foun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:14926,error,error,14926,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['error'],['error']
Availability," Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 4 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 128 , 1 ) Activation Function = Identity; : Using 11200 events for training and 2800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 1.171; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.66619 0.628056 0.587341 0.0468945 20605.2 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.605139 0.593298 0.586597 0.0468674 20632.5 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.581823 0.587355 0.586416 0.0468644 20639.4 0; : 4 | 0.575813 0.593823 0.586862 0.0466947 20615.8 1; : 5 Minimum Test error found - save the configuration ; : 5 | 0.572257 0.578309 0.587324 0.0469531 20608.1 0; : 6 | 0.567347 0.582461 0.586969 0.0467966 20615.6 1; : 7 Minimum Test error found - save the configuration ; : 7 | 0.564553 0.577241 0.588162 0.0470086 20578.3 0; : 8 | 0.56278 0.582039 0.588324 0.0468355 20565.5 1; : 9 | 0.559377 0.582454 0.588676 0.0469029 20554.7 2; : 10 | 0.55743 0.581686 0.590386 0.0469245 20490.9 3; : 11 | 0.555638 0.57854 0.591068 0.0469776 20467.2 4; : 12 | 0.556914 0.579893 0.589121 0.0470111 20542 5; : 13 | 0.553226 0.579356 0.590241 0.0470372 20500.6 6; : 14 Minimum Test error found - save the configuration ; : 14 | 0.551359 0.575116 0.590392 0.0472515 20503 0; : 15 | 0.550484 0.575412 0.59006 0.0471061 20510 1; : 16 Minimum Test error found - save the configuration ; : 16 | 0.548532 0.572184 0.591616 0.0473333 20460 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:24540,error,error,24540,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['error'],['error']
Availability," Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.7616; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.731202 0.712689 0.193045 0.0157486 14439.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.701214 0.698536 0.191577 0.0154545 14535.3 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.6901 0.69615 0.192163 0.0158037 14515.8 0; : 4 | 0.683586 0.700826 0.19294 0.0151654 14400.2 1; : 5 | 0.682085 0.701998 0.192893 0.0153949 14422.7 2; : 6 | 0.6867 0.696275 0.191869 0.0152227 14492.2 3; : 7 Minimum Test error found - save the configuration ; : 7 | 0.692231 0.691692 0.197632 0.0164904 14132.6 0; : 8 | 0.683383 0.694963 0.194299 0.0156318 14328.3 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.682898 0.684979 0.192122 0.0157399 14513.9 0; : 10 | 0.670592 0.688549 0.192796 0.0152906 14422.1 1; : 11 Minimum Test error found - save the configuration ; : 11 | 0.670202 0.684295 0.191832 0.0154715 14515.7 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.675447 0.682107 0.194058 0.0158608 14366.1 0; : 13 | 0.678105 0.691356 0.193716 0.0152633 14345.5 1; : 14 | 0.684972 0.687408 0.191852 0.0154194 14509.8 2; : 15 | 0.676423 0.689156 0.193176 0.0153404 14395.3 3; : 16 | 0.683185 0.689966 0.191807 0.0149908 14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:19270,error,error,19270,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability," Window_t, etc. ... ). { return DispatchVA( ""k"", param ); }. PyObject* Dispatch(Event_t* event); { return DispatchVA1( ""Event_t"", event, 0 ); }. PyObject* Dispatch(Event_t* event, ULong_t wid); { return DispatchVA1( ""Event_t"", event, ""k"", wid ); }. PyObject* Dispatch(TEveDigitSet* qs, Int_t idx); { return DispatchVA1( ""TEveDigitSet"", qs, ""i"", idx ); }. PyObject* Dispatch(TEveElement* el); { return DispatchVA1( ""TEveElement"", el, 0 ); }. PyObject* Dispatch(TEveTrack* et); { return DispatchVA1( ""TEveTrack"", et, 0 ); }. PyObject* Dispatch(TEveWindow* window); { return DispatchVA1( ""TEveWindow"", window, 0 ); }. PyObject* Dispatch(TGFrame* frame); { return DispatchVA1( ""TGFrame"", frame, 0 ); }. PyObject* Dispatch(TGFrame* frame, Int_t btn). PyObject* Dispatch(TGFrame* frame, Int_t btn, Int_t x, Int_t y). PyObject* Dispatch(TGFrame* frame, UInt_t keysym, UInt_t mask). PyObject* Dispatch(TGListTreeItem* entry); { return DispatchVA1( ""TGListTreeItem"", entry, 0 ); }. PyObject* Dispatch(TGListTreeItem* entry, UInt_t mask). PyObject* Dispatch(TGListTreeItem* entry, UInt_t keysym, UInt_t mask). PyObject* Dispatch(TGListTreeItem* entry, Int_t btn). PyObject* Dispatch(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y). PyObject* Dispatch(TGLVEntry* entry, Int_t btn). PyObject* Dispatch(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y). PyObject* Dispatch(TGLViewerBase* viewer). PyObject* Dispatch(TGLPhysicalShape* shape). PyObject* Dispatch(TGLPhysicalShape* shape, UInt_t u1, UInt_t u2). PyObject* Dispatch(TGMdiFrame* frame); { return DispatchVA1( ""TGMdiFrame"", frame, 0 ); }. PyObject* Dispatch(TGShutterItem* item); { return DispatchVA1( ""TGShutterItem"", item, 0 ); }. PyObject* Dispatch(TGVFileSplitter* frame); { return DispatchVA1( ""TGVFileSplitter"", frame, 0 ); }. PyObject* Dispatch(TList* objs); { return DispatchVA1( ""TList"", objs, 0 ); }. PyObject* Dispatch(TObject* obj); { return DispatchVA1( ""TObject"", obj, 0 ); }. PyObject* Dispatch(TObject* obj, Bool_t check). PyObject* Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPyDispatcher.html:11641,mask,mask,11641,root/html534/TPyDispatcher.html,https://root.cern,https://root.cern/root/html534/TPyDispatcher.html,6,['mask'],['mask']
Availability," Window_t ; id, . UInt_t ; evmask . ). virtual . Defines which input events the window is interested in. ; By default events are propagated up the window stack. This mask can also be set at window creation time via the SetWindowAttributes_t::fEventMask attribute. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1946 of file TVirtualX.cxx. ◆ SelectPixmap(). void TVirtualX::SelectPixmap ; (; Int_t ; qpixid). virtual . Selects the pixmap ""qpixid"". ; Reimplemented in TGCocoa.; Definition at line 700 of file TVirtualX.cxx. ◆ SelectWindow(). void TVirtualX::SelectWindow ; (; Int_t ; wid). virtual . Selects the window ""wid"" to which subsequent output is directed. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 693 of file TVirtualX.cxx. ◆ SendEvent(). void TVirtualX::SendEvent ; (; Window_t ; id, . Event_t * ; ev . ). virtual . Specifies the event ""ev"" is to be sent to the window ""id"". ; This function requires you to pass an event mask. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1623 of file TVirtualX.cxx. ◆ SetCharacterUp(). void TVirtualX::SetCharacterUp ; (; Float_t ; chupx, . Float_t ; chupy . ). virtual . Sets character up vector. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 707 of file TVirtualX.cxx. ◆ SetClassHints(). void TVirtualX::SetClassHints ; (; Window_t ; id, . char * ; className, . char * ; resourceName . ). virtual . Sets the windows class and resource name. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1727 of file TVirtualX.cxx. ◆ SetClipOFF(). void TVirtualX::SetClipOFF ; (; Int_t ; wid). virtual . Turns off the clipping for the window ""wid"". ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 714 of file TVirtualX.cxx. ◆ SetClipRectangles(). void TVirtualX::SetClipRectangles ; (; GContext_t ; gc, . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:116751,mask,mask,116751,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['mask']
Availability," Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Accessing a TTree With a TSelector. What is a Selector?; To benefit from many ROOT features (e.g. PROOF and PROOF-lite) you should use a class deriving from the TSelector to analyze a TTree. The selector's code will be used by calling TTree::Process().; We provide a TSelector derived class in a simple source file. So please download the following source file and save it where you can find it: EventSelector.C. This is a skeleton of our selector.; N.B. If you are using ROOT via ssh, you have to download the file with wget from your remote directory. E.g.:; wget http://root-mirror.github.io/training/intro/EventSelector.C; Preparation; Now quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. Processing a Selector on a Tree; To apply this selector on the tree you do not call the selector directly; instead, the selector is passed to the tree which then runs it (see the documentation of TTree::Process()):; root[1] EventTree->Process(""EventSelector.C""). As you can see, nothing happens because our selector is empty. So lets see what we can do with this selector.; Editing the Selector Skeleton; Open the downloaded selector file (EventSelector.C) in a text editor, e.g. with vi, emacs, wordpad, Eclipse... At the beginning of the file is the EventSelector class definition with the data members declaration etc. This is the place where to add new member definitions, e.g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:2418,down,download,2418,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['down'],['download']
Availability," WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFitResult_8cxx_source.html:8434,error,errors,8434,doc/master/TFitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html,1,['error'],['errors']
Availability," X maximum with errors. ; Reimplemented from TGraph2D.; Definition at line 241 of file TGraph2DErrors.cxx. ◆ GetXminE(). Double_t TGraph2DErrors::GetXminE ; (; ); const. overridevirtual . Returns the X minimum with errors. ; Reimplemented from TGraph2D.; Definition at line 252 of file TGraph2DErrors.cxx. ◆ GetYmaxE(). Double_t TGraph2DErrors::GetYmaxE ; (; ); const. overridevirtual . Returns the Y maximum with errors. ; Reimplemented from TGraph2D.; Definition at line 263 of file TGraph2DErrors.cxx. ◆ GetYminE(). Double_t TGraph2DErrors::GetYminE ; (; ); const. overridevirtual . Returns the Y minimum with errors. ; Reimplemented from TGraph2D.; Definition at line 274 of file TGraph2DErrors.cxx. ◆ GetZmaxE(). Double_t TGraph2DErrors::GetZmaxE ; (; ); const. overridevirtual . Returns the Z maximum with errors. ; Reimplemented from TGraph2D.; Definition at line 285 of file TGraph2DErrors.cxx. ◆ GetZminE(). Double_t TGraph2DErrors::GetZminE ; (; ); const. overridevirtual . Returns the Z minimum with errors. ; Reimplemented from TGraph2D.; Definition at line 296 of file TGraph2DErrors.cxx. ◆ IsA(). TClass * TGraph2DErrors::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGraph2D.; Definition at line 61 of file TGraph2DErrors.h. ◆ operator=(). TGraph2DErrors & TGraph2DErrors::operator= ; (; const TGraph2DErrors & ; g). Assignment operator Copy everything except list of functions. ; Definition at line 167 of file TGraph2DErrors.cxx. ◆ Print(). void TGraph2DErrors::Print ; (; Option_t * ; chopt = """"); const. overridevirtual . Print 2D graph and errors values. ; Reimplemented from TGraph2D.; Definition at line 307 of file TGraph2DErrors.cxx. ◆ RemovePoint(). Int_t TGraph2DErrors::RemovePoint ; (; Int_t ; ipoint). Deletes point number ipoint. ; Definition at line 356 of file TGraph2DErrors.cxx. ◆ Scale(). void TGraph2DErrors::Scale ; (; Double_t ; c1 = 1., . Option_t * ; option = ""z"" . ). overridevirtual . Multiply the va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2DErrors.html:32565,error,errors,32565,doc/master/classTGraph2DErrors.html,https://root.cern,https://root.cern/doc/master/classTGraph2DErrors.html,1,['error'],['errors']
Availability," X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; If noAddr is true, printout of all pointer values is skipped. ; Definition at line 2535 of file TClass.cxx. ◆ DynamicCast() [1/2]. const void * TClass::DynamicCast ; (; const TClass * ; cl, . const void * ; obj, . Bool_t ; up = kTRUE . ). Cast obj of this class type up to baseclass cl if up is true. ; Cast obj of this class type down from baseclass cl if up is false. If this class is not a baseclass of cl return 0, else the pointer to the cl part of this (up) or to this (down). ; Definition at line 4937 of file TClass.cxx. ◆ DynamicCast() [2/2]. void * TClass::DynamicCast ; (; const TClass * ; cl, . void * ; obj, . Bool_t ; up = kTRUE . ). Cast obj of this class type up to baseclass cl if up is true. ; Cast obj of this class type down from baseclass cl if up is false. If this class is not a baseclass of cl return 0, else the pointer to the cl part of this (up) or to this (down). ; Definition at line 4915 of file TClass.cxx. ◆ EscapeChars(). char * TClass::EscapeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2568 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4440 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:66209,down,down,66209,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['down'],['down']
Availability," X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; If noAddr is true, printout of all pointer values is skipped. ; Definition at line 2602 of file TClass.cxx. ◆ DynamicCast() [1/2]. const void * TClass::DynamicCast ; (; const TClass * ; cl, . const void * ; obj, . Bool_t ; up = kTRUE . ). Cast obj of this class type up to baseclass cl if up is true. ; Cast obj of this class type down from baseclass cl if up is false. If this class is not a baseclass of cl return 0, else the pointer to the cl part of this (up) or to this (down). ; Definition at line 5004 of file TClass.cxx. ◆ DynamicCast() [2/2]. void * TClass::DynamicCast ; (; const TClass * ; cl, . void * ; obj, . Bool_t ; up = kTRUE . ). Cast obj of this class type up to baseclass cl if up is true. ; Cast obj of this class type down from baseclass cl if up is false. If this class is not a baseclass of cl return 0, else the pointer to the cl part of this (up) or to this (down). ; Definition at line 4982 of file TClass.cxx. ◆ EscapeChars(). char * TClass::EscapeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2635 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4507 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:66210,down,down,66210,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['down'],['down']
Availability," X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149436,error,error,149436,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability," You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c1 is negative, whether TAxis::kAxisRange is true, and whether TH1::ResetStats has been called on either this or h1. See TH1::GetStats.; The function return kFALSE if the Add operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 954 of file TH1.cxx. ◆ Add() [3/3]. Bool_t TH1::Add ; (; TF1 * ; f1, . Double_t ; c1 = 1, . Option_t * ; option = """" . ). virtual . Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ; By default, the function is computed at the centre of the bin. if option ""I"" is specified (1-d histogram only), the integral of the function in each bin is used instead of the value of the function at the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Add; The function return kFALSE if the Add operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 826 of file TH1.cxx. ◆ AddBinContent() [1/2]. void TH1::AddBinContent ; (; Int_t ; bin). virtual . Increment bin content by 1. ; Passing an out-of-range bin leads to undefined behavior ; Reimplemented in TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, and TH3D.; Definition at line 1268 of file TH1.cxx. ◆ AddBinContent() [2/2]. void TH1::AddBinContent ; (; Int_t ; bin, . Double_t ; w . ). virtual . Increment bin content by a weight w. ; Passing an out-of-range bin leads to undefined behavior ; Reimplemented in TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, and TH3D.; Definition at line 127",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:78036,error,errors,78036,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability," Z range of the histogram to be used in the fit. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:15996,error,error,15996,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['error'],['error']
Availability," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8C.html:6758,error,error,6758,doc/master/rf605__profilell_8C.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html,2,['error'],['error']
Availability," [#7164] - TGSpeedo mean value calculation; [#7195] - ROOT crash when parameter by value passed to slot: StrDup; [#7240] - [RF] Batch mode returns broken logarithms when -DVDT=OFF; [#7180] - TGCommandLinePlugin Up-Down Arrows and Tab Keys; [#7181] - RDataFrame Snapshot of friend trees; [#7258] - [RF] Update crystal ball shapes in RooFit; [#7086] - [DF] Section of RDF reference guide about RDF+RVec; [#7182] - Range not considered when computing integral of RooParamHistFunc; [#7547] - [DF] Crash in lazy jitted Snapshot; [#7010] - fifo in $CWD causes TCanvas to hang on macOS; [#7676] - hadd reverses order of object cycles; [#6343] - Problem with using namespace std in generated dictionary files; [#7657] - New dictionary-related crash in 6.24.00-patches; [#7718] - PyROOT in root 6.24 branch hangs while loading CMSSW library; [#7090] - Apple M1: bug in jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with unsigned num assigned to a not declared item; [#7292] - compilation fails on xrootd: _STAT_VER was not declared; [#7481] - String parse error in RooSimPdfBuilder.cxx; [#7433] - Segmentation fault after quitting Cling in CUDA mode; [#7239] - [RF] Use integral of PDF curves for pull plots and residuals; [#7390] - Must not forward declare template specialization with enumerator as template arg; [#7454] - [RF][Docs] Breaking changes of batch computation interface not documented in release notes; [#7558] - AfterImage compilation broken with binutils 2.36; [#7507] - [tree] Possible error in TLeaf::GetLeafCounter; [#7361] - RooFit backend library: force to specific architecture; [#7362] - Incremental build problems; [#7319] - [Hist] Wrong computation in TH3::GetCovariance for diagonal elements; [#7206] - Unable to build with builtin_cling=OFF for LLVM 9; [#7157] - RooFFTConvPdf doesn’t work with RooProdPdf; [#7076] - RNTuple, parallel unzip te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:45497,error,error,45497,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['error'],['error']
Availability," [2/2]. void TGListTree::KeyPressed ; (; TGListTreeItem * ; entry, . UInt_t ; keysym, . UInt_t ; mask . ). virtual . Signal emitted when keyboard key pressed. ; entry - selected item keysym - defined in ""KeySymbols.h"" mask - modifier key mask, defined in ""GuiTypes.h""; const Mask_t kKeyShiftMask = BIT(0); const Mask_t kKeyLockMask = BIT(1); const Mask_t kKeyControlMask = BIT(2); const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key const Mask_t kButton1Mask = BIT(8); const Mask_t kButton2Mask = BIT(9); const Mask_t kButton3Mask = BIT(10); const Mask_t kButton4Mask = BIT(11); const Mask_t kButton5Mask = BIT(12); const Mask_t kAnyModifier = BIT(15); ; Definition at line 1085 of file TGListTree.cxx. ◆ Layout(). void TGListTree::Layout ; (; ). inlineoverrideprotectedvirtual . Layout container entries. ; Reimplemented from TGContainer.; Definition at line 290 of file TGListTree.h. ◆ LineDown(). void TGListTree::LineDown ; (; Bool_t ; select = kFALSE). overridevirtual . Move content one item-size down. ; Reimplemented from TGContainer.; Definition at line 1262 of file TGListTree.cxx. ◆ LineUp(). void TGListTree::LineUp ; (; Bool_t ; select = kFALSE). overridevirtual . Move content one item-size up. ; Reimplemented from TGContainer.; Definition at line 1236 of file TGListTree.cxx. ◆ MouseOver() [1/2]. void TGListTree::MouseOver ; (; TGListTreeItem * ; entry). virtual . Signal emitted when pointer is over entry. ; Definition at line 1051 of file TGListTree.cxx. ◆ MouseOver() [2/2]. void TGListTree::MouseOver ; (; TGListTreeItem * ; entry, . UInt_t ; mask . ). virtual . Signal emitted when pointer is over entry. ; Definition at line 1059 of file TGListTree.cxx. ◆ OnMouseOver(). void TGListTree::OnMouseOver ; (; TGFrame * ; f). inlineoverrideprotectedvirtual . Signal emitted when pointer is over entry. ; Reimplemented from TGContainer.; Definition at line 292 of file TGListTree.h. ◆ OpenItem(). void TGListTree::OpenItem ; (; TGListTreeItem * ; item). Open item in list tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:70945,down,down,70945,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['down'],['down']
Availability," [2/2]. void TGWin32VirtualXProxy::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). overridevirtual . Moves the specified window to the specified x and y coordinates. ; It does not change the window's size, raise the window, or change the mapping state of the window.; Parameters. [in]idwindow identifier ; [in]x,ycoordinates, which define the new position of the window relative to its parent. . Reimplemented from TVirtualX. ◆ NextEvent(). void TGWin32VirtualXProxy::NextEvent ; (; Event_t & ; event). overridevirtual . Process next event in the queue - if any. ; Reimplemented from TVirtualX.; Definition at line 304 of file TGWin32VirtualXProxy.cxx. ◆ OpenDisplay(). Int_t TGWin32VirtualXProxy::OpenDisplay ; (; const char * ; dpyName = nullptr). overridevirtual . Opens connection to display server (if such a thing exist on the current platform). ; The encoding and interpretation of the display name.; On X11 this method returns on success the X display socket descriptor >0, 0 in case of batch mode, and <0 in case of failure (cannot connect to display dpyName). ; Reimplemented from TVirtualX. ◆ OpenPixmap(). Int_t TGWin32VirtualXProxy::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Creates a pixmap of the width ""w"" and height ""h"" you specified. ; Reimplemented from TVirtualX. ◆ ParseColor(). Bool_t TGWin32VirtualXProxy::ParseColor ; (; Colormap_t ; cmap, . const char * ; cname, . ColorStruct_t & ; color . ). overridevirtual . Looks up the string name of a color ""cname"" with respect to the screen associated with the specified colormap. ; It returns the exact color value. If the color name is not in the Host Portable Character Encoding, the result is implementation dependent.; Parameters. [in]cmapthe colormap ; [in]cnamethe color name string; use of uppercase or lowercase does not matter ; [in]colorreturns the exact color value for later use. The ColorStruct_t structure is set to default. Let system think we could parse color. ; Reimplemented from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:97177,failure,failure,97177,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['failure'],['failure']
Availability," [3/4]. TServerSocket::TServerSocket ; (; Int_t ; port, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a server socket object on a specified port. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. If port is 0 a port scan will be done to find a free port. This option is mutual exlusive with the reuse option. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 139 of file TServerSocket.cxx. ◆ TServerSocket() [4/4]. TServerSocket::TServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a server socket object for a named service. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:20305,error,error,20305,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['error'],['error']
Availability," [5/6]. TThread::TThread ; (; const char * ; thname, . VoidFunc_t ; fn, . void * ; arg = nullptr, . EPriority ; pri = kNormalPriority . ). Create a detached thread with a name. ; Specify the function or static class method to be executed by the thread and a pointer to the argument structure. To start the thread call Run(). ; Definition at line 259 of file TThread.cxx. ◆ TThread() [6/6]. TThread::TThread ; (; Long_t ; id = 0). Create a TThread for a already running thread. ; Definition at line 274 of file TThread.cxx. ◆ ~TThread(). TThread::~TThread ; (; ). virtual . Cleanup the thread. ; Definition at line 390 of file TThread.cxx. Member Function Documentation. ◆ AfterCancel(). void TThread::AfterCancel ; (; TThread * ; th). staticprivate . Static method which is called after the thread has been canceled. ; Definition at line 729 of file TThread.cxx. ◆ CancelPoint(). Int_t TThread::CancelPoint ; (; ). static . Static method to set a cancellation point. ; Returns 0 on success, otherwise an error number will be returned. ; Definition at line 676 of file TThread.cxx. ◆ Class(). static TClass * TThread::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TThread::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TThread::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 180 of file TThread.h. ◆ CleanUp(). Int_t TThread::CleanUp ; (; ). static . Static method to cleanup the calling thread. ; Definition at line 708 of file TThread.cxx. ◆ CleanUpPop(). Int_t TThread::CleanUpPop ; (; Int_t ; exe = 0). static . Static method which pops thread cleanup method off stack. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 697 of file TThread.cxx. ◆ CleanUpPush(). Int_t TThread::CleanUpPush ; (; void * ; free, . void * ; arg = nullptr . ). static . Static method which pushes thread cleanup method on stack. ; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:20516,error,error,20516,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['error'],['error']
Availability," [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 1785 of file TGCocoa.mm. ◆ DrawSegmentsAux(). void TGCocoa::DrawSegmentsAux ; (; Drawable_t ; wid, . const GCValues_t & ; gcVals, . const Segment_t * ; segments, . Int_t ; nSegments . ). Definition at line 1774 of file TGCocoa.mm. ◆ DrawString(). void TGCocoa::DrawString ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . const char * ; s, . Int_t ; len . ). overridevirtual . Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ; Parameters. [in]idthe drawable ; [in]gcthe GC ; [in]x,ycoordinates, which are relative to the origin of the specified drawable and define the origin of the first character ; [in]sthe character string ; [in]lenthe number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 2219 of file TGCocoa.mm. ◆ DrawStringAux(). void TGCocoa::DrawStringAux ; (; Drawable_t ; wid, . const GCValues_t & ; gc, . Int_t ; x, . Int_t ; y, . const char * ; s, . Int_t ; len . ). Definition at line 2175 of file TGCocoa.mm. ◆ EmptyRegion(). Bool_t TGCocoa::EmptyRegion ; (; Region_t ; reg). overridevirtual . Returns kTRUE if the region re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:75545,mask,mask,75545,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability," [in]x1,y1,x2,y2The TLegend coordinates ; [in]titleThe legend title. By default it is "" "" ; [in]optionThe TLegend option. The caller program owns the returned TLegend.; If the pad contains some TMultiGraph or THStack the individual graphs or histograms in them are added to the TLegend. Automatic placement of the legend; If x1 is equal to x2 and y1 is equal to y2 the legend will be automatically placed to avoid overlapping with the existing primitives already displayed. x1 is considered as the width of the legend and y1 the height. By default the legend is automatically placed with width = x1= x2 = 0.3 and height = y1= y2 = 0.21. ; Implements TVirtualPad.; Definition at line 555 of file TPad.cxx. ◆ cd(). TVirtualPad * TPad::cd ; (; Int_t ; subpadnumber = 0). overridevirtual . Set Current pad. ; When a canvas/pad is divided via TPad::Divide, one can directly set the current path to one of the subdivisions. See TPad::Divide for the convention to number sub-pads.; Returns the new current pad, or 0 in case of failure.; For example: c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad points to the current pad. One can use gPad to set attributes of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with: TPad subpad = (TPad)pad->GetPad(subpadnumber); ; Implements TVirtualPad.; Definition at line 693 of file TPad.cxx. ◆ Class(). static TClass * TPad::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TPad::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TPad::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 419 of file TPad.h. ◆ Clear(). void TPad::Clear ; (; Option_t * ; option = """").",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:59958,failure,failure,59958,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['failure'],['failure']
Availability," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:10897,error,errorLevel,10897,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,4,['error'],"['errorLevel', 'errors']"
Availability," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTabCom.html:10925,error,errorLevel,10925,root/html530/TTabCom.html,https://root.cern,https://root.cern/root/html530/TTabCom.html,20,['error'],"['errorLevel', 'errors']"
Availability," \]. The distribution of the control variable \(x\) obtained by histogramming the weighted events reproduces, on average, the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); The class TSPlot allows to reconstruct the true distribution \({\hbox{ {M}}}_{\rm n}(x)\); of a control variable \(x\) for each of the \({\rm N}_{\rm s}\) species from the sole knowledge of the PDFs of the discriminating variables \({\rm f}_i(y)\). The plots obtained thanks to the TSPlot class are called \(\hbox {$_s$}{\cal P}lots\). Some properties and checks; Beside reproducing the true distribution, \(\hbox {$_s$}{\cal P}lots\) bear remarkable properties:. Each \(x\) - distribution is properly normalized:. \[; \sum_{e=1}^{N} {_s{\cal P}}_{\rm n}(y_e)~=~N_{\rm n} ~. \tag{4}; \]. For any event:. \[; \sum_{l=1}^{{\rm N}_{\rm s}} {_s{\cal P}}_l(y_e) ~=~1 ~. \tag{5}; \]. That is to say that, summing up the \({\rm N}_{\rm s}\) \(\hbox {$_s$}{\cal P}lots\), one recovers the data sample distribution in \(x\), and summing up the number of events entering in a \(\hbox{$_s$}{\cal P}lot\) for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. \[; \sigma[N_{\rm n}\ _s\tilde{\rm M}_{\rm n}(x) {\delta x}]~=~\sqrt{\sum_{e \subset {\delta x}} ({_s{\cal P}}_{\rm n})^2} ~. \tag{6}; \]. reproduces the statistical uncertainty on the yield \(N_{\rm n}\), as provided by the fit: \(\sigma[N_{\rm n}]\equiv\sqrt{\hbox{ V}_{{\rm n}{\rm n}}}\) . Because of that and since the determination of the yields is optimal when obtained using a Likelihood fit, one can conclude that the \(\hbox{$_s$}{\cal P}lot\) technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields \(N_i\) of the various species.The fit relies on discriminating variables \(y\) uncorrelated with a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPlot.html:5055,recover,recovers,5055,doc/master/classTSPlot.html,https://root.cern,https://root.cern/doc/master/classTSPlot.html,2,['recover'],['recovers']
Availability," \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. - VavilovAccurate uses the algorithm by; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Vavilov.html:1639,Avail,Available,1639,root/html532/ROOT__Math__Vavilov.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Vavilov.html,4,['Avail'],['Available']
Availability," __LINE__; } /** \endcond */; 352 ; 353#define ClassDefInlineOverride(name,id) \; 354 _ClassDefInline_(name,id,,override) \; 355 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 356 ; 357#define ClassDefInlineNV(name,id) \; 358 _ClassDefInline_(name,id,,) \; 359 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 360 ; 361//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 362 ; 363#define R__UseDummy(name) \; 364 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 365 ; 366#define ClassImpUnique(name,key) \; 367 namespace ROOT { \; 368 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 369 namespace { \; 370 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 371 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 372 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 373 } \; 374 }; 375 ; 376/// \deprecated; 377#define ClassImp(name) ClassImpUnique(name,default); 378 ; 379/// Macro for Namespace; 380#define NamespaceImpUnique(name,key) \; 381 namespace name { \; 382 namespace ROOTDict { \; 383 /** \cond HIDDEN_SYMBOLS */ \; 384 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 385 namespace { \; 386 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 387 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 388 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 389 } \; 390 } \; 391 }; 392 ; 393#define NamespaceImp(name) NamespaceImpUnique(name,default); 394 ; 395//---- ClassDefT macros for templates with one template argument ---------------; 396// ClassDefT corresponds to ClassDef; 397// ClassDefT2 goes in the same header as ClassDefT but must be; 398// outside the class scope; 399// ClassImpT corresponds to ClassImp; 400 ; 401 ; 402/// This ClassDefT is strictly redundant and is kept only for; 403/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:17177,redundant,redundant,17177,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['redundant'],['redundant']
Availability," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:17598,redundant,redundant,17598,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['redundant'],['redundant']
Availability," _dm, RooAbsReal& _dm0, RooAbsReal& _c, RooAbsReal& _a, RooAbsReal& _b); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDstD0BG.html:28787,Error,ErrorLoggingMode,28787,root/html602/RooDstD0BG.html,https://root.cern,https://root.cern/root/html602/RooDstD0BG.html,2,['Error'],['ErrorLoggingMode']
Availability," _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html:29707,Error,ErrorLoggingMode,29707,root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,6,['Error'],['ErrorLoggingMode']
Availability," `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:9126,error,error,9126,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability," a ',' (i.e. p->Process(""datasets.txt,"",...); with the dataset names listed in 'datasets.txt') in which case they are; treated as in 2); the file is open in raw mode with TFile::Open and; therefore it cane be remote, e.g. on a Web server.; Each <dsetj> has the format specified above for the single dataset processing,; included wildcarding (the name of the tree and subdirectory must be same for; all the datasets).; In the case of multiple datasets, 'elist' is treated a global entry list.; It is possible to specify per-dataset entry lists using the syntax; ""mydset[#adir/[T]]?enl=entrylist""; or; ""mydset[#adir/[T]]<<entrylist""; Here 'entrylist' is a tag identifying, in the order :; i. a named entry-list in the input list or in the input data list; ii. a named entry-list in memory (in gDirectory); iii. the path of a file containing the entry-list to be used; In the case ii) and iii) the entry-list object(s) is(are) added to the input; data list.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* selector, Long64_t nentries, Option_t* option = """"); Generic (non-data based) selector processing: the Process() method of the; specified selector (.C) is called 'n' times.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t GetQueryReference(Int_t qry, TString& ref); Get reference for the qry-th query in fQueries (as; displayed by ShowQueries). Long64_t Finalize(Int_t query = -1, Bool_t force = kFALSE); Finalize the qry-th query in fQueries.; If force, force retrieval if the query is found in the local list; but has already been finalized (default kFALSE).; If query < 0, finalize current query.; Return 0 on success, -1 on error. Long64_t Finalize(const char* queryref, Bool_t force = kFALSE); Finalize query with reference ref.; If force, force retrieval if the query is found in the local list; but has already been finalized (default kFALSE).; If ref = 0, finalize cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:48844,error,error,48844,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," a ',' (i.e. p->Process(""datasets.txt,"",...); with the dataset names listed in 'datasets.txt') in which case they are; treated as in 2); the file is open in raw mode with TFile::Open and; therefore it cane be remote, e.g. on a Web server.; Each <dsetj> has the format specified above for the single dataset processing,; included wildcarding (the name of the tree and subdirectory must be same for; all the datasets).; In the case of multiple datasets, 'elist' is treated a global entry list.; It is possible to specify per-dataset entry lists using the syntax; ""mydset[#adir/[T]]?enl=entrylist""; or; ""mydset[#adir/[T]]<<entrylist""; Here 'entrylist' is a tag identifying, in the order :; i. a named entry-list in the input list or in the input data list; ii. a named entry-list in memory (in gDirectory); iii. the path of a file containing the entry-list to be used; In the case ii) and iii) the entry-list object(s) is(are) added to the input; data list.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* selector, Long64_t nentries, Option_t* option = """"); Generic (non-data based) selector processing: the Process() method of the; specified selector (.C) or TSelector object is called 'n' times.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TDSet* dset, TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector object.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector object; The default tree is analyzed (i.e. the first one found). To speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:55226,error,error,55226,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['error'],['error']
Availability," a 3D vector; ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers). Lorentz Rotation. ROOT::Math::LorentzRotation , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix; ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetric matrix (10 numbers); ROOT::Math::BoostX, a boost in the X axis direction; ROOT::Math::BoostY, a boost in the Y axis direction; ROOT::Math::BoostZ, a boost in the Z axis direction. Compatibility with CLHEP Vector classes; For compatibility with CLHEP, the vector classes can be constructed easily from a CLHEP Hep3Vector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessors x(), y() and z() (and t() for HepLorentzVector). The vector classes also provide member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). Additional Documentation; A more detailed description of all the GenVector classes is available in this document. . Namespaces; namespace  ROOT::Math::VectorUtil;  Global Helper functions for generic Vector classes. ;  . Classes; class  ROOT::Math::AxisAngle;  AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotation around that axis. More...;  ; class  ROOT::Math::Boost;  Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix. More...;  ; class  ROOT::Math::BoostX;  Class representing a Lorentz Boost along the X axis, by beta. More...;  ; class  ROOT::Math::BoostY;  Class representing a Lorentz Boost along the Y axis, by beta. More...;  ; class  ROOT::Math::BoostZ;  Class representing a Lorentz Boost along the Z axis, by beta. More...;  ; class  ROOT::Math::Cartesian2D< T >;  Class describing a 2D cartesian coordinate system (x, y coordinates) More...;  ; class  ROOT::Math::Cartesian3D< T >;  Class describing a 3D cartesian coordinate system (x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:9727,avail,available,9727,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['avail'],['available']
Availability," a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37276,error,errors,37276,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,4,['error'],"['error', 'errors']"
Availability," a TGraph2D with asymmetric errors. It behaves like a TGraph2D and has the same drawing options.; The **""ERR""** drawing option allows to display the error bars. The following example shows how to use it:; {; auto c = new TCanvas(""c"",""TGraph2DAsymmErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;; ; Double_t *rx=0, *ry=0, *rz=0;; Double_t *exl=0, *exh=0, *eyl=0, *eyh=0, *ezl=0, *ezh=0;; ; rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; exl = new Double_t[np];; exh = new Double_t[np];; eyl = new Double_t[np];; eyh = new Double_t[np];; ezl = new Double_t[np];; ezh = new Double_t[np];; ; auto r = new TRandom();; ; for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; exl[N] = r->Rndm(N);; exh[N] = r->Rndm(N);; eyl[N] = r->Rndm(N);; eyh[N] = r->Rndm(N);; ezl[N] = 10*r->Rndm(N);; ezh[N] = 10*r->Rndm(N);; }; ; auto g = new TGraph2DAsymmErrors(np, rx, ry, rz, exl, exh, eyl, eyh, ezl, ezh);; g->SetTitle(""TGraph2D with asymmetric error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; N#define N; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2DAsymmErrors.html:1482,error,error,1482,doc/master/classTGraph2DAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraph2DAsymmErrors.html,1,['error'],['error']
Availability," a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:41610,error,errors,41610,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['error'],['errors']
Availability," a class that is known to ROOT, e.g. ;  ; TClass * IsA () const override;  ; Bool_t IsBatch () const;  ; Bool_t IsEscaped () const;  ; Bool_t IsExecutingMacro () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool_t IsRootFile (const char *filename) const;  Return true if the file is local and is (likely) to be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:10508,error,error,10508,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['error'],['error']
Availability," a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1); Multiply this profile by h1*-*-; *-* =============================. this = this*h1. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile by multiplication of h1 by h2; *-* ================================================================. this = (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:39500,error,errors,39500,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,6,['error'],['errors']
Availability," a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. void Multiply(const TH1* h1); Multiply this profile by h1*-*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH1D * ProjectionX(const char* name = ""_px"", Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:37446,error,errors,37446,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,4,['error'],['errors']
Availability," a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1anal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:262374,avail,available,262374,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avail'],['available']
Availability," a default verbosity.Definition RLogger.hxx:113; ROOT::Experimental::RLogDiagCountKeep track of emitted errors and warnings.Definition RLogger.hxx:53; ROOT::Experimental::RLogDiagCount::fNumFatalErrorsstd::atomic< long long > fNumFatalErrorsNumber of errors.Definition RLogger.hxx:57; ROOT::Experimental::RLogDiagCount::fNumWarningsstd::atomic< long long > fNumWarningsDefinition RLogger.hxx:55; ROOT::Experimental::RLogDiagCount::Incrementvoid Increment(ELogLevel severity)Increase warning or error count.Definition RLogger.hxx:70; ROOT::Experimental::RLogDiagCount::GetNumWarningslong long GetNumWarnings() constNumber of fatal errors.Definition RLogger.hxx:61; ROOT::Experimental::RLogDiagCount::fNumErrorsstd::atomic< long long > fNumErrorsNumber of warnings.Definition RLogger.hxx:56; ROOT::Experimental::RLogDiagCount::GetNumFatalErrorslong long GetNumFatalErrors() constReturns the current number of fatal errors.Definition RLogger.hxx:67; ROOT::Experimental::RLogDiagCount::GetNumErrorslong long GetNumErrors() constReturns the current number of errors.Definition RLogger.hxx:64; ROOT::Experimental::RLogEntryA diagnostic that can be emitted by the RLogManager.Definition RLogger.hxx:178; ROOT::Experimental::RLogEntry::fMessagestd::string fMessageDefinition RLogger.hxx:181; ROOT::Experimental::RLogEntry::IsDebugbool IsDebug() constDefinition RLogger.hxx:191; ROOT::Experimental::RLogEntry::RLogEntryRLogEntry(ELogLevel level, RLogChannel &channel, const RLogLocation &loc)Definition RLogger.hxx:186; ROOT::Experimental::RLogEntry::IsFatalbool IsFatal() constDefinition RLogger.hxx:195; ROOT::Experimental::RLogEntry::IsErrorbool IsError() constDefinition RLogger.hxx:194; ROOT::Experimental::RLogEntry::RLogEntryRLogEntry(ELogLevel level, RLogChannel &channel)Definition RLogger.hxx:185; ROOT::Experimental::RLogEntry::IsInfobool IsInfo() constDefinition RLogger.hxx:192; ROOT::Experimental::RLogEntry::IsWarningbool IsWarning() constDefinition RLogger.hxx:193; ROOT::Experimental::RLogEnt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:18577,error,errors,18577,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['errors']
Availability," a dictionary will be automatically created ;  fildir.C This macro displays the ROOT Directory data structure ;  file.C This macro displays the physical ROOT file structure ;  hadd.C Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  importCode.C Example of script showing how to create a ROOT file with subdirectories ;  loopdir.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  loopdir11.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  mergeSelective.C Merge only part of the content of a set of files ;  readCode.C Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory ;  testMergeCont.C Macro demonstrating the merging of containers ;  ► math;  Bessel.C Show the different kinds of Bessel functions available in ROOT To execute the macro type in: ;  Bessel.py Show the different kinds of Bessel functions available in ROOT To execute the macro type in: ;  binomial.C tutorial illustrating the use of TMath::Binomial can be run with: ;  ChebyshevPol.C Example of Chebyshev polynomials using new TFormula pre-defined definitions of chebyshev polynomials ;  chi2test.C Example to use chi2 test for comparing two histograms One unweighted histogram is compared with a weighted histogram ;  CrystalBall.C Example of CrystalBall Function and its distribution (pdf and cdf) ;  exampleFunctor.C Tutorial illustrating how creating a TF1 class using functor or class member functions ;  exampleMultiRoot.C Example of using multiroot finder based on GSL algorithm ;  exampleTKDE.C Example of using the TKDE class (kernel density estimator) ;  FeldmanCousins.C Example macro of using the TFeldmanCousins class in root ;  GammaFun.C Example showing the usage of the major special math functions (gamma, beta, erf) in R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:131200,avail,available,131200,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['avail'],['available']
Availability," a histogram is empty (this is a protected method used mainly by TH1Merger ) ;  ; int LoggedInconsistency (const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) const;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  . Protected Attributes; TArrayD fBinEntries;  Number of entries per bin. ;  ; TArrayD fBinSumw2;  Array of sum of squares of weights per bin. ;  ; EErrorType fErrorMode;  Option to compute errors. ;  ; Bool_t fScaling;  ! True when TProfile2D::Scale is called ;  ; Double_t fTsumwz;  Total Sum of weight*Z. ;  ; Double_t fTsumwz2;  Total Sum of weight*Z*Z. ;  ; Double_t fZmax;  Upper limit in Z (if set) ;  ; Double_t fZmin;  Lower limit in Z (if set) ;  ;  Protected Attributes inherited from TH2; Double_t fScalefactor;  Scale factor. ;  ; Double_t fTsumwxy;  Total Sum of weight*X*Y. ;  ; Double_t fTsumwy;  Total Sum of weight*Y. ;  ; Double_t fTsumwy2;  Total Sum of weight*Y*Y. ;  ;  Protected Attributes inherited from TH1; Short_t fBarOffset;  (1000*offset) for bar charts or legos ;  ; Short_t fBarWidth;  (1000*width) for bar charts or legos ;  ; EBinErrorOpt fBinStatErrOpt;  Option for bin statistical errors. ;  ; Double_t * fBuffer;  [fBufferSize] entry buffer ;  ; Int_t fBufferSize;  fBuffer size ;  ; TArrayD fContour;  Array to display contour levels. ;  ; Int_t fDimension;  ! Histogram dimension (1, 2 or 3 dim) ;  ; TDirectory * fDirectory;  ! Poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:60236,error,errors,60236,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['error'],['errors']
Availability," a histogram is empty (this is a protected method used mainly by TH1Merger ) ;  ; int LoggedInconsistency (const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) const;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  . Protected Attributes; TArrayD fBinEntries;  Number of entries per bin. ;  ; TArrayD fBinSumw2;  Array of sum of squares of weights per bin. ;  ; EErrorType fErrorMode;  Option to compute errors. ;  ; Bool_t fScaling;  ! True when TProfile3D::Scale is called ;  ; Double_t fTmax;  Upper limit in T (if set) ;  ; Double_t fTmin;  Lower limit in T (if set) ;  ; Double_t fTsumwt;  Total Sum of weight*T. ;  ; Double_t fTsumwt2;  Total Sum of weight*T*T. ;  ;  Protected Attributes inherited from TH3; Double_t fTsumwxy;  Total Sum of weight*X*Y. ;  ; Double_t fTsumwxz;  Total Sum of weight*X*Z. ;  ; Double_t fTsumwy;  Total Sum of weight*Y. ;  ; Double_t fTsumwy2;  Total Sum of weight*Y*Y. ;  ; Double_t fTsumwyz;  Total Sum of weight*Y*Z. ;  ; Double_t fTsumwz;  Total Sum of weight*Z. ;  ; Double_t fTsumwz2;  Total Sum of weight*Z*Z. ;  ;  Protected Attributes inherited from TH1; Short_t fBarOffset;  (1000*offset) for bar charts or legos ;  ; Short_t fBarWidth;  (1000*width) for bar charts or legos ;  ; EBinErrorOpt fBinStatErrOpt;  Option for bin statistical errors. ;  ; Double_t * fBuffer;  [fBufferSize] entry buffer ;  ; Int_t fBufferSize;  fBuffer size ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:59243,error,errors,59243,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['error'],['errors']
Availability," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2010-11-29 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumiliMinimizer.html:7968,error,error,7968,root/html528/TFumiliMinimizer.html,https://root.cern,https://root.cern/root/html528/TFumiliMinimizer.html,4,['error'],"['error', 'errors']"
Availability," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFumiliMinimizer.html:8100,error,error,8100,root/html530/TFumiliMinimizer.html,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html,4,['error'],"['error', 'errors']"
Availability," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFumiliMinimizer.html:8100,error,error,8100,root/html532/TFumiliMinimizer.html,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html,9,"['Error', 'error']","['Errors', 'error', 'errors']"
Availability," a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fOptions.MaxFunctionCalls(); }. unsigned int MaxIterations() const; max iterations. { return fOptions.MaxIterations(); }. double Tolerance() const; absolute tolerance. { return fOptions.Tolerance(); }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fOptions.Precision(); }. int Strategy() const; strategy. { return fOptions.Strategy(); }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fOptions.ErrorDef(); }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. void SetPrintLevel(int level); set print level. { fOptions.SetPrintLevel(level); }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { if (maxfcn > 0) fOptions.SetMaxFunctionCalls(maxfcn); }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { if (maxiter > 0) fOptions.SetMaxIterations(maxiter); }. void SetTolerance(double tol); set the tolerance. { fOptions.SetTolerance(tol); }. void SetPrecision(double prec); set in the minimizer the objective function evaluation precision; ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case). { fOptions.SetPrecision(prec); }. void SetStrategy(int strategyLevel); set the strategy. { fOptions.SetStrategy(strategyLevel); }. void SetErrorDef(double up); set scale for calculating the errors. { fOptions.SetErrorDef(up); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:12848,error,error,12848,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,6,['error'],['error']
Availability," a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = new TProofProgressStatus(); }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:19433,error,error,19433,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,1,['error'],['error']
Availability," a point. ; This function is threadsafe in contrast to Coords(...) and can easily get vectorized by the compiler in loops running over the ipoint-index. ; Definition at line 395 of file BinData.h. ◆ GetErrorType(). ErrorType ROOT::Fit::BinData::GetErrorType ; (; ); const. inline . retrieve the errortype ; Definition at line 562 of file BinData.h. ◆ GetPoint() [1/2]. const double * ROOT::Fit::BinData::GetPoint ; (; unsigned int ; ipoint, . double & ; value . ); const. inline . retrieve at the same time a pointer to the coordinate data and the fit value More efficient than calling Coords(i) and Value(i) ; Definition at line 381 of file BinData.h. ◆ GetPoint() [2/2]. const double * ROOT::Fit::BinData::GetPoint ; (; unsigned int ; ipoint, . double & ; value, . double & ; invError . ); const. inline . retrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit point. ; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned for the error. ; Definition at line 439 of file BinData.h. ◆ GetPointError() [1/2]. const double * ROOT::Fit::BinData::GetPointError ; (; unsigned int ; ipoint, . double & ; errlow, . double & ; errhigh . ); const. inline . Get errors on the point (coordinate errors and asymmetric value errors) for the given fit point. ; It must be called only when the coordinate errors and asymmetric errors are stored otherwise it will produce an assert. ; Definition at line 480 of file BinData.h. ◆ GetPointError() [2/2]. const double * ROOT::Fit::BinData::GetPointError ; (; unsigned int ; ipoint, . double & ; errvalue . ); const. inline . Retrieve the errors on the point (coordinate and value) for the given fit point It must be called only when the coordinate errors are stored otherwise it will produce an assert. ; Definition at line 462 of file BinData.h. ◆ HasBinEdges(). bool ROOT::Fit::BinData::HasBinEdges ; (; ); const. inline . query if the data store the bin edges instead of the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:23893,error,error,23893,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['error'],['error']
Availability," a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::ImplBase, ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(x). double operator()(double x) const. Template method to eveluate the function using the begin of an iterator; User is responsible to provide correct size for the iterator. virtual ~IBaseFunctionOneDim(). virtual destructor. {}. » Last changed: root/mathcore:$Id$ » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html:1512,avail,available,1512,root/html534/ROOT__Math__IBaseFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html,2,['avail'],['available']
Availability," a, Float_t z, Float_t density, Float_t radl, Float_t inter); virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tGetInterLength() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRadLength() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMaterial.html:1572,error,error,1572,root/html528/TMaterial.html,https://root.cern,https://root.cern/root/html528/TMaterial.html,6,['error'],['error']
Availability," a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. Bool_t CreateMerger(TSlave* sl, Int_t port); Create a new merger. void MarkBad(TSlave* wrk, const char* reason = 0); Add a bad slave server to the bad slave list and remove it from; the active list and from the two monitor objects. Assume that the work; done by this worker was lost and ask packerizer to reassign it. void MarkBad(TSocket* s, const char* reason = 0); Add slave with socket s to the bad slave list and remove if from; the active list and from the two monitor objects. void TerminateWorker(TSlave* wrk); Ask an active worker 'wrk' to terminate, i.e. to shutdown. void TerminateWorker(const char* ord); Ask an active worker 'ord' to terminate, i.e. to shutdown. Int_t Ping(); Ping PROOF. Returns 1 if master server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Int_t HandleOutputOptions(TString& opt, TString& target, Int_t action); Extract from opt information about output handling settings.; The understood keywords are:; of=<file>, outfile=<file> output file location; ds=<dsname>, dataset=<dsname> dataset name ('of' and 'ds' are; mutually exclusive,execution stops; if both are found); sft[=<opt>], savetofile[=<opt>] control saving to file. For 'mvf', the <opt> integer has the following meaning:; <opt> = <how>*10 + <force>; <force> = 0 save to file if memory threshold is reached; (the memory threshold is set by the cluster; admin); in case an output file is defined, the; files are merged at the end;; 1 save results to file.; <how> = 0 save at the end of the query; 1 save results after each packet (to reduce the; loss in case of crash). Setting 'ds' automatically sets 'mvf=1'; it is still possible to set 'mvf=11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:49166,Ping,Ping,49166,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['Ping'],['Ping']
Availability," a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. Bool_t CreateMerger(TSlave* sl, Int_t port); Create a new merger. void MarkBad(TSlave* wrk, const char* reason = 0); Add a bad slave server to the bad slave list and remove it from; the active list and from the two monitor objects. Assume that the work; done by this worker was lost and ask packerizer to reassign it. void MarkBad(TSocket* s, const char* reason = 0); Add slave with socket s to the bad slave list and remove if from; the active list and from the two monitor objects. void TerminateWorker(TSlave* wrk); Ask an active worker 'wrk' to terminate, i.e. to shutdown. void TerminateWorker(const char* ord); Ask an active worker 'ord' to terminate, i.e. to shutdown. Int_t Ping(); Ping PROOF. Returns 1 if master server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C) file.; The default tree is analyzed (i.e. the first one found). To specify another; tree, the default tree can be changed using TFileCollection::SetDefaultMetaData .; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* dse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:45583,Ping,Ping,45583,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,1,['Ping'],['Ping']
Availability," a[] and b[] due to the parameters uncertainties.; 2719/// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); 2720/// TF1::IntegralMultiple is used for the integral calculation; 2721///; 2722/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2723/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2724/// previously performed fit using the TFitResult class.; 2725/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:103186,error,error,103186,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability," about the content. ; Reimplemented from TNamed.; Definition at line 158 of file TProofLog.cxx. ◆ Prt(). void TProofLog::Prt ; (; const char * ; what, . Bool_t ; newline = kTRUE . ). Special printing procedure. ; Definition at line 181 of file TProofLog.cxx. ◆ Retrieve(). Int_t TProofLog::Retrieve ; (; const char * ; ord = ""*"", . TProofLog::ERetrieveOpt ; opt = TProofLog::kTrailing, . const char * ; fname = 0, . const char * ; pattern = 0 . ). Retrieve the content of the log file associated with worker 'ord'. ; If 'ord' is ""*"" (default), all the workers are retrieved. If 'all' is true, the whole files are retrieved; else a max of fgMaxTransferSize (about 1000 lines) per file is read, starting from the end (i.e. the last ~1000 lines). The received buffer is added to the file fname, if the latter is defined. If opt == TProofLog::kGrep only the lines containing 'pattern' are retrieved (remote grep functionality); to filter out a pattern 'pat' use pattern = ""-v pat"". Return 0 on success, -1 in case of any error. ; Definition at line 87 of file TProofLog.cxx. ◆ Save(). Int_t TProofLog::Save ; (; const char * ; ord = ""*"", . const char * ; fname = 0, . Option_t * ; opt = ""w"" . ). Save the content associated with worker 'ord' to finel 'fname'. ; If 'ord' is ""*"" (default), the log from all the workers is saved. If 'opt' is ""a"" the file is open in append mode; otherwise the file is truncated. ; Definition at line 201 of file TProofLog.cxx. ◆ SetLogToBox(). void TProofLog::SetLogToBox ; (; Bool_t ; lgbox = kFALSE). inline . Definition at line 70 of file TProofLog.h. ◆ SetMaxTransferSize(). void TProofLog::SetMaxTransferSize ; (; Long64_t ; maxsz). static . Set max transfer size. ; Definition at line 304 of file TProofLog.cxx. ◆ StartTime(). TDatime TProofLog::StartTime ; (; ). inline . Definition at line 67 of file TProofLog.h. ◆ Streamer(). void TProofLog::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed. ◆ Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLog.html:20732,error,error,20732,doc/master/classTProofLog.html,https://root.cern,https://root.cern/doc/master/classTProofLog.html,1,['error'],['error']
Availability," above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1 and +1 or three states with; 1559/// indices -1,0 and +1.; 1560///; 1561/// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:64863,error,errors,64863,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability," according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the loo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsGenContext.html:8753,avail,available,8753,root/html530/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html,1,['avail'],['available']
Availability," added to the list of functions (fFunctions) associated to each histogram. A call to TH1::Fit adds the fitted function to this list. Given a histogram h, one can retrieve the associated function with:; TF1 *myfunc = h->GetFunction(""myfunc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180584,Error,Errors,180584,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Error'],['Errors']
Availability," adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91613,error,errors,91613,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],['errors']
Availability," algorithm either in the constructor, or with the selectFastAlgorithm() method.; NoteThe ""width"" parameter that determines the Breit-Wigner shape represents the full width at half maximum (FWHM) of the Breit-Wigner (often referred to as \(\Gamma\) or \(2\gamma\)). ; Definition at line 22 of file RooVoigtian.h. Public Member Functions;  RooVoigtian ();  ;  RooVoigtian (const char *name, const char *title, RooAbsReal &_x, RooAbsReal &_mean, RooAbsReal &_width, RooAbsReal &_sigma, bool doFast=false);  Construct a RooVoigtian PDF, which represents the convolution of a Breit-Wigner with a Gaussian. ;  ;  RooVoigtian (const RooVoigtian &other, const char *name=nullptr);  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; void selectDefaultAlgorithm ();  Disable the fast evaluation of the complex error function using look-up tables (default is the ""slow"" CERNlib algorithm). ;  ; void selectFastAlgorithm ();  Enable the fast evaluation of the complex error function using look-up tables (default is the ""slow"" CERNlib algorithm). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:1733,error,error,1733,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['error'],['error']
Availability," all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Deve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:5471,down,download,5471,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['down'],['download']
Availability," all members ; ROOT::Experimental::RLogChannel Class Reference. ; A log configuration for a channel, e.g. ; ""RHist"". Each ROOT module has its own log, with potentially distinct verbosity. ; Definition at line 101 of file RLogger.hxx. Public Member Functions;  RLogChannel ()=default;  Construct an anonymous channel. ;  ;  RLogChannel (const std::string &name);  Construct a log channel given its name, which is part of the diagnostics. ;  ;  RLogChannel (ELogLevel verbosity);  Construct an anonymous channel with a default verbosity. ;  ; ELogLevel GetEffectiveVerbosity (const RLogManager &mgr) const;  ; const std::string & GetName () const;  ; ELogLevel GetVerbosity () const;  ; ELogLevel SetVerbosity (ELogLevel verbosity);  ;  Public Member Functions inherited from ROOT::Experimental::RLogDiagCount; long long GetNumErrors () const;  Returns the current number of errors. ;  ; long long GetNumFatalErrors () const;  Returns the current number of fatal errors. ;  ; long long GetNumWarnings () const;  Number of fatal errors. ;  ; void Increment (ELogLevel severity);  Increase warning or error count. ;  . Private Attributes; std::string fName;  Name as shown in diagnostics. ;  ; ELogLevel fVerbosity = ELogLevel::kUnset;  Verbosity of this channel. By default, use the global verbosity. ;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Experimental::RLogDiagCount; std::atomic< long long > fNumErrors {0ll};  Number of warnings. ;  ; std::atomic< long long > fNumFatalErrors {0ll};  Number of errors. ;  ; std::atomic< long long > fNumWarnings {0ll};  . #include <ROOT/RLogger.hxx>. Inheritance diagram for ROOT::Experimental::RLogChannel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RLogChannel() [1/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; ). default . Construct an anonymous channel. . ◆ RLogChannel() [2/3]. ROOT::Experimental::RLogChannel::RLogChan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html:1242,error,errors,1242,doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,2,['error'],['errors']
Availability," all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; List of all members ; TKey Class ReferenceInput/Output Library. ; Book space in a file, create I/O buffers, to fill them, (un)compress them. ; The TKey class includes functions to book space in a file, to create I/O buffers, to fill these buffers, to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must be created. The key structure contains all the information to uniquely identify a persistent object in a file. . Data Member Explanation . fNbytes Number of bytes for the compressed object and key. . fObjlen Length of uncompressed object. . fDatime Date/Time when the object was written. . fKeylen Number of bytes for the key structure. . fCycle Cycle number of the object. . fSeekKey Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. . fSeekPdir Pointer to the directory supporting this object. . fClassName Object class name. . fName Name of the object. . fTitle Title of the object. . In the 16 highest bits of fSeekPdir is encoded a pid offset. This offset is to be added to the pid index stored in the TRef object and the referenced TObject.; The TKey class is used by ROOT to:; Write an object in the current directory; Write a new ntuple buffer. The structure of a file is shown in TFile::TFile. The structure of a directory is shown in TDirectoryFile::TDirectoryFile. The TKey class is used by the TBasket class. See also TTree. ; Definition at line 28 of file TKey.h. Public Member Functions;  TKey ();  TKey default constructor. ;  ;  TKey (const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory *motherDir);  Create a TKey object with the specified name, title for the given class. ;  ;  TKey (const TObject *obj, const char *name, Int_t bufsize, TDirectory *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:1091,redundant,redundant,1091,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['redundant'],['redundant']
Availability," all nodes that (in)directly depend on these selected; nodes. Mark all directly and indirecty selected nodes; as 'selected' using the selectComp() method. RooPlot* plotOn(RooPlot *frame, PlotOpt o); Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:71222,error,errors,71222,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['error'],['errors']
Availability," all other parameters which is most strongly correlated with i. ; Minimizer must overload method if implemented ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer, and TMinuitMinimizer.; Definition at line 161 of file Minimizer.cxx. ◆ Hesse(). bool ROOT::Math::Minimizer::Hesse ; (; ). virtual . perform a full calculation of the Hessian matrix for error calculation ; Reimplemented in TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 185 of file Minimizer.cxx. ◆ IsFixedVariable(). bool ROOT::Math::Minimizer::IsFixedVariable ; (; unsigned int ; ivar); const. virtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented in ROOT::Math::BasicMinimizer, ROOT::Minuit2::Minuit2Minimizer, and TMinuitMinimizer.; Definition at line 102 of file Minimizer.cxx. ◆ IsValidError(). bool ROOT::Math::Minimizer::IsValidError ; (; ); const. inline . return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ; Definition at line 320 of file Minimizer.h. ◆ MaxFunctionCalls(). unsigned int ROOT::Math::Minimizer::MaxFunctionCalls ; (; ); const. inline . max number of function calls ; Definition at line 294 of file Minimizer.h. ◆ MaxIterations(). unsigned int ROOT::Math::Minimizer::MaxIterations ; (; ); const. inline . max iterations ; Definition at line 297 of file Minimizer.h. ◆ MinGradient(). virtual const double * ROOT::Math::Minimizer::MinGradient ; (; ); const. inlinevirtual . return pointer to gradient values at the minimum ; Reimplemented in TFumiliMinimizer, ROOT::Math::GeneticMinimizer, ROOT::Math::GSLMinimizer, ROOT::Math::GSLNLSMinimizer, TLinearMinimizer, TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 225 of file Minimizer.h. ◆ Minimize(). virtual bool ROOT::Math::Minimizer::Minimize ; (; ). pure virtual . method to perform the minimization ; Implemented in TFumiliMinimizer, ROOT::Math::Genetic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:21073,error,error,21073,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['error'],['error']
Availability," all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; RooSetProxy deps;  dependents of this p.d.f ;  ; RooSetProxy intobs;  observables that p.d.f is integrated over ;  ; RooRealProxy intpdf;  p.d.f that is integrated ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:68522,error,errors,68522,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['error'],['errors']
Availability," along R for sector. ; Parameters. [in]valencoded value; [out]iv1,iv2,iv3,iv4,iv5,iv6visibility of the sides ; [out]irincrement along R . Definition at line 3244 of file TPainter3dAlgorithms.cxx. ◆ SideVisibilityEncode(). void TPainter3dAlgorithms::SideVisibilityEncode ; (; Int_t ; iopt, . Double_t ; phi1, . Double_t ; phi2, . Double_t & ; val . ). Encode side visibilities and order along R for sector. ; Parameters. [in]ioptoptions: 1: from BACK to FRONT 'BF', 2: from FRONT to BACK 'FB' ; [in]phi11st phi of sector ; [in]phi22nd phi of sector; [out]valencoded value . Definition at line 3276 of file TPainter3dAlgorithms.cxx. ◆ Spectrum(). void TPainter3dAlgorithms::Spectrum ; (; Int_t ; nl, . Double_t ; fmin, . Double_t ; fmax, . Int_t ; ic, . Int_t ; idc, . Int_t & ; irep . ). Set Spectrum. ; Parameters. [in]nlnumber of levels ; [in]fminMIN function value ; [in]fmaxMAX function value ; [in]icinitial color index (for 1st level) ; [in]idccolor index increment; [out]irepreply (0 O.K., -1 error) . Definition at line 3314 of file TPainter3dAlgorithms.cxx. ◆ SurfaceCartesian(). void TPainter3dAlgorithms::SurfaceCartesian ; (; Double_t ; ang, . Int_t ; nx, . Int_t ; ny, . const char * ; chopt . ). Draw surface in cartesian coordinate system. ; Parameters. [in]angangle between X ang Y (not used in this method) ; [in]nxnumber of steps along X ; [in]nynumber of steps along Y ; [in]choptspecific options. chopt = 'BF' from BACK to FRONT; chopt = 'FB' from FRONT to BACK . Definition at line 3370 of file TPainter3dAlgorithms.cxx. ◆ SurfaceCylindrical(). void TPainter3dAlgorithms::SurfaceCylindrical ; (; Int_t ; iordr, . Int_t ; na, . Int_t ; nb, . const char * ; chopt . ). Draw surface in cylindrical coordinates. ; Parameters. [in]iordrorder of variables (0 - Z,PHI; 1 - PHI,Z) ; [in]nanumber of steps along 1st variable ; [in]nbnumber of steps along 2nd variable ; [in]choptspecific options. chopt = 'BF' from BACK to FRONT; chopt = 'FB' from FRONT to BACK . Definition at line 3689 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPainter3dAlgorithms.html:40530,error,error,40530,doc/master/classTPainter3dAlgorithms.html,https://root.cern,https://root.cern/doc/master/classTPainter3dAlgorithms.html,1,['error'],['error']
Availability," also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:13774,error,error,13774,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['error'],['error']
Availability," also be used to specify the projected profile error type.; 2132/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2133/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2134///; 2135/// One must create a graphical cut (mouse or C++) and specify the name; 2136/// of the cut between [] in the option.; 2137/// For example, with a TCutG named ""cutg"", one can call:; 2138/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; 2139/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2140/// myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; 2141/// It is possible to apply several cuts:; 2142/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2143///; 2144/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2145/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2146/// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; 2147///; 2148/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; 2149///; 2150/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2151/// does! Profiles take the bin center into account, so here the under- and overflow; 2152/// bins are ignored by default.; 2153///; 2154/// NOTE that the return profile histogram is computed using the X bin center values instead of; 2155/// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2156/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2157 ; 2158 ; 2159TProfile *TH2::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2160{; 2161 return DoProfile(false, name, firstxbin, lastxbin, option);; 2162}; 2163 ; 2164 ; 2165///////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:87603,error,error,87603,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability," also cleared, since there is no more content in the bins. ; Definition at line 2517 of file TH1.cxx. ◆ Clone(). TObject * TH1::Clone ; (; const char * ; newname = """"); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Reimplemented in TH2Poly.; Definition at line 2752 of file TH1.cxx. ◆ ComputeIntegral(). Double_t TH1::ComputeIntegral ; (; Bool_t ; onlyPositive = false). virtual . Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned Returns1 if success, 0 if integral is zero, NAN if onlyPositive-test fails ; Reimplemented in TH2Poly.; Definition at line 2537 of file TH1.cxx. ◆ Copy(). void TH1::Copy ; (; TObject & ; obj); const. overridevirtual . Copy this histogram structure to newth1. ; Note that this function does not copy the list of associated functions. Use TObject::Clone to make a full copy of a histogram.; Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true) or will not be added to any directory if AddDirectoryStatus()=false independently of the current directory stored in the original histogram ; Reimplemented from TObject.; Reimplemented in TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, TH3D, TProfile, TProfile2D, TProfile3D, TH2Poly, and TH1K.; Definition at line 2671 of file TH1.cxx. ◆ DeclFileName(). static const char * TH1::DeclFileName ; (; ). inlinestatic . ReturnsName of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:102972,error,error,102972,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200176,toler,tolerance,200176,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,10,"['error', 'toler']","['error', 'errors', 'tolerance']"
Availability, also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOptions.h:213; ROOT::Math::MinimizerOptions::SetStrategyvoid SetStrategy(int stra)set the strategyDefinition MinimizerOptions.h:225; ROOT::Math::MinimizerOptions::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition MinimizerOptions.h:216; ROOT::Math::MinimizerOptions::Strategyint Strategy() conststrategyDefinition MinimizerOptions.h:183; ROOT::Math::MinimizerOptions::Tolerancedouble Tolerance() constabsolute toleranceDefinition MinimizerOptions.h:186; ROOT::Math::MinimizerOptions::Precisiondouble Precision() constprecision in the objective function calculation (value <=0 means left to default)Definition MinimizerOptions.h:189; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::SetExtraOptionsvoid SetExtraOptions(const IOptions &opt)set extra options (in this case pointer is cloned)Definition MinimizerOptions.cxx:210; ROOT::Math::MinimizerOptions::MaxIterationsunsigned int MaxIterations() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::SetPrecisionvoid SetPrecision(double prec)set the precisionDefinition MinimizerOptions.h:222; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::ResetToDefaultOptionsvoid ResetToDefaultOptio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:18369,toler,toleranceDefinition,18369,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['toler'],['toleranceDefinition']
Availability," alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetSystem.html:20117,mask,mask,20117,root/html534/TNetSystem.html,https://root.cern,https://root.cern/root/html534/TNetSystem.html,18,['mask'],"['mask', 'masks']"
Availability," an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boolean specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:8256,error,error,8256,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,4,['error'],['error']
Availability," an average over all observable values in given set.; 1532/// Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:64619,error,error,64619,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability," an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:10014,error,error,10014,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability," an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter is a tool to robustify; other multivariate techniques such as, for e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRobustEstimator.html:1576,Robust,Robust,1576,root/html532/TRobustEstimator.html,https://root.cern,https://root.cern/root/html532/TRobustEstimator.html,4,['Robust'],['Robust']
Availability," an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t Update (MethodInfo_t *info) override;  Update the TMethod to reflect the new info. ;  ;  Public Member Functions inherited from TFunction;  TFunction (const TFunction &orig);  Copy operator. ;  ;  TFunction (MethodInfo_t *info=nullptr);  Default TFunction ctor. ;  ; virtual ~TFunction ();  TFunction dtor deletes adopted CINT MethodInfo. ;  ; Long_t ExtraProperty () const;  Get property description word. For meaning of bits see EProperty. ;  ; DeclId_t GetDeclId () const;  ; TList * GetListOfMethodArgs ();  Return list containing the TMethodArgs of a TFunction. ;  ; virtual const char * GetMangledName () const;  Returns the mangled name as defined by CINT, or 0 in case of error. ;  ; Int_t GetNargs () const;  Number of function arguments. ;  ; Int_t GetNargsOpt () const;  Number of function optional (default) arguments. ;  ; virtual const char * GetPrototype () const;  Returns the prototype of a function as defined by CINT, or 0 in case of error. ;  ; const char * GetReturnTypeName () const;  Get full type description of function return type, e,g.: ""class TDirectory*"". ;  ; std::string GetReturnTypeNormalizedName () const;  Get the normalized name of the return type. ;  ; const char * GetSignature ();  Return signature of function. ;  ; void * InterfaceMethod () const;  Return pointer to the interface method. ;  ; void ls (Option_t *option="""") const override;  List TFunction name and title. ;  ; TFunction & operator= (const TFunction &rhs);  Assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TFunction name and title. ;  ; Long_t Property () const override;  Get property description word. For meaning of bits see EProperty. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TDictionary;  TDictionary ();  ;  TDictionary (const char *name);  ;  TDictionary (const TDictionary &dic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethod.html:3060,error,error,3060,doc/master/classTMethod.html,https://root.cern,https://root.cern/doc/master/classTMethod.html,1,['error'],['error']
Availability," and K >=3; This class has been implemented by Victor Perevoztchikov perev.nosp@m.@bnl.nosp@m..gov ; Definition at line 26 of file TH1K.h. Public Member Functions;  TH1K ();  Constructor. ;  ;  TH1K (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t k=0);  Create a 1-Dim histogram with fix bins of type float (see TH1K::TH1 for explanation of parameters) ;  ;  ~TH1K () override;  Destructor. ;  ; void Copy (TObject &obj) const override;  Copy this histogram structure to newth1. ;  ; Int_t Fill (const char *name, Double_t w) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (Double_t x) override;  Increment bin with abscissa X by 1. ;  ; Int_t Fill (Double_t x, Double_t w) override;  Increment bin with abscissa X with a weight w. ;  ; Double_t GetBinContent (Int_t bin) const override;  Return content of global bin number bin. ;  ; Double_t GetBinContent (Int_t bin, Int_t) const override;  ; Double_t GetBinContent (Int_t bin, Int_t, Int_t) const override;  ; Double_t GetBinError (Int_t bin) const override;  Return content of global bin error. ;  ; Double_t GetBinError (Int_t bin, Int_t) const override;  ; Double_t GetBinError (Int_t bin, Int_t, Int_t) const override;  ; TClass * IsA () const override;  ; void Reset (Option_t *option="""") override;  Reset. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out Note the following restrictions in the code generated: ;  ; void SetKOrd (Int_t k);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1K.html:1885,error,error,1885,doc/master/classTH1K.html,https://root.cern,https://root.cern/doc/master/classTH1K.html,1,['error'],['error']
Availability, and Sunday day 7. ; Definition at line 86 of file TDatime.cxx. ◆ GetGlobalDayFromDate(). Int_t TDatime::GetGlobalDayFromDate ; (; Int_t ; date). static . Static function that returns the global day number from date. ; The input is in TDatime format yyyymmdd (as obtained via TDatime::GetDate()). This algorithm is only accurate for dates later than October 1582 (earliest date on Gregorian calendar). ; Definition at line 449 of file TDatime.cxx. ◆ GetHour(). Int_t TDatime::GetHour ; (; ); const. inline . Definition at line 69 of file TDatime.h. ◆ GetLegalGlobalDayFromDate(). Int_t TDatime::GetLegalGlobalDayFromDate ; (; Int_t ; date). static . Static function that returns the global day number from date. ; The input is in TDatime format yyyymmdd (as obtained via TDatime::GetDate()). This algorithm is only accurate for dates later than October 1582 (earliest date on Gregorian calendar) and it is checked that the date is larger than 15821001 and conversion is correct. In case of conversion failure 0 is returned. No need to use when you know dates are larger than October 1582. ; Definition at line 492 of file TDatime.cxx. ◆ GetMinute(). Int_t TDatime::GetMinute ; (; ); const. inline . Definition at line 70 of file TDatime.h. ◆ GetMonth(). Int_t TDatime::GetMonth ; (; ); const. inline . Definition at line 66 of file TDatime.h. ◆ GetSecond(). Int_t TDatime::GetSecond ; (; ); const. inline . Definition at line 71 of file TDatime.h. ◆ GetTime(). Int_t TDatime::GetTime ; (; ); const. Return time in form of 123623 (i.e. 12:36:23) ; Definition at line 259 of file TDatime.cxx. ◆ GetYear(). Int_t TDatime::GetYear ; (; ); const. inline . Definition at line 65 of file TDatime.h. ◆ IsA(). virtual TClass * TDatime::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 95 of file TDatime.h. ◆ operator=(). TDatime & TDatime::operator= ; (; const TDatime & ; d). inline . Definition at line 99 of file TDatime.h. ◆ Print(). void TDatime::Print ; (;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatime.html:10940,failure,failure,10940,doc/master/classTDatime.html,https://root.cern,https://root.cern/doc/master/classTDatime.html,1,['failure'],['failure']
Availability," and covariance matrix.; 1002 * This uses two covariance matrices, one with the weights, the other with squared weights,; 1003 * to obtain the correct errors for weighted likelihood fits. If this option is activated, the; 1004 * corrected covariance matrix is calculated as \f$ V_\mathrm{corr} = V C^{-1} V \f$, where \f$ V \f$ is the original; 1005 * covariance matrix and \f$ C \f$ is the inverse of the covariance matrix calculated using the; 1006 * squared weights. This allows to switch between two interpretations of errors:; 1007 * <table>; 1008 * <tr><th> SumW2Error <th> Interpretation; 1009 * <tr><td> true <td> The errors reflect the uncertainty of the Monte Carlo simulation.; 1010 * Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; 1011 *; 1012 * **Example**: Simulation with 1000 events, the average weight is 0.1.; 1013 * The errors are as big as if one fitted to 1000 events.; 1014 * <tr><td> false <td> The errors reflect the errors of a dataset, which is as big as the sum of weights.; 1015 * Use this if you want to know what statistical errors you would get if you had a dataset with as many; 1016 * events as the (weighted) Monte Carlo simulation represents.; 1017 *; 1018 * **Example** (Data as above):; 1019 * The errors are as big as if one fitted to 100 events.; 1020 * </table>; 1021 * \note If the `SumW2Error` correction is enabled, the covariance matrix quality stored in the RooFitResult; 1022 * object will be the minimum of the original covariance matrix quality and the quality of the covariance; 1023 * matrix calculated with the squared weights.; 1024 * <tr><td> `AsymptoticError()` <td> Use the asymptotically correct approach to estimate errors in the presence of weights.; 1025 * This is slower but more accurate than `SumW2Error`. See also https://arxiv.org/abs/1911.01303).; 1026 This option even correctly implements the case of extended likelihood fits; 1027 (see this [writeup on extended weighted fits](",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:48279,error,errors,48279,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['error'],['errors']
Availability," and drag to the new point position.; A Curly Line: Proceed as for the arrow or line. Once done, click with the third button to change the characteristics of the curly line, like transform it to wave, change the wavelength, etc.; A Curly Arc: Proceed like for an ellipse. The first click is located at the position of the center, the second click at the position of the arc beginning. Once done, one obtains a curly ellipse, for which one can click with the third button to change the characteristics, like transform it to wavy, change the wavelength, set the minimum and maximum angle to make an arc that is not closed, etc.; A Text/Latex string: Click with the left button where you want to draw the text and then type in the text terminated by carriage return. All TLatex expressions are valid. To move the text or formula, point on it keeping the left mouse button pressed and drag the text to its new position. You can grow/shrink the text if you position the mouse to the first top-third part of the string, then move the mouse up or down to grow or shrink the text respectively. If you position the mouse near the bottom-end of the text, you can rotate it.; A Marker: Click with the left button where to place the marker. The marker can be modified by using the method SetMarkerStyle() of TSystem.; A Graphical Cut: Click with the left button on each point of a polygon delimiting the selected area. Close the cut by double clicking on the last point. A TCutG object is created. It can be used as a selection for a TTree::Draw. You can get a pointer to this object with:; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); Once you are happy with your picture, you can select the Save as canvas.C item in the canvas File menu. This will automatically generate a script with the C++ statements corresponding to the picture. This facility also works if you have other objects not drawn with the graphics editor (histograms for example).; 2.3.2 The Editor Frame; The ROOT graphics editor loads the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:44406,down,down,44406,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability," and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); Mn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:50204,error,error,50204,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['error']
Availability," and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Long_t ExecPlugin(Int_t va_(nargs), ...); Execute ctor for this plugin and return pointer to object of specific; class. User must cast the returned long to the correct class.; This method accepts a variable number of arguments to be passed; to the ctor, where nargs is the number of arguments, followed; by nargs arguments. Returns 0 in case of error. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginHandler.html:10028,error,error,10028,root/html528/TPluginHandler.html,https://root.cern,https://root.cern/root/html528/TPluginHandler.html,6,['error'],['error']
Availability," and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiLayerPerceptron.html:25730,Error,Error,25730,root/html532/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html532/TMultiLayerPerceptron.html,4,['Error'],['Error']
Availability," and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:1777,error,error,1777,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['error'],['error']
Availability," and runtime overhead; [#14509] - ROOT segfaults on riscv64; [#14508] - Using LZMA compression with RNTupleWriter leads to memory corruption; [#14499] - It is not possible to set the Title of the palette for a 3D axis; [#14462] - Parser for I/O customization rule is too strict.; [#14458] - Crash when doing Weighted Likelihood fit; [#14453] - Implement IsInside for TEllipse; [#14401] - The red frame around the selected pad of the webgui is not configurable; [#14385] - Strange behavior with TF1 and SetParameters; [#14381] - Legend entry for exclusion graph; [#14376] - build failure with mysql 8.3; [#14372] - File with mtime equal to 0 are ignored by Cling.; [#14333] - “Empty plot” for df014_CSVDataSource.C; [#14331] - Unexpected behaviour when using the Project3D function to make a TH2 from a TH3; [#14329] - [RF] RDataFrameToRooFit - Clarification on returned object; [#14324] - Compatibility Issue with thisroot.sh and zsh; [#14320] - [RF] Wrong analytic integrals when using Gaussians with sigma depending on the observable; [#14303] - Test failure with nbconvert-7.14; [#14302] - The command “root –notebook” is not allowed on Windows 11; [#14277] - Cling triggers a huge number of openat calls when loading libraries; [#14263] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; [#14256] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; [#14244] - String comparison operators defined in TString.h should be defined as constexpr; [#14229] - [6.30] root-config –git-revision broken; [#14225] - [RF] Segmentation fault in ROOT 6.30 workspace creation; [#14223] - Extremely long startup time when loading dictionaries with pyroot; [#14219] - [cling] Use deduction guides for llvm::ArrayRef; [#14211] - Implement value printing for std::source_location; [#14205] - [cling] Replace llvm::Optional and llvm::None with std::optional; [#14199] - Memory hoarding triggered by the TPluginManager; [#14188] - cmake find_package R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:29377,failure,failure,29377,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['failure'],['failure']
Availability," and set there the objective function; 695 // obj function must have been set before; 696 auto objFunction = ObjFunction();; 697 if (!objFunction) {; 698 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Objective function has not been set"");; 699 return false;; 700 }; 701 ; 702 // check configuration and objective function; 703 if ( fConfig.ParamsSettings().size() != objFunction->NDim() ) {; 704 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong function dimension or wrong size for FitConfig"");; 705 return false;; 706 }; 707 ; 708 // create first Minimizer; 709 // using an auto_Ptr will delete the previous existing one; 710 fMinimizer = std::shared_ptr<ROOT::Math::Minimizer> ( fConfig.CreateMinimizer() );; 711 if (fMinimizer == nullptr) {; 712 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Minimizer cannot be created"");; 713 return false;; 714 }; 715 ; 716 // in case of gradient function one needs to downcast the pointer; 717 if (fUseGradient) {; 718 const ROOT::Math::IMultiGradFunction * gradfcn = dynamic_cast<const ROOT::Math::IMultiGradFunction *> (objFunction );; 719 if (!gradfcn) {; 720 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong type of function - it does not provide gradient"");; 721 return false;; 722 }; 723 fMinimizer->SetFunction( *gradfcn);; 724 // set also Hessian if available; 725 if (Config().MinimizerType() == ""Minuit2"") {; 726 const ROOT::Math::FitMethodGradFunction *fitGradFcn =; 727 dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(gradfcn);; 728 if (fitGradFcn && fitGradFcn->HasHessian()) {; 729 auto hessFcn = [=](std::span<const double> x, double *hess) {; 730 unsigned int ndim = x.size();; 731 unsigned int nh = ndim * (ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:27694,down,downcast,27694,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,2,"['avail', 'down']","['available', 'downcast']"
Availability," and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' and user 'usr'.; Checks .rootrc family files. Returned string must be deleted by the user. void RemoveHostAuth(THostAuth* ha, Option_t* opt = """"); Remove THostAuth instance from the list. void Show(Option_t* opt = ""S""); Print info about the authentication sector.; If 'opt' contains 's' or 'S' prints information about established TSecContext,; else prints information about THostAuth (if 'opt' is 'p' or 'P', prints; Proof related information). Int_t AuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); Check if we have a valid established sec context in memory; Retrieves relevant info and negotiates with server.; options = ""Opt,strlen(username),username.Data()""; message = kROOTD_USER, ... void InitRandom(); Initialize random machine using seed from /dev/urandom; (or current time if /dev/urandom not available). Int_t GenRSAKeys(); Generate a valid pair of private/public RSA keys to protect for; authentication token exchange. char * GetRandString(Int_t Opt, Int_t Len); Allocates and fills a 0 terminated buffer of length len+1 with; len random characters.; Returns pointer to the buffer (to be deleted by the caller); opt = 0 any non dangerous char; 1 letters and numbers (upper and lower case); 2 hex characters (upper and lower case). Int_t SecureSend(TSocket* Socket, Int_t enc, Int_t KeyType, const char* In); Encode null terminated str using the session private key indicated by enc; and sends it over the network; Returns number of bytes sent, or -1 in case of error.; enc = 1 for private encoding, enc = 2 for public encoding. Int_t SecureRecv(TSocket* Socket, Int_t dec, Int_t KeyType, char** Out); Receive str from sock and decode it using key indicated by key type; Return number of received bytes or -1 in case of error.; dec = 1 for p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:19410,avail,available,19410,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,11,['avail'],['available']
Availability," and wgt2 are not; 1 in this mode, a warning message is printed. If SumW2 errors are selectd the histograms are added; and the histograms errors are added in quadrature, taking the weights into account. void initialize(); Perform common initialization for all constructors. Double_t getFitRangeNEvt() const; Return the number of events of the dataset associated with this RooHist.; This is the number of events in the RooHist itself, unless a different; value was specified through setRawEntries(). Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Calculate integral of histogram in given range. Double_t getFitRangeBinW() const; Return (average) bin width of this RooHist. Int_t roundBin(Double_t y); Return the nearest positive integer to the input value; and print a warning if an adjustment is required. void addBin(Axis_t binCenter, Double_t n, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the specified integer bin contents; and using an error bar calculated with Poisson statistics. The bin width; is used to set the relative scale of bins with different widths. void addBinWithError(Axis_t binCenter, Double_t n, Double_t elow, Double_t ehigh, Double_t binWidth = 0, Double_t xErrorFrac = 1., Bool_t correctForBinWidth = kTRUE, Double_t scaleFactor = 1.); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addBinWithXYError(Axis_t binCenter, Double_t n, Double_t exlow, Double_t exhigh, Double_t eylow, Double_t eyhigh, Double_t scaleFactor = 1.); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addAsymmetryBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHist.html:23648,error,error,23648,root/html602/RooHist.html,https://root.cern,https://root.cern/root/html602/RooHist.html,4,['error'],['error']
Availability," and z values and errors are scaled ; Reimplemented from TGraph2D.; Definition at line 322 of file TGraph2DErrors.cxx. ◆ Set(). void TGraph2DErrors::Set ; (; Int_t ; n). overridevirtual . Set number of points in the 2D graph. ; Existing coordinates are preserved. New coordinates above fNpoints are preset to 0. ; Reimplemented from TGraph2D.; Definition at line 345 of file TGraph2DErrors.cxx. ◆ SetPoint(). void TGraph2DErrors::SetPoint ; (; Int_t ; i, . Double_t ; x, . Double_t ; y, . Double_t ; z . ). overridevirtual . Set x, y and z values for point number i. ; Reimplemented from TGraph2D.; Definition at line 404 of file TGraph2DErrors.cxx. ◆ SetPointError(). void TGraph2DErrors::SetPointError ; (; Int_t ; i, . Double_t ; ex, . Double_t ; ey, . Double_t ; ez . ). virtual . Set ex, ey and ez values for point number i. ; Definition at line 446 of file TGraph2DErrors.cxx. ◆ Streamer(). void TGraph2DErrors::Streamer ; (; TBuffer & ; b). overridevirtual . Stream an object of class TGraph2DErrors. ; Reimplemented from TGraph2D.; Definition at line 462 of file TGraph2DErrors.cxx. ◆ StreamerNVirtual(). void TGraph2DErrors::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file TGraph2DErrors.h. Member Data Documentation. ◆ fEX. Double_t* TGraph2DErrors::fEX {nullptr}. protected . [fNpoints] array of X errors ; Definition at line 29 of file TGraph2DErrors.h. ◆ fEY. Double_t* TGraph2DErrors::fEY {nullptr}. protected . [fNpoints] array of Y errors ; Definition at line 30 of file TGraph2DErrors.h. ◆ fEZ. Double_t* TGraph2DErrors::fEZ {nullptr}. protected . [fNpoints] array of Z errors ; Definition at line 31 of file TGraph2DErrors.h. Libraries for TGraph2DErrors:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TGraph2DErrors.h; hist/hist/src/TGraph2DErrors.cxx. TGraph2DErrors. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2DErrors.html:35188,error,errors,35188,doc/master/classTGraph2DErrors.html,https://root.cern,https://root.cern/doc/master/classTGraph2DErrors.html,3,['error'],['errors']
Availability," and/or slaves.; If plusMaster is kTRUE then exeucte on slaves and master too.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char *cmd, ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); Send command to be executed on node of ordinal 'ord' (use ""0"" for master).; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster.; If logtomacro is TRUE the text result of the action is saved in the fMacroLog; TMacro, accessible via TMacro::GetMacroLog();; Returns -1 in case of error, >=0 in case of succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. TString Getenv(const char* env, const char* ord = ""0""); Get value of environment variable 'env' on node 'ord'. Int_t GetRC(const char* RCenv, Int_t& env, const char* ord = ""0""); Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. Int_t GetRC(const char* RCenv, Double_t& env, const char* ord = ""0""); Get into 'env' the value of double RC env variable 'rcenv' on node 'ord'. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:62373,error,error,62373,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['error'],['error']
Availability," angle of x radians. ; Definition at line 588 of file TMath.h. ◆ SinH(). Double_t TMath::SinH ; (; Double_t ; x). inline . Returns the hyperbolic sine of `x. ; Definition at line 606 of file TMath.h. ◆ Sort(). template<typename Element , typename Index > . void TMath::Sort ; (; Index ; n, . const Element * ; a, . Index * ; index, . Bool_t ; down = kTRUE . ). Sort the n elements of the array a of generic templated type Element. ; In output the array index of type Index contains the indices of the sorted array. If down is false sort in increasing order (default is decreasing order).; NOTE that the array index must be created with a length >= n before calling this function. NOTE also that the size type for n must be the same type used for the index array (templated type Index) ; Definition at line 431 of file TMathBase.h. ◆ SortItr(). template<typename Iterator , typename IndexIterator > . void TMath::SortItr ; (; Iterator ; first, . Iterator ; last, . IndexIterator ; index, . Bool_t ; down = kTRUE . ). Sort the n1 elements of the Short_t array defined by its iterators. ; In output the array index contains the indices of the sorted array. If down is false sort in increasing order (default is decreasing order).; NOTE that the array index must be created with a length bigger or equal than the main array before calling this function. ; Definition at line 406 of file TMathBase.h. ◆ Sq(). Double_t TMath::Sq ; (; Double_t ; x). inline . Returns x*x. ; Definition at line 656 of file TMath.h. ◆ Sqrt(). Double_t TMath::Sqrt ; (; Double_t ; x). inline . Returns the square root of x. ; Definition at line 662 of file TMath.h. ◆ Sqrt2(). constexpr Double_t TMath::Sqrt2 ; (; ). constexpr . \( \sqrt{2} \) ; Definition at line 86 of file TMath.h. ◆ StdDev() [1/3]. template<typename Iterator > . Double_t TMath::StdDev ; (; Iterator ; first, . Iterator ; last . ). Same as RMS. ; Definition at line 528 of file TMath.h. ◆ StdDev() [2/3]. template<typename Iterator , typename WeightIterato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:82445,down,down,82445,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['down'],['down']
Availability," any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html:4380,error,error,4380,root/html528/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html,4,['error'],['error']
Availability," any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. void SetFunction(const ROOT::Math::IGenFunction& , bool copy = false); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations.; \@param copy Indicates whether the function has to be copied. double Integral(); This method is not implemented. . double IntegralUp(double a); This method is not implemented. . double IntegralLow(double b); This method is not implemented. . double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GaussIntegrator.html:4357,error,error,4357,root/html526/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GaussIntegrator.html,1,['error'],['error']
Availability," any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); -*-*Compute reasonable histogram intervals; *-* ==============",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:34032,error,error,34032,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,4,['error'],['error']
Availability," approximate number; of lines to be retrieved is given by 'lines', with the convention that; 0 means 'all', a positive number means the first 'lines' and a negative; number means the last '-lines'. Default is -1000.; If opt == TProofLog::kGrep only the lines containing 'pattern' are; retrieved (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Return 0 on success, -1 in case of any error. void Display(Int_t from = 0, Int_t to = -1); Display the current content starting from line 'from' to line 'to'; inclusive.; A negative value for 'from' indicates lines counted from the end; (tail action); 'to' is ignored in such a case.; TProofLog::Prt is called to display: the location (screen, file, box); is defined there.; Return 0 on success, -1 in case of any error. void Print(Option_t* opt = 0) const; Print a line with the relevant info. void Prt(const char* what); Special printing procedure. Int_t Grep(const char* txt, TString& res, Int_t from = 0); Search lines containing 'txt', starting from line 'from'. Return; their blanck-separated list into 'res'.; Return the number of lines found, or -1 in case of error. TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. » Author: G. Ganis 31/08/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: 5d579564fccbadad9cd6f81ccb7726dddea80e0d $ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLogElem.html:8358,error,error,8358,root/html602/TProofLogElem.html,https://root.cern,https://root.cern/root/html602/TProofLogElem.html,2,['error'],['error']
Availability," approximate number; of lines to be retrieved is given by 'lines', with the convention that; 0 means 'all', a positive number means the first 'lines' and a negative; number means the last '-lines'. Default is -1000.; If opt == TProofLog::kGrep only the lines containing 'pattern' are; retrieved (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Return 0 on success, -1 in case of any error. void Display(Int_t from = 0, Int_t to = -1); Display the current content starting from line 'from' to line 'to'; inclusive.; A negative value for 'from' indicates lines counted from the end; (tail action); 'to' is ignored in such a case.; TProofLog::Prt is called to display: the location (screen, file, box); is defined there.; Return 0 on success, -1 in case of any error. void Print(Option_t* opt = 0) const; Print a line with the relevant info. void Prt(const char* what); Special printing procedure. Int_t Grep(const char* txt, TString& res, Int_t from = 0); Search lines containing 'txt', starting from line 'from'. Return; their blanck-separated list into 'res'.; Return the number of lines found, or -1 in case of error. TProofLogElem(const char* ord, const char* url, TProofLog* logger); the name of TProofLogElem is the ordinal number of the corresp. worker; the title is the url. TMacro * GetMacro() const; { return fMacro; }. const char * GetRole(); { return fRole.Data(); }. Bool_t IsMaster() const; { return (fRole == ""master"") ? kTRUE : kFALSE; }. Bool_t IsSubMaster() const; { return (fRole == ""submaster"") ? kTRUE : kFALSE; }. Bool_t IsWorker() const; { return (fRole == ""worker"") ? kTRUE : kFALSE; }. » Author: G. Ganis 31/08/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: 5d579564fccbadad9cd6f81ccb7726dddea80e0d $ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofLogElem.html:8358,error,error,8358,root/html604/TProofLogElem.html,https://root.cern,https://root.cern/root/html604/TProofLogElem.html,2,['error'],['error']
Availability," archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char *member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers 30/6/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TArchiveFile.h 28638 2009-05-15 12:31:05Z rdm $ » Last generated: 2009-12-07 13:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TArchiveFile.html:7439,error,error,7439,root/html526/TArchiveFile.html,https://root.cern,https://root.cern/root/html526/TArchiveFile.html,1,['error'],['error']
Availability," archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers 30/6/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TArchiveFile.h 28638 2009-05-15 12:31:05Z rdm $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TArchiveFile.html:7425,error,error,7425,root/html528/TArchiveFile.html,https://root.cern,https://root.cern/root/html528/TArchiveFile.html,1,['error'],['error']
Availability," archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers 30/6/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TArchiveFile.h 28638 2009-05-15 12:31:05Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TArchiveFile.html:7494,error,error,7494,root/html530/TArchiveFile.html,https://root.cern,https://root.cern/root/html530/TArchiveFile.html,1,['error'],['error']
Availability," archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers 30/6/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TArchiveFile.h 28638 2009-05-15 12:31:05Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TArchiveFile.html:7494,error,error,7494,root/html532/TArchiveFile.html,https://root.cern,https://root.cern/root/html532/TArchiveFile.html,2,['error'],['error']
Availability," are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “Only” will allow drawing only the edited volume. The check button “Raytrace” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. . Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled “From”, “Step” and “Nslices” correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors.; 18.11.6 How to Create a Valid Geometry with Geometry Editors.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1038562,down,down,1038562,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability," are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in extern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:12037,error,errors,12037,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['error'],['errors']
Availability," are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); Replace contents of this histogram by the division of h1 by h2. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:65013,error,errors,65013,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability," are bin-to-bin uncorrelated. In many cases this corresponds to the ""Monte Carlo statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 760 of file TUnfoldSys.cxx. ◆ GetEmatrixTotal(). void TUnfoldSys::GetEmatrixTotal ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ). Get total error matrix, summing up all contributions. ; Parameters. [out]ematrixhistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins. the array binMap is explained with the method GetOutput(). ; Definition at line 1276 of file TUnfoldSys.cxx. ◆ GetRhoItotal(). void TUnfoldSys::GetRhoItotal ; (; TH1 * ; rhoi, . const Int_t * ; binMap = nullptr, . TH2 * ; invEmat = nullptr . ). Get global correlatiocn coefficients, summing up all contributions. ; Parameters. [out]rhoihistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins ; [out]invEmat(default=nullptr) inverse of error matrix. return the global correlation coefficients, including all error sources. If invEmat is nonzero, the inverse of the error matrix is returned in that histogram ; the array binMap is explained with the method GetOutput(). ; Definition at line 1401 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixXX(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixXX ; (; void ; ). protected . determine total error matrix on the vector x ; Definition at line 1331 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixYY(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixYY ; (; void ; ). protected . determine total error matrix on the vector Ax ; Definition at line 1296 of file TUnfoldSys.cxx. ◆ GetSysSources(). TSortedList * TUnfoldSys::GetSysSources ; (; void ; ); const. Get a new list of all systematic uuncertainty sources. ; The user is responsible for deleting the list ; Definition at line 1512 of file TUnfoldSys.cxx. ◆ InitTUnfoldS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:43339,error,error,43339,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['error'],['error']
Availability," are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of bins is greater than the number; of pixels in the current pad. This option should be combined with a ""drawi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:6580,error,error,6580,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,4,['error'],['error']
Availability," are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:64657,error,error,64657,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['error'],['error']
Availability," are only executed the first time Run() is called. char * Argv(Int_t index) const; Return specified argument. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Arguments handled are removed; from the argument array. The following arguments are handled:; -b : run in batch mode without graphics; -x : exit on exception; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TAppli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:14798,avail,available,14798,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,6,['avail'],['available']
Availability," are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePlayer.html:12700,error,error,12700,root/html530/TTreePlayer.html,https://root.cern,https://root.cern/root/html530/TTreePlayer.html,9,['error'],['error']
Availability," are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttLine_8cxx_source.html:2156,avail,available,2156,doc/master/TAttLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html,1,['avail'],['available']
Availability," area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8462,error,errors,8462,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,3,['error'],['errors']
Availability," args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 444",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:131798,error,error,131798,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,['error'],['error']
Availability," args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 444",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:131830,error,error,131830,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,['error'],['error']
Availability," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:12040,error,errors,12040,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,12,['error'],['errors']
Availability," argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. ROOT::Internal::TExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object. The signature of the reduce function should be (const std::vector<T>) -> T; An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in. (Note: Please be aware that chunking is only available when the policy is kMultiThread, ignoring this argument in other cases) This may be useful to avoid the overhead introduced when running really short tasks. In this case, the reduction function should be independent of the size of the vector returned by Map due to optimization of the number of chunks.; Examples:; root[] ROOT::Internal::TExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int>; &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::Internal::TExecutor; pool(ROOT::EExecutionPolicy::kMultiProcess); auto hist = pool.MapReduce(CreateAndFillHists, 10,; PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::Internal::TExecutorThis class implements the interface to execute the same task multiple times, sequentially or in paral...Definition TExecutor.hxx:37; ROOT::Internal::TExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc, unsigned nChunks) -> InvokeResult_t< F >Execute a function nTimes (M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html:2370,avail,available,2370,doc/v632/classROOT_1_1Internal_1_1TExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Internal_1_1TExecutor.html,2,['avail'],['available']
Availability," arg . ). overridevirtual . Add thread cleanup function. ; Implements TThreadImp.; Definition at line 156 of file TPosixThread.cxx. ◆ DeclFileName(). static const char * TPosixThread::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 55 of file TPosixThread.h. ◆ Exit(). Int_t TPosixThread::Exit ; (; void * ; ret). overridevirtual . Terminates the execution of the calling thread. Return 0. ; Implements TThreadImp.; Definition at line 86 of file TPosixThread.cxx. ◆ IsA(). TClass * TPosixThread::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 55 of file TPosixThread.h. ◆ Join(). Int_t TPosixThread::Join ; (; TThread * ; th, . void ** ; ret . ). overridevirtual . Join suspends the execution of the calling thread until the thread identified by th terminates, either by calling pthread_exit or by being cancelled. ; Returns 0 on success, otherwise an error number will be returned. ; Implements TThreadImp.; Definition at line 78 of file TPosixThread.cxx. ◆ Kill(). Int_t TPosixThread::Kill ; (; TThread * ; th). overridevirtual . Cancellation is the mechanism by which a thread can terminate the execution of another thread. ; Returns 0 on success, otherwise an error number will be returned. ; Implements TThreadImp.; Definition at line 97 of file TPosixThread.cxx. ◆ Run(). Int_t TPosixThread::Run ; (; TThread * ; th, . const int ; affinity = -1 . ). overridevirtual . Create a pthread. ; Returns 0 on success, otherwise an error number will be returned. ; Implements TThreadImp.; Definition at line 31 of file TPosixThread.cxx. ◆ SelfId(). Long_t TPosixThread::SelfId ; (; ). overridevirtual . Return the thread identifier for the calling thread. ; Implements TThreadImp.; Definition at line 193 of file TPosixThread.cxx. ◆ SetCancelAsynchronous(). Int_t TPosixThread::SetCancelAsynchronous ; (; ). overridevirtual . Set the cancellation resp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPosixThread.html:14210,error,error,14210,doc/master/classTPosixThread.html,https://root.cern,https://root.cern/doc/master/classTPosixThread.html,1,['error'],['error']
Availability," array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 760 of file TUnfoldSys.cxx. ◆ GetEmatrixTotal(). void TUnfoldSys::GetEmatrixTotal ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ). Get total error matrix, summing up all contributions. ; Parameters. [out]ematrixhistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins. the array binMap is explained with the method GetOutput(). ; Definition at line 1276 of file TUnfoldSys.cxx. ◆ GetRhoItotal(). void TUnfoldSys::GetRhoItotal ; (; TH1 * ; rhoi, . const Int_t * ; binMap = nullptr, . TH2 * ; invEmat = nullptr . ). Get global correlatiocn coefficients, summing up all contributions. ; Parameters. [out]rhoihistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins ; [out]invEmat(default=nullptr) inverse of error matrix. return the global correlation coefficients, including all error sources. If invEmat is nonzero, the inverse of the error matrix is returned in that histogram ; the array binMap is explained with the method GetOutput(). ; Definition at line 1401 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixXX(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixXX ; (; void ; ). protected . determine total error matrix on the vector x ; Definition at line 1331 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixYY(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixYY ; (; void ; ). protected . determine total error matrix on the vector Ax ; Definition at line 1296 of file TUnfoldSys.cxx. ◆ GetSysSources(). TSortedList * TUnfoldSys::GetSysSources ; (; void ; ); const. Get a new list of all systematic uuncertainty sources. ; The user is responsible for deleting the list ; Definition at line 1512 of file TUnfoldSys.cxx. ◆ InitTUnfoldSys(). void TUnfoldSys::InitTUnfoldSys ; (; void ; ). private . Definition at line 618 of file TUnfoldSys.cxx. ◆ Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:43411,error,error,43411,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['error'],['error']
Availability," array.Definition TObjArray.cxx:577; TObjArray::LowerBoundInt_t LowerBound() constDefinition TObjArray.h:91; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:153591,error,error,153591,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['error'],['error']
Availability," as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. bool ParameterBounds(unsigned int ipar, double& lower, double& upper) const; retrieve parameter bounds - return false if parameter is not bound. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }. » Author: L. Moneta Wed Aug 30 11:05:34 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitResult.html:10886,error,error,10886,root/html602/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitResult.html,2,['error'],['error']
Availability," as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:31176,error,errors,31176,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['error'],['errors']
Availability," as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:4131,error,error,4131,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,2,['error'],['error']
Availability," as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define calls for each variation and fill the histogram with values and cuts that depend on the variation.; There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and complex functors. The callable can be applied to zero or more existing columns and it will always receive their nominal value in input.; Varying multiple columns in lockstep; In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or ""in lockstep"":; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist.; The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; Combining multiple variations; Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced by applying multiple systematic variations at the same time. For example, in the following example snippet, the RResultMap instance all_h will contain keys ""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);; ; auto nom_h = df.Histo2D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:55743,down,down,55743,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['down'],['down']
Availability," as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted histograms comparison:. Let us denote the common weight of events of the ith bin in the first; histogram as w1i and as w2i in the second one. The total weight of events; in the first histogram is equal to. and. in the second histogram. Let us formulate the hypothesis of identity of; weighted histograms so t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:49154,down,down,49154,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,10,['down'],['down']
Availability," ascii file.; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); Creates or simply read branches from the file named whose name is passed in 'filename'.; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; If branchDescriptor is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:583958,avail,available,583958,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability," associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:168351,error,error,168351,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability," asymmetric value errors) for the; 473 given fit point.; 474 It must be called only when the coordinate errors and asymmetric errors are stored; 475 otherwise it will produce an assert.; 476 */; 477 // not threadsafe, to be replaced with never constructs!; 478 // for example: just return std::array or std::vector, there's; 479 // is going to be only minor overhead in c++11.; 480 const double* GetPointError(unsigned int ipoint, double & errlow, double & errhigh) const; 481 {; 482 assert( ipoint < fMaxPoints );; 483 assert( fErrorType == kAsymError );; 484 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 485 assert( fDataError.empty() );; 486 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 487 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 488 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 489 ; 490 errhigh = fDataErrorHighPtr[ ipoint ];; 491 errlow = fDataErrorLowPtr[ ipoint ];; 492 ; 493 return CoordErrors( ipoint );; 494 }; 495 ; 496 /**; 497 returns a single coordinate error component of a point.; 498 This function is threadsafe in contrast to Coords(...); 499 and can easily get vectorized by the compiler in loops; 500 running over the ipoint-index.; 501 */; 502 double GetBinUpEdgeComponent( unsigned int ipoint, unsigned int icoord ) const; 503 {; 504 assert( icoord < fDim );; 505 assert( !fBinEdge.empty() );; 506 assert( ipoint < fBinEdge.front().size() );; 507 ; 508 return fBinEdge[icoord][ipoint];; 509 }; 510 ; 511 /**; 512 return an array containing the upper edge of the bin for coordinate i; 513 In case of empty bin they could be merged in a single larger bin; 514 Return a NULL pointer if the bin width is not stored; 515 */; 516 // not threadsafe, to be replaced with never constructs!; 517 // for example: just return std::array or std::vector, there's; 518 // is going to be only minor overhead in c++11.; 519 const double* BinUpEdge( unsigned int ipoint ) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:17698,error,error,17698,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['error'],['error']
Availability," at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:8047,error,error,8047,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability," at line 1044 of file TProof.h. ◆ SetDataSetTreeName(). Int_t TProof::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). virtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented in TProofLite.; Definition at line 10766 of file TProof.cxx. ◆ SetDrawFeedbackOption(). void TProof::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). Set draw feedback option. ; Definition at line 10102 of file TProof.cxx. ◆ SetDSet(). void TProof::SetDSet ; (; TDSet * ; dset). inlineprotected . Definition at line 737 of file TProof.h. ◆ SetFeedback(). void TProof::SetFeedback ; (; TString & ; opt, . TString & ; optfb, . Int_t ; action . ). protected . Extract from opt in optfb information about wanted feedback settings. ; Feedback are removed from the input string opt. If action == 0, set up feedback accordingly, if action == 1 clean related feedback settings (using info in optfb, if available, or reparsing opt).; Feedback requirements are in the form <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>; The special name 'stats' triggers feedback about events and packets. The separator from the next option is either a ' ' or a ';'. Called interanally by TProof::Process. ; Definition at line 5232 of file TProof.cxx. ◆ SetInputDataFile(). void TProof::SetInputDataFile ; (; const char * ; datafile). Set the file to be used to optimally distribute the input data objects. ; If the file exists the object in the file are added to those in the fInputData list. If the file path is null, a default file will be created at the moment of sending the processing request with the content of the fInputData list. See also SendInputDataFile. ; Definition at line 9585 of file TProof.cxx. ◆ SetLogLevel(). void TProof::SetLogLevel ; (; Int_t ; level, . UInt_t ; mask = TProofDebu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:142906,avail,available,142906,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['avail'],['available']
Availability," at line 106 of file TTreeDrawArgsParser.h. ◆ IsSpecified(). bool TTreeDrawArgsParser::IsSpecified ; (; int ; num); const. returns true if the num-th parameter was specified otherwise returns fFALSE in case of an error (wrong num) prints an error message and returns false. ; Definition at line 380 of file TTreeDrawArgsParser.cxx. ◆ Parse(). bool TTreeDrawArgsParser::Parse ; (; const char * ; varexp, . const char * ; selection, . Option_t * ; option . ). Parses parameters from TTree::Draw(). . varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawing option; see TTree::Draw . Definition at line 237 of file TTreeDrawArgsParser.cxx. ◆ ParseName(). bool TTreeDrawArgsParser::ParseName ; (; TString ; name). protected . Syntax: ; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName to appropriate values.; Returns false in case of an error. ; Definition at line 131 of file TTreeDrawArgsParser.cxx. ◆ ParseOption(). bool TTreeDrawArgsParser::ParseOption ; (; ). protected . Check if options contain some data important for choosing the type of the drawn object. ; Definition at line 212 of file TTreeDrawArgsParser.cxx. ◆ ParseVarExp(). bool TTreeDrawArgsParser::ParseVarExp ; (; ). protected . Split variables and parse name and parameters in brackets. ; Definition at line 186 of file TTreeDrawArgsParser.cxx. ◆ SetObjectName(). void TTreeDrawArgsParser::SetObjectName ; (; const char * ; s). inline . Definition at line 102 of file TTreeDrawArgsParser.h. ◆ SetOriginal(). void TTreeDrawArgsParser::SetOriginal ; (; TObject * ; o). inline . Definition at line 103 of file TTreeDrawArgsParser.h. ◆ SplitVariables(). bool TTreeDrawArgsParser::SplitVariables ; (; TString ; variables). protected . Parse expression [var1 [:var2 [:var3] ...]], number of variables cannot be greater than fgMaxDimension. ; A colon which is fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeDrawArgsParser.html:19635,error,error,19635,doc/master/classTTreeDrawArgsParser.html,https://root.cern,https://root.cern/doc/master/classTTreeDrawArgsParser.html,1,['error'],['error']
Availability," at line 111 of file TProfile3D.h. ◆ GetBinEffectiveEntries(). Double_t TProfile3D::GetBinEffectiveEntries ; (; Int_t ; bin). virtual . Return bin effective entries for a weighted filled Profile histogram. ; In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. TProfile::Sumw2() must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored. ; Definition at line 721 of file TProfile3D.cxx. ◆ GetBinEntries(). Double_t TProfile3D::GetBinEntries ; (; Int_t ; bin); const. virtual . Return bin entries of a Profile3D histogram. ; Definition at line 704 of file TProfile3D.cxx. ◆ GetBinError() [1/3]. Double_t TProfile3D::GetBinError ; (; Int_t ; bin); const. overridevirtual . Return bin error of a Profile3D histogram. . Computing errors: A moving field; The computation of errors for a TProfile3D has evolved with the versions of ROOT. The difficulty is in computing errors for bins with low statistics. prior to version 3.10, we had no special treatment of low statistic bins. As a result, these bins had huge errors. The reason is that the expression eprim2 is very close to 0 (rounding problems) or 0.; The algorithm is modified/protected for the case when a TProfile3D is projected (ProjectionX). The previous algorithm generated a N^2 problem when projecting a TProfile3D with a large number of bins (eg 100000).; in version 3.10/02, a new static function TProfile::Approximate is introduced to enable or disable (default) the approximation. (see also comments in TProfile::GetBinError) . Reimplemented from TH1.; Definition at line 745 of file TProfile3D.cxx. ◆ GetBinError() [2/3]. Double_t TProfile3D::GetBinError ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz . ); const. inlineoverridevirtual . Reimplemented from TH1.; Definition at line 117 of file TProfile3D.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:88749,error,errors,88749,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,2,['error'],['errors']
Availability," at line 115 of file TProfile2D.h. ◆ GetBinEffectiveEntries(). Double_t TProfile2D::GetBinEffectiveEntries ; (; Int_t ; bin). virtual . Return bin effective entries for a weighted filled Profile histogram. ; In case of an unweighted profile, it is equivalent to the number of entries per bin The effective entries is defined as the square of the sum of the weights divided by the sum of the weights square. TProfile::Sumw2() must be called before filling the profile with weights. Only by calling this method the sum of the square of the weights per bin is stored. ; Definition at line 858 of file TProfile2D.cxx. ◆ GetBinEntries(). Double_t TProfile2D::GetBinEntries ; (; Int_t ; bin); const. virtual . Return bin entries of a Profile2D histogram. ; Definition at line 842 of file TProfile2D.cxx. ◆ GetBinError() [1/3]. Double_t TProfile2D::GetBinError ; (; Int_t ; bin); const. overridevirtual . Return bin error of a Profile2D histogram. . Computing errors: A moving field; The computation of errors for a TProfile2D has evolved with the versions of ROOT. The difficulty is in computing errors for bins with low statistics.; prior to version 3.10, we had no special treatment of low statistic bins. As a result, these bins had huge errors. The reason is that the expression eprim2 is very close to 0 (rounding problems) or 0.; The algorithm is modified/protected for the case when a TProfile2D is projected (ProjectionX). The previous algorithm generated a N^2 problem when projecting a TProfile2D with a large number of bins (eg 100000).; in version 3.10/02, a new static function TProfile::Approximate is introduced to enable or disable (default) the approximation. (see also comments in TProfile::GetBinError) . Reimplemented from TH1.; Definition at line 881 of file TProfile2D.cxx. ◆ GetBinError() [2/3]. Double_t TProfile2D::GetBinError ; (; Int_t ; binx, . Int_t ; biny . ); const. inlineoverridevirtual . Reimplemented from TH1.; Definition at line 117 of file TProfile2D.h. ◆ GetBinError(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:88135,error,errors,88135,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,2,['error'],['errors']
Availability," at line 1936 of file TProfile2D.cxx. ◆ SetBins() [4/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins . ). inlineoverrideprivatevirtual . Redefine x axis parameters with variable bin sizes. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1 ; Reimplemented from TH1.; Definition at line 69 of file TProfile2D.h. ◆ SetBins() [5/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). inlineoverrideprivatevirtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented from TH1.; Definition at line 73 of file TProfile2D.h. ◆ SetBins() [6/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). inlineoverrideprivatevirtual . Redefine x axis parameters. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 67 of file TProfile2D.h. ◆ SetBins() [7/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax, . Int_t ; nz, . Double_t ; zmin, . Double_t ; zmax . ). inlineoverrideprivatevirtual . Redefine x, y and z axis parameters. ; The X, Y and Z axis parameters are modified. The bins content array is resized if e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:102931,error,errors,102931,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,2,['error'],['errors']
Availability," at line 229 of file LorentzVector.h. ◆ GetCoordinates() [2/4]. template<class CoordSystem > . template<class IT > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; IT ; begin, . IT ; end . ); const. inline . get internal data into 4 Scalars at *begin to *end ; Definition at line 218 of file LorentzVector.h. ◆ GetCoordinates() [3/4]. template<class CoordSystem > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; Scalar & ; a, . Scalar & ; b, . Scalar & ; c, . Scalar & ; d . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 205 of file LorentzVector.h. ◆ GetCoordinates() [4/4]. template<class CoordSystem > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 211 of file LorentzVector.h. ◆ isLightlike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isLightlike ; (; Scalar ; tolerance = 100*std::numeric_limits<Scalar>::epsilon()); const. inline . Determine if momentum-energy can represent a massless particle. ; Definition at line 535 of file LorentzVector.h. ◆ isSpacelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isSpacelike ; (; ); const. inline . Determine if momentum-energy is spacelike, and represents a tachyon. ; Definition at line 545 of file LorentzVector.h. ◆ isTimelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isTimelike ; (; ); const. inline . Determine if momentum-energy can represent a physical massive particle. ; Definition at line 528 of file LorentzVector.h. ◆ M(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::M ; (; ); const. inline . return magnitude (mass) using the (-,-,-,+) metric. ; If M2 is negative (space-like vector) a GenVector_exception is suggested and if continuing, - sqrt( -M2) is returned ; Definition at line 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:17587,toler,tolerance,17587,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['toler'],['tolerance']
Availability," at line 330 of file TH1.cxx. ◆ Integral() [5/5]. Double_t TH2::Integral ; (; Option_t * ; option = """"); const. overridevirtual . Return integral of bin contents. ; Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y. ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 1317 of file TH2.cxx. ◆ IntegralAndError() [1/2]. Double_t TH1::IntegralAndError ; (; Int_t ; binx1, . Int_t ; binx2, . Double_t & ; error, . Option_t * ; option = """" . ); const. privatevirtual . Return integral of bin contents in range [binx1,binx2] and its error. ; By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x. the error is computed using error propagation from the bin errors assuming that all the bins are uncorrelated ; Reimplemented from TH1.; Definition at line 332 of file TH1.cxx. ◆ IntegralAndError() [2/2]. Double_t TH2::IntegralAndError ; (; Int_t ; firstxbin, . Int_t ; lastxbin, . Int_t ; firstybin, . Int_t ; lastybin, . Double_t & ; error, . Option_t * ; option = """" . ); const. virtual . Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram. ; Calculates also the integral error using error propagation from the bin errors assuming that all the bins are uncorrelated. By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y. ; Definition at line 1345 of file TH2.cxx. ◆ Interpolate() [1/3]. Double_t TH2::Interpolate ; (; Double_t ; x); const. overrideprotectedvirtual . illegal for a TH2 ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 1353 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:89382,error,error,89382,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,3,['error'],"['error', 'errors']"
Availability," at line 438 of file TGComboBox.cxx. ◆ SortByName(). virtual void TGComboBox::SortByName ; (; Bool_t ; ascend = kTRUE). inlinevirtual . Definition at line 120 of file TGComboBox.h. ◆ Streamer(). void TGComboBox::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TGLineStyleComboBox, TGLineWidthComboBox, TGFontTypeComboBox, and TGFSComboBox. ◆ StreamerNVirtual(). void TGComboBox::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 131 of file TGComboBox.h. Member Data Documentation. ◆ fBpic. const TGPicture* TGComboBox::fBpic. protected . down arrow picture used in fDDButton ; Definition at line 59 of file TGComboBox.h. ◆ fComboFrame. TGComboBoxPopup* TGComboBox::fComboFrame. protected . popup containing a listbox ; Definition at line 57 of file TGComboBox.h. ◆ fDDButton. TGScrollBarElement* TGComboBox::fDDButton. protected . button controlling drop down of popup ; Definition at line 56 of file TGComboBox.h. ◆ fLhb. TGLayoutHints* TGComboBox::fLhb. protected . layout hints for fDDButton ; Definition at line 61 of file TGComboBox.h. ◆ fLhdd. TGLayoutHints* TGComboBox::fLhdd. protected . layout hints for fListBox ; Definition at line 62 of file TGComboBox.h. ◆ fLhs. TGLayoutHints* TGComboBox::fLhs. protected . layout hints for selected item frame ; Definition at line 60 of file TGComboBox.h. ◆ fListBox. TGListBox* TGComboBox::fListBox. protected . the listbox with text items ; Definition at line 58 of file TGComboBox.h. ◆ fSelEntry. TGLBEntry* TGComboBox::fSelEntry. protected . selected item frame ; Definition at line 54 of file TGComboBox.h. ◆ fTextEntry. TGTextEntry* TGComboBox::fTextEntry. protected . text entry ; Definition at line 55 of file TGComboBox.h. Libraries for TGComboBox:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGComboBox.h; gui/gui/src/TGComboBox.cxx. TGComboBox. ROOT master - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGComboBox.html:46210,down,down,46210,doc/master/classTGComboBox.html,https://root.cern,https://root.cern/doc/master/classTGComboBox.html,1,['down'],['down']
Availability," at line 726 of file RooWorkspace.cxx. ◆ import() [5/6]. bool RooWorkspace::import ; (; TObject const & ; object, . bool ; replaceExisting = false . ). Import a clone of a generic TObject into workspace generic object container. ; Imported object can be retrieved by name through the obj() method. The object is cloned upon importation and the input argument does not need to live beyond the import call; Returns true if an error has occurred. ; Definition at line 1912 of file RooWorkspace.cxx. ◆ import() [6/6]. bool RooWorkspace::import ; (; TObject const & ; object, . const char * ; aliasName, . bool ; replaceExisting = false . ). Import a clone of a generic TObject into workspace generic object container. ; The imported object will be stored under the given alias name rather than its own name. Imported object can be retrieved its alias name through the obj() method. The object is cloned upon importation and the input argument does not need to live beyond the import call This method is mostly useful for importing objects that do not have a settable name such as TMatrix; Returns true if an error has occurred. ; Definition at line 1952 of file RooWorkspace.cxx. ◆ importClassCode() [1/2]. bool RooWorkspace::importClassCode ; (; const char * ; pat = ""*"", . bool ; doReplace = false . ). Import code of all classes in the workspace that have a class name that matches pattern 'pat' and which are not found to be part of the standard ROOT distribution. ; If doReplace is true any existing class code saved in the workspace is replaced ; Definition at line 1112 of file RooWorkspace.cxx. ◆ importClassCode() [2/2]. bool RooWorkspace::importClassCode ; (; TClass * ; theClass, . bool ; doReplace = false . ). Definition at line 1099 of file RooWorkspace.cxx. ◆ IsA(). TClass * RooWorkspace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 282 of file RooWorkspace.h. ◆ loadSnapshot(). bool RooWorkspace::l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:43477,error,error,43477,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['error'],['error']
Availability," at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 399 of file TListOfDataMembers.cxx. ◆ MapObject(). void TListOfDataMembers::MapObject ; (; TObject * ; obj). private . Add a pair<id, object> to the map of data members and their ids. ; Definition at line 50 of file TListOfDataMembers.cxx. ◆ operator=(). TListOfDataMembers & TListOfDataMembers::operator= ; (; const TListOfDataMembers & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfDataMembers::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 353 of file TListOfDataMembers.cxx. ◆ Remove() [1/2]. TObject * TListOfDataMembers::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 366 of file TListOfDataMembers.cxx. ◆ Remove() [2/2]. TObject * TListOfDataMembers::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 382 of file TListOfDataMembers.cxx. ◆ SetClass(). void TListOfDataMembers::SetClass ; (; TClass * ; cl). inline . Definition at line 91 of file TListOfDataMembers.h. ◆ Streamer(). void TListOfDataMembers::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TListOfDataMembers. ; Reimplemented from THashList.; Definition at line 484 of file TListOfDataMembers.cxx. ◆ StreamerNVirtual(). void TListOfDataMembers::StreamerNVirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:31744,avail,available,31744,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['avail'],['available']
Availability," at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - f(x-h)}{2h}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller. ; Definition at line 116 of file RichardsonDerivator.h. ◆ Derivative2() [1/2]. double ROOT::Math::RichardsonDerivator::Derivative2 ; (; const IGenFunction & ; f, . double ; x, . double ; h . ). Second Derivative calculation passing function and step-size. ; Definition at line 159 of file RichardsonDerivator.cxx. ◆ Derivative2() [2/2]. double ROOT::Math::RichardsonDerivator::Derivative2 ; (; double ; x). inline . Returns the second derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; the argument eps may be specified to control the ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RichardsonDerivator.html:6970,error,error,6970,doc/master/classROOT_1_1Math_1_1RichardsonDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RichardsonDerivator.html,1,['error'],['error']
Availability," at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147655,error,error,147655,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability," automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72835,recover,recovered,72835,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Availability," average of the lower and upper variance. ;  ; Double_t GetErrorYhigh (Int_t i) const;  Returns the high error along Y at point i. ;  ; Double_t GetErrorYlow (Int_t i) const;  Returns the low error along Y at point i. ;  ; Double_t GetErrorZ (Int_t bin) const override;  Returns the combined error along Z at point i by computing the average of the lower and upper variance. ;  ; Double_t GetErrorZhigh (Int_t i) const;  Returns the high error along Z at point i. ;  ; Double_t GetErrorZlow (Int_t i) const;  Returns the low error along Z at point i. ;  ; Double_t * GetEXhigh () const override;  ; Double_t * GetEXlow () const override;  ; Double_t * GetEYhigh () const override;  ; Double_t * GetEYlow () const override;  ; Double_t * GetEZhigh () const override;  ; Double_t * GetEZlow () const override;  ; Double_t GetXmaxE () const override;  Returns the X maximum with errors. ;  ; Double_t GetXminE () const override;  Returns the X minimum with errors. ;  ; Double_t GetYmaxE () const override;  Returns the Y maximum with errors. ;  ; Double_t GetYminE () const override;  Returns the Y minimum with errors. ;  ; Double_t GetZmaxE () const override;  Returns the Z maximum with errors. ;  ; Double_t GetZminE () const override;  Returns the Z minimum with errors. ;  ; TClass * IsA () const override;  ; TGraph2DAsymmErrors & operator= (const TGraph2DAsymmErrors &);  Assignment operator Copy everything except list of functions. ;  ; void Print (Option_t *chopt="""") const override;  Print 2D graph and errors values. ;  ; Int_t RemovePoint (Int_t ipoint);  Deletes point number ipoint. ;  ; void Scale (Double_t c1=1., Option_t *option=""z"") override;  Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1. ;  ; void Set (Int_t n) override;  Set number of points in the 2D graph. ;  ; void SetPoint (Int_t i, Double_t x, Double_t y, Double_t z) override;  Set x, y and z values for point number i. ;  ; virtual void SetPointError (Int_t i, Double_t exl, Double_t exh, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2DAsymmErrors.html:5420,error,errors,5420,doc/master/classTGraph2DAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraph2DAsymmErrors.html,1,['error'],['errors']
Availability," average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get from TDirectory 'd' the TProfile named 'pfn' and create the graph.; Return also the max y in mx. void AssertFittingFun(Double_t mi, Double_t mx); Make sure that the fitting functions are defined. void GetPerfSpecs(const char* path = ""."", Int_t degfit = 1); Get performance specs. Check file 'path', or files in directory 'path'; (default current directory).; The degree of the polynomial used for the fit is 'degfit' (default 1). Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard plot; 'stdx:' draw standard plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); type = 'mbs' MB/s scaling plots (default); 'evts' Event/s scaling plots; dofit = 0 no fit; 1 fit with default 3 parameter saturated I/O formula; 2 fit with 4 par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:11399,error,error,11399,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,6,['error'],['error']
Availability," average response - TODO : rewrite bad dependancy on EvaluateAverage() ! ;  ; Double_t CalcAverageResponseOLD ();  ; Double_t CalcAverageTruth ();  calculate the average truth ;  ; void CalcFStar ();  Estimates F* (optimum scoring function) for all events for the given sets. ;  ; void CalcGDNTau ();  ; void CalcTstAverageResponse ();  calc average response for all test paths - TODO: see comment under CalcAverageResponse() note that 0 offset is used ;  ; Double_t ErrorRateBin ();  Estimates the error rate with the current set of parameters It uses a binary estimate of (y-F*(x)) (y-F*(x)) = (Num of events where sign(F)!=sign(y))/Neve y = {+1 if event is signal, -1 otherwise} — NOT USED —. ;  ; Double_t ErrorRateReg ();  Estimates the error rate with the current set of parameters This code is pretty messy at the moment. ;  ; Double_t ErrorRateRoc ();  Estimates the error rate with the current set of parameters. ;  ; Double_t ErrorRateRocRaw (std::vector< Double_t > &sFsig, std::vector< Double_t > &sFbkg);  Estimates the error rate with the current set of parameters. ;  ; void ErrorRateRocTst ();  Estimates the error rate with the current set of parameters. ;  ; void EvaluateAverage (UInt_t ind1, UInt_t ind2, std::vector< Double_t > &avsel, std::vector< Double_t > &avrul);  evaluate the average of each variable and f(x) in the given range ;  ; void EvaluateAveragePath ();  ; void EvaluateAveragePerf ();  ; void FillCoefficients ();  helper function to store the rule coefficients in local arrays ;  ; void InitNtuple ();  initializes the ntuple ;  ; void MakeGradientVector ();  make gradient vector ;  ; void MakeTstGradientVector ();  make test gradient vector for all tau same algorithm as MakeGradientVector() ;  ; Double_t Optimism ();  implementation of eq. ;  ; void UpdateCoefficients ();  Establish maximum gradient for rules, linear terms and the offset. ;  ; void UpdateTstCoefficients ();  Establish maximum gradient for rules, linear terms and the offset for all taus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:3703,error,error,3703,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['error'],['error']
Availability," averaged over the bin (the default is to evaluate it simply at the bin center).; If option ""R"" is used, the fit range will be taken from the fit function (the default is to use the entire histogram).; If option ""S"" a TFitResult object is returned and it can be used to obtain additional fit information, like covariance or correlation matrix.; Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the ""error"" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.; On output, f1 contains the fitted parameters and errors, as well as the number of degrees of freedom, and the goodness-of-fit estimator as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. ; Definition at line 195 of file TBinomialEfficiencyFitter.cxx. ◆ GetFitter(). ROOT::Fit::Fitter * TBinomialEfficiencyFitter::GetFitter ; (; ). Provide access to the underlying fitter object. ; This may be useful e.g. for the retrieval of additional information (such as the output covariance matrix of the fit). ; Definition at line 162 of file TBinomialEfficiencyFitter.cxx. ◆ IsA(). TClass * TBinomialEfficiencyFitter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ Set(). void TBinomialEfficiencyFitter::Set ; (; const TH1 * ; numerator, . const TH1 * ; denominator . ). Initialize with a new set of inputs. ; Definition at line 139 of file TBinomialEfficiencyFitter.cxx. ◆ SetPrecision(). void TBinomialEfficiencyFitter::SetPrecisio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:18142,error,errors,18142,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['error'],['errors']
Availability," ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};; ; TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; gme->AddYError(5, aeylsys, aeyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; ; gme->Draw(""a p s ; ; 5 s=0.5"");; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073. TGraphPolar options; The drawing options for the polar graphs are the following:. Option Description . ""O"" Polar labels are drawn orthogonally to the polargram radius. . ""P"" Polymarker are drawn at each point position. . ""E"" Draw error bars. . ""F"" Draw fill area (closed polygon). . ""A"" Force axis redrawing even if a polargram already exis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:18311,error,error,18311,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['error'],['error']
Availability," axes will be; 2780/// kept, but only bins inside the selected range will be filled.; 2781///; 2782/// The projection is made for the selected bins only.; 2783/// To select a bin range along an axis, use TAxis::SetRange, eg; 2784/// h3.GetYaxis()->SetRange(23,56);; 2785///; 2786/// NOTE 1: The generated histogram is named th3name + ""_p"" + option; 2787/// eg if the TH3* h histogram is named ""myhist"", then; 2788/// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; 2789/// The following sequence; 2790/// h->Project3DProfile(""xy"");; 2791/// h->Project3DProfile(""xy2"");; 2792/// will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2""; 2793/// So, passing additional characters in the option string one can customize the name.; 2794///; 2795/// NOTE 2: If a profile of the same type already exists with compatible axes,; 2796/// the profile is reset and filled again with the projected contents of the TH3.; 2797/// In the case of axes incompatibility, an error is reported and a NULL pointer is returned.; 2798///; 2799/// NOTE 3: The number of entries in the projected profile is estimated from the number of; 2800/// effective entries for all the cells included in the projection.; 2801///; 2802/// NOTE 4: underflow/overflow are by default excluded from the projection; 2803/// (Note that this is a different default behavior compared to the projection to an histogram); 2804/// To include the underflow and/or overflow use option ""UF"" and/or ""OF""; 2805 ; 2806TProfile2D *TH3::Project3DProfile(Option_t *option) const; 2807{; 2808 TString opt = option; opt.ToLower();; 2809 Int_t pcase = 0;; 2810 TString ptype;; 2811 if (opt.Contains(""xy"")) { pcase = 4; ptype = ""xy""; }; 2812 if (opt.Contains(""yx"")) { pcase = 5; ptype = ""yx""; }; 2813 if (opt.Contains(""xz"")) { pcase = 6; ptype = ""xz""; }; 2814 if (opt.Contains(""zx"")) { pcase = 7; ptype = ""zx""; }; 2815 if (opt.Contains(""yz"")) { pcase = 8; ptype = ""yz""; }; 2816 if (opt.Contains(""zy"")) { pcase = 9; pt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:111168,error,error,111168,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['error'],['error']
Availability," axis of the function.; 2410 ; 2411TAxis *TF1::GetYaxis() const; 2412{; 2413 TH1 *h = GetHistogram();; 2414 if (!h) return nullptr;; 2415 return h->GetYaxis();; 2416}; 2417 ; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// Get z axis of the function. (In case this object is a TF2 or TF3); 2421 ; 2422TAxis *TF1::GetZaxis() const; 2423{; 2424 TH1 *h = GetHistogram();; 2425 if (!h) return nullptr;; 2426 return h->GetZaxis();; 2427}; 2428 ; 2429 ; 2430 ; 2431////////////////////////////////////////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:89193,error,errors,89193,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['errors']
Availability," axis range (default is to smooth all bins); Bin contents are replaced by their smooth values.; Errors (if any) are not modified.; the smoothing procedure is repeated ntimes (default=1). void StatOverflows(Bool_t flag = kTRUE); if flag=kTRUE, underflows and overflows are used by the Fill functions; in the computation of statistics (mean value, RMS).; By default, underflows or overflows are not used. void Streamer(TBuffer& ); Stream a class object. void Print(Option_t* option = """") const; Print some global quantities for this histogram. If option ""base"" is given, number of bins and ranges are also printed; If option ""range"" is given, bin contents and errors are also printed; for all bins in the current range (default 1-->nbins); If option ""all"" is given, bin contents and errors are also printed; for all bins including under and overflows. void Rebuild(Option_t* option = """"); Using the current bin info, recompute the arrays for contents and errors. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc. if option ""ICE"" is specified, resets only Integral, Contents and Errors.; if option ""ICES"" is specified, resets only Integral, Contents , Errors and Statistics; This option is used; if option ""M"" is specified, resets also Minimum and Maximum. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SavePrimitiveHelp(ostream& out, const char* hname, Option_t* option = """"); helper function for the SavePrimitive functions from TH1; or classes derived from TH1, eg TProfile, TProfile2D. void UseCurrentStyle(); Copy current attributes from/to current style. Double_t GetMean(Int_t axis = 1) const; For axis = 1,2 or 3 returns the mean value of the histogram along; X,Y or Z axis.; For axis = 11, 12, 13 returns the standard error of the mean value; of the histogram along X, Y or Z axis. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:109183,error,errors,109183,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['error'],['errors']
Availability," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.; In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with TUBE shape on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:955635,error,error,955635,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:47683,error,error,47683,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['error'],['error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooAbsIntegrator*createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0, Bool_t isBinned = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*getDepIntegratorName(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const RooAbsIntegrator*getProtoIntegrator(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumIntFactory.html:1993,error,error,1993,root/html534/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html534/RooNumIntFactory.html,6,['error'],['error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); voidclearErrorCount(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_t&debugCode(); RooWorkspace*debugWorkspace(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteStream(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_terrorCount() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; RooMsgService::StreamConfig&getStream(Int_t id); Bool_tgetStreamStatus(Int_t id) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; RooFit::MsgLevelglobalKillBelow() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:2940,error,error,2940,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,10,['error'],['error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:5133,error,error,5133,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,10,['error'],['error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMathText.html:54160,Error,Error,54160,root/html534/TMathText.html,https://root.cern,https://root.cern/root/html534/TMathText.html,1,['Error'],['Error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:54040,Error,Error,54040,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,2,['Error'],['Error']
Availability," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPosixThreadFactory.html:1749,error,error,1749,root/html528/TPosixThreadFactory.html,https://root.cern,https://root.cern/root/html528/TPosixThreadFactory.html,20,['error'],['error']
Availability," based on the attribute ""ORIGNAME:<name>"". ; [in]isRecursionStepInternal switch used when called from recursiveRedirectServers(). . Definition at line 1036 of file RooAbsArg.cxx. ◆ redirectServers() [2/2]. bool RooAbsArg::redirectServers ; (; std::unordered_map< RooAbsArg *, RooAbsArg * > const & ; replacements). Replace some servers of this object. ; If there are proxies that correspond to the replaced servers, these proxies are adjusted as well. Parameters. [in]replacementsMap that specifies which args replace which servers. . Definition at line 1150 of file RooAbsArg.cxx. ◆ redirectServersHook(). bool RooAbsArg::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). virtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsOptTestStatistic, RooAbsTestStatistic, RooAbsPdf, RooAbsReal, and RooProjectedPdf.; Definition at line 1313 of file RooAbsArg.cxx. ◆ registerCache(). void RooAbsArg::registerCache ; (; RooAbsCache & ; cache). Register RooAbsCache with this object. ; This function is called by RooAbsCache constructors for objects that are a datamember of this RooAbsArg. By registering itself the RooAbsArg is aware of all its cache data members and will forward server change and cache mode change calls to the cache objects, which in turn can forward them their contents ; Definition at line 2117 of file RooAbsArg.cxx. ◆ r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:91320,error,error,91320,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['error'],['error']
Availability," be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:25143,error,error,25143,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,19,['error'],['error']
Availability," be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1124 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result by scaleFactor. Returns a pointer to the input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input histogram according to the order in which they appear in the input plotVars list. If scaleForDensity is true the histogram is filled with a the functions density rather than the functions value (i.e. the value at the bin center is multiplied with bin volume) ; Definition at line 947 of file RooAbsReal.cxx. ◆ fillTreeBranch(). void RooAbsReal::fillTreeBranch ; (; TTree & ; t). overrideprotectedvirtual . Fill the tree branch that associated with this object with its current value. ; Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3099 of file RooAbsReal.cxx. ◆ findInnerMostIntegration(). void RooAbsReal::findInnerMostIntegration ; (; const RooArgSet & ; allObs, . RooArgSet & ; innerObs, . const char * ; rangeName . ); const. protected . Utility function for createIntObj() that aids i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:103200,error,error,103200,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability," be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1152 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result by scaleFactor. Returns a pointer to the input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input histogram according to the order in which they appear in the input plotVars list. If scaleForDensity is true the histogram is filled with a the functions density rather than the functions value (i.e. the value at the bin center is multiplied with bin volume) ; Definition at line 975 of file RooAbsReal.cxx. ◆ fillTreeBranch(). void RooAbsReal::fillTreeBranch ; (; TTree & ; t). overrideprotectedvirtual . Fill the tree branch that associated with this object with its current value. ; Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3181 of file RooAbsReal.cxx. ◆ findInnerMostIntegration(). void RooAbsReal::findInnerMostIntegration ; (; const RooArgSet & ; allObs, . RooArgSet & ; innerObs, . const char * ; rangeName . ); const. protected . Utility function for createIntObj() that aids i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:104459,error,error,104459,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability," be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1310 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; ofs, . Int_t ; ncol, . const char * ; option = ""NEYU"", . Int_t ; sigDigit = 1, . const RooLinkedList & ; siblingLists = RooLinkedList(), . const RooCmdArg * ; formatCmd = nullptr . ); const. Internal implementation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:49797,error,error,49797,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['error'],['error']
Availability," be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1320 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; ofs, . Int_t ; ncol, . const char * ; option = ""NEYU"", . Int_t ; sigDigit = 1, . const RooLinkedList & ; siblingLists = RooLinkedList(), . const RooCmdArg * ; formatCmd = nullptr . ); const. Internal implementation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:48014,error,error,48014,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['error'],['error']
Availability," be used. Colors automatically picked in palette; SinceROOT version 6.09/01; When several histograms are painted in the same canvas thanks to the option ""SAME"" or via a THStack it might be useful to have an easy and automatic way to choose their color. The simplest way is to pick colors in the current active color palette. Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and PMC (Palette Marker Color). When one of these options is given to TH1::Draw the histogram get its color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of objects having palette coloring in the current pad.; ; void histpalettecolor(); {; auto C = new TCanvas();; ; gStyle->SetOptTitle(kFALSE);; gStyle->SetOptStat(0);; ; auto h1 = new TH1F(""h1"",""Histogram drawn with full circles"",100,-4,4);; auto h2 = new TH1F(""h2"",""Histogram drawn with full squares"",100,-4,4);; auto h3 = new TH1F(""h3"",""Histogram drawn with full triangles up"",100,-4,4);; auto h4 = new TH1F(""h4"",""Histogram drawn with full triangles down"",100,-4,4);; auto h5 = new TH1F(""h5"",""Histogram drawn with empty circles"",100,-4,4);; ; TRandom3 rng;; Double_t px,py;; for (Int_t i = 0; i < 25000; i++) {; rng.Rannor(px,py);; h1->Fill(px,10.);; h2->Fill(px, 8.);; h3->Fill(px, 6.);; h4->Fill(px, 4.);; h5->Fill(px, 2.);; }; ; h1->SetMarkerStyle(kFullCircle);; h2->SetMarkerStyle(kFullSquare);; h3->SetMarkerStyle(kFullTriangleUp);; h4->SetMarkerStyle(kFullTriangleDown);; h5->SetMarkerStyle(kOpenCircle);; ; h1->Draw(""PLC PMC"");; h2->Draw(""SAME PLC PMC"");; h3->Draw(""SAME PLC PMC"");; h4->Draw(""SAME PLC PMC"");; h5->Draw(""SAME PLC PMC"");; ; gPad->BuildLegend();; }; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kFullTriangleDown@ kFullTriangleDownDefinition TAttMarker.h:56; kFullSquare@ kFullSquareDefinition TAttMarker.h:55; kFullTriangleUp@ kFullTriangleUpDefinition TAttMarker.h:55; kFullCircle@ kFullCircleDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:17607,down,down,17607,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['down'],['down']
Availability," been created before via the default constructor. See TObject::Write(). ; Reimplemented from TKey.; Definition at line 69 of file TKeyXML.h. ◆ Read() [2/2]. Int_t TKeyXML::Read ; (; TObject * ; tobj). finalvirtual . To read an object from the file. ; The object associated to this key is read from the file into memory. Before invoking this function, obj has been created via the default constructor. ; Reimplemented from TKey.; Definition at line 245 of file TKeyXML.cxx. ◆ ReadBuffer(). void TKeyXML::ReadBuffer ; (; char *& ; buffer). inlinefinalvirtual . Decode input buffer. ; In some situation will add key to gDirectory. ; Reimplemented from TKey.; Definition at line 54 of file TKeyXML.h. ◆ ReadFile(). Bool_t TKeyXML::ReadFile ; (; ). inlinefinalvirtual . Read the key structure from the file. ; Reimplemented from TKey.; Definition at line 55 of file TKeyXML.h. ◆ ReadObj(). TObject * TKeyXML::ReadObj ; (; ). finalvirtual . read object derived from TObject class, from key if it is not TObject or in case of error, return nullptr ; Reimplemented from TKey.; Definition at line 259 of file TKeyXML.cxx. ◆ ReadObjectAny(). void * TKeyXML::ReadObjectAny ; (; const TClass * ; expectedClass). finalvirtual . read object of any type ; Reimplemented from TKey.; Definition at line 312 of file TKeyXML.cxx. ◆ ReadObjWithBuffer(). TObject * TKeyXML::ReadObjWithBuffer ; (; char * ; bufferRead). finalvirtual . read object derived from TObject class, from key if it is not TObject or in case of error, return nullptr ; Reimplemented from TKey.; Definition at line 286 of file TKeyXML.cxx. ◆ SetBuffer(). void TKeyXML::SetBuffer ; (; ). inlinefinalvirtual . Reimplemented from TKey.; Definition at line 56 of file TKeyXML.h. ◆ SetSubir(). void TKeyXML::SetSubir ; (; ). inline . Definition at line 64 of file TKeyXML.h. ◆ StoreKeyAttributes(). void TKeyXML::StoreKeyAttributes ; (; ). protected . Stores keys attributes in key node. ; Definition at line 142 of file TKeyXML.cxx. ◆ StoreObject(). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKeyXML.html:22802,error,error,22802,doc/master/classTKeyXML.html,https://root.cern,https://root.cern/doc/master/classTKeyXML.html,1,['error'],['error']
Availability," been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:14980,error,error,14980,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,18,['error'],['error']
Availability," been set; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with asymmetric errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end). Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t i) const; Get high error on X. Double_t GetErrorXlow(Int_t i) const; Get low error on X. Double_t GetErrorYhigh(Int_t i) const; Get high error on Y. Double_t GetErrorYlow(Int_t i) const; Get low error on Y. Int_t Merge(TCollection* list); Adds all graphs with asymmetric errors from the collection to this graph.; Returns the total number of poins in the result or -1 in case of an error. void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); Set ex and ey values for point pointed by the mouse. void SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); Set ex and ey values for point number i. void SetPointEXlow(Int_t i, Double_t exl); Set EXlow for point i. void SetPointEXhigh(Int_t i, Double_t exh); Set EXhigh for point i. void SetPointEYlow(Int_t i, Double_t eyl); Set EYlow for point i. void SetPointEYhigh(Int_t i, Double_t eyh); Set EYhigh for point i. void Streamer(TBuffer& ); Stream an object of class TGraphAsymmErrors. void SwapPoints(Int_t pos1, Int_t pos2); Swap points. Double_t** Allocate(Int_t size). Double_t * GetEXlow() const; {return fEXlow;}. Double_t * GetEXhigh() const; {return fEXhigh;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphAsymmErrors.html:23611,error,error,23611,root/html602/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html,4,['error'],['error']
Availability," before filling; the histogram. Return mean value of this histogram along the X axis. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t GetMeanError(Int_t axis = 1) const; Return standard error of mean of this histogram along the X axis. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Also note, that although the definition of standard error doesn't include the; assumption of normality, many uses of this feature implicitly assume it. Double_t GetRMS(Int_t axis = 1) const; For axis = 1,2 or 3 returns the Sigma value of the histogram along; X, Y or Z axis; For axis = 11, 12 or 13 returns the error of RMS estimation along; X, Y or Z axis for Normal distribution. Note that the mean value/sigma is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Note that this function returns the Standard Deviation (Sigma); of the distribution (not RMS).; The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2)); The name ""RMS"" was introduced many years ago (Hbook/PAW times).; We kept the name for continuity. Double_t GetRMSError(Int_t axis = 1) const; Return error of RMS e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:111358,error,error,111358,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['error'],['error']
Availability," begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20618,error,error,20618,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability," being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:59488,error,errors,59488,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,4,['error'],['errors']
Availability," being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are compu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:57806,error,errors,57806,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['error'],['errors']
Availability," below (above) the data point, ey is ey_low (ey_high).; The approach used to approximate the uncertainty in y because of the errors in x is to make it equal the error in x times the slope of the line. This approach is called ""effective variance method"" and the implementation is provided in the function FitUtil::EvaluateChi2Effective. Linear fitting:; When the fitting function is linear (contains the ++ sign) or the fitting function is a polynomial, a linear fitter is initialised. To create a linear function, use the following syntax: linear parts separated by ++ sign. Example: to fit the parameters of the function p0*x + p1*sin(x), you can create a TF1 object as TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option ROB. See the tutorial fitLinearRobust.C. Notes on TGraph/TGraphErrors Fitting:. By using the ""effective variance"" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.; The effective variance technique assumes that there is no correlation between the x and y coordinate.; The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option ""EX0""; The linear fitter doesn't take into account the errors in x. When fitting a TGraphErrors with a linear functions the errors in x will not be considered. If errors in x are important, use option ""F"" for linear function fitting.; When fitting a TGraph (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: parameter_error *= sqrt(chisquare/(ndf-1)). General Fitting documentation; See in T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:51607,robust,robust,51607,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['robust'],['robust']
Availability," between ""labeled"" bins they will not be removed. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Bool_t SameLimitsAndNBins(const TAxis& axis1, const TAxis& axis2); Same limits and bins. Bool_t RecomputeAxisLimits(TAxis& destAxis, const TAxis& anAxis); Finds new limits for the axis for the Merge function.; returns false if the limits are incompatible. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If all histograms have bin labels, bins with identical labels; will be merged, no matter what their order is.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width.; Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH1.html:93235,error,errors,93235,root/html530/TH1.html,https://root.cern,https://root.cern/root/html530/TH1.html,1,['error'],['errors']
Availability," between two interpretations of errors: . SumW2Error Interpretation . true The errors reflect the uncertainty of the Monte Carlo simulation. Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; Example: Simulation with 1000 events, the average weight is 0.1. The errors are as big as if one fitted to 1000 events. . false The errors reflect the errors of a dataset, which is as big as the sum of weights. Use this if you want to know what statistical errors you would get if you had a dataset with as many events as the (weighted) Monte Carlo simulation represents.; Example (Data as above): The errors are as big as if one fitted to 100 events. . NoteIf the SumW2Error correction is enabled, the covariance matrix quality stored in the RooFitResult object will be the minimum of the original covariance matrix quality and the quality of the covariance matrix calculated with the squared weights. . AsymptoticError() Use the asymptotically correct approach to estimate errors in the presence of weights. This is slower but more accurate than SumW2Error. See also https://arxiv.org/abs/1911.01303). This option even correctly implements the case of extended likelihood fits (see this writeup on extended weighted fits that complements the paper linked before). . PrefitDataFraction(double fraction) Runs a prefit on a small dataset of size fraction*(actual data size). This can speed up fits by finding good starting values for the parameters for the actual fit. WarningPrefitting may give bad results when used in binned analysis. Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit). . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default. . PrintLevel(Int_t level) Set Minuit print level (-1 to 3, default is 1). At -1 all RooFit informational messages are suppressed as well. See RooMinimizer::PrintLevel for the meaning of the leve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:108543,error,errors,108543,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['errors']
Availability," bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap his",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnfoldSys.html:4858,Error,Error,4858,root/html532/TUnfoldSys.html,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html,1,['Error'],['Error']
Availability," bin contents in a given bin range. If the option “width” is specified, the integral is the sum of the bin contents multiplied by the bin width in x .; TH1::GetMean(int axis) - returns the mean value along axis.; TH1::GetStdDev(int axis) - returns the sigma distribution along axis.; TH1::GetRMS(int axis) - returns the Root Mean Square along axis.; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:117676,error,errors,117676,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['errors']
Availability," bin list.Definition TH2Poly.cxx:877; TH2Poly::SetBinContentChangedvoid SetBinContentChanged(Bool_t flag)Definition TH2Poly.h:122; TH2Poly::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2Poly.cxx:1440; TH2Poly::fCompletelyInsideBool_t * fCompletelyInside[fNCells] The array that returns true if the cell at the given coordinate is completely inside a binDefinition TH2Poly.h:166; TH2Poly::TH2PolyTH2Poly()Default Constructor. No boundaries specified.Definition TH2Poly.cxx:148; TH2Poly::IsInsideBinBool_t IsInsideBin(Int_t binnr, Double_t x, Double_t y)Return ""true"" if the point (x,y) is inside the bin of binnr.Definition TH2Poly.cxx:1432; TH2Poly::fNewBinAddedBool_t fNewBinAdded!For the 3D PainterDefinition TH2Poly.h:168; TH2Poly::Copyvoid Copy(TObject &newth2p) const overrideCopy function for TH2Poly.Definition TH2Poly.cxx:212; TH2Poly::SetBinErrorvoid SetBinError(Int_t bin, Double_t error) overrideSet the bin Error.Definition TH2Poly.cxx:893; TH2Poly::GetBinTitleconst char * GetBinTitle(Int_t bin) constReturns the bin title.Definition TH2Poly.cxx:918; TH2Poly::SetNewBinAddedvoid SetNewBinAdded(Bool_t flag)Definition TH2Poly.h:124; TH2Poly::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this histogram by a constant c1.Definition TH2Poly.cxx:1393; TH2Poly::ChangePartitionvoid ChangePartition(Int_t n, Int_t m)Changes the number of partition cells in the histogram.Definition TH2Poly.cxx:515; TH2Poly::Interpolatevirtual Double_t Interpolate(Double_t, Double_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1749; TH2Poly::GetMinimumDouble_t GetMinimum() constReturns the minimum value of the histogram.Definition TH2Poly.cxx:976; TH2Poly::GetBinNameconst char * GetBinName(Int_t bin) constReturns the bin name.Definition TH2Poly.cxx:908; TH2Poly::fStepXDouble_t fStepXDefinition TH2Poly.h:164; TH2Poly::FillNvoid FillN(Int_t ntimes, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:70237,error,error,70237,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['error'],['error']
Availability," bin number bin. The error will depend on the statistic option used will return; the binContent - lower interval value. Double_t GetBinErrorUp(Int_t bin) const; Return upper error associated to bin number bin. The error will depend on the statistic option used will return; the binContent - upper interval value. Double_t GetBinCenter(Int_t bin) const; return bin center for 1D historam; Better to use h1.GetXaxis().GetBinCenter(bin). Double_t GetBinLowEdge(Int_t bin) const; return bin lower edge for 1D historam; Better to use h1.GetXaxis().GetBinLowEdge(bin). Double_t GetBinWidth(Int_t bin) const; return bin width for 1D historam; Better to use h1.GetXaxis().GetBinWidth(bin). void GetCenter(Double_t* center) const; Fill array with center of bins for 1D histogram; Better to use h1.GetXaxis().GetCenter(center). void GetLowEdge(Double_t* edge) const; Fill array with low edge of bins for 1D histogram; Better to use h1.GetXaxis().GetLowEdge(edge). void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or CanExtendAllAxes(),; the number of bins is automatically doubled to accommodate the new bin. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); see convention for numbering bins in TH1::GetBin. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram. Function parameters:; -niter, number of iterations (default value = 2); Increasing niter make the result smoother and lower.; -option: may contain one of the following options; - to set the direction parameter; ""BackDecreasingWindow"". By de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:129159,error,error,129159,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['error']
Availability," bin to this histogram with the value (n1-n2)/(n1+n2) using an error bar calculated with Binomial statistics. ;  ; void addBin (Axis_t binCenter, double n, double binWidth=0, double xErrorFrac=1.0, double scaleFactor=1.0);  Add a bin to this histogram with the specified integer bin contents and using an error bar calculated with Poisson statistics. ;  ; void addBinWithError (Axis_t binCenter, double n, double elow, double ehigh, double binWidth=0, double xErrorFrac=1.0, bool correctForBinWidth=true, double scaleFactor=1.0);  Add a bin to this histogram with the specified bin contents and error. ;  ; void addBinWithXYError (Axis_t binCenter, double n, double exlow, double exhigh, double eylow, double eyhigh, double scaleFactor=1.0);  Add a bin to this histogram with the specified bin contents and error. ;  ; void addEfficiencyBin (Axis_t binCenter, Int_t n1, Int_t n2, double binWidth=0, double xErrorFrac=1.0, double scaleFactor=1.0);  Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ;  ; void addEfficiencyBinWithError (Axis_t binCenter, double n1, double n2, double en1, double en2, double binWidth=0, double xErrorFrac=1.0, double scaleFactor=1.0);  Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ;  ; double getFitRangeBinW () const override;  Return (average) bin width of this RooHist. ;  ; double getFitRangeNEvt () const override;  Return the number of events of the dataset associated with this RooHist. ;  ; double getFitRangeNEvt (double xlo, double xhi) const override;  Calculate integral of histogram in given range. ;  ; double getNominalBinWidth () const;  ; bool hasIdenticalBinning (const RooHist &other) const;  Return true if binning of this RooHist is identical to that of 'other'. ;  ; TClass * IsA () const override;  ; bool isIdentical (const RooHist &other, double tol=1e-6, bool verbose=true) const;  Return true if contents of this RooH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:3383,error,error,3383,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['error'],['error']
Availability," bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ;  ; void addEfficiencyBinWithError (Axis_t binCenter, double n1, double n2, double en1, double en2, double binWidth=0, double xErrorFrac=1.0, double scaleFactor=1.0);  Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ;  ; double getFitRangeBinW () const override;  Return (average) bin width of this RooHist. ;  ; double getFitRangeNEvt () const override;  Return the number of events of the dataset associated with this RooHist. ;  ; double getFitRangeNEvt (double xlo, double xhi) const override;  Calculate integral of histogram in given range. ;  ; double getNominalBinWidth () const;  ; bool hasIdenticalBinning (const RooHist &other) const;  Return true if binning of this RooHist is identical to that of 'other'. ;  ; TClass * IsA () const override;  ; bool isIdentical (const RooHist &other, double tol=1e-6, bool verbose=true) const;  Return true if contents of this RooHist is identical within given relative tolerance to that of 'other'. ;  ; RooHist * makePullHist (const RooCurve &curve, bool useAverage=false) const;  ; RooHist * makeResidHist (const RooCurve &curve, bool normalize=false, bool useAverage=false) const;  Create and return RooHist containing residuals w.r.t to given curve. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of RooHist. ;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Print info about this histogram to the specified output stream. ;  ; void printName (std::ostream &os) const override;  Print name of RooHist. ;  ; void printTitle (std::ostream &os) const override;  Print title of RooHist. ;  ; void setRawEntries (double n);  ; void Streamer (TBuffer &) override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:4411,toler,tolerance,4411,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['toler'],['tolerance']
Availability," bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:450212,mask,mask,450212,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['mask'],['mask']
Availability," bin); const. private . Function for internal use, checking whether the given bin is excluded from the fit or not. ; Definition at line 452 of file TFractionFitter.cxx. ◆ ReleaseRangeX(). void TFractionFitter::ReleaseRangeX ; (; ). Release restrictions on the X range of the histogram to be used in the fit. ; Definition at line 350 of file TFractionFitter.cxx. ◆ ReleaseRangeY(). void TFractionFitter::ReleaseRangeY ; (; ). Release restrictions on the Y range of the histogram to be used in the fit. ; Definition at line 378 of file TFractionFitter.cxx. ◆ ReleaseRangeZ(). void TFractionFitter::ReleaseRangeZ ; (; ). Release restrictions on the Z range of the histogram to be used in the fit. ; Definition at line 408 of file TFractionFitter.cxx. ◆ SetData(). void TFractionFitter::SetData ; (; TH1 * ; data). Change the histogram to be fitted to. ; Notes:; Parameter constraints and settings are retained from a possible previous fit.; Modifying the dimension or number of bins results in an error (in this case rather instantiate a new TFractionFitter object) . Definition at line 271 of file TFractionFitter.cxx. ◆ SetMC(). void TFractionFitter::SetMC ; (; Int_t ; parm, . TH1 * ; MC . ). Change the histogram for template number <parm>. ; Notes:; Parameter constraints and settings are retained from a possible previous fit.; Modifying the dimension or number of bins results in an error (in this case rather instantiate a new TFractionFitter object) . Definition at line 283 of file TFractionFitter.cxx. ◆ SetRangeX(). void TFractionFitter::SetRangeX ; (; Int_t ; low, . Int_t ; high . ). Set the X range of the histogram to be used in the fit. ; Use ReleaseRangeX() to go back to fitting the full histogram. The consistency check ensures that no empty fit range occurs (and also recomputes the bin content integrals). Parameters. [in]lowlower X bin number ; [in]highupper X bin number . Definition at line 341 of file TFractionFitter.cxx. ◆ SetRangeY(). void TFractionFitter::SetRangeY ; (; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:30690,error,error,30690,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['error'],['error']
Availability," bin, Double_t content); virtual voidTH3D::SetBinContent(Int_t bin, Int_t, Double_t content); virtual voidTH3D::SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); virtual voidSetBinEntries(Int_t bin, Double_t w); virtual voidTH1::SetBinError(Int_t bin, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidSetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidSetBins(Int_t nbinsx, Double_t xmin, Double_t xmax, Int_t nbinsy, Double_t ymin, Double_t ymax, Int_t nbinsz, Double_t zmin, Double_t zmax); virtual voidTH3D::SetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuffer(Int_t buffersize, Option_t* opt = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidSetErrorOption(Option_t* option = """")MENU ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile3D.html:19667,error,error,19667,root/html532/TProfile3D.html,https://root.cern,https://root.cern/root/html532/TProfile3D.html,2,['error'],['error']
Availability," bin.; Statistics will be recomputed from the new bin contents. TProfile * DoProfile(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const. TProfile * ProfileX(const char* name = ""_pfx"", Int_t firstybin = 1, Int_t lastybin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along X*-*-*-*-*-*; *-* ========================================================. The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, bins 1 to ny are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:43494,error,error,43494,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['error'],['error']
Availability," bin.Definition TEfficiency.cxx:3368; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::GetWeightDouble_t GetWeight() constDefinition TEfficiency.h:128; TEfficiency::Addvoid Add(const TEfficiency &rEff)Definition TEfficiency.h:97; TEfficiency::GetCopyTotalHistoTH1 * GetCopyTotalHisto() constReturns a cloned version of fTotalHistogram.Definition TEfficiency.cxx:2647; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TEfficiency::SetConfidenceLevelvoid SetConfidenceLevel(Double_t level)Sets the confidence level (0 < level < 1) The default value is 1-sigma :~ 0.683.Definition TEfficiency.cxx:3511; TEfficiency::GetEfficiencyErrorLowDouble_t GetEfficiencyErrorLow(Int_t bin) constReturns the lower error on the efficiency in the given global bin.Definition TEfficiency.cxx:2732; TEfficiency::UsesShortestIntervalBool_t UsesShortestInterval() constDefinition TEfficiency.h:163; TEfficiency::EStatOptionEStatOptionEnumeration type for different statistic options for calculating confidence intervals kF* ....Definition TEfficiency.h:33; TEfficiency::kBJeffrey@ kBJeffreyJeffrey interval (Prior ~ Beta(0.5,0.5)Definition TEfficiency.h:39; TEfficiency::kFWilson@ kFWilsonWilson interval.Definition TEfficiency.h:36; TEfficiency::kFAC@ kFACAgresti-Coull interval.Definition TEfficiency.h:37; TEfficiency::kMidP@ kMidPMid-P Lancaster interval.Definition TEfficiency.h:42; TEfficiency::kBUniform@ kBUniformPrior ~ Uniform = Beta(1,1)Definition TEfficiency.h:40; TEfficiency::kFFC@ kFFCFeldman-Cousins interval.Definition TEfficiency.h:38; TEfficiency::kBBayesian@ kBBayesianUser specified Prior ~ Beta(fBeta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8h_source.html:27134,error,error,27134,doc/master/TEfficiency_8h_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html,1,['error'],['error']
Availability," bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); Redefine x, y and z axis parameters. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); Redefine x, y and z axis parameters with variable bin sizes. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. Note that the directory is not a real property of the histogram and; it will not be copied when the histogram is copied or cloned.; If the user wants to have the copied (cloned) histogram in the same; directory, he needs to set again the directory using SetDirectory to the; copied histograms. void SetError(const Double_t* error); Replace bin errors by values in array error. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:126218,error,errors,126218,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,4,['error'],['errors']
Availability," bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); Redefine x, y and z axis parameters. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); Redefine x, y and z axis parameters with variable bin sizes. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. void SetError(const Double_t* error); Replace bin errors by values in array error. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Styl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:126090,error,errors,126090,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability," bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x. ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 330 of file TH1.cxx. ◆ Integral() [5/5]. Double_t TH2::Integral ; (; Option_t * ; option = """"); const. overridevirtual . Return integral of bin contents. ; Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x and in y. ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 1317 of file TH2.cxx. ◆ IntegralAndError() [1/2]. Double_t TH1::IntegralAndError ; (; Int_t ; binx1, . Int_t ; binx2, . Double_t & ; error, . Option_t * ; option = """" . ); const. privatevirtual . Return integral of bin contents in range [binx1,binx2] and its error. ; By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x. the error is computed using error propagation from the bin errors assuming that all the bins are uncorrelated ; Reimplemented from TH1.; Definition at line 332 of file TH1.cxx. ◆ IntegralAndError() [2/2]. Double_t TH2::IntegralAndError ; (; Int_t ; firstxbin, . Int_t ; lastxbin, . Int_t ; firstybin, . Int_t ; lastybin, . Double_t & ; error, . Option_t * ; option = """" . ); const. virtual . Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram. ; Calculates also the integral error using error propagation from the bin errors assuming that all the bins are uncorrelated. By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:89182,error,error,89182,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['error'],['error']
Availability," bins with identical labels; will be merged, no matter what their order is.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width.; Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:92636,error,errors,92636,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['error'],['errors']
Availability," binz = hzfirst; binz <= hzlast; ++binz) {; 212 if (useBinEdges) {; 213 x[2] = zaxis->GetBinLowEdge(binz);; 214 s[2] = zaxis->GetBinUpEdge(binz);; 215 }; 216 else; 217 x[2] = zaxis->GetBinCenter(binz);; 218 ; 219 // need to evaluate function to know about rejected points; 220 // hugly but no other solutions; 221 if (func != nullptr) {; 222 TF1::RejectPoint(false);; 223 (*func)( &x[0] ); // evaluate using stored function parameters; 224 if (TF1::RejectedPoint() ) continue;; 225 }; 226 ; 227 ; 228 double value = hfit->GetBinContent(binx, biny, binz);; 229 double error = hfit->GetBinError(binx, biny, binz);; 230 if (!HFitInterface::AdjustError(fitOpt,error,value) ) continue;; 231 ; 232 if (ndim == hdim -1) {; 233 // case of fitting a function with dimension -1; 234 // point error is bin width y / sqrt(N) where N is the number of entries in the bin; 235 // normalization of error will be wrong - but they will be rescaled in the fit; 236 if (hdim == 2) dv.Add( x, x[1], yaxis->GetBinWidth(biny) / error );; 237 if (hdim == 3) dv.Add( x, x[2], zaxis->GetBinWidth(binz) / error );; 238 } else {; 239 if (fitOpt.fErrors1); 240 dv.Add( x, value );; 241 else; 242 dv.Add( x, value, error );; 243 if (useBinEdges) {; 244 dv.AddBinUpEdge( s );; 245 }; 246 }; 247 ; 248 ; 249#ifdef DEBUG; 250 std::cout << ""bin "" << binx << "" add point "" << x[0] << "" "" << hfit->GetBinContent(binx) << std::endl;; 251#endif; 252 ; 253 } // end loop on z bins; 254 } // end loop on y bins; 255 } // end loop on x axis; 256 ; 257 ; 258#ifdef DEBUG; 259 std::cout << ""THFitInterface::FillData: Hist FitData size is "" << dv.Size() << std::endl;; 260#endif; 261 ; 262}; 263 ; 264////////////////////////////////////////////////////////////////////////////////; 265/// Compute rough values of parameters for an exponential; 266 ; 267void InitExpo(const ROOT::Fit::BinData & data, TF1 * f1); 268{; 269 unsigned int n = data.Size();; 270 if (n == 0) return;; 271 ; 272 // find xmin and xmax of the data; 273 double valxmin;; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:8228,error,error,8228,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['error'],['error']
Availability," bl1, Float_t tl1, Float_t alpha1, Float_t h2, Float_t bl2, Float_t tl2, Float_t alpha2); virtual~TGTRA(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAlpha1() const; Float_tGetAlpha2() const; Float_tGetBl1() const; Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Float_tGetH1() const; Float_tGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTRA.html:3353,Error,Error,3353,root/html532/TGTRA.html,https://root.cern,https://root.cern/root/html532/TGTRA.html,2,['Error'],['Error']
Availability," bl1, Float_t tl1, Float_t alpha1, Float_t h2, Float_t bl2, Float_t tl2, Float_t alpha2); virtual~TTRAP(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha1() const; virtual Float_tGetAlpha2() const; virtual Float_tGetBl1() const; virtual Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTRAP.html:2650,Error,Error,2650,root/html532/TTRAP.html,https://root.cern,https://root.cern/root/html532/TTRAP.html,2,['Error'],['Error']
Availability," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:12054,error,error,12054,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,12,['error'],['error']
Availability," boolQWidget::isLeftToRight() const; boolQWidget::isMaximized() const; boolQWidget::isMinimized() const; boolQWidget::isModal() const; boolQWidget::isRightToLeft() const; boolQWidget::isTopLevel() const; boolQWidget::isVisible() const; boolQWidget::isVisibleTo(QWidget*) const; boolQObject::isWidgetType() const; boolQWidget::isWindow() const; boolQWidget::isWindowModified() const; static QWidget*QWidget::keyboardGrabber(); voidQObject::killTimer(int id); QLayout*QWidget::layout() const; Qt::LayoutDirectionQWidget::layoutDirection() const; QLocaleQWidget::locale() const; intQPaintDevice::logicalDpiX() const; intQPaintDevice::logicalDpiY() const; voidQWidget::lower(); QPointQWidget::mapFrom(QWidget*, const QPoint&) const; QPointQWidget::mapFromGlobal(const QPoint&) const; QPointQWidget::mapFromParent(const QPoint&) const; QPointQWidget::mapTo(QWidget*, const QPoint&) const; QPointQWidget::mapToGlobal(const QPoint&) const; QPointQWidget::mapToParent(const QPoint&) const; QRegionQWidget::mask() const; intQWidget::maximumHeight() const; QSizeQWidget::maximumSize() const; intQWidget::maximumWidth() const; virtual const QMetaObject*QWidget::metaObject() const; intQWidget::minimumHeight() const; QSizeQWidget::minimumSize() const; virtual QSizeQWidget::minimumSizeHint() const; intQWidget::minimumWidth() const; static QWidget*QWidget::mouseGrabber(); voidQWidget::move(const QPoint&); voidQWidget::move(int x, int y); voidQObject::moveToThread(QThread* thread); QWidget*QWidget::nativeParentWidget() const; QWidget*QWidget::nextInFocusChain() const; QRectQWidget::normalGeometry() const; intQPaintDevice::numColors() const; QStringQObject::objectName() const; voidQWidget::overrideWindowFlags(Qt::WindowFlags type); voidQWidget::overrideWindowState(Qt::WindowStates state); virtual QPaintEngine*QWidget::paintEngine() const; boolQPaintDevice::paintingActive() const; const QPalette&QWidget::palette() const; QObject*QObject::parent() const; QWidget*QWidget::parentWidget() const; intQPaintD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQRootCanvas.html:5434,mask,mask,5434,root/html602/TQRootCanvas.html,https://root.cern,https://root.cern/root/html602/TQRootCanvas.html,4,['mask'],['mask']
Availability," boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8620,recover,recover,8620,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,1,['recover'],['recover']
Availability," bounds - return false if parameter is not bound; 323 bool ParameterBounds(unsigned int ipar, double &lower, double &upper) const;; 324 ; 325 ; 326 /// get name of parameter (deprecated); 327 std::string GetParameterName(unsigned int ipar) const {; 328 return ParName(ipar);; 329 }; 330 ; 331 ; 332protected:; 333 ; 334 ; 335 /// Return pointer non const pointer to model (fit) function with fitted parameter values.; 336 /// used by Fitter class; 337 std::shared_ptr<IModelFunction> ModelFunction() { return fFitFunc; }; 338 void SetModelFunction(const std::shared_ptr<IModelFunction> & func) { fFitFunc = func; }; 339 ; 340 friend class Fitter;; 341 ; 342 ; 343 bool fValid; ///< flag for indicating valid fit; 344 bool fNormalized; ///< flag for indicating is errors are normalized; 345 unsigned int fNFree; ///< number of fit free parameters (total parameters are in size of parameter vector); 346 unsigned int fNdf; ///< number of degree of freedom; 347 unsigned int fNCalls; ///< number of function calls; 348 int fStatus; ///< minimizer status code; 349 int fCovStatus; ///< covariance matrix status code; 350 double fVal; ///< minimum function value; 351 double fEdm; ///< expected distance from minimum; 352 double fChi2; ///< fit chi2 value (different than fval in case of chi2 fits); 353 std::shared_ptr<ROOT::Math::Minimizer> fMinimizer; ///<! minimizer object used for fitting; 354 std::shared_ptr<ROOT::Math::IMultiGenFunction> fObjFunc; ///<! objective function used for fitting; 355 std::shared_ptr<IModelFunction> fFitFunc; ///<! model function resulting from the fit.; 356 std::shared_ptr<FitData> fFitData; ///<! data set used in the fit; 357 std::map<unsigned int, bool> fFixedParams; ///< list of fixed parameters; 358 std::map<unsigned int, unsigned int> fBoundParams; ///< list of limited parameters; 359 std::vector<std::pair<double,double> > fParamBounds; ///< parameter bounds; 360 std::vector<double> fParams; ///< parameter values. Size is total number of parameters; 361 s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8h_source.html:13676,error,errors,13676,doc/master/FitResult_8h_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html,1,['error'],['errors']
Availability," bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be error free, however, instantiating a subTree object from the Cling command line will cause a fatal error. In general, it is recommended to let rootcling see as many header files as possible.; 7.5 Classes Defined By Scripts; Lets create a small class TMyClass and a derived class TChild. The virtual method TMyClass::Print()is overridden in TChild. Save this in file called script4.C.; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:278598,error,error,278598,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability," branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:38734,error,error,38734,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['error'],['error']
Availability," break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24823,error,error,24823,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['error'],['error']
Availability," browsers firefox/chrome/edge for interactive web display; ""qt5"": uses QWebEngine from Qt5, no real http server started (requires qt5web component build for ROOT); ""qt6"": uses QWebEngine from Qt6, no real http server started (requires qt6web component build for ROOT); ""cef"": uses Chromium Embeded Framework, no real http server started (requires cefweb component build for ROOT); ""local"": select on of available local (without http server) engines like qt5/qt6/cef; ""default"": system default web browser, invoked with xdg-open on Linux, start on Mac or open on Windows; ""on"": try ""local"", then ""native"", then ""default"" option; ""off"": turns off the web display and comes back to normal graphics in interactive mode.; ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output . Definition at line 2831 of file TROOT.cxx. ◆ ShutDown(). void TROOT::ShutDown ; (; ). static . Shut down ROOT. ; Definition at line 3136 of file TROOT.cxx. ◆ Streamer(). void TROOT::Streamer ; (; TBuffer & ; R__b). overridevirtual . TDirectory Streamer. ; Reimplemented from TDirectory. ◆ StreamerNVirtual(). void TROOT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 372 of file TROOT.h. ◆ Time(). void TROOT::Time ; (; Int_t ; casetime = 1). inline . Definition at line 335 of file TROOT.h. ◆ Timer(). Int_t TROOT::Timer ; (; ); const. inline . Definition at line 336 of file TROOT.h. Friends And Related Symbol Documentation. ◆ ::ROOT::Internal::TROOTAllocator. friend class ::ROOT::Internal::TROOTAllocator. friend . Definition at line 181 of file TROOT.h. ◆ ROOT::Internal::GetROOT2. TROOT * ROOT::Internal::GetROOT2 ; (; ). friend . ◆ TCling. friend class TCling. friend . Definition at line 96 of file TROOT.h. Member Data Documentation. ◆ fApplication. std::atomic<TApplication*> TROOT::fApplication. protected . Pointer to current application. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:79285,down,down,79285,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['down'],['down']
Availability," browsers firefox/chrome/edge for interactive web display; ""qt5"": uses QWebEngine from Qt5, no real http server started (requires qt5web component build for ROOT); ""qt6"": uses QWebEngine from Qt6, no real http server started (requires qt6web component build for ROOT); ""cef"": uses Chromium Embeded Framework, no real http server started (requires cefweb component build for ROOT); ""local"": select on of available local (without http server) engines like qt5/qt6/cef; ""default"": system default web browser, invoked with xdg-open on Linux, start on Mac or open on Windows; ""on"": try ""local"", then ""native"", then ""default"" option; ""off"": turns off the web display and comes back to normal graphics in interactive mode.; ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output . Definition at line 2831 of file TROOT.cxx. ◆ ShutDown(). void TROOT::ShutDown ; (; ). static . Shut down ROOT. ; Definition at line 3140 of file TROOT.cxx. ◆ Streamer(). void TROOT::Streamer ; (; TBuffer & ; R__b). overridevirtual . TDirectory Streamer. ; Reimplemented from TDirectory. ◆ StreamerNVirtual(). void TROOT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 372 of file TROOT.h. ◆ Time(). void TROOT::Time ; (; Int_t ; casetime = 1). inline . Definition at line 335 of file TROOT.h. ◆ Timer(). Int_t TROOT::Timer ; (; ); const. inline . Definition at line 336 of file TROOT.h. Friends And Related Symbol Documentation. ◆ ::ROOT::Internal::TROOTAllocator. friend class ::ROOT::Internal::TROOTAllocator. friend . Definition at line 181 of file TROOT.h. ◆ ROOT::Internal::GetROOT2. TROOT * ROOT::Internal::GetROOT2 ; (; ). friend . ◆ TCling. friend class TCling. friend . Definition at line 96 of file TROOT.h. Member Data Documentation. ◆ fApplication. std::atomic<TApplication*> TROOT::fApplication. protected . Pointer to current application. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:79254,down,down,79254,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['down'],['down']
Availability," bufSize=32000) override;  Overload RooAbsReal::attachToTree to also attach branches for errors and/or asymmetric errors attribute StoreError and/or StoreAsymError are set. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Overload RooAbsReal::attachToTree to also attach branches for errors and/or asymmetric errors attribute StoreError and/or StoreAsymError are set. ;  ; double chopAt (double what, Int_t where) const;  Utility to calculate number of decimals to show based on magnitude of error. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Overload RooAbsReal::fillTreeBranch to also fill tree branches with (asymmetric) errors if requested. ;  ; void installSharedProp (std::shared_ptr< RooRealVarSharedProperties > &&prop);  Install the shared property into the member _sharedProp. ;  ; void setExpensiveObjectCache (RooExpensiveObjectCache &) override;  variables don't need caches ;  ; void setValFast (double value) override;  ; std::shared_ptr< RooRealVarSharedProperties > sharedProp () const;  Hand out our shared property, create on the fly and register in shared map if necessary. ;  ;  Protected Member Functions inherited from RooAbsRealLValue; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ;  Protected Member Functions inherited from RooAbsReal; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void findInnerMostI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:60247,error,errors,60247,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['error'],['errors']
Availability," buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53361,recover,recovered,53361,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Availability," buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:22305,error,error,22305,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['error'],['error']
Availability," but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:3688,error,error,3688,doc/master/rf606__nllerrorhandling_8py.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html,2,['error'],['error']
Availability," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10458,error,errors,10458,doc/master/rf606__nllerrorhandling_8py.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html,5,['error'],"['error', 'errors']"
Availability," but referring to states by index is more efficient. Conversion between index and name can be done using lookupName() or lookupIndex(). It is possible to iterate through all defined states using begin() and end().; For category classes deriving from RooAbsCategory, states can only be evaluated, i.e., queried. Refer to RooAbsCategoryLValue and its derived classes for categories where states can also be set. The simplest category class whose states can be set, queried and saved in a dataset, refer to RooCategory. Interface change in ROOT-6.22; Category data were based in the class RooCatType, holding an index state and a category name truncated to 256 characters. This wastes 64 bytes of storage space per entry, and prevents fast retrieval of category data. Since ROOT-6.22, categories are only represented by an integer. RooAbsCategory::lookupName() can be used to retrieve the corresponding state name. There is no limit for the length of the state name.; To not break old code, the old RooCatType interfaces are still available. Whenever possible, the following replacements should be used:; lookupType() \( \rightarrow \) lookupName() / lookupIndex(); typeIterator() \( \rightarrow \) range-based for loop / begin() / end(); isValidIndex(Int_t index) \( \rightarrow \) hasIndex(); isValid(const RooCatType&) \( \rightarrow \) hasIndex() / hasLabel() . Definition at line 33 of file RooAbsCategory.h. Public Types; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:1690,avail,available,1690,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['avail'],['available']
Availability," but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ProcessLine takes a parameter, which is a pointer to an int or to a TInterpreter::EErrorCode to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in enum TInterpreter::EErrorCode with TInterpreter::kSuccess being the value for a successful execution.; 7.2.2 Executing a Script From the Invocation; Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:; $ root -l -b 'myCode.C(""some String"", 12)'; The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.; ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; 7.3 C++ Extensions To Ease Scripting; In the next example, we demonstrate three of the most important extensions ROOT and Cling make to C++. Start ROOT in the directory $ROOTSYS/tutorials (make sure to have first run .x hsimple.C):; root [0] f = new TFile(""hsimple.roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:265189,error,error,265189,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability," by CheckBoundaryErrors method. ;  ; void CheckEdit ();  Check if Ged library is loaded and load geometry editor classe. ;  ; void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;  Geometry checking method (see TGeoChecker). ;  ; void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr) override;  Geometry checking method (see: TGeoManager::CheckGeometry()) ;  ; void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const override;  Check overlaps for the top volume of the geometry, within a limit OVLP. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) override;  Check current point in the geometry. ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;  Test for shape navigation methods. ;  ; Int_t CountNodes (TGeoVolume *vol, Int_t level) const;  Count number of visible nodes down to a given level. ;  ; Int_t CountVisibleNodes () override;  Count total number of visible nodes. ;  ; void DefaultAngles () override;  Set default angles for the current view. ;  ; void DefaultColors () override;  Set default volume colors according to tracking media. ;  ; Int_t DistanceToPrimitiveVol (TGeoVolume *vol, Int_t px, Int_t py) override;  Compute the closest distance of approach from point px,py to a volume. ;  ; void Draw (Option_t *option="""") override;  Draw method. ;  ; void DrawBatemanSol (TGeoBatemanSol *sol, Option_t *option="""") override;  Draw the time evolution of a radionuclide. ;  ; void DrawCurrentPoint (Int_t color) override;  Draw current point in the same view. ;  ; void DrawOnly (Option_t *option="""") override;  Draw only one volume. ;  ; void DrawOverlap (void *ovlp, Option_t *option="""") override;  Draw an overlap. ;  ; void DrawPanel () override;  ; void DrawPath (const char *path, Option_t *option="""") override;  Draw ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:2520,down,down,2520,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['down'],['down']
Availability," by default excluded from the projection; (Note that this is a different default behavior compared to the projection to an histogram); To include the underflow and/or overflow use option ""UF"" and/or ""OF"". void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH3 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin3D. TH3 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin3D. TH3 * RebinZ(Int_t ngroup = 2, const char* newname = """"); Rebin only the Z axis; see Rebin3D. TH3 * Rebin3D(Int_t nxgroup = 2, Int_t nygroup = 2, Int_t nzgroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; // Carefull: previous contents of hpxpy are lost; hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ====================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3.html:49946,error,errors,49946,root/html534/TH3.html,https://root.cern,https://root.cern/root/html534/TH3.html,4,['error'],['errors']
Availability," by default; 4221/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4222/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4223/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4224///; 4225/// <tr><th><th> Options to control informational output; 4226/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4227/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4228/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4229/// messages are suppressed as well; 4230/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4231/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4232/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4233/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4234/// </table>; 4235 ; 4236RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4237 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4238 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4239{; 4240 RooLinkedList l ;; 4241 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4242 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4243 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4244 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4245 return chi2FitTo(xydata,l) ;; 4246}; 4247 ; 4248 ; 4249 ; 4250 ; 4251////////////////////////////////////////////////////////////////////////////////; 4252/// \copydoc RooAbsReal::chi2Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:186656,error,errors,186656,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability," by h1. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); Replace contents of this histogram by the division of h1 by h2. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:64909,error,errors,64909,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability," by jitted actions; 3124 auto retTypeName = RDFInternal::TypeID2TypeName(typeid(RetType));; 3125 if (retTypeName.empty()) {; 3126 // The type is not known to the interpreter.; 3127 // We must not error out here, but if/when this column is used in jitted code; 3128 const auto demangledType = RDFInternal::DemangleTypeIdName(typeid(RetType));; 3129 retTypeName = ""CLING_UNKNOWN_TYPE_"" + demangledType;; 3130 }; 3131 ; 3132 using NewCol_t = RDFDetail::RDefine<F, DefineType>;; 3133 auto newColumn = std::make_shared<NewCol_t>(name, retTypeName, std::forward<F>(expression), validColumnNames,; 3134 fColRegister, *fLoopManager);; 3135 ; 3136 RDFInternal::RColumnRegister newCols(fColRegister);; 3137 newCols.AddDefine(std::move(newColumn));; 3138 ; 3139 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 3140 ; 3141 return newInterface;; 3142 }; 3143 ; 3144 // This overload is chosen when the callable passed to Define or DefineSlot returns void.; 3145 // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; 3146 // this way compilation of `Define` has no way to continue after throwing the error.; 3147 template <typename F, typename DefineType, typename RetType = typename TTraits::CallableTraits<F>::ret_type,; 3148 bool IsFStringConv = std::is_convertible<F, std::string>::value,; 3149 bool IsRetTypeDefConstr = std::is_default_constructible<RetType>::value>; 3150 std::enable_if_t<!IsFStringConv && !IsRetTypeDefConstr, RInterface<Proxied, DS_t>>; 3151 DefineImpl(std::string_view, F, const ColumnNames_t &, const std::string &); 3152 {; 3153 static_assert(std::is_default_constructible<typename TTraits::CallableTraits<F>::ret_type>::value,; 3154 ""Error in `Define`: type returned by expression is not default-constructible"");; 3155 return *this; // never reached; 3156 }; 3157 ; 3158 template <typename... ColumnTypes>; 3159 RResultPtr<RInterface<RLoopManager>> SnapshotImpl(std::string_view fullTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:178755,error,error,178755,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['error'],['error']
Availability," by namex,namey by a weight w.Definition TProfile2D.h:112; TProfile2D::GetW2Double_t * GetW2()Definition TProfile2D.h:66; TProfile2D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TProfile2D.h:45; TProfile2D::GetBinErrorDouble_t GetBinError(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:117; TProfile2D::SetBinsvoid SetBins(Int_t, const Double_t *) overrideRedefine x axis parameters with variable bin sizes.Definition TProfile2D.h:69; TProfile2D::FillInt_t Fill(const char *namex, Double_t y, Double_t z) overrideIncrement cell defined by namex,y by a weight w.Definition TProfile2D.h:111; TProfile2D::fScalingBool_t fScaling! True when TProfile2D::Scale is calledDefinition TProfile2D.h:38; TProfile2D::GetBinEffectiveEntriesvirtual Double_t GetBinEffectiveEntries(Int_t bin)Return bin effective entries for a weighted filled Profile histogram.Definition TProfile2D.cxx:858; TProfile2D::GetErrorOptionOption_t * GetErrorOption() constReturn option to compute profile2D errors.Definition TProfile2D.cxx:889; TProfile2D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile2D.cxx:1856; TProfile2D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile2D.h:41; TProfile2D::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny) const overrideDefinition TProfile2D.h:114; TProfile2D::GetB2Double_t * GetB2()Definition TProfile2D.h:64; TProfile2D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile2D.cxx:1514; TProfile2D::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TProfile2D.cxx:1389; TProfile2D::RebinYTProfile2D * RebinY(Int_t ngroup=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8h_source.html:14331,error,errors,14331,doc/master/TProfile2D_8h_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html,1,['error'],['errors']
Availability," byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Double_t_cutOffCutoff parameter for running product; RooArgSet_defNormSetDefault normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Int_t_extendedIndexIndex of extended PDF (if any) ; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAICRegistry_genCode! Registry of composite direct generator codes; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:42017,error,errors,42017,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['error'],['errors']
Availability," bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:53453,recover,recovered,53453,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recovered']
Availability," bytes; 12653 data[data_len] = '\x00';; 12654 data[data_len + 1] = '\x00';; 12655 data[data_len + 2] = '\xff';; 12656 data[data_len + 3] = '\xff';; 12657 do {; 12658 if (inflate_buf_size_old == 0) {; 12659 new_mem =; 12660 (Bytef *)mg_calloc(inflate_buf_size,; 12661 sizeof(Bytef));; 12662 } else {; 12663 inflate_buf_size *= 2;; 12664 new_mem =; 12665 (Bytef *)mg_realloc(inflated,; 12666 inflate_buf_size);; 12667 }; 12668 if (new_mem == NULL) {; 12669 mg_cry_internal(; 12670 conn,; 12671 ""Out of memory: Cannot allocate ""; 12672 ""inflate buffer of %lu bytes"",; 12673 (unsigned long)inflate_buf_size);; 12674 exit_by_callback = 1;; 12675 break;; 12676 }; 12677 inflated = new_mem;; 12678 conn->websocket_inflate_state.avail_out =; 12679 (uInt)(inflate_buf_size; 12680 - inflate_buf_size_old);; 12681 conn->websocket_inflate_state.next_out =; 12682 inflated + inflate_buf_size_old;; 12683 ret = inflate(&conn->websocket_inflate_state,; 12684 Z_SYNC_FLUSH);; 12685 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12686 || ret == Z_MEM_ERROR) {; 12687 mg_cry_internal(; 12688 conn,; 12689 ""ZLIB inflate error: %i %s"",; 12690 ret,; 12691 (conn->websocket_inflate_state.msg; 12692 ? conn->websocket_inflate_state.msg; 12693 : ""<no error message>""));; 12694 exit_by_callback = 1;; 12695 break;; 12696 }; 12697 inflate_buf_size_old = inflate_buf_size;; 12698 ; 12699 } while (conn->websocket_inflate_state.avail_out; 12700 == 0);; 12701 inflate_buf_size -=; 12702 conn->websocket_inflate_state.avail_out;; 12703 if (!ws_data_handler(conn,; 12704 mop,; 12705 (char *)inflated,; 12706 inflate_buf_size,; 12707 callback_data)) {; 12708 exit_by_callback = 1;; 12709 }; 12710 mg_free(inflated);; 12711 }; 12712 } else; 12713#endif; 12714 if (!ws_data_handler(conn,; 12715 mop,; 12716 (char *)data,; 12717 (size_t)data_len,; 12718 callback_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_fre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:368867,error,error,368867,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," bytes; 12654 data[data_len] = '\x00';; 12655 data[data_len + 1] = '\x00';; 12656 data[data_len + 2] = '\xff';; 12657 data[data_len + 3] = '\xff';; 12658 do {; 12659 if (inflate_buf_size_old == 0) {; 12660 new_mem =; 12661 (Bytef *)mg_calloc(inflate_buf_size,; 12662 sizeof(Bytef));; 12663 } else {; 12664 inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes"",; 12674 (unsigned long)inflate_buf_size);; 12675 exit_by_callback = 1;; 12676 break;; 12677 }; 12678 inflated = new_mem;; 12679 conn->websocket_inflate_state.avail_out =; 12680 (uInt)(inflate_buf_size; 12681 - inflate_buf_size_old);; 12682 conn->websocket_inflate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inflate_buf_size;; 12699 ; 12700 } while (conn->websocket_inflate_state.avail_out; 12701 == 0);; 12702 inflate_buf_size -=; 12703 conn->websocket_inflate_state.avail_out;; 12704 if (!ws_data_handler(conn,; 12705 mop,; 12706 (char *)inflated,; 12707 inflate_buf_size,; 12708 callback_data)) {; 12709 exit_by_callback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_fre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:368900,error,error,368900,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59130,Error,Error,59130,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Error'],['Error']
Availability," c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnBase* RebinBase(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. THnBase* RebinBase(const Int_t* gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:15638,error,errors,15638,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,6,['error'],['errors']
Availability," c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtRootGuiFactory.html:2790,error,error,2790,root/html528/TQtRootGuiFactory.html,https://root.cern,https://root.cern/root/html528/TQtRootGuiFactory.html,7,['error'],['error']
Availability," c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGuiFactory.html:2705,error,error,2705,root/html528/TGuiFactory.html,https://root.cern,https://root.cern/root/html528/TGuiFactory.html,10,['error'],['error']
Availability," c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:4966,error,error,4966,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,6,['error'],['error']
Availability," c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:5062,error,error,5062,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,6,['error'],['error']
Availability," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitter.html:16511,error,error,16511,root/html534/TFitter.html,https://root.cern,https://root.cern/root/html534/TFitter.html,2,['error'],['error']
Availability," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 15:48; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitter.html:17084,error,error,17084,root/html604/TFitter.html,https://root.cern,https://root.cern/root/html604/TFitter.html,2,['error'],['error']
Availability," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-30 14:49; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:17084,error,error,17084,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,2,['error'],['error']
Availability," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:16423,error,error,16423,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,4,['error'],['error']
Availability," cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:37608,error,error,37608,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,['error'],['error']
Availability," cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:57527,error,error,57527,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:343613,avail,available,343613,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avail'],['available']
Availability," cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:208689,error,error,208689,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['error'],['error']
Availability," calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least MINUIT believes the errors are accurate, although there is always a small chance that MINUIT has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterised so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning message, may make both the function minimum and parameter errors unreliable. See the discussion above `‘Getting the right parameter errors with limits’'. The best way to be absolutely sure of the errors, is to use independent'' calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for aphysical'' function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; A non-physical region:; On its way to the minimum, MIGRAD may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem:; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well-defined, for example that there are more unknowns than there are data points, or that the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:9420,error,errors,9420,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['errors']
Availability," callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id$ » Last generat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:10910,Error,Error,10910,root/html534/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html,3,['Error'],['Error']
Availability," callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:10910,Error,Error,10910,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,1,['Error'],['Error']
Availability," called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnBase* RebinBase(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:15537,error,errors,15537,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,6,['error'],['errors']
Availability," called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:27884,error,error,27884,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,6,"['Error', 'error']","['ErrorHandler', 'error']"
Availability," caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1,const RooCmdArg& arg2,				 const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:64574,error,error,64574,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['error'],['error']
Availability," calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThread.html:13067,error,error,13067,root/html528/TThread.html,https://root.cern,https://root.cern/root/html528/TThread.html,2,['error'],['error']
Availability," can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effective variance"" method.; In case of a pure TGraph, the denominator is 1.; In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; into account.; By default the range of the graph is used whatever function range.; Use option ""R"" to use the function range. Bool_t CompareArg(const TGraph* gr, Int_t left, Int_t right); Return kTRUE if point number ""left""'s argument (angle with respect to positive; x-axis) is bigger than that of point number ""right"". Can be used by Sort. Bool_t CompareX(const TGraph* gr, Int_t left, Int_t right); Return kTRUE if fX[left] > fX[right]. Can be used by Sort. Bool_t CompareY(const TGraph* gr, Int_t left, Int_t right); Return kTRUE if fY[left] > fY[right]. Can be used by Sort. Bool_t CompareRadius(const TGraph* gr, Int_t left, Int_t right); Return kTRUE if point number ""left""'s distance to origin is bigger than; that of point number ""right"". Can be used by Sort. void ComputeRange(Double_t& xmin, Double_t& ymin, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:17576,error,errors,17576,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,4,['error'],['errors']
Availability," can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4232,recover,recovery,4232,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Availability," can be passed to the Filter() method to create a **named filter**. Named filters; 515work as usual, but also keep track of how many entries they accept and reject.; 516 ; 517Statistics are retrieved through a call to the Report() method:; 518 ; 519- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 520named filters declared up to that point; 521- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 522relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 523 ; 524Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; 525that has been run using the relevant RDataFrame.; 526 ; 527\anchor ranges; 528### Ranges; 529When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; 530Range() transformations are available. These act very much like filters but instead of basing their decision on; 531a filter expression, they rely on `begin`,`end` and `stride` parameters.; 532 ; 533- `begin`: initial entry number considered for this range.; 534- `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 535- `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 536 ; 537The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; 538entries than that are available).; 539 ; 540Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; 541*that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; 542and the range has a `begin` parameter of 10, that means the range will skip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:32388,avail,available,32388,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability," can be passed to the Filter() method to create a **named filter**. Named filters; 555work as usual, but also keep track of how many entries they accept and reject.; 556 ; 557Statistics are retrieved through a call to the Report() method:; 558 ; 559- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 560named filters declared up to that point; 561- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 562relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 563 ; 564Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; 565that has been run using the relevant RDataFrame.; 566 ; 567\anchor ranges; 568### Ranges; 569When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; 570Range() transformations are available. These act very much like filters but instead of basing their decision on; 571a filter expression, they rely on `begin`,`end` and `stride` parameters.; 572 ; 573- `begin`: initial entry number considered for this range.; 574- `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 575- `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 576 ; 577The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; 578entries than that are available).; 579 ; 580Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; 581*that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; 582and the range has a `begin` parameter of 10, that means the range will skip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:34028,avail,available,34028,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability," can be started by hand at any time of the day (see later) and select for what configurations to run.; incremental builds: The jobs are named root-incremental-<version> and they are implemented as multi-configuration project. They are run as soon new commits appear in the ROOT git repository and the builds are incremental by default. A full re-build can be triggered by checking the option EMPTY_BINARY.; documentation generation. The jobs are named root-makedoc-<version>. They are started automatically once a day during the day.; testing installations. The job is named root-install and builds ROOT for a number of platforms, produces the installation tar-file or installation kit, installs it in a different place nd runs the tests against the installation (needed to delete the build and source area).; building releases. The job is named root-release-<version> and is multi-configuration job. It builds ROOT for a given 'tagged' version using the source distribution tar-file and produces binaries for a number of configurations, which are installed automatically in the download ROOT server.; other procedures. cling-periodic; cling-clone-repo; cling-repo-sync; root-test; root-staticAnalysis-master. Basic operations; Understanding information for a single build; The Status shows a summary for the build. In case of multi-configuration jobs it it also show the configuration matrix that can be used to select a contrete configuration. See the following figure: ; For each individual build (select one cell in the matrix) the following information is provided:. Status. Shows a summary of the build (changes, errors, warnings, git revision, test results, etc.); Changes. Shows the details about the changes since the last build.; Console Output/View as plain text. Shows the full log of the build including all the steps (checkout, configuration, build, running tests, etc.); Parsed Console Output. The same as previous but with warnings and errors selected.; Parameters. The parameters use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:3988,down,download,3988,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,1,['down'],['download']
Availability," can still read the StreamerInfo with; myfile.ReadStreamerInfo();. Bool_t GetReadStreamerInfo(); static function to get the value of fgReadInfo.; See TFile::SetReadStreamerInfo for more documentation. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:48715,down,downloaded,48715,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,4,['down'],['downloaded']
Availability," cannot be used for images which were created with the; SetImage() functions, because the original pixel values would be; destroyed. UInt_t GetWidth() const; Return width of original image not of the displayed image.; (Number of image pixels). UInt_t GetHeight() const; Return height of original image not of the displayed image.; (Number of image pixels). UInt_t GetScaledWidth() const; Return width of the displayed image not of the original image.; (Number of screen pixels). UInt_t GetScaledHeight() const; Return height of the displayed image not of the original image.; (Number of screen pixels). void GetZoomPosition(UInt_t& x, UInt_t& y, UInt_t& w, UInt_t& h) const; Return the zoom parameters.; This is useful when the zoom has been done interactively using the mouse. Bool_t InitVisual(); Static function to initialize the ASVisual. void StartPaletteEditor(); Start palette editor. Pixmap_t GetPixmap(); Returns image pixmap.; The pixmap must deleted by user. Pixmap_t GetMask(); Returns image mask pixmap (alpha channel).; The pixmap must deleted by user. void SetImage(Pixmap_t pxm, Pixmap_t mask = 0); Create image from pixmap. TArrayL * GetPixels(Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Return 2D array of machine dependent pixel values. Double_t * GetVecArray(); Return a pointer to internal array[width x height] of double values [0,1].; This array is directly accessible. That allows to manipulate/change the; image. TArrayD * GetArray(UInt_t w = 0, UInt_t h = 0, TImagePalette* pal = gWebImagePalette); In case of vectorized image return an associated array of doubles; otherwise this method creates and returns a 2D array of doubles corresponding to palette.; If palette is ZERO a color converted to double value [0, 1] according to formula; Double_t((r << 16) + (g << 8) + b)/0xFFFFFF; The returned array must be deleted after usage. void DrawText(Int_t x = 0, Int_t y = 0, const char* text = """", Int_t size = 12, const char* color = 0, const char* font = ""fixed"", T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:29748,mask,mask,29748,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,11,['mask'],['mask']
Availability," cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:55225,error,error,55225,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['error'],['error']
Availability," carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far aw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuit.html:8746,Failure,Failure,8746,root/html532/TMinuit.html,https://root.cern,https://root.cern/root/html532/TMinuit.html,4,['Failure'],['Failure']
Availability," case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:52312,error,error,52312,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,2,['error'],['error']
Availability," case of success. Long64_t Process(const char* selector, Long64_t nentries, Option_t* option = """"); Generic (non-data based) selector processing: the Process() method of the; specified selector (.C) is called 'n' times.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t GetQueryReference(Int_t qry, TString& ref); Get reference for the qry-th query in fQueries (as; displayed by ShowQueries). Long64_t Finalize(Int_t query = -1, Bool_t force = kFALSE); Finalize the qry-th query in fQueries.; If force, force retrieval if the query is found in the local list; but has already been finalized (default kFALSE).; If query < 0, finalize current query.; Return 0 on success, -1 on error. Long64_t Finalize(const char* queryref, Bool_t force = kFALSE); Finalize query with reference ref.; If force, force retrieval if the query is found in the local list; but has already been finalized (default kFALSE).; If ref = 0, finalize current query.; Return 0 on success, -1 on error. Int_t Retrieve(Int_t query, const char* path = 0); Send retrieve request for the qry-th query in fQueries.; If path is defined save it to path. Int_t Retrieve(const char* queryref, const char* path = 0); Send retrieve request for the query specified by ref.; If path is defined save it to path.; Generic method working for all queries known by the server. Int_t Remove(Int_t query, Bool_t all = kFALSE); Send remove request for the qry-th query in fQueries. Int_t Remove(const char* queryref, Bool_t all = kFALSE); Send remove request for the query specified by ref.; If all = TRUE remove also local copies of the query, if any.; Generic method working for all queries known by the server.; This method can be also used to reset the list of queries; waiting to be processed: for that purpose use ref == ""cleanupqueue"". Int_t Archive(Int_t query, const char* url); Send archive request for the qry-th query in fQueries. Int_t Archive(const char* queryref, const char* url = 0); Send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:49895,error,error,49895,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34302,error,error,34302,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,4,['error'],['error']
Availability," case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:28898,failure,failure,28898,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['failure'],['failure']
Availability," case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:25928,failure,failure,25928,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['failure'],['failure']
Availability," case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:13230,avail,available,13230,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['avail'],['available']
Availability," cases an elegant replacement of three-dimensional histograms : the inter-relation of three measured quantities X, Y and Z can always be visualized by a three-dimensional histogram or scatter-plot; its representation on the line-printer is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) approximate function of X,Y this function is displayed by a profile2D histogram with much better precision than by a scatter-plot.; The following formulae show the cumulated contents (capital letters) and the values displayed by the printing or plotting routines (small letters) of the elements for cell i, j. ; \[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \]. The bin content is always the mean of the Z values, but errors change depending on options: ; \[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell) the bin error e(I,J) is computed from the average of the s(I,J) for all cells if the static function TProfile2D::Approximate has been called. This simple/crude approximation was suggested in order to keep the cell during a fit operation. But note that this approximation is not the default behaviour. Creating and drawing a 2D profile; {; auto c1 = new TCanvas(""c1"",""Prof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:1485,error,errors,1485,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['error'],['errors']
Availability," char *=""~/"", const char *=0, const char *=0);  ; virtual Bool_t MatchUrl (const char *url);  Checks if 'url' refers to the same user@host:port entity as the URL in memory. ;  ; virtual Int_t Md5sum (const char *, TString &, const char *=0);  ; virtual void More (const char *, const char *=0, const char *=0);  ; virtual Int_t PutFile (const char *, const char *, const char *=0);  ; virtual TList * QuerySessions (Option_t *opt=""S"");  Get list of sessions accessible to this manager. ;  ; virtual Int_t Reset (Bool_t hard=kFALSE, const char *usr=0);  Send a cleanup request for the sessions associated with the current user. ;  ; virtual Int_t Rm (const char *, const char *=0, const char *=0);  Run 'rm' on 'what'. Locally it is just a call to TSystem::Unlink . ;  ; virtual Int_t SendMsgToUsers (const char *, const char *=0);  Send a message to connected users. ;  ; virtual void SetAlias (const char *alias="""");  ; virtual void SetInvalid ();  ; virtual void SetMssUrl (const char *mss);  ; virtual Int_t SetROOTVersion (const char *);  ; virtual void ShowROOTVersions ();  ; virtual void ShowWorkers ();  Show available workers. ;  ; virtual void ShutdownSession (Int_t id);  ; virtual void ShutdownSession (TProof *p);  ; virtual Int_t Stat (const char *, FileStat_t &, const char *=0);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Tail (const char *, const char *=0, const char *=0);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgrLite.html:4016,avail,available,4016,doc/master/classTProofMgrLite.html,https://root.cern,https://root.cern/doc/master/classTProofMgrLite.html,1,['avail'],['available']
Availability," char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void addPoint (Axis_t binCenter, double y, double yscale, double exlow, double exhigh, double eylow, double eyhigh);  . Private Attributes; double _entries = 0.0;  Number of entries in histogram. ;  ; double _nominalBinWidth = 1.0;  Average bin width. ;  ; double _nSigma = 1.0;  Number of 'sigmas' error bars represent. ;  ; std::vector< double > _originalWeights;  The original bin weights that were passed to the RooHist::addBin functions before scaling and bin width correction. ;  ; double _rawEntries = 0.0;  Number of entries in source dataset. ;  . Friends; class RooPlot;  . Additional Inherited Members;  Public Types inherited from TGraph; enum  EStatusBits { ;   kNoStats = (1ULL << ( 9 )); , kClipFrame = (1ULL << ( 10 )); , kResetHisto = (1ULL << ( 17 )); , kNotEditable = (1ULL << ( 18 )); , ;   kIsSortedX = (1ULL << ( 19 )); , kIsHighlight = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:39769,error,error,39769,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['error'],['error']
Availability," char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual Double_t EvalControl (const Int_t *powers) const;  PRIVATE METHOD: Calculate the control parameter from the passed powers. ;  ; virtual Double_t EvalFactor (Int_t p, Double_t x) const;  PRIVATE METHOD: Evaluate function with power p at variable value x. ;  ; virtual void MakeCandidates ();  PRIVATE METHOD: Create list of candidate functions for the parameterisation. ;  ; virtual void MakeCoefficientErrors ();  PRIVATE METHOD: Compute the errors on the coefficients. ;  ; virtual void MakeCoefficients ();  PRIVATE METHOD: Invert the model matrix B, and compute final coefficients. ;  ; virtual void MakeCorrelation ();  PRIVATE METHOD: Compute the correlation matrix. ;  ; virtual Double_t MakeGramSchmidt (Int_t function);  PRIVATE METHOD: Make Gram-Schmidt orthogonalisation. ;  ; virtual void MakeNormalized ();  PRIVATE METHOD: Normalize data to the interval [-1;1]. ;  ; virtual void MakeParameterization ();  PRIVATE METHOD: Find the parameterization over the training sample. ;  ; virtual void MakeRealCode (const char *filename, const char *classname, Option_t *option="""");  PRIVATE METHOD: This is the method that actually generates the code for the evaluation the parameterization on some point. ;  ; virtual Bool_t Select (const Int_t *iv);  Selection method. ;  ; virtual Bool_t TestFunction (Double_t squareResidual, Double_t dResidur);  PRIVATE METHOD: Test whether the currently considered function c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:33508,error,errors,33508,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['error'],['errors']
Availability," char ebuf[100];; 18521 const char *hostend;; 18522 int reqerr, uri_type;; 18523 ; 18524#if defined(USE_SERVER_STATS); 18525 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18526 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18527 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18528#endif; 18529 ; 18530 DEBUG_TRACE(""Start processing connection from %s"",; 18531 conn->request_info.remote_addr);; 18532 ; 18533 /* Loop over multiple requests sent using the same connection; 18534 * (while ""keep alive""). */; 18535 do {; 18536 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18537 conn->handled_requests + 1);; 18538 ; 18539#if defined(USE_SERVER_STATS); 18540 conn->conn_state = 3; /* ready */; 18541#endif; 18542 ; 18543 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18544 /* The request sent by the client could not be understood by; 18545 * the server, or it was incomplete or a timeout. Send an; 18546 * error message and close the connection. */; 18547 if (reqerr > 0) {; 18548 DEBUG_ASSERT(ebuf[0] != '\0');; 18549 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18550 }; 18551 ; 18552 } else if (strcmp(ri->http_version, ""1.0""); 18553 && strcmp(ri->http_version, ""1.1"")) {; 18554 /* HTTP/2 is not allowed here */; 18555 mg_snprintf(conn,; 18556 NULL, /* No truncation check for ebuf */; 18557 ebuf,; 18558 sizeof(ebuf),; 18559 ""Bad HTTP version: [%s]"",; 18560 ri->http_version);; 18561 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18562 }; 18563 ; 18564 if (ebuf[0] == '\0') {; 18565 uri_type = get_uri_type(conn->request_info.request_uri);; 18566 switch (uri_type) {; 18567 case 1:; 18568 /* Asterisk */; 18569 conn->request_info.local_uri_raw = 0;; 18570 /* TODO: Deal with '*'. */; 18571 break;; 18572 case 2:; 18573 /* relative uri */; 18574 conn->request_info.local_uri_raw =; 18575 conn->request_info.request_uri;; 18576 break;; 18577 case 3:; 18578 case 4:; 18579 /* absolute uri (with/without port) */; 185",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:550319,error,error,550319,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," char ebuf[100];; 18522 const char *hostend;; 18523 int reqerr, uri_type;; 18524 ; 18525#if defined(USE_SERVER_STATS); 18526 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18527 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18528 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18529#endif; 18530 ; 18531 DEBUG_TRACE(""Start processing connection from %s"",; 18532 conn->request_info.remote_addr);; 18533 ; 18534 /* Loop over multiple requests sent using the same connection; 18535 * (while ""keep alive""). */; 18536 do {; 18537 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18538 conn->handled_requests + 1);; 18539 ; 18540#if defined(USE_SERVER_STATS); 18541 conn->conn_state = 3; /* ready */; 18542#endif; 18543 ; 18544 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18545 /* The request sent by the client could not be understood by; 18546 * the server, or it was incomplete or a timeout. Send an; 18547 * error message and close the connection. */; 18548 if (reqerr > 0) {; 18549 DEBUG_ASSERT(ebuf[0] != '\0');; 18550 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18551 }; 18552 ; 18553 } else if (strcmp(ri->http_version, ""1.0""); 18554 && strcmp(ri->http_version, ""1.1"")) {; 18555 /* HTTP/2 is not allowed here */; 18556 mg_snprintf(conn,; 18557 NULL, /* No truncation check for ebuf */; 18558 ebuf,; 18559 sizeof(ebuf),; 18560 ""Bad HTTP version: [%s]"",; 18561 ri->http_version);; 18562 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18563 }; 18564 ; 18565 if (ebuf[0] == '\0') {; 18566 uri_type = get_uri_type(conn->request_info.request_uri);; 18567 switch (uri_type) {; 18568 case 1:; 18569 /* Asterisk */; 18570 conn->request_info.local_uri_raw = 0;; 18571 /* TODO: Deal with '*'. */; 18572 break;; 18573 case 2:; 18574 /* relative uri */; 18575 conn->request_info.local_uri_raw =; 18576 conn->request_info.request_uri;; 18577 break;; 18578 case 3:; 18579 case 4:; 18580 /* absolute uri (with/without port) */; 185",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:550352,error,error,550352,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," char* command); Set the command to be executed after the system has been idle for; idleTimeInSec seconds. Normally called via TROOT::Idle(...). void RemoveIdleTimer(); Remove idle timer. Normally called via TROOT::Idle(0). void StartIdleing(); Called when system starts idleing. void StopIdleing(); Called when system stops idleing. Int_t TabCompletionHook(char* buf, int* pLoc, ostream& out); What to do when tab is pressed. Re-implemented by TRint.; See TTabCom::Hook() for meaning of return values. void Terminate(Int_t status = 0); Terminate the application by call TSystem::Exit() unless application has; been told to return from Run(), by a call to SetReturnFromRun(). void LineProcessed(const char* line); Emit signal when a line has been processed. void KeyPressed(Int_t key); Emit signal when console keyboard key was pressed. void ReturnPressed(char* text); Emit signal when return key was pressed. void SetEchoMode(Bool_t mode); Set console echo mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. void CreateApplication(); Static function used to create a default application environment. TApplication * Open(const char* url, Int_t debug, const char* script); Static function used to attach to an existing remote application; or to start one. void Close(TApplication* app); Static function used to close a remote application. void ls(Option_t* option = """") const; Show available sessions. TList * GetApplications(); Static method returning the list of available applications. TApplication(const TApplication& ). TApplication& operator=(const TApplication& ). void SetSignalHandler(TSignalHandler* sh); { fSigHandler = sh; }. TApplication * Open(const char* url, Int_t debug, const char* script). TSignalHandler * GetSignalHandler() const; { return fSigHandler; }. Bool_t HandleTermInput(); { return kFALSE; }. void Init(); { fAppImp->Init(); }. const char * GetIdleCommand() const; { return fIdleCommand; }. const char * ApplicationName() const; { return fAppI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TApplication.html:18977,echo,echo,18977,root/html530/TApplication.html,https://root.cern,https://root.cern/root/html530/TApplication.html,9,['echo'],['echo']
Availability," char* grp, Int_t priority, TList* workers); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. Int_t BroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. void ResetMergePrg(); Reset the merge progress notificator. Int_t Broadcast(const TMessage& mess, TList* slaves); Broadcast a message to all slaves in the specified list. Returns; the number of slaves the message was successfully sent to.; Returns -1 in case of error. Int_t Broadcast(const TMessage& mess, TProof::ESlaves list = kActive); Broadcast a message to all slaves in the specified list (either; all slaves or only the active slaves). Returns the number of slaves; the message was successfully sent to. Returns -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind, TList* slaves); Broadcast a character string buffer to all slaves in the specified; list. Use kind to set the TMessage what field. Returns the number of; slaves the message was sent to. Returns -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, TProof::ESlaves list = kActive); Broadcast a character string buffer to all slaves in the specified; list (either all slaves or only the active slaves). Use kind to; set the TMessage what field. Returns the number of slaves the message; was sent to. Returns -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Broadcast an object to all slaves in the specified list. Use kind to; set the TMEssage what field. Returns the number of slaves the message; was sent to. Returns -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Broadcast an object to all sl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:39370,error,error,39370,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['error'],['error']
Availability," char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). Bool_t GetObjectStat(); Get status of object stat flag. void SetObjectStat(Bool_t stat); Turn on/off tracking of objects in the TObjectTable. Long_t GetDtorOnly(); return destructor only flag. void SetDtorOnly(void* obj); set destructor only flag. void operator delete(void* ptr); operator delete. void operator delete[](void* ptr); operator delete []. void operator delete(void* ptr, void* vp); Only called by placement new when throwing an exception. void operator delete[](void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:17450,error,error,17450,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,1,['error'],['error']
Availability," char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be removed. Bool_t GetObjectStat(); Get status of object stat flag. void SetObjectStat(Bool_t stat); Turn on/off tracking of objects in the TObjectTable. Long_t GetDtorOnly(); return destructor only flag. void SetDtorOnly(void* obj); set destructor only fla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TObject.html:17479,error,error,17479,root/html530/TObject.html,https://root.cern,https://root.cern/root/html530/TObject.html,9,['error'],['error']
Availability," char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); virtual~TCONE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCONE.html:1789,Error,Error,1789,root/html532/TCONE.html,https://root.cern,https://root.cern/root/html532/TCONE.html,2,['Error'],['Error']
Availability," char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t* opt); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPoints3D.html:2572,Error,Error,2572,root/html532/TPoints3D.html,https://root.cern,https://root.cern/root/html532/TPoints3D.html,2,['Error'],['Error']
Availability," char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPointsArray3D.html:2632,Error,Error,2632,root/html532/TPointsArray3D.html,https://root.cern,https://root.cern/root/html532/TPointsArray3D.html,4,['Error'],['Error']
Availability," char* method) const; virtual voidAdd(TObject* arg); virtual voidTObject::AppendPad(Option_t* option = """"); TObject*At(Int_t index) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* o = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* o = 0); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TObject*find(const char* name) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*First() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Int_tIndexOf(const char* name) const; Int_tIndexOf(const TObject* arg) const; virtual voidTObject::Info(const char* method, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:1773,error,error,1773,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,3,['error'],['error']
Availability," char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLimitDataSource.html:1642,error,error,1642,root/html528/TLimitDataSource.html,https://root.cern,https://root.cern/root/html528/TLimitDataSource.html,10,['error'],['error']
Availability," char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchRef.html:2240,Error,Error,2240,root/html532/TBranchRef.html,https://root.cern,https://root.cern/root/html532/TBranchRef.html,4,['Error'],['Error']
Availability," char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Double_tCLb(bool use_sMC = kFALSE) const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCLs(bool use_sMC = kFALSE) const; Double_tCLsb(bool use_sMC = kFALSE) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGet3sProbability() const; Double_tGet5sProbability() const; Double_tGetAverageCLs() const; Double_tGetAverageCLsb() const; Double_tGetBtot() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetDtot() const; Double_tGetExpectedCLb_b(Int_t sigma = 0) const; Double_tGetExpectedCLb_sb(Int_t sigma = 0) const; Double_tGetExpectedCLs_b(Int_t sigma = 0) const; Double_tGetExpectedCLsb_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_sb(Int_t sigma = 0) const; virtual const char*TObject::GetIconName() const; virtual const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TConfidenceLevel.html:1568,error,error,1568,root/html526/TConfidenceLevel.html,https://root.cern,https://root.cern/root/html526/TConfidenceLevel.html,7,['error'],['error']
Availability," char* name = 0); Copy constructor. ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 2 15:27:32 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsString.html:23506,error,error,23506,root/html604/RooAbsString.html,https://root.cern,https://root.cern/root/html604/RooAbsString.html,2,['error'],['error']
Availability," char* name = 0); Copy constructor. ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 30 14:30:34 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:23506,error,error,23506,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['error'],['error']
Availability," char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Refresh the list of shared libraries and return it. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:30434,error,error,30434,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,"['error', 'failure']","['error', 'failures']"
Availability," char* name, const RooRealVar& scannedVariable, double cl); constructor. ~HypoTestInverterResult(); destructor; no need to delete explictly the objects in the TList since the TList owns the objects. bool Add(RooStats::HypoTestInverterResult otherResult); Merge this HypoTestInverterResult with another; HypoTestInverterResult passed as argument. double GetXValue(int index) const. double GetYValue(int index) const. double GetYError(int index) const. HypoTestResult* GetResult(int index) const. double FindInterpolatedLimit(double target). int FindClosestPointIndex(double target); find the object with the smallest error that is < 1 sigma from the target. Double_t LowerLimit(); std::cout << ""finding point with cl = "" << 1-(1-ConfidenceLevel())/2 << endl;. Double_t UpperLimit(); std::cout << ""finding point with cl = "" << (1-ConfidenceLevel())/2 << endl;. Double_t CalculateEstimatedError(double target); Return an error estimate on the upper limit. This is the error on; either CLs or CLsplusb divided by an estimate of the slope at this; point. Double_t LowerLimitEstimatedError(); std::cout << ""The HypoTestInverterResult::LowerLimitEstimatedError() function evaluates only a rought error on the upper limit. Be careful when using this estimation\n"";. Double_t UpperLimitEstimatedError(); std::cout << ""The HypoTestInverterResult::UpperLimitEstimatedError() function evaluates only a rought error on the upper limit. Be careful when using this estimation\n"";. int ArraySize() const; number of entries in the results array. { return fXValues.size(); }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) (eg. 0.05 for a 95% Confidence Interval). { fConfidenceLevel = 1.-size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fConfidenceLevel = cl; }. void UseCLs(bool on = true); flag to switch between using CLsb (default) or CLs as confidence level. { fUseCLs = on; }. » Author: Kyle Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestInverterResult.html:8463,error,error,8463,root/html526/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestInverterResult.html,1,['error'],['error']
Availability," char* name, const char* title, RooAbsPdf& pdf, RooAbsReal& efficiency); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:29132,Error,ErrorLoggingMode,29132,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,2,['Error'],['ErrorLoggingMode']
Availability," char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t x); virtual Int_tFill(Double_t x, Double_t w); virtual Int_tFill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1K.html:3132,Error,Error,3132,root/html532/TH1K.html,https://root.cern,https://root.cern/root/html532/TH1K.html,1,['Error'],['Error']
Availability," char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::FittedFunction() const; voidROOT::Fit::FitResult::GetConfidenceIntervals(const ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFitResult.html:1826,error,error,1826,root/html530/TFitResult.html,https://root.cern,https://root.cern/root/html530/TFitResult.html,3,['error'],['error']
Availability," char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to loa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:73710,error,error,73710,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['error'],['error']
Availability," char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDockableFrame.html:4755,error,error,4755,root/html602/TGDockableFrame.html,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html,4,['error'],['error']
Availability," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLEmbeddedViewer.html:5394,error,error,5394,root/html528/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html,6,['error'],['error']
Availability," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedMarkerSelect.html:4518,error,error,4518,root/html602/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html,8,['error'],['error']
Availability," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeViewer.html:11725,error,error,11725,root/html602/TTreeViewer.html,https://root.cern,https://root.cern/root/html602/TTreeViewer.html,4,['error'],['error']
Availability," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableItem(const char* name, Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGShutter.html:4536,error,error,4536,root/html528/TGShutter.html,https://root.cern,https://root.cern/root/html528/TGShutter.html,6,['error'],['error']
Availability," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedEditor.html:6655,error,error,6655,root/html528/TGedEditor.html,https://root.cern,https://root.cern/root/html528/TGedEditor.html,6,['error'],['error']
Availability," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTProofServ::EnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidTProofServ::FilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*TProofServ::GetCacheLock(); const char*TProofServ::GetConfDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServLite.html:4294,error,error,4294,root/html602/TProofServLite.html,https://root.cern,https://root.cern/root/html602/TProofServLite.html,4,['error'],['error']
Availability," char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGHtml.html:4465,Error,Error,4465,root/html532/TGHtml.html,https://root.cern,https://root.cern/root/html532/TGHtml.html,2,['Error'],['Error']
Availability," char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorSelect.html:4754,Error,Error,4754,root/html602/TGColorSelect.html,https://root.cern,https://root.cern/root/html602/TGColorSelect.html,2,['Error'],['Error']
Availability," char* title, Int_t offset, Int_t dtype, const char* countName, const char* countClass, Int_t version, const char* typeName); virtual~TStreamerBasicPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; const char*GetCountClass() const; const char*GetCountName() const; Int_tGetCountVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerBasicPointer.html:1520,Error,Error,1520,root/html532/TStreamerBasicPointer.html,https://root.cern,https://root.cern/root/html532/TStreamerBasicPointer.html,2,['Error'],['Error']
Availability," char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); virtual~TTUBE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTUBE.html:1625,Error,Error,1625,root/html532/TTUBE.html,https://root.cern,https://root.cern/root/html532/TTUBE.html,2,['Error'],['Error']
Availability," char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi); virtual~THYPE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THYPE.html:1642,Error,Error,1642,root/html532/THYPE.html,https://root.cern,https://root.cern/root/html532/THYPE.html,2,['Error'],['Error']
Availability," char* title, double(*)(double,double,double,int) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html:24902,Error,ErrorLoggingMode,24902,root/html602/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html,2,['Error'],['ErrorLoggingMode']
Availability," char* title, double(*)(int,int) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html:29477,Error,ErrorLoggingMode,29477,root/html602/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_int_.html,2,['Error'],['ErrorLoggingMode']
Availability," char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinimizerOptions(const ROOT::Math::MinimizerOptions& minopt); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing); vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitConfig.html:2173,error,error,2173,root/html602/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitConfig.html,16,['error'],"['error', 'errors']"
Availability," char* user, const char* pass, const char* table); virtual~TSQLMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLMonitoringWriter.html:1458,error,error,1458,root/html528/TSQLMonitoringWriter.html,https://root.cern,https://root.cern/root/html528/TSQLMonitoringWriter.html,6,['error'],['error']
Availability," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual Long64_tGetDrawFlag() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TH1*GetOldHistogram()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorDraw.html:1474,error,error,1474,root/html528/TSelectorDraw.html,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html,4,['error'],['error']
Availability," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual Long64_tGetDrawFlag() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual TList*TSelector::GetInputList() const; Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelectorDraw.html:1474,error,error,1474,root/html534/TSelectorDraw.html,https://root.cern,https://root.cern/root/html534/TSelectorDraw.html,6,['error'],['error']
Availability," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual TList*TSelector::GetInputList() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; virtual Long64_tGetSelectedRows() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelectorEntries.html:1908,error,error,1908,root/html534/TSelectorEntries.html,https://root.cern,https://root.cern/root/html534/TSelectorEntries.html,6,['error'],['error']
Availability," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; virtual Long64_tGetSelectedRows() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorEntries.html:1906,error,error,1906,root/html528/TSelectorEntries.html,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html,4,['error'],['error']
Availability," char*); static uintQObject::registerUserData(); voidQObject::removeEventFilter(QObject*); voidQObject::setObjectName(const QString& name); voidQObject::setParent(QObject*); boolQObject::setProperty(const char* name, const QVariant& value); voidQObject::setUserData(uint id, QObjectUserData* data); boolQObject::signalsBlocked() const; intQObject::startTimer(int interval); voidTerminate() const; voidTerminate(int status) const; voidTerminateAndQuit() const; QThread*QObject::thread() const; static QStringtr(const char* s, const char* c = 0); static QStringtr(const char* s, const char* c, int n); static QStringtrUtf8(const char* s, const char* c = 0); static QStringtrUtf8(const char* s, const char* c, int n); QObjectUserData*QObject::userData(uint id) const. protected:. virtual voidQObject::childEvent(QChildEvent*); virtual voidQObject::connectNotify(const char* signal); virtual voidQObject::customEvent(QEvent*); voidQObject::destroyed(QObject* = 0); virtual voidQObject::disconnectNotify(const char* signal); voidError(int error); intQObject::receivers(const char* signal) const; QObject*QObject::sender() const; intQObject::senderSignalIndex() const; virtual voidQObject::timerEvent(QTimerEvent*); TQtRootSlot(). private:. voidoperator=(const TQtRootSlot&); static voidqt_static_metacall(QObject*, QMetaObject::Call, int, void**); TQtRootSlot(const TQtRootSlot&). Data Members; public:. static const QMetaObjectstaticMetaObject; static const QMetaObjectQObject::staticMetaObject. protected:. QScopedPointer<QObjectData>QObject::d_ptr; static TQtRootSlot*fgTQtRootSlot; static const QMetaObjectQObject::staticQtMetaObject. private:. static const QMetaObjectExtraDatastaticMetaObjectExtraData. Class Charts. Inheritance Chart:. QObject. ←; TQtRootSlot. Function documentation; TQtRootSlot * CintSlot(); create and return the singleton. void EndOfLine(); slot to perform the standard ""EndOfLine"" ROOT action; it used to update the current gPad. void ProcessLine(const QString& ); execute the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtRootSlot.html:3199,error,error,3199,root/html602/TQtRootSlot.html,https://root.cern,https://root.cern/root/html602/TQtRootSlot.html,2,['error'],['error']
Availability," char*); static uintQObject::registerUserData(); voidQObject::removeEventFilter(QObject*); voidQObject::setObjectName(const QString& name); voidQObject::setParent(QObject*); boolQObject::setProperty(const char* name, const QVariant& value); voidQObject::setUserData(uint id, QObjectUserData* data); boolQObject::signalsBlocked() const; intQObject::startTimer(int interval); voidTerminate() const; voidTerminate(int status) const; voidTerminateAndQuit() const; QThread*QObject::thread() const; static QStringtr(const char* s, const char* c = 0); static QStringtr(const char* s, const char* c, int n); static QStringtrUtf8(const char* s, const char* c = 0); static QStringtrUtf8(const char* s, const char* c, int n); QObjectUserData*QObject::userData(uint id) const. protected:. virtual voidQObject::childEvent(QChildEvent*); virtual voidQObject::connectNotify(const char* signal); virtual voidQObject::customEvent(QEvent*); voidQObject::destroyed(QObject* = 0); virtual voidQObject::disconnectNotify(const char* signal); voidError(int error); intQObject::receivers(const char* signal) const; QObject*QObject::sender() const; intQObject::senderSignalIndex() const; virtual voidQObject::timerEvent(QTimerEvent*); TQtRootSlot(). private:. voidoperator=(const TQtRootSlot&); static voidqt_static_metacall(QObject*, QMetaObject::Call, int, void**); TQtRootSlot(const TQtRootSlot&). Data Members; public:. static const QMetaObjectstaticMetaObject; static const QMetaObjectQObject::staticMetaObject. protected:. QScopedPointer<QObjectData>QObject::d_ptr; static TQtRootSlot*fgTQtRootSlot; static const QMetaObjectQObject::staticQtMetaObject. private:. static const QMetaObjectExtraDatastaticMetaObjectExtraData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQtRootSlot * CintSlot(); create and return the singleton. void EndOfLine(); slot to perform the standard ""EndOfLine"" ROOT action; it used to update the current gPad. void ProcessLine(const QString& ); exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQtRootSlot.html:3175,error,error,3175,root/html604/TQtRootSlot.html,https://root.cern,https://root.cern/root/html604/TQtRootSlot.html,2,['error'],['error']
Availability," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*highBoundFunc() const; virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsBinning.html:2144,error,error,2144,root/html526/RooAbsBinning.html,https://root.cern,https://root.cern/root/html526/RooAbsBinning.html,10,['error'],['error']
Availability," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidClose(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*GetListOfManagers(); virtual const char*GetMssUrl(Bool_t = kFALSE); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofMgr.html:1975,Error,Error,1975,root/html534/TProofMgr.html,https://root.cern,https://root.cern/root/html534/TProofMgr.html,3,['Error'],['Error']
Availability," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidClose(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMgr.html:1975,Error,Error,1975,root/html532/TProofMgr.html,https://root.cern,https://root.cern/root/html532/TProofMgr.html,1,['Error'],['Error']
Availability," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionLevel() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMessage.html:2358,error,error,2358,root/html528/TMessage.html,https://root.cern,https://root.cern/root/html528/TMessage.html,1,['error'],['error']
Availability," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:2402,error,error,2402,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,9,['error'],['error']
Availability," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&GetiSlowerBound(); virtual TVectorD&GetiSupperBound(); virtual TVectorD&GetiXlowerBound(); virtual TVectorD&GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVectorD&GetSlowerBound(); virtual TVectorD&GetSupperBound(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpDataBase.html:2326,error,error,2326,root/html528/TQpDataBase.html,https://root.cern,https://root.cern/root/html528/TQpDataBase.html,10,['error'],['error']
Availability," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpDataDens.html:2074,error,error,2074,root/html528/TQpDataDens.html,https://root.cern,https://root.cern/root/html528/TQpDataDens.html,20,['error'],['error']
Availability," character string message of maximum max length. ; The expected message must be of type kMESS_STRING. Returns length of received string (can be 0 if otherside of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Definition at line 694 of file TUDPSocket.cxx. ◆ Recv() [2/4]. Int_t TUDPSocket::Recv ; (; char * ; str, . Int_t ; max, . Int_t & ; kind . ). virtual . Receive a character string message of maximum max length. ; Returns in kind the message type. Returns length of received string+4 (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Definition at line 722 of file TUDPSocket.cxx. ◆ Recv() [3/4]. Int_t TUDPSocket::Recv ; (; Int_t & ; status, . Int_t & ; kind . ). virtual . Receives a status and a message type. ; Returns length of received integers, 2*sizeof(Int_t) (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Definition at line 755 of file TUDPSocket.cxx. ◆ Recv() [4/4]. Int_t TUDPSocket::Recv ; (; TMessage *& ; mess). virtual . Receive a TMessage object. ; The user must delete the TMessage object. Returns length of message in bytes (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read) or -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. ; Definition at line 784 of file TUDPSocket.cxx. ◆ RecvProcessIDs(). Bool_t TUDPSocket::RecvProcessIDs ; (; TMessage * ; mess). protected . Receive a message containing process ids. ; In case the message contains process ids they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 945 of file TUDPSocket.cxx. ◆ RecvRaw(). Int_t TUDPSocket::RecvRaw ; (; void * ; buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:26938,error,error,26938,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['error'],['error']
Availability," characters are the characters outside of tags. ; Definition at line 147 of file TSAXParser.cxx. ◆ OnComment(). void TSAXParser::OnComment ; (; const char * ; text). virtual . Emit a signal for OnComment, where text is the comment. ; Definition at line 155 of file TSAXParser.cxx. ◆ OnEndDocument(). void TSAXParser::OnEndDocument ; (; ). virtual . Emit a signal for OnEndDocument. ; Definition at line 115 of file TSAXParser.cxx. ◆ OnEndElement(). void TSAXParser::OnEndElement ; (; const char * ; name). virtual . Emit a signal for OnEndElement, where name is the Element's name. ; Definition at line 138 of file TSAXParser.cxx. ◆ OnError(). Int_t TSAXParser::OnError ; (; const char * ; text). virtual . Emit a signal for OnError, where text is the error and it returns the Parse Error Code, see TXMLParser. ; Definition at line 172 of file TSAXParser.cxx. ◆ OnFatalError(). Int_t TSAXParser::OnFatalError ; (; const char * ; text). virtual . Emit a signal for OnFactalError, where text is the error and it returns the Parse Error Code, see TXMLParser. ; Definition at line 185 of file TSAXParser.cxx. ◆ OnStartDocument(). void TSAXParser::OnStartDocument ; (; ). virtual . Emit a signal for OnStartDocument. ; Definition at line 107 of file TSAXParser.cxx. ◆ OnStartElement(). void TSAXParser::OnStartElement ; (; const char * ; name, . const TList * ; attributes . ). virtual . Emit a signal for OnStarElement, where name is the Element's name and attribute is a TList of (TObjString*, TObjString *) TPair's. ; The TPair's key is the attribute's name and value is the attribute's value. ; Definition at line 126 of file TSAXParser.cxx. ◆ OnWarning(). void TSAXParser::OnWarning ; (; const char * ; text). virtual . Emit a signal for OnWarning, where text is the warning. ; Definition at line 163 of file TSAXParser.cxx. ◆ operator=(). TSAXParser & TSAXParser::operator= ; (; const TSAXParser & ; ). privatedelete . ◆ Parse(). Int_t TSAXParser::Parse ; (; ). privatevirtual . This function parses",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSAXParser.html:22327,error,error,22327,doc/master/classTSAXParser.html,https://root.cern,https://root.cern/doc/master/classTSAXParser.html,1,['error'],['error']
Availability," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoamSampler.html:1314,error,error,1314,root/html528/TFoamSampler.html,https://root.cern,https://root.cern/root/html528/TFoamSampler.html,12,['error'],"['error', 'errors']"
Availability," check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(void* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TChain.html:44467,error,error,44467,root/html530/TChain.html,https://root.cern,https://root.cern/root/html530/TChain.html,1,['error'],['error']
Availability," check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(void* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made usi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:45732,error,error,45732,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,2,['error'],['error']
Availability," check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:43052,error,error,43052,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,1,['error'],['error']
Availability," check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:42459,error,error,42459,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['error'],['error']
Availability," check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:12765,down,down,12765,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,4,['down'],['down']
Availability," check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13061,down,down,13061,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,6,['down'],['down']
Availability," chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:17661,error,error,17661,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,6,['error'],['error']
Availability," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFile.html:5073,error,error,5073,root/html532/TNetFile.html,https://root.cern,https://root.cern/root/html532/TNetFile.html,2,['error'],['error']
Availability," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; virtual TFile::EAsyncOpenStatusGetAsyncOpenStatus(); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSize() const; virtual Long64_tTFile::GetBytesRead() const; virtual Long64_tTFile::GetBytesReadExtra() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetFile.html:4291,error,error,4291,root/html532/TXNetFile.html,https://root.cern,https://root.cern/root/html532/TXNetFile.html,2,['error'],['error']
Availability," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:3430,error,error,3430,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,10,['error'],['error']
Availability," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TStringGetAccessId() const; TStringGetAccessKey() const; TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); TStringGetA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:3506,error,error,3506,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,4,['error'],['error']
Availability," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTNetFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCastorFile.html:4356,error,error,4356,root/html532/TCastorFile.html,https://root.cern,https://root.cern/root/html532/TCastorFile.html,2,['error'],['error']
Availability," cl->fState = TClass::kEmulated;; 4147 } else {; 4148 cl->fState = TClass::kForwardDeclared;; 4149 }; 4150// }; 4151 }; 4152 }; 4153 if (cl->fClassInfo) {; 4154 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:161518,error,error,161518,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability," class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DistSampler.html:1261,error,error,1261,root/html528/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DistSampler.html,12,['error'],"['error', 'errors']"
Availability," class charts. ROOT; » ROOFIT; » ROOFITCORE; » Roo1DTable. class Roo1DTable: public RooTable. Roo1DTable implements a one-dimensional table. A table is the category; equivalent of a plot. To create a table use the RooDataSet::table method.; . Function Members (Methods); public:. virtual~Roo1DTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(RooAbsCategory& cat, Double_t weight = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tget(const char* label, Bool_t silent = kFALSE) const; Double_tget(const int index, Bool_t silent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DTable.html:1631,error,error,1631,root/html602/Roo1DTable.html,https://root.cern,https://root.cern/root/html602/Roo1DTable.html,10,"['Error', 'error']","['Error', 'error']"
Availability," class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-likelihood function implemented using the; 464 sum of weight squared; 465 When using FitConfig.SetWeightCorrection() this correction is applied; 466 automatically when doing a likelihood fit (binned or unbinned); 467 */; 468 bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L=false);; 469 ; 470 /// Set number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int npoints) {; 473 if (fExtObjFunction) fDataSize = npoints;; 474 if (!fResult->IsEmpty()) fResult->SetChi2AndNdf(-1,npoints);; 475 }; 476 ; 477 /// Set the type of fit when using an external FCN; 478 /// possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood); 479 /// Note that in case of binned likelihood fit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:18572,error,error,18572,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['error'],['error']
Availability," class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:191715,robust,robust,191715,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['robust'],['robust']
Availability," class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:210009,robust,robust,210009,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['robust'],['robust']
Availability," class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  ►CTTreeCache;  CIOPos;  ►CMissCache;  CEntry;  ►CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderA simple, robust and fast interface to read values from ROOT colmnar datasets such as TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list vie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:217421,robust,robust,217421,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['robust'],['robust']
Availability," class to prevent infinite recursion in the usage of TTree Friends ;  ►CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CIOPos;  ►CMissCache;  CEntry;  ►CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:213823,robust,robust,213823,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['robust'],['robust']
Availability," class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; THStack::THStackTHStack()Definition THStack.h:57; TTextBase class for several text objects.Definition TText.h:22; h1TH1F * h1Definition legend1.C:5. A more complex example:; ; void hstack(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; auto cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");; ; cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; auto a = new THStack(""a"",""Stacked 2D histograms"");; auto f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params1[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5,; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params1);; auto h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHStack.html:4364,error,errors,4364,doc/master/classTHStack.html,https://root.cern,https://root.cern/doc/master/classTHStack.html,1,['error'],['errors']
Availability," classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15937,error,error,15937,doc/master/TGraphMultiErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html,1,['error'],['error']
Availability," classes ; Implemented in TFoamSampler, and TUnuranSampler. ◆ Sample1D(). virtual double ROOT::Math::DistSampler::Sample1D ; (; ). inlinevirtual . Sample one event in one dimension. ; Specialized implementation could be provided by the derived classes ; Reimplemented in TUnuranSampler.; Definition at line 184 of file DistSampler.h. ◆ SampleBin(). virtual bool ROOT::Math::DistSampler::SampleBin ; (; double ; prob, . double & ; value, . double * ; error = nullptr . ). inlinevirtual . Sample one bin given an estimate of the pdf in the bin. ; (this can be function value at the center or its integral in the bin divided by the bin width) By default do not do random sample, just return the function values Typically Poisson statistics will be used ; Reimplemented in TFoamSampler, and TUnuranSampler.; Definition at line 212 of file DistSampler.h. ◆ SampleBins(). virtual bool ROOT::Math::DistSampler::SampleBins ; (; unsigned int ; n, . const double * ; prob, . double * ; values, . double * ; errors = nullptr . ). inlinevirtual . Sample a set of bins given a vector of probabilities Typically multinomial statistics will be used and the sum of the probabilities will be equal to the total number of events to be generated For sampling the bins independently, SampleBin should be used. ; Definition at line 223 of file DistSampler.h. ◆ SetArea(). virtual void ROOT::Math::DistSampler::SetArea ; (; double ; ). inlinevirtual . Set the normalization area of distribution. ; Implemented by derived classes if needed ; Reimplemented in TUnuranSampler.; Definition at line 158 of file DistSampler.h. ◆ SetCdf(). virtual void ROOT::Math::DistSampler::SetCdf ; (; const ROOT::Math::IGenFunction & ; ). inlinevirtual . Set usage of Cumulative of PDF. ; Can be implemented by derived class ; Reimplemented in TUnuranSampler.; Definition at line 170 of file DistSampler.h. ◆ SetDPdf(). virtual void ROOT::Math::DistSampler::SetDPdf ; (; const ROOT::Math::IGenFunction & ; ). inlinevirtual . Set usage of De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DistSampler.html:11558,error,errors,11558,doc/master/classROOT_1_1Math_1_1DistSampler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DistSampler.html,1,['error'],['errors']
Availability," clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:45181,error,error,45181,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,8,['error'],['error']
Availability," client area. With Zoom mode on the user can access; TAxis3D context menu and set /change the attributes of axice all together; or separately. To add the 3D rulers to any 3D view one has to create; an instance of this class and Draw it. TAxis3D rulers;; rulers.Draw();. One can use a static method to create ruler and attach it to the current gPad. TAxis3D::ToggleRulers(); // Brings the 3D axice up; TAxis3D::ToggleRulers(); // next calls remove the rulers from the TPad etc. To activate Zoomer one may call. TAxis3D::ToggleZoom();. each time one needs move or zoom the image. Then the user can:; - move:; . - zoom:; . its 3D view with <left-mouse button> press / move.; The ""Zoom"" deactivates itself just the user release the <left-mouse button>. To change attributes of the rulers attached to the current Pad, one may; query its pointer first:. TAxis3D *axis = TAxis3D::GetPadAxis(); // Ask axis pointer; if (axis) {; TAxis3D::ToggleRulers() // To pop axice down; axis->SetLabelColor(kBlue); // Paint the axice labels with blue color; axis->SetAxisColor(kRed); // Paint the axice itself with blue color; TAxis3D::ToggleRulers() // To pop axice up; }. The attributes of the created axice are affected by the current style; (see TStyle class ) and Set... methods of this class. For example:. gStyle->SetAxisColor(kYellow,""X"");; gStyle->SetAxisColor(kYellow,""Y"");; gStyle->SetAxisColor(kYellow,""Z"");. gStyle->SetLabelColor(kYellow,""X"");; gStyle->SetLabelColor(kYellow,""Y"");; gStyle->SetLabelColor(kYellow,""Z"");. TAxis3D::ToggleRulers();; TAxis3D::ToggleRulers();. will draw all axice and labels with yellow color. Function Members (Methods); public:. TAxis3D(); TAxis3D(Option_t* option); TAxis3D(const TAxis3D& axis); virtual~TAxis3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAxis3D.html:1434,down,down,1434,root/html526/TAxis3D.html,https://root.cern,https://root.cern/root/html526/TAxis3D.html,7,['down'],['down']
Availability," client area. With Zoom mode on the user can access; TAxis3D context menu and set /change the attributes of axice all together; or separately. To add the 3D rulers to any 3D view one has to create; an instance of this class and Draw it. TAxis3D rulers;; rulers.Draw();. One can use a static method to create ruler and attach it to the current gPad. TAxis3D::ToggleRulers(); // Brings the 3D axice up; TAxis3D::ToggleRulers(); // next calls remove the rulers from the TPad etc. To activate Zoomer one may call. TAxis3D::ToggleZoom();. each time one needs move or zoom the image. Then the user can:; - move:; . - zoom:; . its 3D view with <left-mouse button> press / move.; The ""Zoom"" deactivates itself just the user release the <left-mouse button>. To change attributes of the rulers attached to the current Pad, one may; query its pointer first:. TAxis3D *axis = TAxis3D::GetPadAxis(); // Ask axis pointer; if (axis) {; TAxis3D::ToggleRulers() // To pop axice down; axis->SetLabelColor(kBlue); // Paint the axice labels with blue color; axis->SetAxisColor(kRed); // Paint the axice itself with blue color; TAxis3D::ToggleRulers() // To pop axice up; }. The attributes of the created axice are affected by the current style; (see TStyle class ) and Set... methods of this class. For example:. gStyle->SetAxisColor(kYellow,""X"");; gStyle->SetAxisColor(kYellow,""Y"");; gStyle->SetAxisColor(kYellow,""Z"");. gStyle->SetLabelColor(kYellow,""X"");; gStyle->SetLabelColor(kYellow,""Y"");; gStyle->SetLabelColor(kYellow,""Z"");. TAxis3D::ToggleRulers();; TAxis3D::ToggleRulers();. will draw all axice and labels with yellow color. Function Members (Methods); public:. virtual~TAxis3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxis3D.html:1434,down,down,1434,root/html602/TAxis3D.html,https://root.cern,https://root.cern/root/html602/TAxis3D.html,4,['down'],['down']
Availability, clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:44762,error,errors,44762,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,4,['error'],['errors']
Availability," cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:37416,avail,available,37416,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability," closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:12052,error,error,12052,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['error'],['error']
Availability," closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authenticati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:12365,error,error,12365,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,9,['error'],['error']
Availability," closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:33994,error,error,33994,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,1,['error'],['error']
Availability," closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TChain.html:35107,error,error,35107,root/html530/TChain.html,https://root.cern,https://root.cern/root/html530/TChain.html,9,['error'],['error']
Availability," coefficient, input; parameter, it should be positive number and <=1, for details see references; ��; Double_t� fChi;���������������������� //here the fitting functions return; resulting chi square�� ; ��; Double_t *fPositionInit;������������� //[fNPeaks] array of initial values of; peaks positions, input parameters; ��; Double_t *fPositionCalc;������������� //[fNPeaks] array of calculated values of; fitted positions, output parameters; ��; Double_t *fPositionErr;�������������� //[fNPeaks] array of position errors; ��; Double_t *fAmpInit;������������������ //[fNPeaks] array of initial values of; peaks amplitudes, input parameters; ��; Double_t *fAmpCalc;������������������ //[fNPeaks] array of calculated values of; fitted amplitudes, output parameters; ��; Double_t *fAmpErr;������������������� //[fNPeaks] array of amplitude errors; ��; Double_t *fArea;����� ����������������//[fNPeaks] array of calculated areas of; peaks; ��; Double_t *fAreaErr;������������������ //[fNPeaks] array of errors of peak areas; ��; Double_t� fSigmaInit;���������������� //initial value of sigma parameter; ��; Double_t� fSigmaCalc;��������� �������//calculated value of sigma parameter; ��; Double_t� fSigmaErr;����������������� //error value of sigma parameter; ��; Double_t� fTInit;�������������������� //initial value of t parameter (relative; amplitude of tail), for details see html manual and references; ��; Double_t� fTCalc;�������������������� //calculated value of t parameter; ��; Double_t� fTErr;��������������������� //error value of t parameter; ��; Double_t� fBInit;�������������������� //initial value of b parameter (slope),; for details see html manual and references; ��; Double_t� fBCalc;�������������������� //calculated value of b parameter; ��; Double_t� fBErr;��������������������� //error value of b parameter; ��; Double_t� fSInit;�������������������� //initial value of s parameter (relative; amplitude of step), for details see html manual and references; ��; Double_t� fSCalc;�����",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:23031,error,errors,23031,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,10,['error'],['errors']
Availability," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__RichardsonDerivator.html:6553,error,error,6553,root/html526/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__RichardsonDerivator.html:6564,error,error,6564,root/html528/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html530/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability," coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (function is not copied in). \@param f Function to be differentiated. { fFunction = &f; }. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id: RichardsonDerivator.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html532/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__RichardsonDerivator.html,12,['error'],['error']
Availability," collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayIterIterator of object array.Definition TObjArray.h:117; TObjArrayIter::NextTObject * Next() overrideReturn next object in array. Returns 0 when no more objects in array.Definition TObjArray.cxx:931; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the array.Definition TObjArray.cxx:321; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::GetStringconst TString & GetString() constDefinition TObjString.h:46; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::GetClassVersionInt_t GetClassVersion() const overrideDefinition TStreamerInfo.h:161; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:47842,error,error,47842,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['error'],['error']
Availability," color cell ;  ; TGColorFrame * fCe [16];  matrix of color cells ;  ; const TGWindow * fMsgWindow;  window handling container messages ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Private Member Functions;  TG16ColorSelector (const TG16ColorSelector &)=delete;  ; TG16ColorSelector & operator= (const TG16ColorSelector &)=delete;  . Additional Inherited Members;  Public Types inherited from TGWindow; enum  EEditMode { ;   kEditEnable = 0; , kEditD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTG16ColorSelector.html:25547,mask,mask,25547,doc/master/classTG16ColorSelector.html,https://root.cern,https://root.cern/doc/master/classTG16ColorSelector.html,1,['mask'],['mask']
Availability," color components for a specific pixel value. ; On input fPixel should be set on return the fRed, fGreen and fBlue components will be set. ; Reimplemented from TVirtualX.; Definition at line 5776 of file TGWin32.cxx. ◆ QueryColors(). void TGWin32::QueryColors ; (; GdkColormap * ; cmap, . GdkColor * ; colors, . Int_t ; ncolors . ). protected . Returns the current RGB value for the pixel in the XColor structure. ; Definition at line 1176 of file TGWin32.cxx. ◆ QueryPointer() [1/2]. void TGWin32::QueryPointer ; (; Int_t & ; ix, . Int_t & ; iy . ). overridevirtual . Query pointer position. ; ix : X coordinate of pointer iy : Y coordinate of pointer (both coordinates are relative to the origin of the root window) ; Reimplemented from TVirtualX.; Definition at line 2262 of file TGWin32.cxx. ◆ QueryPointer() [2/2]. void TGWin32::QueryPointer ; (; Window_t ; id, . Window_t & ; rootw, . Window_t & ; childw, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). overridevirtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; The pointer coordinates returned to win_x and win_y are relative to the origin of the specified window. In this case, QueryPointer returns the child that contains the pointer, if any, or else kNone to childw. QueryPointer returns the current logical state of the keyboard buttons and the modifier keys in mask. ; Reimplemented from TVirtualX.; Definition at line 7017 of file TGWin32.cxx. ◆ RaiseWindow(). void TGWin32::RaiseWindow ; (; Window_t ; id). overridevirtual . Put window on top of window stack. ; Reimplemented from TVirtualX.; Definition at line 4695 of file TGWin32.cxx. ◆ ReadGIF(). Pixmap_t TGWin32::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id = 0 . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:97700,mask,mask,97700,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['mask'],['mask']
Availability," comma) must be quoted.; 43~~~; 44 1997,Ford,E350,""Super, luxurious truck""; 45~~~; 46- Fields with double-quote characters must be quoted, and each of the embedded; 47double-quote characters must be represented by a pair of double-quote characters.; 48~~~; 49 1997,Ford,E350,""Super, """"luxurious"""" truck""; 50~~~; 51- Fields with embedded line breaks are not supported, even when quoted.; 52~~~; 53 1997,Ford,E350,""Go get one now; 54 they are going fast""; 55~~~; 56- Spaces are considered part of a field and are not ignored.; 57~~~; 58 1997, Ford , E350; 59 not same as; 60 1997,Ford,E350; 61 but same as; 62 1997, ""Ford"" , E350; 63~~~; 64- If a header row is provided, it must contain column names for each of the fields.; 65~~~; 66 Year,Make,Model; 67 1997,Ford,E350; 68 2000,Mercury,Cougar; 69~~~; 70 ; 71The current implementation of RCsvDS reads the entire CSV file content into memory before; 72RDataFrame starts processing it. Therefore, before creating a CSV RDataFrame, it is; 73important to check both how much memory is available and the size of the CSV file.; 74 ; 75RCsvDS can handle empty cells and also allows the usage of the special keywords ""NaN"" and ""nan"" to; 76indicate `nan` values. If the column is of type double, these cells are stored internally as `nan`.; 77Empty cells and explicit `nan`-s inside columns of type Long64_t/bool are stored as zeros.; 78*/; 79// clang-format on; 80 ; 81#include <ROOT/TSeq.hxx>; 82#include <ROOT/RCsvDS.hxx>; 83#include <ROOT/RRawFile.hxx>; 84#include <TError.h>; 85 ; 86#include <algorithm>; 87#include <memory>; 88#include <sstream>; 89#include <string>; 90 ; 91namespace ROOT {; 92 ; 93namespace RDF {; 94 ; 95std::string RCsvDS::AsString(); 96{; 97 return ""CSV data source"";; 98}; 99 ; 100// Regular expressions for type inference; 101const TRegexp RCsvDS::fgIntRegex(""^[-+]?[0-9]+$"");; 102const TRegexp RCsvDS::fgDoubleRegex1(""^[-+]?[0-9]+\\.[0-9]*$"");; 103const TRegexp RCsvDS::fgDoubleRegex2(""^[-+]?[0-9]*\\.[0-9]+$"");; 104const TRegexp ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCsvDS_8cxx_source.html:3273,avail,available,3273,doc/master/RCsvDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html,1,['avail'],['available']
Availability," command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. Int_t SendCurrentState(TProof::ESlaves list = kActive); Transfer the current state of the master to the active slave servers.; The current state includes: the current working directory, etc.; Returns the number of active slaves. Returns -1 in case of error. Int_t SendInitialState(); Transfer the initial (i.e. current) state of the master to all; slave servers. Currently the initial state includes: log level.; Returns the number of active slaves. Returns -1 in case of error. Bool_t CheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); Check if a file needs to be send to the slave. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:54721,error,error,54721,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSAXParser.html:12945,error,error,12945,root/html534/TSAXParser.html,https://root.cern,https://root.cern/root/html534/TSAXParser.html,4,['error'],['error']
Availability," comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSAXParser.html:13472,error,error,13472,root/html604/TSAXParser.html,https://root.cern,https://root.cern/root/html604/TSAXParser.html,4,['error'],['error']
Availability," comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSAXParser.html:13472,error,error,13472,root/html602/TSAXParser.html,https://root.cern,https://root.cern/root/html602/TSAXParser.html,4,['error'],['error']
Availability," compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16524,echo,echo,16524,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['down', 'echo']","['download', 'echo']"
Availability," components are set to default.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the RGB values for the pixel specified in the structure . Reimplemented from TVirtualX.; Definition at line 2927 of file TGCocoa.mm. ◆ QueryPointer() [1/2]. void TGCocoa::QueryPointer ; (; Int_t & ; ix, . Int_t & ; iy . ). overridevirtual . Returns the pointer position. ; Reimplemented from TVirtualX.; Definition at line 3144 of file TGCocoa.mm. ◆ QueryPointer() [2/2]. void TGCocoa::QueryPointer ; (; Window_t ; id, . Window_t & ; rootw, . Window_t & ; childw, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). overridevirtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; Parameters. [in]idspecifies the window ; [in]rootwthe root window that the pointer is in ; [in]childwthe child window that the pointer is located in, if any ; [in]root_x,root_ythe pointer coordinates relative to the root window's origin ; [in]win_x,win_ythe pointer coordinates relative to the specified window ""id"" ; [in]maskthe current state of the modifier keys and pointer buttons . Reimplemented from TVirtualX.; Definition at line 3155 of file TGCocoa.mm. ◆ RaiseWindow(). void TGCocoa::RaiseWindow ; (; Window_t ; id). overridevirtual . Raises the specified window to the top of the stack so that no sibling window obscures it. ; Reimplemented from TVirtualX.; Definition at line 1214 of file TGCocoa.mm. ◆ ReadGIF(). Pixmap_t TGCocoa::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented from TVirtualX.; Definition at line 4044 of file TGCocoa.mm. ◆ ReadPictureDataFromFile(). Bool_t TGCocoa::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Reads",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:106184,mask,maskthe,106184,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['maskthe']
Availability," components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e for a PtEtaPhiEVector; v2.SetCoordinates(c1,c2,c3,c4);; //sets cartesian components for PtEtaPhiEVector; v2.SetXYZ(x,y,z,t);; Single coordinate setter methods are available for the basic vector coordinates, like SetX() for a XYZTVector or SetPt() for a PtEtaPhiEVector. Attempting to do a SetX() on a non-Cartesian vector will not compile.; XYZTVector v1;; v1.SetX(1); //OK setting x for a cartesian vector; PtEtaPhiEVector v2;; v2.SetX(1); //ERROR: cannot set X for a non-cartesian; //vector. Method will not compile.; v2.SetR(1) // OK setting Pt for a PtEtaPhiEVector vector; In addition, there are setter methods from C arrays or iterators.; double d[4] = {1.,2.,3.,4.};; XYZTVector v;; //set (x,y,z,t) components of v using values from d; v.SetCoordinates(d);; or for example from an std::vectorusing the iterators; std::vector w(4);; //set (x,y,z,t) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; 13.12.4.4 Arithmetic Operations; The following operations are possible between Lorentz vectors classes, even of different coordinate system types: (v andw are two Lorentz vector of the same type, qis a generic Lorentz vector implementing x(), y(), z() and t()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:738547,avail,available,738547,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability, configuration ; : 129 | 10648.9 9650.52 0.0200265 0.0017972 43885.3 0; : 130 Minimum Test error found - save the configuration ; : 130 | 10561.5 9564.19 0.0200344 0.00180234 43878.7 0; : 131 Minimum Test error found - save the configuration ; : 131 | 10475.3 9477.45 0.0200356 0.00180107 43872.9 0; : 132 Minimum Test error found - save the configuration ; : 132 | 10388.3 9392.54 0.0200847 0.0018148 43788 0; : 133 Minimum Test error found - save the configuration ; : 133 | 10303 9307.9 0.0200258 0.00180758 43912.1 0; : 134 Minimum Test error found - save the configuration ; : 134 | 10217.2 9225.8 0.0200352 0.00180785 43890.1 0; : 135 Minimum Test error found - save the configuration ; : 135 | 10133.2 9143.83 0.0200313 0.00180712 43897.8 0; : 136 Minimum Test error found - save the configuration ; : 136 | 10051.9 9059.29 0.0200892 0.0018637 43894.4 0; : 137 Minimum Test error found - save the configuration ; : 137 | 9966.99 8978.86 0.0201265 0.00183533 43737 0; : 138 Minimum Test error found - save the configuration ; : 138 | 9887.13 8895.8 0.0200521 0.00180887 43851.8 0; : 139 Minimum Test error found - save the configuration ; : 139 | 9804.58 8815.4 0.020043 0.00180744 43870.3 0; : 140 Minimum Test error found - save the configuration ; : 140 | 9722.87 8737.3 0.0202214 0.00190002 43664.9 0; : 141 Minimum Test error found - save the configuration ; : 141 | 9644.27 8657.79 0.020429 0.00182729 43006.8 0; : 142 Minimum Test error found - save the configuration ; : 142 | 9564.39 8579.88 0.0204803 0.00186473 42974.8 0; : 143 Minimum Test error found - save the configuration ; : 143 | 9485.56 8503.01 0.0205275 0.0018356 42799.2 0; : 144 Minimum Test error found - save the configuration ; : 144 | 9408.47 8425.29 0.0205008 0.00183704 42863.9 0; : 145 Minimum Test error found - save the configuration ; : 145 | 9331.33 8347.95 0.0201933 0.00180744 43511.7 0; : 146 Minimum Test error found - save the configuration ; : 146 | 9254.79 8271.21 0.0201415 0.00180723 43634.1 0; : 147 M,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:26509,error,error,26509,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 249 | 3970.44 3073.93 0.0201703 0.00181858 43592.7 0; : 250 Minimum Test error found - save the configuration ; : 250 | 3939.05 3041.72 0.0204513 0.00185682 43023.5 0; : 251 Minimum Test error found - save the configuration ; : 251 | 3905.19 3012.24 0.0207706 0.0018857 42361.9 0; : 252 Minimum Test error found - save the configuration ; : 252 | 3873.64 2981.7 0.0208833 0.0019031 42149.1 0; : 253 Minimum Test error found - save the configuration ; : 253 | 3841.98 2951.54 0.0208487 0.0019305 42287.4 0; : 254 Minimum Test error found - save the configuration ; : 254 | 3809.95 2921.87 0.0208755 0.00187363 42101.1 0; : 255 Minimum Test error found - save the configuration ; : 255 | 3779.13 2892.2 0.020905 0.00188208 42054.6 0; : 256 Minimum Test error found - save the configuration ; : 256 | 3747.34 2863.22 0.020356 0.00183152 43186 0; : 257 Minimum Test error found - save the configuration ; : 257 | 3717.23 2832.96 0.0205175 0.00183548 42822 0; : 258 Minimum Test error found - save the configuration ; : 258 | 3685.71 2804.1 0.0207306 0.00191201 42511.2 0; : 259 Minimum Test error found - save the configuration ; : 259 | 3655.28 2775.93 0.0206157 0.0018465 42623 0; : 260 Minimum Test error found - save the configuration ; : 260 | 3624.6 2748.54 0.0206258 0.00186298 42637.5 0; : 261 Minimum Test error found - save the configuration ; : 261 | 3595.24 2720.67 0.0206036 0.00182681 42605.8 0; : 262 Minimum Test error found - save the configuration ; : 262 | 3565.68 2692.59 0.0203715 0.00187472 43250.7 0; : 263 Minimum Test error found - save the configuration ; : 263 | 3536.15 2665.16 0.0204197 0.00183921 43055.9 0; : 264 Minimum Test error found - save the configuration ; : 264 | 3507.67 2636.8 0.0206158 0.00185399 42639.7 0; : 265 Minimum Test error found - save the configuration ; : 265 | 3477.42 2610.03 0.0202093 0.0018315 43530.8 0; : 266 Minimum Test error found - save the configuration ; : 266 | 3448.44 2583.82 0.0201348 0.00181129 43659.7 0; : 267 Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:40096,error,error,40096,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 594 | 130.385 83.3494 0.0201184 0.00182079 43721.6 0; : 595 Minimum Test error found - save the configuration ; : 595 | 128.821 82.7241 0.0201197 0.00182054 43718 0; : 596 Minimum Test error found - save the configuration ; : 596 | 127.285 81.8772 0.0201421 0.00182102 43665.5 0; : 597 Minimum Test error found - save the configuration ; : 597 | 125.567 80.7585 0.0201182 0.00182506 43732.1 0; : 598 Minimum Test error found - save the configuration ; : 598 | 124.213 80.6209 0.0201133 0.0018121 43713 0; : 599 Minimum Test error found - save the configuration ; : 599 | 122.94 79.487 0.0201252 0.00180702 43672.5 0; : 600 Minimum Test error found - save the configuration ; : 600 | 121.268 78.716 0.0201262 0.0018137 43686.1 0; : 601 Minimum Test error found - save the configuration ; : 601 | 119.733 78.5666 0.0201064 0.00181556 43737.8 0; : 602 Minimum Test error found - save the configuration ; : 602 | 118.293 77.4143 0.0201212 0.00181376 43698 0; : 603 Minimum Test error found - save the configuration ; : 603 | 116.739 75.9525 0.0201101 0.00180951 43714.3 0; : 604 Minimum Test error found - save the configuration ; : 604 | 115.282 75.4842 0.0201093 0.00181811 43737 0; : 605 Minimum Test error found - save the configuration ; : 605 | 113.756 74.5415 0.0201179 0.00181105 43699.5 0; : 606 Minimum Test error found - save the configuration ; : 606 | 112.65 73.8117 0.0200987 0.00180944 43741.5 0; : 607 Minimum Test error found - save the configuration ; : 607 | 110.993 73.1273 0.0200934 0.00180455 43742.6 0; : 608 Minimum Test error found - save the configuration ; : 608 | 109.653 72.3206 0.0201066 0.00180567 43713.6 0; : 609 Minimum Test error found - save the configuration ; : 609 | 108.357 71.632 0.0200983 0.00180999 43743.9 0; : 610 Minimum Test error found - save the configuration ; : 610 | 106.875 70.7773 0.0201154 0.00182046 43728 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:79139,error,error,79139,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 596 | 127.285 81.8772 0.0201421 0.00182102 43665.5 0; : 597 Minimum Test error found - save the configuration ; : 597 | 125.567 80.7585 0.0201182 0.00182506 43732.1 0; : 598 Minimum Test error found - save the configuration ; : 598 | 124.213 80.6209 0.0201133 0.0018121 43713 0; : 599 Minimum Test error found - save the configuration ; : 599 | 122.94 79.487 0.0201252 0.00180702 43672.5 0; : 600 Minimum Test error found - save the configuration ; : 600 | 121.268 78.716 0.0201262 0.0018137 43686.1 0; : 601 Minimum Test error found - save the configuration ; : 601 | 119.733 78.5666 0.0201064 0.00181556 43737.8 0; : 602 Minimum Test error found - save the configuration ; : 602 | 118.293 77.4143 0.0201212 0.00181376 43698 0; : 603 Minimum Test error found - save the configuration ; : 603 | 116.739 75.9525 0.0201101 0.00180951 43714.3 0; : 604 Minimum Test error found - save the configuration ; : 604 | 115.282 75.4842 0.0201093 0.00181811 43737 0; : 605 Minimum Test error found - save the configuration ; : 605 | 113.756 74.5415 0.0201179 0.00181105 43699.5 0; : 606 Minimum Test error found - save the configuration ; : 606 | 112.65 73.8117 0.0200987 0.00180944 43741.5 0; : 607 Minimum Test error found - save the configuration ; : 607 | 110.993 73.1273 0.0200934 0.00180455 43742.6 0; : 608 Minimum Test error found - save the configuration ; : 608 | 109.653 72.3206 0.0201066 0.00180567 43713.6 0; : 609 Minimum Test error found - save the configuration ; : 609 | 108.357 71.632 0.0200983 0.00180999 43743.9 0; : 610 Minimum Test error found - save the configuration ; : 610 | 106.875 70.7773 0.0201154 0.00182046 43728 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 | 104.268 69.338 0.0202166 0.00183521 43522.3 0; : 613 Minimum Test error found - save the configuration ; : 613 | 102.858 68.9009 0.0202348 0.00182917 43464.9 0; : 614 Minimum Test error found - save the configuration ; : 614,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:79365,error,error,79365,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 6 | 0.387736 0.373696 0.0792581 0.00678916 44156.9 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.373399 0.360485 0.0791536 0.00677002 44208.9 0; : 8 Minimum Test error found - save the configuration ; : 8 | 0.362792 0.352336 0.0796639 0.00682572 43933 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.353594 0.340526 0.0805399 0.00700876 43519 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.345712 0.336826 0.080966 0.0069933 43259.2 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.338399 0.329567 0.0802544 0.00691181 43630.9 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.333122 0.322325 0.0804981 0.00689735 43477.8 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.326577 0.317097 0.0800716 0.00688531 43724 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.320979 0.311994 0.080369 0.00694962 43585.2 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.316442 0.305918 0.0803736 0.00690045 43553.3 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.311672 0.301667 0.0807629 0.00695777 43357.4 0; : 17 Minimum Test error found - save the configuration ; : 17 | 0.306787 0.297289 0.0804752 0.00690149 43493.8 0; : 18 Minimum Test error found - save the configuration ; : 18 | 0.303107 0.295781 0.0805443 0.00693772 43474.3 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.300241 0.290359 0.0805629 0.00693546 43462 0; : 20 | 0.29682 0.292587 0.0806285 0.00686869 43384.1 1; : ; : Elapsed time for training with 4000 events: 1.62 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of DL_CPU on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.106 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:16382,error,error,16382,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['error'],['error']
Availability, configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19546,error,error,19546,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:98289,error,error,98289,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test error found - save the configuration ; : 812 | 9.42328 13.0239 0.0202708 0.00183859 43402.3 0; : 813 | 9.26754 13.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:98403,error,error,98403,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 873 | 5.70638 8.71803 0.0200731 0.00181478 43815.7 0; : 874 Minimum Test error found - save the configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.334,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:104974,error,error,104974,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105088,error,error,105088,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.35846 6.60136 0.0200632 0.00176343 43716.3 1; : 920 | 4.30933 6.53557 0.0200239 0.00175965 43801.4 2; : 921 Minimum Test error found - save the configuration ; : 921 | 4.32266 6.29119 0.0200952 0.00182605 43789.5 0; : 922 | 4.32742 6.39561 0.0200257 0.00176292 43804.9 1; : 923 | 4.33774 6.46608 0.0200201 0.00176071 43813 2; : 924 | 4.36503 6.3111 0.0200702 0.00177545 43728.3 3; : 925 | 4.7314 7.24632 0.0202093 0.00176259 43368.2 4; : 926 | 4.61316 6.64099 0.020249 0.00181216 43391.3 5; : 927 Minimum Test error found - save the configuration ; : 927 | 4.41727 6.09792,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:107105,error,error,107105,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability, configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.29174 0.0201055 0.00180854 43723.1 1; : 941 | 3.89757 5.80965 0.0203179 0.00179759 43195.8 2; : 942 | 3.94904 5.73464 0.0200877 0.00175468 43637.1 3; : 943 | 3.90362 5.73888 0.0200954 0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:109684,error,error,109684,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability," configuration for a channel, e.g. ; ""RHist"". Each ROOT module has its own log, with potentially distinct verbosity. ; Definition at line 101 of file RLogger.hxx. Public Member Functions;  RLogChannel ()=default;  Construct an anonymous channel. ;  ;  RLogChannel (const std::string &name);  Construct a log channel given its name, which is part of the diagnostics. ;  ;  RLogChannel (ELogLevel verbosity);  Construct an anonymous channel with a default verbosity. ;  ; ELogLevel GetEffectiveVerbosity (const RLogManager &mgr) const;  ; const std::string & GetName () const;  ; ELogLevel GetVerbosity () const;  ; ELogLevel SetVerbosity (ELogLevel verbosity);  ;  Public Member Functions inherited from ROOT::Experimental::RLogDiagCount; long long GetNumErrors () const;  Returns the current number of errors. ;  ; long long GetNumFatalErrors () const;  Returns the current number of fatal errors. ;  ; long long GetNumWarnings () const;  Number of fatal errors. ;  ; void Increment (ELogLevel severity);  Increase warning or error count. ;  . Private Attributes; std::string fName;  Name as shown in diagnostics. ;  ; ELogLevel fVerbosity = ELogLevel::kUnset;  Verbosity of this channel. By default, use the global verbosity. ;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Experimental::RLogDiagCount; std::atomic< long long > fNumErrors {0ll};  Number of warnings. ;  ; std::atomic< long long > fNumFatalErrors {0ll};  Number of errors. ;  ; std::atomic< long long > fNumWarnings {0ll};  . #include <ROOT/RLogger.hxx>. Inheritance diagram for ROOT::Experimental::RLogChannel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RLogChannel() [1/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; ). default . Construct an anonymous channel. . ◆ RLogChannel() [2/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; ELogLevel ; verbosity). inlineexplicit . Construct an anonymo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html:1313,error,error,1313,doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,2,['error'],['error']
Availability," configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual void preferredObservableScanOrder (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:26049,error,error,26049,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,2,['error'],['error']
Availability," configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:27015,error,error,27015,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['error'],['error']
Availability," configured to allow so).; Returns 0 on success, -1 on failure. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen | kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen | kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. TFileCollection * GetDataSet(const char* uri, const char* srv = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. void UpdateUsedSpace(); updates the used space maps. Long_t GetModTime(const char* uri); Gets last dataset modification time. Returns -1 on error, or number of; seconds since epoch on success. const char * GetDataSetPath(const char* group, const char* user, const char* dsName). TDataSetManagerFile(); { }. TDataSetManagerFile(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManagerFile.html:22089,Avail,Available,22089,root/html602/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html602/TDataSetManagerFile.html,2,['Avail'],['Available']
Availability," connection to server; TUrlfUrlserver's url; TRemoteObject*fWorkingDirworking (remote) directory; static Int_tfgPortAttemptsnumber of attempts to find a port; static Int_tfgPortLowerlower bound for ports; static Int_tfgPortUpperupper bound for ports. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationRemote(const char* url, Int_t debug = 0, const char* script = 0); Main constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the serve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14106,error,error,14106,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,11,['error'],['error']
Availability," consecutive and starts from the first bin; 1045 // in that case the current code will work fine; 1046 Int_t firstLabelBin = axis->GetNbins() + 1;; 1047 Int_t lastLabelBin = -1;; 1048 for (Int_t i = 0; i < n; ++i) {; 1049 Int_t bin = labels->At(i)->GetUniqueID();; 1050 if (bin < firstLabelBin); 1051 firstLabelBin = bin;; 1052 if (bin > lastLabelBin); 1053 lastLabelBin = bin;; 1054 }; 1055 if (firstLabelBin != 1 || lastLabelBin - firstLabelBin + 1 != n) {; 1056 Error(""LabelsOption"",; 1057 ""%s of TProfile %s contains bins without labels. Sorting will not work correctly - return"",; 1058 axis->GetName(), GetName());; 1059 return;; 1060 }; 1061 // case where label bins are consecutive starting from first bin will work; 1062 Warning(; 1063 ""LabelsOption"",; 1064 ""axis %s of TProfile %s has extra following bins without labels. Sorting will work only for first label bins"",; 1065 axis->GetName(), GetName());; 1066 }; 1067 std::vector<Int_t> a(n);; 1068 Int_t i;; 1069 std::vector<Double_t> cont(n);; 1070 std::vector<Double_t> sumw(n);; 1071 std::vector<Double_t> errors(n);; 1072 std::vector<Double_t> ent(n);; 1073 std::vector<Double_t> binsw2;; 1074 if (fBinSumw2.fN) binsw2.resize(n);; 1075 ; 1076 // delete buffer if it is there since bins will be reordered.; 1077 if (fBuffer); 1078 BufferEmpty(1);; 1079 ; 1080 // make a labelold list but ordered with bins; 1081 // (re-ordered original label list); 1082 std::vector<TObject *> labold(n);; 1083 for (i = 0; i < n; i++); 1084 labold[i] = nullptr;; 1085 TIter nextold(labels);; 1086 TObject *obj;; 1087 while ((obj=nextold())) {; 1088 Int_t bin = obj->GetUniqueID();; 1089 R__ASSERT(bin <= n);; 1090 labold[bin - 1] = obj;; 1091 }; 1092 // order now labold according to bin content; 1093 ; 1094 labels->Clear();; 1095 if (sort > 0) {; 1096 //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:39547,error,errors,39547,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability," considered an error.Definition RooCmdConfig.h:44; RooCmdConfig::getIntint getInt(const char *name, int defaultValue=0) constReturn integer property registered with name 'name'.Definition RooCmdConfig.cxx:481; RooCmdConfig::getObjectTObject * getObject(const char *name, TObject *obj=nullptr) constReturn TObject property registered with name 'name'.Definition RooCmdConfig.cxx:519; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooFit::Detail::CompileContextDefinition NormalizationHelpers.h:29; RooFit::Detail::CompileContext::markAsCompiledvoid markAsCompiled(RooAbsArg &arg) constDefinition NormalizationHelpers.cxx:74; RooFit::Detail::CompileContext::compileServersvoid compileServers(RooAbsArg &arg, RooArgSet const &normSet)Definition NormalizationHelpers.cxx:39; RooGenContextImplements a universal generator context for all RooAbsPdf classes that do not have or need a special...Definition RooGenContext.h:29; RooHelpers::LocalChangeMsgLevelSwitches the message service to a different level while the instance is alive.Definition RooHelpers.h:37; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooNameReg::strstatic const char * str(const TNamed *ptr)Return C++ string corresponding to given TNamed pointer.Definition RooNameReg.h:39; RooNumGenConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumGenConfig.h:25; RooNumGenConfig::defaultConfigstatic RooNumGenConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumGenConfig.cxx:44; RooObjCacheManagerImplementation of a RooCacheManager<RooAbsCacheEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:165003,alive,alive,165003,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['alive'],['alive']
Availability," consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual UInt_t GetUniqueID () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:45403,error,error,45403,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['error'],['error']
Availability," consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPaletteEditor_1_1LimitLine.html:5500,error,error,5500,doc/master/classTASPaletteEditor_1_1LimitLine.html,https://root.cern,https://root.cern/doc/master/classTASPaletteEditor_1_1LimitLine.html,2,['error'],['error']
Availability," const =0;  ; virtual void MethodInfo_CreateSignature (MethodInfo_t *, TString &) const;  ; virtual void MethodInfo_Delete (MethodInfo_t *) const;  ; virtual Long_t MethodInfo_ExtraProperty (MethodInfo_t *) const =0;  ; virtual MethodInfo_t * MethodInfo_Factory () const;  ; virtual MethodInfo_t * MethodInfo_Factory (ClassInfo_t *) const;  ; virtual MethodInfo_t * MethodInfo_Factory (DeclId_t declid) const =0;  ; virtual MethodInfo_t * MethodInfo_FactoryCopy (MethodInfo_t *) const;  ; virtual const char * MethodInfo_GetMangledName (MethodInfo_t *) const;  ; virtual const char * MethodInfo_GetPrototype (MethodInfo_t *) const;  ; virtual void * MethodInfo_InterfaceMethod (MethodInfo_t *) const;  ; virtual Bool_t MethodInfo_IsValid (MethodInfo_t *) const;  ; virtual EReturnType MethodInfo_MethodCallReturnType (MethodInfo_t *minfo) const =0;  ; virtual const char * MethodInfo_Name (MethodInfo_t *) const;  ; virtual int MethodInfo_NArg (MethodInfo_t *) const;  ; virtual int MethodInfo_NDefaultArg (MethodInfo_t *) const;  ; virtual int MethodInfo_Next (MethodInfo_t *) const;  ; virtual Long_t MethodInfo_Property (MethodInfo_t *) const =0;  ; virtual const char * MethodInfo_Title (MethodInfo_t *) const;  ; virtual TypeInfo_t * MethodInfo_Type (MethodInfo_t *) const;  ; virtual const char * MethodInfo_TypeName (MethodInfo_t *) const;  ; virtual std::string MethodInfo_TypeNormalizedName (MethodInfo_t *) const;  ; virtual void PrintIntro ()=0;  ; virtual Longptr_t ProcessLine (const char *line, EErrorCode *error=nullptr)=0;  ; virtual Longptr_t ProcessLineSynch (const char *line, EErrorCode *error=nullptr)=0;  ; virtual void RegisterModule (const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0;  ; virtual bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:21112,error,error,21112,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,2,['error'],['error']
Availability," const Double_t *x, const Double_t *y, const Double_t *exL, const Double_t *exH, std::vector< TArrayD > eyL, std::vector< TArrayD > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector< std::vector< Float_t > > eyL, std::vector< std::vector< Float_t > > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector< TArrayF > eyL, std::vector< TArrayF > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne=1);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const TGraphMultiErrors &tgme);  TGraphMultiErrors copy constructor. ;  ;  TGraphMultiErrors (const TH1 *pass, const TH1 *total, Int_t ne=1, Option_t *option="""");  Creates a TGraphMultiErrors by dividing two input TH1 histograms: pass/total. ;  ;  TGraphMultiErrors (const TH1 *th, Int_t ne=1);  TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument. ;  ;  TGraphMultiErrors (const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL, const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m=kOnlyFirst);  Constructor with six vectors of doubles in input and a single y error dimension. ;  ;  TGraphMultiErrors (const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL, const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m=kOnlyFirst);  Constructor with six vectors of floats in input and a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:5937,error,errors,5937,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['errors']
Availability," const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1); need to re-implement all function in ModularFuncitionMinimizer otherwise they will be hided. FunctionMinimum Minimize(const FCNGradientBase&fcn, const std::vector<double>&par, const std::vector<double>&err, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const MnFcn& mfcn, const GradientCalculator& gc, const MinimumSeed& seed, const MnStrategy& stra, unsigned int maxfcn, double toler). » Last changed: root/minuit2:$Id: FumiliMinimizer.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__FumiliMinimizer.html:5423,toler,toler,5423,root/html526/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__FumiliMinimizer.html,4,['toler'],['toler']
Availability," const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1); need to re-implement all function in ModularFuncitionMinimizer otherwise they will be hided. FunctionMinimum Minimize(const FCNGradientBase&fcn, const std::vector<double>&par, const std::vector<double>&err, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const MnFcn& mfcn, const GradientCalculator& gc, const MinimumSeed& seed, const MnStrategy& stra, unsigned int maxfcn, double toler). » Last changed: root/minuit2:$Id: FumiliMinimizer.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__FumiliMinimizer.html:5423,toler,toler,5423,root/html528/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__FumiliMinimizer.html,4,['toler'],['toler']
Availability," const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1); need to re-implement all function in ModularFuncitionMinimizer otherwise they will be hided. FunctionMinimum Minimize(const FCNGradientBase&fcn, const std::vector<double>&par, const std::vector<double>&err, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const MnFcn& mfcn, const GradientCalculator& gc, const MinimumSeed& seed, const MnStrategy& stra, unsigned int maxfcn, double toler). » Last changed: root/minuit2:$Id: FumiliMinimizer.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__FumiliMinimizer.html:5425,toler,toler,5425,root/html530/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliMinimizer.html,4,['toler'],['toler']
Availability," const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1); need to re-implement all function in ModularFuncitionMinimizer otherwise they will be hided. FunctionMinimum Minimize(const FCNGradientBase&fcn, const std::vector<double>&par, const std::vector<double>&err, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, const MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const MnFcn& mfcn, const GradientCalculator& gc, const MinimumSeed& seed, const MnStrategy& stra, unsigned int maxfcn, double toler). » Last changed: root/minuit2:$Id: FumiliMinimizer.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__FumiliMinimizer.html:5425,toler,toler,5425,root/html532/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__FumiliMinimizer.html,8,['toler'],['toler']
Availability," const ROOT::Math::IBaseFunctionMultiDim& ftor, const RooArgList& vars); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorPdfBinding.html:29300,Error,ErrorLoggingMode,29300,root/html602/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorPdfBinding.html,2,['Error'],['ErrorLoggingMode']
Availability," const RooArgSet& auxSplitCats, Bool_t verbose = kFALSE); RooSimultaneous*buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, const RooArgSet* auxSplitCats = 0, Bool_t verbose = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooArgSet*createProtoBuildConfig(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimPdfBuilder.html:15306,error,error,15306,root/html526/RooSimPdfBuilder.html,https://root.cern,https://root.cern/root/html526/RooSimPdfBuilder.html,11,['error'],['error']
Availability," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:16609,error,error,16609,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,98,['error'],['error']
Availability," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:12724,error,error,12724,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,8,['error'],['error']
Availability," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:13866,error,error,13866,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,28,['error'],['error']
Availability," const Settings &settings, size_t trainFromLayer, size_t totalNumWeights) const;  ; void clear ();  ; template<typename Weights > ; std::vector< double > compute (const std::vector< double > &input, const Weights &weights) const;  compute the net with the given input and the given weights ;  ; template<typename ItWeight > ; std::tuple< double, double > computeError (const Settings &settings, std::vector< LayerData > &lastLayerData, Batch &batch, ItWeight itWeightBegin, ItWeight itWeightEnd) const;  ; void dE ();  ; template<typename WeightsType , typename DropProbabilities > ; void dropOutWeightFactor (WeightsType &weights, const DropProbabilities &drops, bool inverse=false);  set the drop out configuration ;  ; double E ();  ; template<typename Container , typename ItWeight > ; double errorFunction (LayerData &layerData, Container truth, ItWeight itWeight, ItWeight itWeightEnd, double patternWeight, double factorWeightDecay, EnumRegularization eRegularization) const;  computes the error of the DNN ;  ; template<typename OutputContainer > ; void fetchOutput (const LayerData &lastLayerData, OutputContainer &outputContainer) const;  ; template<typename OutputContainer > ; void fetchOutput (const std::vector< LayerData > &layerPatternData, OutputContainer &outputContainer) const;  ; template<typename LayerContainer , typename PassThrough , typename ItWeight , typename ItGradient , typename OutContainer > ; double forward_backward (LayerContainer &layers, PassThrough &settingsAndBatch, ItWeight itWeightBegin, ItWeight itWeightEnd, ItGradient itGradientBegin, ItGradient itGradientEnd, size_t trainFromLayer, OutContainer &outputContainer, bool fetchOutput) const;  main NN computation function ;  ; template<typename LayerContainer , typename LayerPatternContainer > ; void forwardBatch (const LayerContainer &_layers, LayerPatternContainer &layerPatternData, std::vector< double > &valuesMean, std::vector< double > &valuesStdDev, size_t trainFromLayer) const;  ; template<type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:1983,error,error,1983,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['error'],['error']
Availability," const char * TPackMgr::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TNamed.; Definition at line 61 of file TPackMgr.h. ◆ GetPackDir(). Int_t TPackMgr::GetPackDir ; (; const char * ; pack, . TString & ; pdir . ). Method to get the path of the dir for package 'pack'. ; Return -1 in case of error (not found), 0 otherwise ; Definition at line 487 of file TPackMgr.cxx. ◆ GetPackMgr(). TPackMgr * TPackMgr::GetPackMgr ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Get the package manager having 'pack'; priority is given to packmgr, if defined. ; Returns packmgr or nullptr ; Definition at line 912 of file TPackMgr.cxx. ◆ GetParPath(). Int_t TPackMgr::GetParPath ; (; const char * ; pack, . TString & ; path . ). Method to get the path of the PAR file for package 'pack'. ; Return -1 in case of error (not found), 0 otherwise ; Definition at line 521 of file TPackMgr.cxx. ◆ GetTitle(). const char * TPackMgr::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TNamed.; Definition at line 63 of file TPackMgr.h. ◆ Has(). Bool_t TPackMgr::Has ; (; const char * ; pack). Method to check if this package manager has package 'pack'. ; Return kTRUE or kFALSE ; Definition at line 458 of file TPackMgr.cxx. ◆ Install(). Int_t TPackMgr::Install ; (; const char * ; parpath, . Bool_t ; rmold = kFALSE . ). Install package from par (unpack the file in the directory); par can be an URL for remote retrieval. ; If rmold is kTRUE an existing version of the package is removed if existing. Returns 0 on success, <0 otherwise ; Definition at line 766 of file TPackMgr.cxx. ◆ IsA(). TClass * TPackMgr::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:19465,error,error,19465,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['error'],['error']
Availability," const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.; 249 ; 250 // Misc; 251 virtual int DisplayClass(FILE * /* fout */,const char * /* name */,int /* base */,int /* start */) const {return 0;}; 252 virtual int DisplayIncludePath(FILE * /* fout */) const {return 0;}; 253 virtual void *FindSym(const char * /* entry */) const {return nullptr;}; 254 virtual void GenericError(const char * /* error */) const {}; 255 virtual Long_t GetExecByteCode() const {return 0;}; 256 virtual const char *GetTopLevelMacroName() const {return nullptr;};; 257 virtual const char *GetCurrentMacroName() const {return nullptr;};; 258 virtual int GetSecurityError() const{return 0;}; 259 virtual int LoadFile(const char * /* path */) const {return 0;}; 260 virtual Bool_t LoadText(const char * /* text */) const {return kFALSE;}; 261 virtual const char *MapCppName(const char*) const {return nullptr;}; 262 virtual void SetAlloclockfunc(void (*)()) const {}; 263 virtual void SetAllocunlockfunc(void (*)()) const {}; 264 virtual int SetClassAutoLoading(int) const {return 0;}; 265 int SetClassAutoloading(int a) const { return SetClassAutoLoading(a); } // Deprecated; 266 virtual int SetClassAutoparsing(int) {return 0;};; 267 virtual void SetErrmsgcallback(void * /* p */) const {}; 268 /// \brief Report diagnostics to the ROOT error handler (see TError.h).; 269 virtual void ReportDiagnosticsToErrorHandler(bool /*enable*/ = true) {}; 270 virtual void SetTempLevel(int /* val */) const {}; 271 virtual int UnloadFile(const char * /* path */) const {return 0;}; 272 ; 273 /// The created temporary must be deleted by the caller.; 274 /// Deprecated! Please use MakeInterpreterValue().; 275 TInterpreterValue *Cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:11516,error,error,11516,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,2,['error'],['error']
Availability," const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 delete[] buf;; 130 buf_storage = buf = new char[buf_size];; 131 ; 132 // Try again with a sufficiently large buffer; 133 va_copy(ap_copy, ap);; 134 vsnprintf(buf, buf_size, fmt, ap_copy);; 135 }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:3608,error,error,3608,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability," const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:29920,error,errors,29920,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['error'],['errors']
Availability," const char * DisplayName (const char *) override;  Returns hostname on which the display is opened. ;  ; void DrawLine (Drawable_t wid, GContext_t gc, Int_t x1, Int_t y1, Int_t x2, Int_t y2) override;  Uses the components of the specified GC to draw a line between the specified set of points (x1, y1) and (x2, y2). ;  ; void DrawLineAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x1, Int_t y1, Int_t x2, Int_t y2);  ; void DrawRectangle (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; void DrawRectangleAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x, Int_t y, UInt_t w, UInt_t h);  ; void DrawSegments (Drawable_t wid, GContext_t gc, Segment_t *segments, Int_t nSegments) override;  Draws multiple line segments. ;  ; void DrawSegmentsAux (Drawable_t wid, const GCValues_t &gcVals, const Segment_t *segments, Int_t nSegments);  ; void DrawString (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, const char *s, Int_t len) override;  Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ;  ; void DrawStringAux (Drawable_t wid, const GCValues_t &gc, Int_t x, Int_t y, const char *s, Int_t len);  ; Bool_t EmptyRegion (Region_t reg) override;  Returns kTRUE if the region reg is empty. ;  ; Bool_t EqualRegion (Region_t rega, Region_t regb) override;  Returns kTRUE if the two regions have the same offset, size, and shape. ;  ; Int_t EventsPending () override;  Returns the number of events that have been received from the X server but have not been removed from the event queue. ;  ; UInt_t ExecCommand (TGWin32Command *code) override;  Executes the command ""code"" coming from the other threads (Win32) ;  ; void FillPolygon (Window_t wid, GContext_t gc, Point_t *polygon, Int_t nPoints) override;  Fills the region closed by the specified path. ;  ; void FillPolygonAux (Window_t wid, const GCValues_t &gcVals,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:9219,mask,mask,9219,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability," const char * UnixHomedirectory (const char *user, char *path, char *mydir);  Returns the user's home directory. ;  ; static const char * UnixHomedirectory (const char *user=nullptr);  Returns the user's home directory. ;  ; static void UnixIgnoreSignal (ESignals sig, Bool_t ignore);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; static int UnixMakedir (const char *name);  Make a Unix file system directory. ;  ; static Long64_t UnixNow ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; static void * UnixOpendir (const char *name);  Open a directory. ;  ; static int UnixRecv (int sock, void *buf, int len, int flag);  Receive exactly length bytes into buffer. ;  ; static void UnixResetSignal (ESignals sig);  Restore old signal handler for specified signal. ;  ; static void UnixResetSignals ();  Restore old signal handlers. ;  ; static int UnixSelect (Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout);  Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ;  ; static int UnixSend (int sock, const void *buf, int len, int flag);  Send exactly length bytes from buffer. ;  ; static int UnixSetitimer (Long_t ms);  Set interval timer to time-out in ms milliseconds. ;  ; static void UnixSigAlarmInterruptsSyscalls (Bool_t set);  When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; static void UnixSignal (ESignals sig, SigHandler_t h);  Set a signal handler for a signal. ;  ; static const char * UnixSigname (ESignals sig);  Return the signal name associated with a signal. ;  ; static int UnixTcpConnect (const char *hostname, int port, int tcpwindowsize);  Open a TCP/IP connection to server and connect to a service (i.e. ;  ; static int UnixTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize);  Open a socket, bind to it and start listening fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:34873,mask,masks,34873,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['mask'],['masks']
Availability," const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TModuleDocInfo.html:2058,error,error,2058,root/html528/TModuleDocInfo.html,https://root.cern,https://root.cern/root/html528/TModuleDocInfo.html,6,['error'],['error']
Availability," const char* extF = """", const char* extD = """"); virtual~TMultiLayerPerceptron(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeDEDw() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawResult(Int_t index = 0, Option_t* option = ""test"") const; virtual voidTObject::Dump() constMENU ; Bool_tDumpWeights(Option_t* filename = ""-"") const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEvaluate(Int_t index, Double_t* params) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExport(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEpsilon() const; Double_tGetError(Int_t event) const; Double_tGetError(TMultiLayerPerceptron::EDataSet set) const; Double_tGetEta() const; Double_tGetEtaDecay() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:10904,Error,Error,10904,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,1,['Error'],['Error']
Availability," const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:16264,error,error,16264,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,6,['error'],['error']
Availability," const char* name = 0); RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:23977,Error,ErrorLoggingMode,23977,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,2,['Error'],['ErrorLoggingMode']
Availability," const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCompiler() const; virtual const char*GetBuildCompilerVersion() const; virtual const char*GetBuildDir() const; virtual const char*GetBuildNode() const; virtual intG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:3517,error,error,3517,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['error'],['error']
Availability," const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* = ""*"", Option_t* = """"); virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; Int_tGetArrayLimit() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLFile.html:9710,error,error,9710,root/html532/TSQLFile.html,https://root.cern,https://root.cern/root/html532/TSQLFile.html,2,['error'],['error']
Availability," const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*GetArchive() const; static TFile::EAsyncOpenStatusGetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusGetAsyncOpenStatus(TFileOpenHandle* handle); Int_tGetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSize() const; virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:4833,error,error,4833,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['error'],['error']
Availability," const char* name, Int_t bufsize, TDirectory* motherDir = 0); virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:3040,error,error,3040,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,6,['error'],['error']
Availability," const char* s, Int_t len); Each character image, as defined by the font in the GC, is treated as an; additional mask for a fill operation on the drawable. id - the drawable; gc - the GC; x, y - coordinates, which are relative to the origin of the specified; drawable and define the origin of the first character; s - the character string; len - the number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font,; subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return lenght of the string ""s"" in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Returns the font properties. void GetGCValues(GContext_t gc, GCValues_t& gval); Returns the components specified by the mask in ""gval"" for the; specified GC ""gc"" (see also the GCValues_t structure). FontStruct_t GetFontStruct(FontH_t fh); Retrieves the associated font structure of the font specified font; handle ""fh"". Free returned FontStruct_t using FreeFontStruct(). void FreeFontStruct(FontStruct_t fs); Frees the font structure ""fs"". The font itself will be freed when; no other resource references it. void ClearWindow(Window_t id); Clears the entire area in the specified window and it is equivalent to; ClearArea(id, 0, 0, 0, 0). Int_t KeysymToKeycode(UInt_t keysym); Converts the ""keysym"" to the appropriate keycode. For example,; keysym is a letter and keycode is the matching keyboard key (which; is dependend on the current keyboard mapping). If the specified; ""keysym"" is not defined for any keycode, returns zero. void FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h].; using the GC you spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:52758,mask,mask,52758,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,4,['mask'],['mask']
Availability," const char* s, Int_t len); Each character image, as defined by the font in the GC, is treated as an; additional mask for a fill operation on the drawable. id - the drawable; gc - the GC; x, y - coordinates, which are relative to the origin of the specified; drawable and define the origin of the first character; s - the character string; len - the number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font,; subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of the string ""s"" in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Returns the font properties. void GetGCValues(GContext_t gc, GCValues_t& gval); Returns the components specified by the mask in ""gval"" for the; specified GC ""gc"" (see also the GCValues_t structure). FontStruct_t GetFontStruct(FontH_t fh); Retrieves the associated font structure of the font specified font; handle ""fh"". Free returned FontStruct_t using FreeFontStruct(). void FreeFontStruct(FontStruct_t fs); Frees the font structure ""fs"". The font itself will be freed when; no other resource references it. void ClearWindow(Window_t id); Clears the entire area in the specified window and it is equivalent to; ClearArea(id, 0, 0, 0, 0). Int_t KeysymToKeycode(UInt_t keysym); Converts the ""keysym"" to the appropriate keycode. For example,; keysym is a letter and keycode is the matching keyboard key (which; is dependend on the current keyboard mapping). If the specified; ""keysym"" is not defined for any keycode, returns zero. void FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h].; using the GC you spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualX.html:56412,mask,mask,56412,root/html602/TVirtualX.html,https://root.cern,https://root.cern/root/html602/TVirtualX.html,2,['mask'],['mask']
Availability," const char* s, Int_t len); Each character image, as defined by the font in the GC, is treated as an; additional mask for a fill operation on the drawable. id - the drawable; gc - the GC; x, y - coordinates, which are relative to the origin of the specified; drawable and define the origin of the first character; s - the character string; len - the number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font,; subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of the string ""s"" in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Returns the font properties. void GetGCValues(GContext_t gc, GCValues_t& gval); Returns the components specified by the mask in ""gval"" for the; specified GC ""gc"" (see also the GCValues_t structure). FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. FontStruct_t GetFontStruct(FontH_t fh); Retrieves the associated font structure of the font specified font; handle ""fh"". Free returned FontStruct_t using FreeFontStruct(). void FreeFontStruct(FontStruct_t fs); Frees the font structure ""fs"". The font itself will be freed when; no other resource references it. void ClearWindow(Window_t id); Clears the entire area in the specified window and it is equivalent to; ClearArea(id, 0, 0, 0, 0). Int_t KeysymToKeycode(UInt_t keysym); Converts the ""keysym"" to the appropriate keycode. For example,; keysym is a letter and keycode is the matching keyboard key (which; is dependend on the current keyboard mapping). If the specified; ""keysym"" is not defined for any keycode, returns zero. void FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualX.html:55799,mask,mask,55799,root/html534/TVirtualX.html,https://root.cern,https://root.cern/root/html534/TVirtualX.html,4,['mask'],['mask']
Availability," const char* title, const RooArgSet& phfSet, Int_t threshold = 1000000); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:28735,Error,ErrorLoggingMode,28735,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,2,['Error'],['ErrorLoggingMode']
Availability," const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TStringConvertToJSON(const TObject* obj, Int_t compact = 0, const char* member_name = 0); static TStringConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0, const char* member_name = 0); static TStringConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0, Int_t arraylen = -1); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo*, Bool_t); virtual voidForceWriteInfoClones(TClonesArray*); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); virtual const char*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:3149,Error,Error,3149,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,1,['Error'],['Error']
Availability," const double*X() const. protected:. boolCheckMinuitInstance() const; boolCheckVarIndex(unsigned int ivar) const; voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs); TMinuitMinimizer(const TMinuitMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovarvector storing the covariance matrix; unsigned intfDim; vector<double>fErrorsvector of output errors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuitMinimizer.html:5698,error,errors,5698,root/html602/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html602/TMinuitMinimizer.html,4,['error'],['errors']
Availability," const overrideTPolyLinevirtual; TAttLine::Copy(TAttLine &attline) constTAttLine; TAttFill::Copy(TAttFill &attfill) constTAttFill; DeclFileName()TCurlyArcinlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2)TAttLine; DistancetoPrimitive(Int_t px, Int_t py) overrideTCurlyArcvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""") overrideTPolyLinevirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; DrawPolyLine(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")TPolyLinevirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideTCurlyArcvirtual; fAmplitudeTCurlyLineprotected; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fFillColorTAttFillprotected; fFillStyleTAttFillprotected; fgDefaultAmplitudeTCurlyArcprivatestatic; fgDefaultIsCurlyTCurlyArcprivatestatic; fgDefaultWaveLengthTCurlyArcprivatestatic; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fIsCurlyTCurlyLineprotected; fLastPointTPolyLineprotected; fLineColorTAttLineprotected; fLineStyleTAttLineprotected; fLineWidthTAttLineprotected; fNTPolyLineprotected; fNstepsTCurlyLineprotected; fOptionTPolyLineprotected; fPhimaxTCurlyArcprivate; fPhiminTCurlyArcprivate; fR1TCurlyArcprivate; fThetaTCurlyArcprivate; fUniqueIDTObjectprivate; fWaveLengthTCurlyLineprotected; fXTPolyLineprotected; fX1TCurlyLineprotected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCurlyArc-members.html:1665,error,error,1665,doc/master/classTCurlyArc-members.html,https://root.cern,https://root.cern/doc/master/classTCurlyArc-members.html,2,['error'],['error']
Availability," const& absReal) {; 2623 RooLinkedList tmp(plotArgList) ;; 2624 RooCmdConfig::stripCmdList(tmp, ""FillColor"");; 2625 absReal.plotOn(frame, tmp);; 2626 };; 2627 ; 2628 // Generate central value curve; 2629 plotFunc(*this);; 2630 RooCurve* cenCurve = frame->getCurve() ;; 2631 if(!cenCurve){; 2632 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOnWithErrorBand: no curve for central value available"" << std::endl;; 2633 return frame;; 2634 }; 2635 frame->remove(nullptr,false) ;; 2636 ; 2637 RooCurve* band(nullptr) ;; 2638 if (!linMethod) {; 2639 ; 2640 // *** Interval method ***; 2641 //; 2642 // Make N variations of parameters samples from V and visualize N% central interval where N% is defined from Z; 2643 ; 2644 // Clone self for internal use; 2645 RooAbsReal* cloneFunc = static_cast<RooAbsReal*>(cloneTree()) ;; 2646 RooArgSet cloneParams;; 2647 cloneFunc->getObservables(&fr.floatParsFinal(), cloneParams) ;; 2648 RooArgSet errorParams{cloneParams};; 2649 if(params) {; 2650 // clear and fill errorParams only with parameters that both in params and cloneParams; 2651 cloneParams.selectCommon(*params, errorParams);; 2652 }; 2653 ; 2654 // Generate 100 random parameter points distributed according to fit result covariance matrix; 2655 RooAbsPdf* paramPdf = fr.createHessePdf(errorParams) ;; 2656 Int_t n = Int_t(100./TMath::Erfc(Z/sqrt(2.))) ;; 2657 if (n<100) n=100 ;; 2658 ; 2659 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") INFO: visualizing "" << Z << ""-sigma uncertainties in parameters ""; 2660 << errorParams << "" from fit result "" << fr.GetName() << "" using "" << n << "" samplings."" << std::endl ;; 2661 ; 2662 // Generate variation curves with above set of parameter values; 2663 double ymin = frame->GetMinimum() ;; 2664 double ymax = frame->GetMaximum() ;; 2665 std::unique_ptr<RooDataSet> generatedData{paramPdf->generate(errorParams,n)};; 2666 std::vector<RooCurve*> cvec ;; 2667 for (int i=0 ; i<generatedData->numEntries() ; i++) {; 2668 cloneParams",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:116693,error,errorParams,116693,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['error'],['errorParams']
Availability," const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 246 of file RooMsgService.h. ◆ isActive(). template<class T > . bool RooMsgService::isActive ; (; T ; self, . RooFit::MsgTopic ; topic, . RooFit::MsgLevel ; level . ). inline . Check if logging is active for given object/topic/RooFit::MsgLevel combination. ; Definition at line 186 of file RooMsgService.h. ◆ log() [1/3]. ostream & RooMsgService::log ; (; const RooAbsArg * ; self, . RooFit::MsgLevel ; level, . RooFit::MsgTopic ; topic, . bool ; skipPrefix = false . ). Log error message associated with RooAbsArg object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 419 of file RooMsgService.cxx. ◆ log() [2/3]. ostream & RooMsgService::log ; (; const TObject * ; self, . RooFit::MsgLevel ; level, . RooFit::MsgTopic ; topic, . bool ; skipPrefix = false . ). Log error message associated with TObject object self at given level and topic. ; If skipPrefix is true the standard RooMsgService prefix is not added. ; Definition at line 456 of file RooMsgService.cxx. ◆ log() [3/3]. std::ostream & RooMsgService::log ; (; std::nullptr_t ; , . RooFit::MsgLevel ; level, . RooFit::MsgTopic ; facility, . bool ; forceSkipPrefix = false . ). inline . Definition at line 180 of file RooMsgService.h. ◆ numStreams(). Int_t RooMsgService::numStreams ; (; ); const. inline . Definition at line 163 of file RooMsgService.h. ◆ Print(). void RooMsgService::Print ; (; Option_t * ; options = nullptr); const. overridevirtual . Print configuration of message service. ; If ""v"" option is given also inactive streams are listed ; Reimplemented from TObject.; Definition at line 486 of file RooMsgService.cxx. ◆ reset(). void RooMsgService::reset ; (; ). Definition at line 113 of file RooMsgService.cxx. ◆ restoreState(). void RooMsgService::restoreState ; (; ). Restore last saved state of message service. ; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:20432,error,error,20432,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['error'],['error']
Availability," const. private . Definition at line 1133 of file TKDE.cxx. ◆ ComputeMidspread(). Double_t TKDE::ComputeMidspread ; (; ). private . Definition at line 1191 of file TKDE.cxx. ◆ CosineArchKernel(). Double_t TKDE::CosineArchKernel ; (; Double_t ; x); const. inlineprivate . Returns the kernel evaluation at x. ; Definition at line 254 of file TKDE.h. ◆ DeclFileName(). static const char * TKDE::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 301 of file TKDE.h. ◆ Draw(). void TKDE::Draw ; (; const Option_t * ; option = """"). override . Draws either the KDE functions or its errors. ; Definition at line 895 of file TKDE.cxx. ◆ DrawConfidenceInterval(). void TKDE::DrawConfidenceInterval ; (; TString & ; drawOpt, . double ; cl = 0.95 . ). private . // Draws the KDE and its confidence interval ; Definition at line 965 of file TKDE.cxx. ◆ DrawErrors(). void TKDE::DrawErrors ; (; TString & ; drawOpt). private . Draws a TGraphErrors with KDE values and errors. ; Definition at line 931 of file TKDE.cxx. ◆ EpanechnikovKernel(). Double_t TKDE::EpanechnikovKernel ; (; Double_t ; x); const. inlineprivate . Definition at line 244 of file TKDE.h. ◆ Fill() [1/2]. void TKDE::Fill ; (; Double_t ; data). Definition at line 713 of file TKDE.cxx. ◆ Fill() [2/2]. void TKDE::Fill ; (; Double_t ; data, . Double_t ; weight . ). Definition at line 724 of file TKDE.cxx. ◆ GaussianKernel(). Double_t TKDE::GaussianKernel ; (; Double_t ; x); const. inlineprivate . Returns the kernel evaluation at x. ; Definition at line 239 of file TKDE.h. ◆ GetAdaptiveWeights(). const Double_t * TKDE::GetAdaptiveWeights ; (; ); const. Definition at line 990 of file TKDE.cxx. ◆ GetApproximateBias(). TF1 * TKDE::GetApproximateBias ; (; UInt_t ; npx = 100, . Double_t ; xMin = 1.0, . Double_t ; xMax = 0.0 . ). Definition at line 708 of file TKDE.cxx. ◆ GetBias(). Double_t TKDE::GetBias ; (; Double_t ; x); const. Definition at line 1082 of file TKDE.cxx. ◆ Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDE.html:27949,error,errors,27949,doc/master/classTKDE.html,https://root.cern,https://root.cern/doc/master/classTKDE.html,1,['error'],['errors']
Availability," const; Bool_tRooAbsCollection::containsInstance(const RooAbsArg& var) const; stringRooAbsCollection::contentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*RooArgSet::create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; Int_tRooArgSet::getCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*RooArgSet::getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSetProxy.html:3437,Error,Error,3437,root/html534/RooSetProxy.html,https://root.cern,https://root.cern/root/html534/RooSetProxy.html,3,['Error'],['Error']
Availability," const; Bool_tRooAbsCollection::containsInstance(const RooAbsArg& var) const; stringRooAbsCollection::contentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*RooArgSet::create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; Int_tRooArgSet::getCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*RooArgSet::getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSetProxy.html:3437,Error,Error,3437,root/html532/RooSetProxy.html,https://root.cern,https://root.cern/root/html532/RooSetProxy.html,1,['Error'],['Error']
Availability," const; Bool_tTXSocket::IsInterrupt(); Bool_tTObject::IsOnHeap() const; Bool_tTXSocket::IsServProofd(); virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTXSocket::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidTSocket::NetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TXUnixSocket&operator=(const TXUnixSocket&); virtual voidTObject::Paint(Option_t* option = """"); Bool_tTXSocket::Ping(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultTXSocket::ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTXSocket::Recv(TMessage*& mess); virtual Int_tTXSocket::Recv(Int_t& status, Int_t& kind); virtual Int_tTXSocket::Recv(char* mess, Int_t max); virtual Int_tTXSocket::Recv(char* mess, Int_t max, Int_t& kind); virtual Int_tTXSocket::RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidTXSocket::RemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tTXSocke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXUnixSocket.html:5636,Ping,Ping,5636,root/html602/TXUnixSocket.html,https://root.cern,https://root.cern/root/html602/TXUnixSocket.html,2,['Ping'],['Ping']
Availability," const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getComponents() const; Return a RooArgSet with all component (branch nodes) of the; expression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:22639,error,error,22639,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,9,['error'],['error']
Availability," const; Return bin content of a Profile histogram*-*-*-; *-* =========================================. Double_t GetBinEntries(Int_t bin) const; Return bin entries of a Profile histogram*-*-*-; *-* =========================================. Double_t GetBinEffectiveEntries(Int_t bin) const; Return bin effective entries for a weighted filled Profile histogram.; In case of an unweighted profile, it is equivalent to the number of entries per bin; The effective entries is defined as the square of the sum of the weights divided by the; sum of the weights square.; TProfile::Sumw2() must be called before filling the profile with weights.; Only by calling this method the sum of the square of the weights per bin is stored. *-* =========================================. Double_t GetBinError(Int_t bin) const; *-*-*-*-*-*-*Return bin error of a Profile histogram*-*-*-*-*-*-*-*-*-*; *-* =======================================. Computing errors: A moving field. The computation of errors for a TProfile has evolved with the versions; of ROOT. The difficulty is in computing errors for bins with low statistics.; - prior to version 3.00, we had no special treatment of low statistic bins.; As a result, these bins had huge errors. The reason is that the; expression eprim2 is very close to 0 (rounding problems) or 0.; - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; eprim2 very small and the bin errors set to the average bin errors, following; recommendations from a group of users.; - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; should be applied only to low statistic bins.; - in version 3.02 (26 Sep 2001), the same group of users recommend instead; to take two times the average error on all bins for these low; statistics bins giving a very small value for eprim2.; - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; when a TProfile is projected (ProjectionX). The previous algorithm; generated a N^2 problem whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:34299,error,errors,34299,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,10,['error'],['errors']
Availability," const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned long long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_ULong64_t_.html:12254,error,error,12254,root/html534/THnT_ULong64_t_.html,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html,4,['error'],"['error', 'errors']"
Availability," const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:5143,error,error,5143,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,10,['error'],['error']
Availability," const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const vector<Double_t>&GetBoostWeights() const; const vector<TMVA::IMethod*>&GetCommittee() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCommittee.html:2837,error,error,2837,root/html528/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html,4,['error'],['error']
Availability," const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlotCoordinates.html:2109,error,errors,2109,root/html534/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html534/TGLPlotCoordinates.html,2,['error'],['errors']
Availability," const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:8485,Error,Error,8485,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['Error'],['Error']
Availability," const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofServ&operator=(const TProofServ&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); Int_tReceiveFile(const char* file, Bool_t bin, Long64_t size); virtual voidTObject::RecursiveRemove(TObject* obj); static Int_tRegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); virtual voidReleaseWorker(const char*); virtual voidTApplication::RemoveIdleTimer(); voidReset(const char* dir); voidTObject::ResetBit(UInt_t f); static voidResolveKeywords(TString& fname, const char* path = 0); voidRestartComputeTime(); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSendAsynMessage(const char* msg, Bool_t lf = kTRUE); virtual voidSendLogFile(Int_t status = 0, Int_t start = -1, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:10082,error,error,10082,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,4,['error'],['error']
Availability," const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsBinning.html:2015,Error,Error,2015,root/html534/RooAbsBinning.html,https://root.cern,https://root.cern/root/html534/RooAbsBinning.html,3,['Error'],['Error']
Availability," const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector&) const; Double_tDeltaR(const TLorentzVector&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector&) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3&) const; Double_tEt2() const; Double_tEt2(const TVector3&) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLorentzVector.html:8239,error,error,8239,root/html602/TLorentzVector.html,https://root.cern,https://root.cern/root/html602/TLorentzVector.html,4,['error'],['error']
Availability," const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::MnFcn& mfcn, const ROOT::Minuit2::GradientCalculator& gc, const ROOT::Minuit2::MinimumSeed& seed, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn, double toler) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__FumiliMinimizer.html:2420,toler,toler,2420,root/html526/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__FumiliMinimizer.html,7,['toler'],['toler']
Availability," const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t*) const; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual Int_tSetClassSharedLibs(const char* cls, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInterpreter.html:13184,error,error,13184,root/html534/TInterpreter.html,https://root.cern,https://root.cern/root/html534/TInterpreter.html,2,['error'],['error']
Availability," const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); TSlaveLite(const TSlaveLite&); TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. static TSlave::ESlaveStatusTSlave::kActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TSlave::ESlaveStatusTSlave::kInactive; static TSlave::ESlaveStatusTSlave::kInvalid; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TSlave::ESlaveTypeTSlave::kMaster; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlaveLite.html:6365,Ping,Ping,6365,root/html602/TSlaveLite.html,https://root.cern,https://root.cern/root/html602/TSlaveLite.html,2,['Ping'],['Ping']
Availability," const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTChair::CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidTChair::CopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTChair::Draw(Option_t* opt); virtual TH1*TChair::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TChair::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTChair::Fit(const char* formula, const char* varexp, const char* selection = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColumnView.html:2135,Error,Error,2135,root/html532/TColumnView.html,https://root.cern,https://root.cern/root/html532/TColumnView.html,4,['Error'],['Error']
Availability," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCreateGVNode(Agraph_t* gv); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Agnode_t*GetGVNode(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Short_tTAttT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphNode.html:1638,error,error,1638,root/html528/TGraphNode.html,https://root.cern,https://root.cern/root/html528/TGraphNode.html,4,['error'],['error']
Availability," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual RooStats::MarkovChain*ConstructChain(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MetropolisHastings.html:2944,error,error,2944,root/html526/RooStats__MetropolisHastings.html,https://root.cern,https://root.cern/root/html526/RooStats__MetropolisHastings.html,11,['error'],['error']
Availability," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoamIntegrand.html:1541,error,error,1541,root/html528/TFoamIntegrand.html,https://root.cern,https://root.cern/root/html528/TFoamIntegrand.html,10,['error'],['error']
Availability," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolCheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetProposalDensity(RooArgSet& x1, RooArgSet& x2); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProposalFunction.html:2121,error,error,2121,root/html526/RooStats__ProposalFunction.html,https://root.cern,https://root.cern/root/html526/RooStats__ProposalFunction.html,11,['error'],['error']
Availability," const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; boolCompareHisto(const TH1* one, const TH1* two) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; RooStats::HistFactory::EstimateSummaryEstimateSummary(); RooStats::HistFactory::EstimateSummaryEstimateSummary(const RooStats::HistFactory::EstimateSummary&); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html:1716,error,error,1716,root/html528/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html,10,['error'],['error']
Availability," const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; Int_tgetCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:5281,error,error,5281,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,7,['error'],['error']
Availability," const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; RooAbsArg*RooAbsCollection::find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooAbsCollection::getSize() const; virtual co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgList.html:5136,error,error,5136,root/html534/RooArgList.html,https://root.cern,https://root.cern/root/html534/RooArgList.html,6,['error'],['error']
Availability," const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; Int_tgetCatIndex(const char* name, Int_t defVal = 0, Bool_t verbose = kFALSE) const; const char*getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:5241,error,error,5241,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,3,['error'],['error']
Availability," const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; RooFIterRooAbsCollection::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooAbsCollection::getSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgList.html:5136,error,error,5136,root/html532/RooArgList.html,https://root.cern,https://root.cern/root/html532/RooArgList.html,1,['error'],['error']
Availability," const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidRooAbsCollection::dump() const; virtual voidTObject::Dump() constMENU ; Bool_tRooAbsCollection::equals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*RooAbsCollection::find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsCollection::first() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooAbsCollection::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooAbsCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooAbsCollection::getSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgList.html:5096,error,error,5096,root/html526/RooArgList.html,https://root.cern,https://root.cern/root/html526/RooArgList.html,3,['error'],['error']
Availability," const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); Int_tReceiveFile(const char* file, Bool_t bin, Long64_t size); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidReset(const char* dir); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:8176,error,error,8176,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,2,['error'],['error']
Availability," const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/PyROOT__TPyROOTApplication.html:8680,error,error,8680,root/html526/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html526/PyROOT__TPyROOTApplication.html,3,['error'],['error']
Availability," const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCustomized(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQApplication.html:8110,error,error,8110,root/html528/TQApplication.html,https://root.cern,https://root.cern/root/html528/TQApplication.html,1,['error'],['error']
Availability," const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTChain::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TChain::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofChain.html:4882,error,error,4882,root/html528/TProofChain.html,https://root.cern,https://root.cern/root/html528/TProofChain.html,2,['error'],['error']
Availability," const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNPoints(unsigned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDimOptions.html:2541,toler,tolerance,2541,root/html528/ROOT__Math__IntegratorOneDimOptions.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDimOptions.html,12,['toler'],['tolerance']
Availability," const; { return fOtherTypes[12]; }. Bool_t GetUseSuffixes() const; configuration of SQL. { return fUseSuffixes; }. Int_t GetArrayLimit() const; { return fArrayLimit; }. void SkipArrayLimit(); { SetArrayLimit(-1); }. const char* GetTablesType() const; { return fTablesType.Data(); }. Int_t GetUseTransactions() const; { return fUseTransactions; }. Int_t GetUseIndexes() const; { return fUseIndexes; }. Int_t GetQuerisCounter() const; { return fQuerisCounter; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. » Author: Sergey Linev 20/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sql:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:49690,Recover,Recover,49690,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,1,['Recover'],['Recover']
Availability," const;  Get Line Width for specified error e (-1 = Global and x errors). ;  ; Int_t GetNYErrors () const;  ; Int_t GetSumErrorsMode () const;  ; TClass * IsA () const override;  ; TGraphMultiErrors & operator= (const TGraphMultiErrors &tgme);  TGraphMultiErrors assignment operator. ;  ; void Print (Option_t *chopt="""") const override;  Print graph and errors values. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; void Scale (Double_t c1=1., Option_t *option=""y"") override;  Multiply the values and errors of a TGraphMultiErrors by a constant c1. ;  ; virtual void SetAttFill (Int_t e, TAttFill *taf);  Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors). ;  ; virtual void SetAttLine (Int_t e, TAttLine *tal);  Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors). ;  ; virtual void SetEY (Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH);  Set error e ey values. ;  ; virtual void SetEYhigh (Int_t e, Int_t np, const Double_t *eyH);  Set error e eyH values. ;  ; virtual void SetEYlow (Int_t e, Int_t np, const Double_t *eyL);  Set error e eyL values. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColor (Int_t e, Color_t fcolor);  Set Fill Color of error e (-1 = Global and x errors). ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillColorAlpha (Int_t e, Color_t fcolor, Float_t falpha);  Set Fill Color and Alpha of error e (-1 = Global and x errors). ;  ; virtual void SetFillStyle (Int_t e, Style_t fstyle);  Set Fill Style of error e (-1 = Global and x errors). ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColor (Int_t e, Color_t lcolor);  Set L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:13761,error,error,13761,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability," const;  return correlation coefficient between variable i and j. ;  ; virtual double CovMatrix (unsigned int ivar, unsigned int jvar) const;  return covariance matrices element for variables ivar,jvar if the variable is fixed the return value is zero The ordering of the variables is the same as in the parameter and errors vectors ;  ; virtual int CovMatrixStatus () const;  return status of covariance matrix using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate} Minimizer who implements covariance matrix calculation will re-implement the method ;  ; virtual double Edm () const;  return expected distance reached from the minimum (re-implement if minimizer provides it ;  ; double ErrorDef () const;  return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization ;  ; virtual const double * Errors () const;  return errors at the minimum ;  ; virtual bool FixVariable (unsigned int ivar);  fix an existing variable ;  ; virtual bool GetCovMatrix (double *covMat) const;  Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ;  ; virtual bool GetHessianMatrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual bool GetVariableSettings (unsigned int ivar, ROOT::Fit::ParameterSettings &pars) const;  get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ;  ; virtual dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:5535,error,errors,5535,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['error'],['errors']
Availability," constTMVA::Event * >::const_iterator EventItr;  . Protected Member Functions; Double_t CalcAverageResponse ();  calculate the average response - TODO : rewrite bad dependancy on EvaluateAverage() ! ;  ; Double_t CalcAverageResponseOLD ();  ; Double_t CalcAverageTruth ();  calculate the average truth ;  ; void CalcFStar ();  Estimates F* (optimum scoring function) for all events for the given sets. ;  ; void CalcGDNTau ();  ; void CalcTstAverageResponse ();  calc average response for all test paths - TODO: see comment under CalcAverageResponse() note that 0 offset is used ;  ; Double_t ErrorRateBin ();  Estimates the error rate with the current set of parameters It uses a binary estimate of (y-F*(x)) (y-F*(x)) = (Num of events where sign(F)!=sign(y))/Neve y = {+1 if event is signal, -1 otherwise} — NOT USED —. ;  ; Double_t ErrorRateReg ();  Estimates the error rate with the current set of parameters This code is pretty messy at the moment. ;  ; Double_t ErrorRateRoc ();  Estimates the error rate with the current set of parameters. ;  ; Double_t ErrorRateRocRaw (std::vector< Double_t > &sFsig, std::vector< Double_t > &sFbkg);  Estimates the error rate with the current set of parameters. ;  ; void ErrorRateRocTst ();  Estimates the error rate with the current set of parameters. ;  ; void EvaluateAverage (UInt_t ind1, UInt_t ind2, std::vector< Double_t > &avsel, std::vector< Double_t > &avrul);  evaluate the average of each variable and f(x) in the given range ;  ; void EvaluateAveragePath ();  ; void EvaluateAveragePerf ();  ; void FillCoefficients ();  helper function to store the rule coefficients in local arrays ;  ; void InitNtuple ();  initializes the ntuple ;  ; void MakeGradientVector ();  make gradient vector ;  ; void MakeTstGradientVector ();  make test gradient vector for all tau same algorithm as MakeGradientVector() ;  ; Double_t Optimism ();  implementation of eq. ;  ; void UpdateCoefficients ();  Establish maximum gradient for rules, linear terms and th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:3545,error,error,3545,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['error'],['error']
Availability," constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TH2PolyBin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void Fill (Double_t value, Double_t weight);  Fill. ;  ; void SetErrorOption (EErrorType type);  ; void UpdateAverage ();  Update average. ;  ; void UpdateError ();  Update error. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; Double_t fAverage;  ; Double_t fError;  ; EErrorType fErrorMode = kERRORMEAN;  ; Double_t fSumvw;  ; Double_t fSumw;  ; Double_t fSumw2;  ; Double_t fSumwv2;  . Friends; class TProfile2Poly;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2PolyBin.html:10901,error,error,10901,doc/master/classTProfile2PolyBin.html,https://root.cern,https://root.cern/doc/master/classTProfile2PolyBin.html,1,['error'],['error']
Availability," construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7078,error,error,7078,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,4,['error'],['error']
Availability," construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:2311,error,error,2311,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,1,['error'],['error']
Availability," contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:10924,error,error,10924,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability," content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;*"");; 1540 ; 1541void TDirectoryFile::rmdir(const char *name); 1542{; 1543 if (!name || (*name==0)) return;; 1544 ; 1545 TString mask(name);; 1546 mask += "";*"";; 1547 Delete(mask);; 1548}; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Save recursively all directory keys and headers; 1552 ; 1553void TDirectoryFile::Save(); 1554{; 1555 TDirectory::TContext ctxt(this);; 1556 ; 1557 SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:52506,mask,mask,52506,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,3,['mask'],['mask']
Availability," content of the branch. If a Data Model Evolution conversion; 2849/// is involved, reset the fInfo of the branch.; 2850/// The return values are:; 2851//; 2852/// - kMissingBranch (-5) : Missing branch; 2853/// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); 2854/// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been iss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:112772,avail,available,112772,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avail'],['available']
Availability," content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH1D using the 2-nd value as a weight. This makes sense only for profile filled with weights =1. If not, the error of the projected histogram obtained with this option will not be correct. . Definition at line 1283 of file TProfile.cxx. ◆ PutStats(). void TProfile::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimplemented from TH1.; Definition at line 1358 of file TProfile.cxx. ◆ Rebin(). TH1 * TProfile::Rebin ; (; Int_t ; ngroup = 2, . const char * ; newname = """", . const Double_t * ; xbins = nullptr . ). overridevirtual . Rebin this profile grouping ngroup bins together. . case 1 xbins=0; if newname is not blank a new temporary profile hnew is created. else the current profile is modified (default) The parameter ngroup indicates how many bins of this have to me merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.; examples: if hp is an existing TProfile histogram with 100 bins; hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; hp->Rebin(5); //merges five bins in one in hp; TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; //merging 5 bins of hp in one bin; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::RebinTH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideRebin this profile grouping ngroup bins together.Definition TProfile.cxx:1410; NOTE: If ngroup is not an exact divider of the number of bins, the top limit of the rebinned profile is changed to the upper edge of the bin=newbins*ngroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents. case 2 xbins!=0; a new profile is created (you should specify newname",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:81686,error,errors,81686,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,2,['error'],['errors']
Availability," contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x, y and in z. ; Reimplemented from TH1.; Definition at line 1390 of file TH3.cxx. ◆ IntegralAndError() [1/2]. Double_t TH1::IntegralAndError ; (; Int_t ; binx1, . Int_t ; binx2, . Double_t & ; error, . Option_t * ; option = """" . ); const. privatevirtual . Return integral of bin contents in range [binx1,binx2] and its error. ; By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x. the error is computed using error propagation from the bin errors assuming that all the bins are uncorrelated ; Reimplemented from TH1.; Definition at line 332 of file TH1.cxx. ◆ IntegralAndError() [2/2]. Double_t TH3::IntegralAndError ; (; Int_t ; binx1, . Int_t ; binx2, . Int_t ; biny1, . Int_t ; biny2, . Int_t ; binz1, . Int_t ; binz2, . Double_t & ; error, . Option_t * ; option = """" . ); const. virtual . Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram. ; Calculates also the integral error using error propagation from the bin errors assuming that all the bins are uncorrelated. By default the integral is computed as the sum of bin contents in the range. if option ""width"" is specified, the integral is the sum of the bin contents multiplied by the bin width in x, y and in z. ; Definition at line 1421 of file TH3.cxx. ◆ Interpolate() [1/3]. Double_t TH3::Interpolate ; (; Double_t ; x); const. overrideprotectedvirtual . Not yet implemented. ; Reimplemented from TH1.; Definition at line 1431 of file TH3.cxx. ◆ Interpolate() [2/3]. Double_t TH3::Interpolate ; (; Double_t ; x, . Double_t ; y . ); const. overrideprotectedvirtual . Not yet implemented. ; Reimplemented from TH1.; Definition at line 1441 of file TH3.cxx. ◆ Interpolate() [3/3]. Double_t TH3::Interpolate ; (; Double_t ; x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:87108,error,error,87108,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['error'],['error']
Availability," context ;  ; TGString * fPath;  entry path ;  ; const TGPicture * fPic;  entry picture ;  ; TGSelectedPicture * fSelPic;  selected picture ;  ; TGString * fText;  entry description ;  ; UInt_t fTHeight;  height of entry text ;  ; UInt_t fTWidth;  width of entry text ;  ;  Protected Attributes inherited from TGLBEntry; Bool_t fActive;  true if entry is active ;  ; Pixel_t fBkcolor;  entry background color ;  ; Int_t fEntryId;  message id of listbox entry ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Static Protected Attributes; static const TGFont * fgDefaultFont = nullptr;  ; static TGGC * fgDefaultGC = nullptr;  ;  Static Protected Attributes inherited from TGFrame; static const TGGC * fgBckgndGC = nullptr;  ; static const TGGC * fgBlackGC = nullptr;  ; static P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTreeLBEntry.html:24398,mask,mask,24398,doc/master/classTGTreeLBEntry.html,https://root.cern,https://root.cern/doc/master/classTGTreeLBEntry.html,1,['mask'],['mask']
Availability," control variable which is unknown to the fit, the two ; for signal and background shown in Fig. 3. One observes that the . for signal reproduces correctly the PDF even where the latter vanishes,; although the error bars remain sizeable. This results from the almost; complete cancellation between positive and negative weights: the sum of; weights is close to zero while the sum of weights squared is not. The; occurence of negative weights occurs through the appearance of the; covariance matrix, and its negative components, in the definition of; Eq. (2). A word of caution is in order with respect to the error bars. Whereas; their sum in quadrature is identical to the statistical uncertainties; of the yields determined by the fit, and if, in addition, they are; asymptotically correct, the error bars should be handled with care for; low statistics and/or for too fine binning. This is because the error; bars do not incorporate two known properties of the PDFs: PDFs are; positive definite and can be non-zero in a given x-bin, even if in the; particular data sample at hand, no event is observed in this bin. The; latter limitation is not specific to; ,; rather it is always present when one is willing to infer the PDF at the; origin of an histogram, when, for some bins, the number of entries does; not guaranty the applicability of the Gaussian regime. In such; situations, a satisfactory practice is to attach allowed ranges to the; histogram to indicate the upper and lower limits of the PDF value which; are consistent with the actual observation, at a given confidence; level. Figure 3:; The ; (signal on the left, background on the right) obtained for are represented as dots with error bars. They are obtained from a fit using only information from and . Chosing and as discriminating variables to determine and through a maximum Likelihood fit, one builds, for the control variable which is unknown to the fit, the two ; for signal and background shown in Fig. 4. In the ; for signa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:7675,error,error,7675,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,10,['error'],['error']
Availability," converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4306,error,error,4306,root/html534/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html,18,['error'],['error']
Availability," correctForBinWidth = kTRUE, Double_t scaleFactor = 1.0); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addBinWithXYError(Axis_t binCenter, Double_t n, Double_t exlow, Double_t exhigh, Double_t eylow, Double_t eyhigh, Double_t scaleFactor = 1.0); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addAsymmetryBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an error bar calculated with Binomial statistics. void addAsymmetryBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 1e-6) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHist.html:23936,error,error,23936,root/html526/RooHist.html,https://root.cern,https://root.cern/root/html526/RooHist.html,7,['error'],['error']
Availability," correction to errors and covariance matrix. This uses two covariance matrices, one with the weights, the other with squared weights, to obtain the correct errors for weighted likelihood fits. If this option is activated, the corrected covariance matrix is calculated as \( V_\mathrm{corr} = V C^{-1} V \), where \( V \) is the original covariance matrix and \( C \) is the inverse of the covariance matrix calculated using the squared weights. This allows to switch between two interpretations of errors: . SumW2Error Interpretation . true The errors reflect the uncertainty of the Monte Carlo simulation. Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; Example: Simulation with 1000 events, the average weight is 0.1. The errors are as big as if one fitted to 1000 events. . false The errors reflect the errors of a dataset, which is as big as the sum of weights. Use this if you want to know what statistical errors you would get if you had a dataset with as many events as the (weighted) Monte Carlo simulation represents.; Example (Data as above): The errors are as big as if one fitted to 100 events. . NoteIf the SumW2Error correction is enabled, the covariance matrix quality stored in the RooFitResult object will be the minimum of the original covariance matrix quality and the quality of the covariance matrix calculated with the squared weights. . AsymptoticError() Use the asymptotically correct approach to estimate errors in the presence of weights. This is slower but more accurate than SumW2Error. See also https://arxiv.org/abs/1911.01303). This option even correctly implements the case of extended likelihood fits (see this writeup on extended weighted fits that complements the paper linked before). . PrefitDataFraction(double fraction) Runs a prefit on a small dataset of size fraction*(actual data size). This can speed up fits by finding good starting values for the parameters for the actual fit. WarningPrefitting may g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:108025,error,errors,108025,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['errors']
Availability," costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); Define view direction (in spherical coordinates). Compute transformation matrix from world coordinates; to normalised coordinates (-1 to +1). Input: S(3) - scale factors; C(3) - centre of scope; COSPHI - longitude COS; SINPHI - longitude SIN; COSTHE - latitude COS (angle between +Z and view direc.); SINTHE - latitude SIN; COSPSI - screen plane rotation angle COS; SINPSI - screen plane rotation angle SIN. void DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); Draw the outline of a cube while rotaing a 3-d object in the pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void ExecuteRotateView(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a object is clicked with the locator. If Left button clicked in the object area, while the button is kept down; the cube representing the surrounding frame for the corresponding; new latitude and longitude position is drawn. void FindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); Find Z component of NORMAL in normalized coordinates. Input: X - X-component of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView3D.html:15581,down,down,15581,root/html528/TView3D.html,https://root.cern,https://root.cern/root/html528/TView3D.html,1,['down'],['down']
Availability, covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 95 of file TLinearMinimizer.h. ◆ CovMatrixStatus(). int TLinearMinimizer::CovMatrixStatus ; (; ); const. inlineoverridevirtual . return covariance matrix status ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 100 of file TLinearMinimizer.h. ◆ DeclFileName(). static const char * TLinearMinimizer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 126 of file TLinearMinimizer.h. ◆ Edm(). double TLinearMinimizer::Edm ; (; ); const. inlineoverridevirtual . return expected distance reached from the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 66 of file TLinearMinimizer.h. ◆ Errors(). const double * TLinearMinimizer::Errors ; (; ); const. inlineoverridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 89 of file TLinearMinimizer.h. ◆ IsA(). virtual TClass * TLinearMinimizer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 126 of file TLinearMinimizer.h. ◆ MinGradient(). const double * TLinearMinimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 72 of file TLinearMinimizer.h. ◆ Minimize(). bool TLinearMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Implements ROOT::Math::Minimizer.; Definition at line 197 of file TLinearMinimizer.cxx. ◆ MinValue(). double TLinearMinimizer::MinValue ; (; ); const. inlineoverridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 63 of file TLinearMinimizer.h. ◆ NCalls(). unsigned int TLinearMinimizer::NCalls ; (; ); const. inlineoverridevirtual . numbe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:13513,error,errors,13513,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['error'],['errors']
Availability," createEmptyDataSets = false . ); const. virtual . Split the dataset into subsets based on states of a categorical variable in this dataset. ; Returns a list of sub-datasets, which each dataset named after a given state name in the splitCat. The observables splitCat itself is no longer present in the sub-datasets.; NoteIf you mean to split a dataset into sub-datasets that correspond to the individual channels of a RooSimultaneous, it is better to use RooAbsData::split(const RooSimultaneous &, bool), because then the sub-datasets only contain variables that the pdf for the corresponding channel depends on. This is much faster in case of many channels, and the resulting sub-datasets don't waste memory for unused columns.; Parameters. splitCatThe categorical variable used for splitting the dataset. ; createEmptyDataSetsFlag indicating whether to create empty datasets for missing categories (false by default). ReturnsAn owning pointer to a TList of subsets of the dataset. Returns nullptr if an error occurs. ; Definition at line 1552 of file RooAbsData.cxx. ◆ split() [2/2]. RooFit::OwningPtr< TList > RooAbsData::split ; (; const RooSimultaneous & ; simPdf, . bool ; createEmptyDataSets = false . ); const. virtual . Split the dataset into subsets based on the channels of a RooSimultaneous. ; Returns a list of sub-datasets, which each dataset named after the applicable state name of the RooSimultaneous index category. The index category itself is no longer present in the sub-datasets. The sub-datasets only contain variables that the pdf for the corresponding channel depends on.; Parameters. simPdfThe simultaneous pdf used for splitting the dataset. ; createEmptyDataSetsFlag indicating whether to create empty datasets for missing categories (false by default). ReturnsAn owning pointer to a TList of subsets of the dataset. Returns nullptr if an error occurs. ; Definition at line 1584 of file RooAbsData.cxx. ◆ standMoment(). double RooAbsData::standMoment ; (; const RooRealVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:69521,error,error,69521,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['error'],['error']
Availability," created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:25378,error,error,25378,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,20,['error'],['error']
Availability," criterion. Function Members (Methods); public:. virtual~GiniIndexWithLaplace(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); virtual TClass*IsA() const; TMVA::GiniIndexWithLaplace&operator=(const TMVA::GiniIndexWithLaplace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Gini(Sample M) = 1 - (c(1)/N)^2 - (c(2)/N)^2 .... - (c(k)/N)^2; Where: M is a smaple of whatever N elements (events); that belong to K different classes; c(k) is the number of elements that belong to class k; Laplace's correction to the prob.density c/N --> (c+1)/(N+2); for just Signal and Background classes this then boils down to:; Gini(Sample) = 2(s*b+s+b+1)/(s+b+2)^2. GiniIndexWithLaplace(); construtor for the GiniIndexWithLaplace. { fName=""GiniLaplace""; }. GiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); copy constructor. {}. virtual ~GiniIndexWithLaplace(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GiniIndexWithLaplace.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__GiniIndexWithLaplace.html:1761,down,down,1761,root/html530/TMVA__GiniIndexWithLaplace.html,https://root.cern,https://root.cern/root/html530/TMVA__GiniIndexWithLaplace.html,1,['down'],['down']
Availability," cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:12069,error,error,12069,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,10,['error'],['error']
Availability," ctor. TProofMgr * Mgr(const char* url); Get instance of the effective manager for 'url'; Return 0 on failure. void Reset(const char* url, Bool_t hard = kFALSE); Wrapper around TProofMgr::Reset(...). const TList * GetEnvVars(); Get environemnt variables. void AddEnvVar(const char* name, const char* value); Add an variable to the list of environment variables passed to proofserv; on the master and slaves. void DelEnvVar(const char* name); Remove an variable from the list of environment variables passed to proofserv; on the master and slaves. void ResetEnvVars(); Clear the list of environment variables passed to proofserv; on the master and slaves. void SaveWorkerInfo(); Save information about the worker set in the file .workers in the working; dir. Called each time there is a change in the worker setup, e.g. by; TProof::MarkBad(). Int_t GetParameter(TCollection* c, const char* par, TString& value); Get the value from the specified parameter from the specified collection.; Returns -1 in case of error (i.e. list is 0, parameter does not exist; or value type does not match), 0 otherwise. Int_t GetParameter(TCollection* c, const char* par, Int_t& value); Get the value from the specified parameter from the specified collection.; Returns -1 in case of error (i.e. list is 0, parameter does not exist; or value type does not match), 0 otherwise. Int_t GetParameter(TCollection* c, const char* par, Long_t& value); Get the value from the specified parameter from the specified collection.; Returns -1 in case of error (i.e. list is 0, parameter does not exist; or value type does not match), 0 otherwise. Int_t GetParameter(TCollection* c, const char* par, Long64_t& value); Get the value from the specified parameter from the specified collection.; Returns -1 in case of error (i.e. list is 0, parameter does not exist; or value type does not match), 0 otherwise. Int_t GetParameter(TCollection* c, const char* par, Double_t& value); Get the value from the specified parameter from the spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:99582,error,error,99582,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['error'],['error']
Availability," cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for other error options and more detailed explanations. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*; ; */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Double_t ylow, Double_t yup, Option_t* option = """"); TProfile(const char* name, const char* title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:2016,error,error,2016,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,2,['error'],['error']
Availability," cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for other error options and more detailed explanations. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*; ; */. Function Members (Methods); public:. virtual~TProfile(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH1D::AddBinContent(Int_t bin); virtual voidTH1D::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:2016,error,error,2016,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,4,['error'],['error']
Availability," data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 13.2274; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 1.28042 0.721714 1.40039 0.112743 931.931 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.744775 0.695682 1.39558 0.112793 935.465 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.694124 0.686492 1.40809 0.112179 925.986 0; : 4 | 0.679848 0.699399 1.40006 0.109116 929.552 1; : 5 Minimum Test error found - save the configuration ; : 5 | 0.670651 0.682024 1.40299 0.112234 929.685 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.652355 0.665731 1.40537 0.11341 928.823 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.647198 0.663594 1.40991 0.11661 927.858 0; : 8 | 0.624112 0.674678 1.40336 0.112656 929.728 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.597489 0.647076 1.41653 0.119736 925.361 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.561268 0.630455 1.40233 0.116045 932.919 0; : ; : Elapsed time for training with 1600 events: 14.2 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.629 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:14991,error,error,14991,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['error'],['error']
Availability," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:1212,avail,available,1212,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,9,['avail'],['available']
Availability," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:1212,avail,available,1212,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['avail'],['available']
Availability," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; RooBrentRootFinder&operator=(const RooBrentRootFinder&); RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. static RooBrentRootFinder::(anonymous)MaxIterations; const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Tue Jun 2 15:28:09 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooBrentRootFinder.html:1948,toler,tolerance,1948,root/html604/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html604/RooBrentRootFinder.html,2,['toler'],['tolerance']
Availability," data param length: number of bytes to be read returns: kTRUE in case of failure ; Reimplemented from TFile.; Definition at line 407 of file TNetXNGFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TNetXNGFile::ReadBuffer ; (; char * ; buffer, . Long64_t ; position, . Int_t ; length . ). overridevirtual . Read a data chunk of the given size, starting from the given offset. ; param buffer: a pointer to a buffer big enough to hold the data param position: offset from the beginning of the file param length: number of bytes to be read returns: kTRUE in case of failure ; Reimplemented from TFile.; Definition at line 420 of file TNetXNGFile.cxx. ◆ ReadBuffers(). Bool_t TNetXNGFile::ReadBuffers ; (; char * ; buffer, . Long64_t * ; position, . Int_t * ; length, . Int_t ; nbuffs . ). overridevirtual . Read scattered data chunks in one operation. ; param buffer: a pointer to a buffer big enough to hold all of the requested data param position: position[i] is the seek position of chunk i of len length[i] param length: length[i] is the length of the chunk at offset position[i] param nbuffs: number of chunks returns: kTRUE in case of failure ; Reimplemented from TFile.; Definition at line 487 of file TNetXNGFile.cxx. ◆ ReOpen(). Int_t TNetXNGFile::ReOpen ; (; Option_t * ; modestr). overridevirtual . Reopen the file with the new access mode. ; param mode: the new access mode returns: 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore ; Reimplemented from TFile.; Definition at line 363 of file TNetXNGFile.cxx. ◆ Seek(). void TNetXNGFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; position = kBeg . ). overridevirtual . Set the position within the file. ; param offset: the new offset relative to position param position: the relative position, either kBeg, kCur or kEnd ; Reimplemented from TFile.; Definition at line 689 of file TNetXNGFile.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:46523,failure,failure,46523,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['failure'],['failure']
Availability," data to stderr**; 198 /// ~~~ {.cpp}; 199 /// #include <ROOT/RNTupleReader.hxx>; 200 /// using ROOT::Experimental::ENTupleInfo;; 201 /// using ROOT::Experimental::RNTupleReader;; 202 ///; 203 /// #include <iostream>; 204 ///; 205 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 206 /// ntuple->PrintInfo(ENTupleInfo::kStorageDetails, std::cerr);; 207 /// ~~~; 208 ///; 209 /// For use of ENTupleInfo::kMetrics, see #EnableMetrics.; 210 void PrintInfo(const ENTupleInfo what = ENTupleInfo::kSummary, std::ostream &output = std::cout) const;; 211 ; 212 /// Shows the values of the i-th entry/row, starting with 0 for the first entry. By default,; 213 /// prints the output in JSON format.; 214 /// Uses the visitor pattern to traverse through each field of the given entry.; 215 void Show(NTupleSize_t index, std::ostream &output = std::cout);; 216 ; 217 /// Analogous to Fill(), fills the default entry of the model. Returns false at the end of the ntuple.; 218 /// On I/O errors, raises an exception.; 219 void LoadEntry(NTupleSize_t index); 220 {; 221 // TODO(jblomer): can be templated depending on the factory method / constructor; 222 if (R__unlikely(!fModel)) {; 223 fModel = fSource->GetSharedDescriptorGuard()->CreateModel();; 224 ConnectModel(*fModel);; 225 }; 226 LoadEntry(index, fModel->GetDefaultEntry());; 227 }; 228 /// Fills a user provided entry after checking that the entry has been instantiated from the ntuple model; 229 void LoadEntry(NTupleSize_t index, REntry &entry) { entry.Read(index); }; 230 ; 231 /// Returns an iterator over the entry indices of the RNTuple.; 232 ///; 233 /// **Example: iterate over all entries and print each entry in JSON format**; 234 /// ~~~ {.cpp}; 235 /// #include <ROOT/RNTupleReader.hxx>; 236 /// using ROOT::Experimental::ENTupleShowFormat;; 237 /// using ROOT::Experimental::RNTupleReader;; 238 ///; 239 /// #include <iostream>; 240 ///; 241 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 242 /// f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:9590,error,errors,9590,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['error'],['errors']
Availability," data3 = nullptr, . RooDataSet * ; data4 = nullptr, . RooDataSet * ; data5 = nullptr, . RooDataSet * ; data6 = nullptr . ). Definition at line 1079 of file RooDataSet.cxx. ◆ merge() [2/2]. bool RooDataSet::merge ; (; std::list< RooDataSet * > ; dsetList). Merge columns of supplied data set(s) with this data set. ; All data sets must have equal number of entries. In case of duplicate columns the column of the last dataset in the list prevails ; Definition at line 1101 of file RooDataSet.cxx. ◆ plotOnXY(). RooDataSet::plotOnXY ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. virtual . Special plot method for 'X-Y' datasets used in \( \chi^2 \) fitting. ; For general plotting, see RooAbsData::plotOn().; These datasets have one observable (X) and have weights (Y) and associated errors. . Contents options Effect . YVar(RooRealVar& var) Designate specified observable as 'y' variable If not specified, the event weight will be the y variable . Histogram drawing options Effect . DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object . LineStyle(Int_t style) Select line style by ROOT line style code, default is solid . LineColor(Int_t color) Select line color by ROOT color code, default is black . LineWidth(Int_t width) Select line with in pixels, default is 3 . MarkerStyle(Int_t style) Select the ROOT marker style, default is 21 . MarkerColor(Int_t color) Select the ROOT marker color, default is black . MarkerSize(double size) Select the ROOT marker size . Rescale(double factor) Apply global rescaling factor to histogram . Misc. other options Effect . Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later . Invisible(bool flag) Add curve to frame, but do not d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:51416,error,errors,51416,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['error'],['errors']
Availability," dataDefinition BinData.h:604; ROOT::Fit::BinData::GetBinUpEdgeCoordinatesvoid GetBinUpEdgeCoordinates(unsigned int ipoint, double *x) constThread save version of function retrieving the bin up-edge in case of multidimensions.Definition BinData.h:532; ROOT::Fit::BinData::fDataErrorPtrconst double * fDataErrorPtrDefinition BinData.h:623; ROOT::Fit::BinData::fSumError2double fSumError2total sum square of the errorsDefinition BinData.h:606; ROOT::Fit::BinData::fpTmpBinEdgeVectordouble * fpTmpBinEdgeVectornot threadsafe stuff!Definition BinData.h:634; ROOT::Fit::BinData::fDataErrorstd::vector< double > fDataErrorDefinition BinData.h:620; ROOT::Fit::BinData::Errordouble Error(unsigned int ipoint) constReturn the error on the given point.Definition BinData.h:262; ROOT::Fit::BinData::HaveAsymErrorsbool HaveAsymErrors() constflag to control if data provides asymmetric errors on the valueDefinition BinData.h:146; ROOT::Fit::BinData::SumOfError2double SumOfError2() constcompute the total sum of the error square (sum of weight square in case of a weighted data set)Definition BinData.h:577; ROOT::Fit::BinData::ErrorTypeErrorTypeDefinition BinData.h:56; ROOT::Fit::BinData::kNoError@ kNoErrorDefinition BinData.h:56; ROOT::Fit::BinData::kCoordError@ kCoordErrorDefinition BinData.h:56; ROOT::Fit::BinData::kAsymError@ kAsymErrorDefinition BinData.h:56; ROOT::Fit::BinData::kValueError@ kValueErrorDefinition BinData.h:56; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value, double &invError) constretrieve in a single call a pointer to the coordinate data, value and inverse error for the given fit...Definition BinData.h:439; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::fMaxPointsunsigned int fMaxPointsDefinition FitData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:29949,error,error,29949,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['error'],['error']
Availability," dataset on specified frame. ; By default:; An unbinned dataset will use the default binning of the target frame.; A binned dataset will retain its intrinsic binning. The following optional named arguments can be used to modify the behaviour: NotePlease follow the function links in the left column to learn about PyROOT specifics for a given option. Data representation options . RooFit::Asymmetry(const RooCategory& c) Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)]. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. . RooFit::Efficiency(const RooCategory& c) Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1 . RooFit::DataError(Int_t) Select the type of error drawn:; Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; Poisson draws asymmetric Poisson confidence intervals.; SumW2 draws symmetric sum-of-weights error ( \( \left( \sum w \right)^2 / \sum\left(w^2\right) \) ); None draws no error bars . RooFit::Binning(int nbins, double xlo, double xhi) Use specified binning to draw dataset . RooFit::Binning(const RooAbsBinning&) Use specified binning to draw dataset . RooFit::Binning(const char* name) Use binning with specified name to draw dataset . RooFit::RefreshNorm() Force refreshing for PDF normalization information in frame. If set, any subsequent PDF will normalize to this dataset, even if it is not the first one added to the frame. By default only the 1st dataset added to a frame will update the normalization information . RooFit::Rescale(double f) Rescale drawn histogram by given factor. . RooFit::Cut(const char*) Only plot entries that pass the given cut. Apart from cutting in continuous variables Cut(""x>5""), this can also be used to plot a specific category state. Use something like Cut(""myCategory == myCategory::stateA""), where myCategory resolves to the state number for a given entry and myCategory::stateA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:68342,error,error,68342,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,4,['error'],['error']
Availability," dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:29693,error,error,29693,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,6,['error'],['error']
Availability," dataset); virtual TObject*AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDoOwner(Bool_t done = kTRUE); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectSet.html:2120,error,error,2120,root/html528/TObjectSet.html,https://root.cern,https://root.cern/root/html528/TObjectSet.html,10,['error'],['error']
Availability," datasetName = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpCfg(const char* cardname); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; RooAbsPdf*GetTotBkgPdf(); RooCategory*GetTotCategory(); RooDataSet*GetTotDataSet(); RooAbsPdf*GetTotSigBkgPdf(); virtual UInt_tTObject::GetUniqueID() const; RooWorkspace*GetWs(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HLFactoryHLFactory(); RooStats",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HLFactory.html:1770,error,error,1770,root/html526/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html526/RooStats__HLFactory.html,2,['error'],['error']
Availability," datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:102702,avail,available,102702,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['avail'],['available']
Availability," datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 705 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:102875,avail,available,102875,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['avail'],['available']
Availability," decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x84ccbe0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.0078",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:6315,error,error,6315,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,2,"['avail', 'error']","['available', 'error']"
Availability," deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Similar to StepReducedWeights(...) but also evaluates the loss. ; May trigger synchronization with the device. ; Definition at line 224 of file DLMinimizers.h. Member Data Documentation. ◆ fBatchSize. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fBatchSize. private . Batch size to use for the training. ; Definition at line 72 of file DLMinimizers.h. ◆ fConvergenceCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceCount. private . Current number of training epochs without. ; considerable decrease in the test error. ; Definition at line 76 of file DLMinimizers.h. ◆ fConvergenceSteps. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceSteps. private . Number of training epochs without considerable. ; decrease in the test error for convergence. ; Definition at line 74 of file DLMinimizers.h. ◆ fLearningRate. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fLearningRate. private . Learning rate \(\alpha\). ; Definition at line 81 of file DLMinimizers.h. ◆ fMinimumError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fMinimumError. private . The minimum loss achieved on the training set during the current training session. ; Definition at line 82 of file DLMinimizers.h. ◆ fStepCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fStepCount. private . Number of steps performed in the current training session. ; Definition at line 73 of file DLMinimizers.h. ◆ fTestError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fTestError. private . Holds the most recently computed test loss. ; Definition at line 80 of file DLMini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:11937,error,error,11937,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['error'],['error']
Availability," default NULL,; missfiles int(11) default NULL,; PRIMARY KEY (id),; KEY ix_querytag (querytag) );. Version 0 corresponds to the table created with the following command:; (no 'querybegin'). CREATE TABLE proofquerydsets (; id int(11) NOT NULL auto_increment,; dsn varchar(512) NOT NULL,; querytag varchar(64) NOT NULL,; numfiles int(11) default NULL,; missfiles int(11) default NULL,; PRIMARY KEY (id),; KEY ix_querytag (querytag) );. The information is posted with a bulk insert. Returns 0 on success, -1 on failure. Int_t SendFileInfo(TDSet* , TList* , const char* , const char* ); Post information about the requested files. The information is taken; from the TDSet object 'dset' and integrated with the missing files; information in the list 'missing'. The string 'qid' is the unique; ID of the query; 'begin' the starting time. The record is formatted for the table 'proofqueryfiles'. There are two versions of this record, with or without the starting time.; The starting time could be looked up from the summary record, if available. The default version 1 corresponds to the table created with the following command:. CREATE TABLE proofqueryfiles (; id int(11) NOT NULL auto_increment,; lfn varchar(255) NOT NULL,; path varchar(2048) NOT NULL,; querytag varchar(64) NOT NULL,; querybegin datetime default NULL,; status enum('Ok','Failed') NOT NULL default 'Ok',; PRIMARY KEY (id),; KEY ix_querytag (querytag) );. Version 0 corresponds to the table created with the following command:; (no 'querybegin'). CREATE TABLE proofqueryfiles (; id int(11) NOT NULL auto_increment,; lfn varchar(255) NOT NULL,; path varchar(2048) NOT NULL,; querytag varchar(64) NOT NULL,; status enum('Ok','Failed') NOT NULL default 'Ok',; PRIMARY KEY (id),; KEY ix_querytag (querytag) );. The information is posted with a bulk insert. Returns 0 on success, -1 on failure. TProofMonSenderSQL(const char* serv, const char* user, const char* pass, const char* table = ""proof.proofquerylog"", const char* dstab = 0, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofMonSenderSQL.html:11072,avail,available,11072,root/html602/TProofMonSenderSQL.html,https://root.cern,https://root.cern/root/html602/TProofMonSenderSQL.html,4,['avail'],['available']
Availability," default size n = 40 will be used; 92 ; 93bool TFitResult::Scan(unsigned int ipar, TGraph *gr, double xmin, double xmax); 94{; 95 if (!gr); 96 return false;; 97 ; 98 unsigned int npoints = gr->GetN();; 99 if (npoints == 0) {; 100 npoints = 40;; 101 gr->Set(npoints);; 102 }; 103 bool ret = ROOT::Fit::FitResult::Scan(ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; 104 if ((int)npoints < gr->GetN()); 105 gr->Set(npoints);; 106 return ret;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a 2D contour around the minimum for the parameter ipar and jpar; 111/// if a minimum does not exist or is invalid it will return false; 112/// on exit a TGraph is filled with the contour points; 113/// the number of contour points is determined by the size of the TGraph.; 114/// if the size is zero a default number of points = 20 is used; 115/// pass optionally the confidence level, default is 0.683; 116/// it is assumed that ErrorDef() defines the right error definition; 117/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 118 ; 119bool TFitResult::Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel); 120{; 121 if (!gr); 122 return false;; 123 ; 124 unsigned int npoints = gr->GetN();; 125 if (npoints == 0) {; 126 npoints = 40;; 127 gr->Set(npoints);; 128 }; 129 bool ret = ROOT::Fit::FitResult::Contour(ipar, jpar, npoints, gr->GetX(), gr->GetY(), confLevel);; 130 if ((int)npoints < gr->GetN()); 131 gr->Set(npoints);; 132 ; 133 return ret;; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Print the TFitResult.; 138 ; 139std::string cling::printValue(const TFitResult* val); 140{; 141 std::stringstream outs;; 142 val->ROOT::Fit::FitResult::Print(outs, false /*doCovMat*/);; 143 return outs.str();; 144}; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFitResult_8cxx_source.html:4567,error,error,4567,doc/master/TFitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html,1,['error'],['error']
Availability," default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented from TVirtualX.; Definition at line 2917 of file TGCocoa.mm. ◆ Bell(). void TGCocoa::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX.; Definition at line 4264 of file TGCocoa.mm. ◆ ChangeActivePointerGrab(). void TGCocoa::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). overridevirtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time. ; Reimplemented from TVirtualX.; Definition at line 2699 of file TGCocoa.mm. ◆ ChangeGC(). void TGCocoa::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overridevirtual . Changes the components specified by the mask in gval for the specified GC. ; Parameters. [in]gcspecifies the GC to be changed ; [in]gvalspecifies the mask and the values to be set. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 3012 of file TGCocoa.mm. ◆ ChangeProperties(). void TGCocoa::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Reimplemented from TVirtualX.; Definition at line 3859 of file TGCocoa.mm. ◆ ChangeProperty(). void TGCocoa::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]prope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:54602,mask,mask,54602,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability," defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1 in case of error; 739 ; 740Int_t TUnixSystem::GetCryptoRandom(void *buf, Int_t len); 741{; 742#if defined(R__ARC4_STDLIB) || defined(R__ARC4_BSDLIB); 743 arc4random_buf(buf, len);; 744 return len;; 745#elif defined(R__GETRANDOM_CLIB); 746 return getrandom(buf, len, GRND_NONBLOCK);; 747#elif defined(R__USE_URANDOM); 748 std::ifstream urandom{""/dev/urandom""};; 749 if (!urandom); 750 return -1;; 751 urandom.read(reinterpret_cast<char *>(buf), len);; 752 return len;; 753#else; 754#error ""Reliable cryptographic random function not defined""; 755 return -1;; 756#endif; 757}; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Return the system's host name.; 761 ; 762const char *TUnixSystem::HostName(); 763{; 764 if (fHostname == """") {; 765 char hn[64];; 766#if defined(R__SOLARIS); 767 sysinfo(SI_HOSTNAME, hn, sizeof(hn));; 768#else; 769 gethostname(hn, sizeof(hn));; 770#endif; 771 fHostname = hn;; 772 }; 773 return (const char *)fHostname;; 774}; 775 ; 776//---- EventLoop ---------------------------------------------------------------; 777 ; 778////////////////////////////////////////////////////////////////////////////////; 779/// Add a file handler to the list of system file handlers. Only adds; 780/// the handler if it is not already in the list of file handlers.; 781 ; 782void TUnixSystem::AddFileHandler(TFileHandler *h); 783{; 784 R__LOCKGUARD2(gSystemMutex);; 785 ; 786 TSystem::AddFileHandler(h);; 787 if (h) {; 788 int fd = h->GetFd();; 789 if (h->HasReadInterest()) {; 790 fReadmask->Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:22726,error,error,22726,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability," delete . Member Function Documentation. ◆ Deriv(). ChebyshevApprox * ROOT::Math::ChebyshevApprox::Deriv ; (; ). Compute the derivative of the series and return a pointer to a new Chebyshev series with the derivatives coefficients. ; The returned pointer must be managed by the user. ; Definition at line 120 of file ChebyshevApprox.cxx. ◆ EvalErr() [1/2]. std::pair< double, double > ROOT::Math::ChebyshevApprox::EvalErr ; (; double ; x); const. Evaluate the series at a given point x estimating both the series result and its absolute error. ; The error estimate is made from the first neglected term in the series. A pair containing result and error is returned ; Definition at line 101 of file ChebyshevApprox.cxx. ◆ EvalErr() [2/2]. std::pair< double, double > ROOT::Math::ChebyshevApprox::EvalErr ; (; double ; x, . size_t ; n . ); const. evaluate the series at a given point x to the given order n, estimating both the series result and its absolute error. ; The error estimate is made from the first neglected term in the series. A pair containing result and error is returned ; Definition at line 113 of file ChebyshevApprox.cxx. ◆ Initialize(). void ROOT::Math::ChebyshevApprox::Initialize ; (; GSLFuncPointer ; f, . void * ; params, . double ; a, . double ; b . ). protected . Initialize series passing function and range. ; Definition at line 82 of file ChebyshevApprox.cxx. ◆ Integral(). ChebyshevApprox * ROOT::Math::ChebyshevApprox::Integral ; (; ). Compute the integral of the series and return a pointer to a new Chebyshev series with the integral coefficients. ; The lower limit of the integration is the left range value a. The returned pointer must be managed by the user ; Definition at line 130 of file ChebyshevApprox.cxx. ◆ operator()() [1/2]. double ROOT::Math::ChebyshevApprox::operator() ; (; double ; x); const. Evaluate the series at a given point x. ; Definition at line 96 of file ChebyshevApprox.cxx. ◆ operator()() [2/2]. double ROOT::Math::ChebyshevApprox::operator(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1ChebyshevApprox.html:5004,error,error,5004,doc/master/classROOT_1_1Math_1_1ChebyshevApprox.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1ChebyshevApprox.html,1,['error'],['error']
Availability," delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:56270,error,error,56270,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,4,['error'],['error']
Availability," depends on the imageData of the corresponding pixel. The palette is used to convert an image value into its color. If palette is not defined (palette = 0) a default palette is used. Any previously defined zooming is reset. ; Reimplemented from TImage.; Definition at line 1057 of file TASImage.cxx. ◆ SetImage() [4/5]. void TASImage::SetImage ; (; const TVectorD & ; imageData, . UInt_t ; width, . TImagePalette * ; palette = nullptr . ). overridevirtual . Delete the old image and creates a new image depending on the values of imageData. ; The size of the image is width X (imageData.fN / width). The color of each pixel depends on the imageData of the corresponding pixel. The palette is used to convert an image value into its color. If palette is not defined (palette = 0) a default palette is used. Any previously defined zooming is reset. ; Reimplemented from TImage.; Definition at line 1070 of file TASImage.cxx. ◆ SetImage() [5/5]. void TASImage::SetImage ; (; Pixmap_t ; pxm, . Pixmap_t ; mask = 0 . ). overridevirtual . Create image from pixmap. ; Reimplemented from TImage.; Definition at line 2365 of file TASImage.cxx. ◆ SetImageBuffer(). Bool_t TASImage::SetImageBuffer ; (; char ** ; buffer, . EImageFileTypes ; type = TImage::kPng . ). overridevirtual . Create image from compressed buffer. ; Supported formats:. PNG - by default; XPM - two options exist:; xpm as a single string (raw buffer). Such string is returned by GetImageBuffer method. For example: char *buf;; int sz;; im1->GetImageBuffer(&buf, &int, TImage::kXpm); /*raw buffer*&zwj;/; TImage *im2 = TImage::Create();; im2->SetImageBuffer(&buf, TImage::kXpm);; TImage::kXpm@ kXpmDefinition TImage.h:37. xpm as an array of strings (pre-parsed) For example:; char *xpm[] = {; ""64 28 58 1"",; "" c #0A030C"",; "". c #1C171B""; ...; TImage *im = TImage::Create();; im->SetImageBuffer(xpm, TImage::kXpm);; . Reimplemented from TImage.; Definition at line 6042 of file TASImage.cxx. ◆ SetJpegDpi(). Bool_t TASImage::SetJpegDpi ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:74465,mask,mask,74465,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['mask'],['mask']
Availability," described, but not resolved:; 16522 * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526; 16523 * Wrong const cast ignored on C or can be suppressed by compiler flags.; 16524 * But when compiled with modern C++ compiler, correct const should be; 16525 * provided; 16526 */; 16527 SSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);; 16528 ; 16529 SSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,; 16530 ssl_servername_callback);; 16531 ; 16532 /* If a callback has been specified, call it. */; 16533 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16534 ? 0; 16535 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16536 phys_ctx->user_data));; 16537 ; 16538 /* If callback returns 0, civetweb sets up the SSL certificate.; 16539 * If it returns 1, civetweb assumes the calback already did this.; 16540 * If it returns -1, initializing ssl fails. */; 16541 if (callback_ret < 0) {; 16542 mg_cry_ctx_internal(phys_ctx,; 16543 ""SSL callback returned error: %i"",; 16544 callback_ret);; 16545 return 0;; 16546 }; 16547 if (callback_ret > 0) {; 16548 /* Callback did everything. */; 16549 return 1;; 16550 }; 16551 ; 16552 /* If a domain callback has been specified, call it. */; 16553 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16554 ? 0; 16555 : (phys_ctx->callbacks.init_ssl_domain(; 16556 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16557 dom_ctx->ssl_ctx,; 16558 phys_ctx->user_data));; 16559 ; 16560 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16561 * If it returns 1, civetweb assumes the calback already did this.; 16562 * If it returns -1, initializing ssl fails. */; 16563 if (callback_ret < 0) {; 16564 mg_cry_ctx_internal(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:490142,error,error,490142,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," described, but not resolved:; 16523 * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526; 16524 * Wrong const cast ignored on C or can be suppressed by compiler flags.; 16525 * But when compiled with modern C++ compiler, correct const should be; 16526 * provided; 16527 */; 16528 SSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);; 16529 ; 16530 SSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,; 16531 ssl_servername_callback);; 16532 ; 16533 /* If a callback has been specified, call it. */; 16534 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16535 ? 0; 16536 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16537 phys_ctx->user_data));; 16538 ; 16539 /* If callback returns 0, civetweb sets up the SSL certificate.; 16540 * If it returns 1, civetweb assumes the calback already did this.; 16541 * If it returns -1, initializing ssl fails. */; 16542 if (callback_ret < 0) {; 16543 mg_cry_ctx_internal(phys_ctx,; 16544 ""SSL callback returned error: %i"",; 16545 callback_ret);; 16546 return 0;; 16547 }; 16548 if (callback_ret > 0) {; 16549 /* Callback did everything. */; 16550 return 1;; 16551 }; 16552 ; 16553 /* If a domain callback has been specified, call it. */; 16554 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16555 ? 0; 16556 : (phys_ctx->callbacks.init_ssl_domain(; 16557 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16558 dom_ctx->ssl_ctx,; 16559 phys_ctx->user_data));; 16560 ; 16561 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16562 * If it returns 1, civetweb assumes the calback already did this.; 16563 * If it returns -1, initializing ssl fails. */; 16564 if (callback_ret < 0) {; 16565 mg_cry_ctx_internal(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:490175,error,error,490175,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; TIterbegin() const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCollection.html:1344,avail,available,1344,root/html534/TCollection.html,https://root.cern,https://root.cern/root/html534/TCollection.html,6,['avail'],['available']
Availability," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCollection.html:1344,avail,available,1344,root/html528/TCollection.html,https://root.cern,https://root.cern/root/html528/TCollection.html,4,['avail'],['available']
Availability," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollection.html:1344,avail,available,1344,root/html526/TCollection.html,https://root.cern,https://root.cern/root/html526/TCollection.html,1,['avail'],['available']
Availability," describing current object ; Reimplemented from TObject.; Definition at line 124 of file TEveBrowser.h. ◆ ItemBelowMouse(). void TEveGListTreeEditorFrame::ItemBelowMouse ; (; TGListTreeItem * ; entry, . UInt_t ; mask . ). Different item is below mouse. ; Definition at line 315 of file TEveBrowser.cxx. ◆ ItemClicked(). void TEveGListTreeEditorFrame::ItemClicked ; (; TGListTreeItem * ; item, . Int_t ; btn, . UInt_t ; mask, . Int_t ; x, . Int_t ; y . ). Item has been clicked, based on mouse button do: . M1 - select, show in editor;; M2 - paste (call gEve->ElementPaste();; M3 - popup context menu. . Definition at line 327 of file TEveBrowser.cxx. ◆ ItemDblClicked(). void TEveGListTreeEditorFrame::ItemDblClicked ; (; TGListTreeItem * ; item, . Int_t ; btn . ). Item has been double-clicked, potentially expand the children. ; Definition at line 365 of file TEveBrowser.cxx. ◆ ItemKeyPress(). void TEveGListTreeEditorFrame::ItemKeyPress ; (; TGListTreeItem * ; entry, . UInt_t ; keysym, . UInt_t ; mask . ). A key has been pressed for an item. ; Only <Delete>, <Enter> and <Return> keys are handled here, otherwise the control is passed back to TGListTree. ; Definition at line 407 of file TEveBrowser.cxx. ◆ operator=(). TEveGListTreeEditorFrame & TEveGListTreeEditorFrame::operator= ; (; const TEveGListTreeEditorFrame & ; ). private . ◆ ReconfToHorizontal(). void TEveGListTreeEditorFrame::ReconfToHorizontal ; (; ). Reconfigure to horizontal layout, list-tree and editor side by side. ; Definition at line 233 of file TEveBrowser.cxx. ◆ ReconfToVertical(). void TEveGListTreeEditorFrame::ReconfToVertical ; (; ). Reconfigure to vertical layout, list-tree above the editor. ; Definition at line 274 of file TEveBrowser.cxx. ◆ SetEditorClass(). void TEveGListTreeEditorFrame::SetEditorClass ; (; const char * ; edclass). static . Set GED editor class. ; Definition at line 189 of file TEveBrowser.cxx. ◆ Streamer(). void TEveGListTreeEditorFrame::Streamer ; (; TBuffer & ; R__b). overridevirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGListTreeEditorFrame.html:39672,mask,mask,39672,doc/master/classTEveGListTreeEditorFrame.html,https://root.cern,https://root.cern/doc/master/classTEveGListTreeEditorFrame.html,1,['mask'],['mask']
Availability," descriptor. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); Send a raw buffer of specified length. Returns the number of bytes; send and -1 in case of error. Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket would; block (i.e. there is nothing to be read). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); Send a raw buffer of specified length. Returns the number of bytes; sent or -1 in case of error. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0. TPSocket(TSocket** pSockets, Int_t size). void operator=(const TPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. Int_t Send(const TMessage& mess). Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess). Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Bool_t IsValid() const; { return fSockets ? kTRUE : kFALSE; }. Int_t GetSize() const; { return fSize; }. » Author: Fons Rademakers 20/1/2001 » Copyright (C) 1995-2001, R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPSocket.html:15379,error,error,15379,root/html528/TPSocket.html,https://root.cern,https://root.cern/root/html528/TPSocket.html,6,['error'],['error']
Availability," descriptor. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); Send a raw buffer of specified length. Returns the number of bytes; send and -1 in case of error. Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket would; block (i.e. there is nothing to be read). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); Send a raw buffer of specified length. Returns the number of bytes; sent or -1 in case of error. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0. TPSocket(TSocket*[] pSockets, Int_t size). void operator=(const TPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. Int_t Send(const TMessage& mess). Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess). Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Bool_t IsValid() const; { return fSockets ? kTRUE : kFALSE; }. Int_t GetSize() const; { return fSize; }. » Author: Fons Rademakers 20/1/2001 » Copyright (C) 1995-2001, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPSocket.html:16329,error,error,16329,root/html602/TPSocket.html,https://root.cern,https://root.cern/root/html602/TPSocket.html,4,['error'],['error']
Availability," descriptors (called by TMonitor). ;  ; virtual Int_t Select (TList *active, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual int SendBuf (int sock, const void *buffer, int length);  Send a buffer headed by a length indicator. ;  ; virtual int SendRaw (int sock, const void *buffer, int length, int flag);  Send exactly length bytes from buffer. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void SetErrorStr (const char *errstr);  Set the system error string. ;  ; virtual void SetFlagsDebug (const char *);  FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ;  ; virtual void SetFlagsOpt (const char *);  FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ;  ; virtual Int_t SetFPEMask (Int_t mask=kDefaultMask);  Set which conditions trigger a floating point exception. ;  ; virtual void SetIncludePath (const char *includePath);  IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ;  ; virtual void SetLinkdefSuffix (const char *suffix);  The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ;  ; virtual void SetLinkedLibs (const char *linkedLibs);  LinkedLibs should contain the library directory and lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:16289,error,error,16289,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['error'],['error']
Availability," details see html manual and references; TStringTNamed::fTitleobject title; Int_tfXmaxlast fitted channel; Int_tfXminfirst fitted channel. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSpectrumFit. Function documentation; TSpectrumFit(); default constructor. TSpectrumFit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks is .  ;  ;  ;  ;  ;  ;  ;  . where a represents vector of; fitted parameters (positions p(j), amplitudes A(j), sigma, relative amplitudes; T, S and slope B).;  . ~TSpectrumFit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Deramp(Double_t i, Double_t i0, Double_t sigma, Double_t t, Double_t s, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of peak shape function (see manual); according to amplitude of peak.; Function parameters:; -i-channel; -i0-position of peak; -sigma-sigma of peak; -t, s-relative amplitudes; -b-slope. Double_t Deri0(Double_t i, Double_t amp, Double_t i0, Double_t sigma, Double_t t, Double_t s, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of peak shape function (see manual); according to peak position.; Function parameters:; -i-channel; -amp-amplitude of peak; -i0-position of peak; -sigma-sigma of peak; -t, s-relative amplitudes; -b-slope. Double_t Derderi0(Double_t i, Double_t amp, Double_t i0, Double_t sigma). AUXILIARY FUNCTION. This function calculates second derivative of peak shape function; (see manual) according to peak position.; Function parameters:; -i-channel; -amp-amplitude of peak; -i0-p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:14913,error,error,14913,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,4,['error'],['error']
Availability," determine the interval. { return fUseKeys; }. Int_t GetNumBurnInSteps(); get the number of steps in the chain to disard as burn-in,; get the number of steps in the chain to disard as burn-in,; starting from the first. { return fNumBurnInSteps; }. Int_t GetDimension() const; Get the number of parameters of interest in this interval. { return fDimension; }. const MarkovChain* GetChain(); Get the markov chain on which this interval is based; You do not own the returned MarkovChain*. { return fChain; }. RooDataSet* GetChainAsDataSet(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a RooDataSet. You own the returned RooDataSet*. { return fChain->GetAsDataSet(whichVars); }. const RooDataSet* GetChainAsConstDataSet(); Get the markov chain on which this interval is based; as a RooDataSet. You do not own the returned RooDataSet*. { return fChain->GetAsConstDataSet(); }. RooDataHist* GetChainAsDataHist(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. » Last changed: root/roostats:$Id: MCMCInterval.h 31276 2009-11-18 15:06:42Z moneta $ » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MCMCInterval.html:16225,error,error,16225,root/html526/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html526/RooStats__MCMCInterval.html,1,['error'],['error']
Availability," dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; 830 /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; 831 /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; 832 /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; 833 ///; 834 /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; 835 /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; 836 /// ~~~{.cpp}; 837 /// auto nominal_hx =; 838 /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); 839 /// .Filter(""pt > k""); 840 /// .Define(""x"", someFunc, {""pt""}); 841 /// .Histo1D(""x"");; 842 ///; 843 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 844 /// hx[""nominal""].Draw();; 845 /// hx[""pt:down""].Draw(""SAME"");; 846 /// hx[""pt:up""].Draw(""SAME"");; 847 /// ~~~; 848 /// RDataFrame computes all variations as part of a single loop over the data.; 849 /// In particular, this means that I/O and computation of values shared; 850 /// among variations only happen once for all variations. Thus, the event loop; 851 /// run-time typically scales much better than linearly with the number of; 852 /// variations.; 853 ///; 854 /// RDataFrame lazily computes the varied values required to produce the; 855 /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". If \ref; 856 /// ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" was not called for a result, the computations are only; 857 /// run for the nominal case.; 858 ///; 859 /// See other overloads for examples when variations are added for multiple existing columns,; 860 /// or when the tags are auto-generated instead of being directly defined.; 861 template <typename F>; 862 RInterface<Proxied, DS_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:45476,down,down,45476,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability," different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__BinData.html:6447,Error,ErrorType,6447,root/html532/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html,1,['Error'],['ErrorType']
Availability," difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5]. Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. Define ; are the 5 dependent; quantities that define a trac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:9464,error,errors,9464,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['error'],['errors']
Availability," direct minimiser away from that region.; 999 * `strength` controls the magnitude of the penalty term. Leaving out this argument defaults to 10. Switch off with `strength = 0.`.; 1000 *; 1001 * <tr><td> `SumW2Error(bool flag)` <td> Apply correction to errors and covariance matrix.; 1002 * This uses two covariance matrices, one with the weights, the other with squared weights,; 1003 * to obtain the correct errors for weighted likelihood fits. If this option is activated, the; 1004 * corrected covariance matrix is calculated as \f$ V_\mathrm{corr} = V C^{-1} V \f$, where \f$ V \f$ is the original; 1005 * covariance matrix and \f$ C \f$ is the inverse of the covariance matrix calculated using the; 1006 * squared weights. This allows to switch between two interpretations of errors:; 1007 * <table>; 1008 * <tr><th> SumW2Error <th> Interpretation; 1009 * <tr><td> true <td> The errors reflect the uncertainty of the Monte Carlo simulation.; 1010 * Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; 1011 *; 1012 * **Example**: Simulation with 1000 events, the average weight is 0.1.; 1013 * The errors are as big as if one fitted to 1000 events.; 1014 * <tr><td> false <td> The errors reflect the errors of a dataset, which is as big as the sum of weights.; 1015 * Use this if you want to know what statistical errors you would get if you had a dataset with as many; 1016 * events as the (weighted) Monte Carlo simulation represents.; 1017 *; 1018 * **Example** (Data as above):; 1019 * The errors are as big as if one fitted to 100 events.; 1020 * </table>; 1021 * \note If the `SumW2Error` correction is enabled, the covariance matrix quality stored in the RooFitResult; 1022 * object will be the minimum of the original covariance matrix quality and the quality of the covariance; 1023 * matrix calculated with the squared weights.; 1024 * <tr><td> `AsymptoticError()` <td> Use the asymptotically correct approach to estimate errors in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:48065,avail,available,48065,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['avail'],['available']
Availability," directory to be freed. const char* GetDirEntry(void* dirp); Get a directory entry. param dirp: the directory pointer; returns: 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file (stat). param path: the path of the file to stat (in); param buf: structure that will hold the stat info (out); returns: 0 if success, 1 if the file could not be stat'ed. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required by 'path' or; 'dirptr'. param path: the path to check; param dirptr: the directory pointer to check. int Unlink(const char* path); Unlink a file on the remote server. param path: the path of the file to unlink; returns: 0 on success, -1 otherwise. Bool_t IsPathLocal(const char* path); Is this path a local path?. param path: the URL of the path to check; returns: kTRUE if the path is local, kFALSE otherwise. Int_t Locate(const char* path, TString& endurl); Get the endpoint URL of a file. param path: the entry-point URL of the file (in); param endurl: the endpoint URL of the file (out); returns: 0 in case of success and 1 if the file could not be; stat'ed. Int_t Stage(const char* path, UChar_t priority); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p""; returns: 0 for success, -1 for error. Int_t Stage(TCollection* files, UChar_t priority); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p""; returns: 0 for success, -1 for error. TNetXNGSystem(Bool_t owner = kTRUE). » Last changed: root/netxng:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNetXNGSystem.html:22246,error,error,22246,root/html604/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html,4,['error'],['error']
Availability," directory to be freed. const char* GetDirEntry(void* dirp); Get a directory entry. param dirp: the directory pointer; returns: 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file (stat). param path: the path of the file to stat (in); param buf: structure that will hold the stat info (out); returns: 0 if success, 1 if the file could not be stat'ed. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required by 'path' or; 'dirptr'. param path: the path to check; param dirptr: the directory pointer to check. int Unlink(const char* path); Unlink a file on the remote server. param path: the path of the file to unlink; returns: 0 on success, -1 otherwise. Bool_t IsPathLocal(const char* path); Is this path a local path?. param path: the URL of the path to check; returns: kTRUE if the path is local, kFALSE otherwise. Int_t Locate(const char* path, TString& endurl); Get the endpoint URL of a file. param path: the entry-point URL of the file (in); param endurl: the endpoint URL of the file (out); returns: 0 in case of success and 1 if the file could not be; stat'ed. Int_t Stage(const char* path, UChar_t priority); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p""; returns: 0 for success, -1 for error. Int_t Stage(TCollection* files, UChar_t priority); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p""; returns: 0 for success, -1 for error. TNetXNGSystem(Bool_t owner = kTRUE). » Last changed: root/netxng:$Id$ » Last generated: 2015-06-30 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGSystem.html:22246,error,error,22246,root/html602/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html602/TNetXNGSystem.html,4,['error'],['error']
Availability," display; 91manager. A ROOT session may have several canvases open at any given time.; 92 ; 93A Canvas may be subdivided into independent graphical areas: the __Pads__.; 94A canvas has a default pad which has the name of the canvas itself.; 95An example of a Canvas layout is sketched in the picture below.; 96 ; 97\image html gpad_canvas.png; 98 ; 99This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; 100moved, grown, shrunk using the normal rules of the Display manager.; 101 ; 102Once objects have been drawn in a canvas, they can be edited/moved by pointing; 103directly to them. The cursor shape is changed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:3384,avail,available,3384,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avail'],['available']
Availability," displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:16687,error,error,16687,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,8,['error'],['error']
Availability," distributed according to the Poisson distribution, with f1 as the mean. . Definition at line 3192 of file TH1.cxx. ◆ ExecuteEvent(). void TH1::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a histogram is clicked with the locator; If Left button clicked on the bin top value, then the content of this bin is modified according to the new position of the mouse when it is released. ; Reimplemented from TObject.; Definition at line 3240 of file TH1.cxx. ◆ ExtendAxis(). void TH1::ExtendAxis ; (; Double_t ; x, . TAxis * ; axis . ). virtual . Histogram is resized along axis such that x is in the axis range. ; The new axis limits are recomputed by doubling iteratively the current axis range until the specified value x is within the limits. The algorithm makes a copy of the histogram, then loops on all bins of the old histogram to fill the extended histogram. Takes into account errors (Sumw2) if any. The algorithm works for 1-d, 2-D and 3-D histograms. The axis must be extendable before invoking this function. Ex:; h->GetXaxis()->SetCanExtend(kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93. Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 6504 of file TH1.cxx. ◆ FFT(). TH1 * TH1::FFT ; (; TH1 * ; h_output, . Option_t * ; option . ). virtual . This function allows to do discrete Fourier transforms of TH1 and TH2. ; Available transform types and flags are described below.; To extract more information about the transform, use the function TVirtualFFT::GetCurrentTransform() to get a pointer to the current transform object.; Parameters. [out]h_outputhistogram for the output. If a null pointer is passed, a new histogram is created and returned, otherwise, the provided histogram is used and should be big enough ; [in]optionoption parameters consists of 3 parts:; option on what to return; ""RE"" - returns a histogram of the real ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:112937,error,errors,112937,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability," distribution function, but different parameters of location or scale, they should still fall on the straight line, but not the 45 degrees one.; The greater their departure from the straight line, the more evidence there is that the datasets come from different distributions. The advantage of qq-plot is that it not only shows that the underlying distributions are different, but, unlike the analytical methods, it also gives information on the nature of this difference: heavier tails, different location/scale, different shape, etc.; 4.8.2 One Dataset. Examples of qq-plots of 1 dataset. Quantile-quantile plots are used to determine if the dataset comes from the specified theoretical distribution, such as normal. A qq-plot draws quantiles of the dataset against quantiles of the specified theoretical distribution. Note, that density, not CDF should be specified a straight line, going through 0.25 and 0.75 quantiles could also be plotted for reference. It represents a robust linear fit, not sensitive to the extremes of the dataset. As in the two datasets case, departures from straight line indicate departures from the specified distribution. Next picture shows an example of a qq-plot of a dataset from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function. Fitting parameters are estimates of the distribution mean and sigma.; 4.9 TMultiGraph. A multigraph example. A TMultiGraph is a collection of TGraph (or derived) objects. Use TMultiGraph::Addto add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing and fitting options are the same as for TGraph.; {; // create the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t x2[n] = {-.12,.15,.35,.45,.6,.71,.8,.95,.99,1.05};; Double_t y2[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the width of errors in x and y direction; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:155509,robust,robust,155509,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['robust'],['robust']
Availability," distribution in , and summing up the number of events entering in a ; for a given species, one recovers the yield of the species, as provided by the fit. The property 4 is implemented in the TSPlot class as a check. the sum of the statistical uncertainties per bin. (6). reproduces the statistical uncertainty on the yield , as provided by the fit: ; .; Because of that and since the determination of the yields is optimal; when obtained using a Likelihood fit, one can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species.; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . Error bars per bin are given by Eq. (6). The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit:; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:4753,Error,Error,4753,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,2,['Error'],['Error']
Availability," dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:4106,Error,Error,4106,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['Error'],['Error']
Availability," division type which applies only to a given; shape type. The implemented patterns are for the moment equidistant slices; on different axis. Implemented patterns are:. TGeoPatternX - a X axis divison pattern; TGeoPatternY - a Y axis divison pattern; TGeoPatternZ - a Z axis divison pattern; TGeoPatternParaX - a X axis divison pattern for PARA shape; TGeoPatternParaY - a Y axis divison pattern for PARA shape; TGeoPatternParaZ - a Z axis divison pattern for PARA shape; TGeoPatternTrapZ - a Z axis divison pattern for TRAP or GTRA shapes; TGeoPatternCylR - a cylindrical R divison pattern; TGeoPatternCylPhi - a cylindrical phi divison pattern; TGeoPatternSphR - a spherical R divison pattern; TGeoPatternSphTheta - a spherical theta divison pattern; TGeoPatternSphPhi - a spherical phi divison pattern; TGeoPatternHoneycomb - a divison pattern specialized for honeycombs. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoPatternFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPatternFinder.html:1397,avail,available,1397,root/html532/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html532/TGeoPatternFinder.html,2,['avail'],['available']
Availability," division type which applies only to a given; shape type. The implemented patterns are for the moment equidistant slices; on different axis. Implemented patterns are:. TGeoPatternX - a X axis divison pattern; TGeoPatternY - a Y axis divison pattern; TGeoPatternZ - a Z axis divison pattern; TGeoPatternParaX - a X axis divison pattern for PARA shape; TGeoPatternParaY - a Y axis divison pattern for PARA shape; TGeoPatternParaZ - a Z axis divison pattern for PARA shape; TGeoPatternTrapZ - a Z axis divison pattern for TRAP or GTRA shapes; TGeoPatternCylR - a cylindrical R divison pattern; TGeoPatternCylPhi - a cylindrical phi divison pattern; TGeoPatternSphR - a spherical R divison pattern; TGeoPatternSphTheta - a spherical theta divison pattern; TGeoPatternSphPhi - a spherical phi divison pattern; TGeoPatternHoneycomb - a divison pattern specialized for honeycombs. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoPatternFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPatternFinder.html:1397,avail,available,1397,root/html534/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html,6,['avail'],['available']
Availability," dko1 = TMath::Sqrt((fXN[z]-fXN[o1])*(fXN[z]-fXN[o1])+(fYN[z]-fYN[o1])*(fYN[z]-fYN[o1]));; 835 dko2 = TMath::Sqrt((fXN[z]-fXN[o2])*(fXN[z]-fXN[o2])+(fYN[z]-fYN[o2])*(fYN[z]-fYN[o2]));; 836 dfo1 = TMath::Sqrt((fXN[f]-fXN[o1])*(fXN[f]-fXN[o1])+(fYN[f]-fYN[o1])*(fYN[f]-fYN[o1]));; 837 dfo2 = TMath::Sqrt((fXN[f]-fXN[o2])*(fXN[f]-fXN[o2])+(fYN[f]-fYN[o2])*(fYN[f]-fYN[o2]));; 838 c1 = ((fXN[z]-fXN[o1])*(fXN[z]-fXN[o2])+(fYN[z]-fYN[o1])*(fYN[z]-fYN[o2]))/dko1/dko2;; 839 c2 = ((fXN[f]-fXN[o1])*(fXN[f]-fXN[o2])+(fYN[f]-fYN[o1])*(fYN[f]-fYN[o2]))/dfo1/dfo2;; 840 sin_sum = c1*TMath::Sqrt(1-c2*c2)+c2*TMath::Sqrt(1-c1*c1);; 841 ; 842 // sin_sum doesn't always come out as zero when it should do.; 843 if (sin_sum < -1.E-6) {; 844 // z is inside the circle, this is not a Delaunay triangle; 845 goto L90;; 846 } else if (TMath::Abs(sin_sum) <= 1.E-6) {; 847 // point z lies on the circumference of the circle (within rounding errors); 848 // defined by the triangle, so there is potential for degeneracy in the; 849 // triangle set (Delaunay triangulation does not give a unique way to split; 850 // a polygon whose points lie on a circle into constituent triangles). Make; 851 // a note of the additional point number.; 852 ndegen++;; 853 degen = z;; 854 fdegen = f;; 855 o1degen = o1;; 856 o2degen = o2;; 857 }; 858L50:; 859 continue;; 860 }; 861 // This is a good triangle; 862 if (ndegen > 0) {; 863 // but is degenerate with at least one other,; 864 // haven't figured out what to do if more than 4 points are involved; 865/// if (ndegen > 1) {; 866/// Error(""Interpolate"",; 867/// ""More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d"",; 868/// p,n,m,degen);; 869/// return thevalue;; 870/// }; 871 ; 872 // we have a quadrilateral which can be split down either diagonal; 873 // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal; 874 // with highest average z-value. Whichever we choose we wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:29240,error,errors,29240,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['error'],['errors']
Availability," does not coincide with the; first point. Point_t *points - specifies an array of points; Int_t npnt - specifies the number of points in the array. GC components in use: function, plane-mask, fill-style, fill-rule,; subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC; mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). Returns the root window the pointer is logically on and the pointer; coordinates relative to the root window's origin. id - specifies the window; rotw - the root window that the pointer is in; childw - the child window that the pointer is located in, if any; root_x, root_y - the pointer coordinates relative to the root window's; origin; win_x, win_y - the pointer coordinates relative to the specified; window ""id""; mask - the current state of the modifier keys and pointer; buttons. void SetForeground(GContext_t gc, ULong_t foreground); Sets the foreground color for the specified GC (shortcut for ChangeGC; with only foreground mask set). gc - specifies the GC; foreground - the foreground you want to set; (see also the GCValues_t structure). void SetClipRectangles(GContext_t gc, Int_t x, Int_t y, Rectangle_t* recs, Int_t n); Sets clipping rectangles in graphics context. [x,y] specify the origin; of the rectangles. ""recs"" specifies an array of rectangles that define; the clipping mask and ""n"" is the number of rectangles.; (see also the GCValues_t structure). void Update(Int_t mode = 0); Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer.; Flush flushes output buffer. Sync flushes buffer and waits till all; requests have been processed by X server. Region_t CreateRegion(); Creates a new empty region. void DestroyRegion(Region_t reg); Destroys the region ""reg"". void UnionRectWithRegion(Rectangle_t* rect, Region_t src, Region_t dest); Updates the destination region from a union of the specified rectangle; and the specified so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:59305,mask,mask,59305,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['mask'],['mask']
Availability," does not have to worry about the decomposition step before calling a solve method, because the decomposition class checks before invoking Solve that the matrix has been decomposed.; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; In the next example, we show again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:792563,toler,tolerance,792563,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Toler', 'toler']","['Tolerances', 'tolerance']"
Availability," does not match existing one, create a new parameter setting list. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetMinosErrors(const std::vector<unsigned int> & paramInd ); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm. » Author: L. Moneta Thu Sep 21 16:21:29 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: FitConfig.h 29513 2009-07-17 15:30:07Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitConfig.html:4494,error,error,4494,root/html526/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitConfig.html,1,['error'],['error']
Availability," does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51288,toler,tolerance,51288,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['toler'],['tolerance']
Availability," don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:63615,error,error,63615,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:73498,error,error,73498,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['error'],['error']
Availability," done anyway. ;  ; TH1 * GetMvaBpdf ();  ; TH1 * GetMvaSpdf ();  ; TH1 * GetPurity (Int_t nStot, Int_t nBtot);  ; TH1D * GetROC ();  get the ROC curve ;  ; Double_t GetROCIntegral ();  code to compute the area under the ROC ( rej-vs-eff ) curve ;  ; Double_t GetSignalReferenceCut ();  ; TH1 * GetSignificance (Int_t nStot, Int_t nBtot);  ; Bool_t GetStatus ();  ; void ResetStatus ();  . Private Member Functions; Double_t GetEffForRoot (Double_t theCut);  returns efficiency as function of cut ;  ; MsgLogger & Log () const;  message logger ;  ; Double_t Root (Double_t);  Root finding using Brents algorithm; taken from CERNLIB function RZERO. ;  . Private Attributes; TH1D * effBvsS;  ; Double_t fAbsTol;  absolute tolerance deviation ;  ; Int_t fCutOrientation;  +1 if larger mva value means more signal like, -1 otherwise ;  ; MsgLogger * fLogger;  ; Int_t fMaxIter;  maximum number of iterations ;  ; TH1 * fmvaB;  the input mva distributions ;  ; TH1 * fmvaBcumul;  ; TH1 * fmvaBpdf;  the normalized (and rebinned) input mva distributions ;  ; TH1 * fmvaS;  ; TH1 * fmvaScumul;  ; TH1 * fmvaSpdf;  ; UInt_t fNbins;  ; Int_t fnBtot;  ; Double_t fNevtS;  number of signal events (used in error calculation) ;  ; Int_t fnStot;  ; TH1 * fPurity;  ; Double_t fSignalCut;  MVA cut value for last demanded background rejection or signal efficiency. ;  ; TH1 * fSignificance;  ; TSpline * fSplB;  ; TSpline * fSpleffBvsS;  ; TSpline * fSplmvaCumB;  spline of cumulated mva distributions ;  ; TSpline * fSplmvaCumS;  ; TSpline * fSplS;  ; Bool_t fStatus;  false if is found some error in mvaS or mvaB ;  ; Bool_t fUseSplines;  ; Float_t fXmax;  min and max of the mva distribution ;  ; Float_t fXmin;  ; TH1D * inveffBvsS;  ; TH1D * rejBvsS;  . #include <TMVA/ROCCalc.h>; Constructor & Destructor Documentation. ◆ ROCCalc(). TMVA::ROCCalc::ROCCalc ; (; TH1 * ; mvaS, . TH1 * ; mvaB . ). Definition at line 42 of file ROCCalc.cxx. ◆ ~ROCCalc(). TMVA::ROCCalc::~ROCCalc ; (; ). destructor ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html:1441,toler,tolerance,1441,doc/master/classTMVA_1_1ROCCalc.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html,2,"['error', 'toler']","['error', 'tolerance']"
Availability," done.; For keeping a minimizer pointer the method ReCreateMinimizer() could eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBackCompFitter.html:19551,error,error,19551,root/html604/TBackCompFitter.html,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html,3,"['Error', 'error']","['ErrorDef', 'error']"
Availability," done.; For keeping a minimizer pointer the method ReCreateMinimizer() could eventually be used. TFitResult * GetTFitResult() const; return a new copy of the TFitResult object which needs to be deleted later by the user. bool Scan(unsigned int ipar, TGraph* gr, double xmin = 0, double xmax = 0); scan parameter ipar between value of xmin and xmax; a graph must be given which will be on return filled with the scan resul; If the graph size is zero, a default size n = 40 will be used; *. bool Contour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); create a 2D contour around the minimum for the parameter ipar and jpar; if a minimum does not exist or is invalid it will return false; on exit a TGraph is filled with the contour points; the number of contur points is determined by the size of the TGraph.; if the size is zero a default number of points = 20 is used; pass optionally the confidence level, default is 0.683; it is assumed that ErrorDef() defines the right error definition; (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level. TBackCompFitter(). void SetMethodCall(TMethodCall* m); for using interpreted function passed by the user. { fMethodCall = m; }. ROOT::Fit::FitConfig & GetFitConfig(); !!!! new method (of this interface); get reference to Fit configuration (NOTE: it will be invalid when class is deleted). { return fFitter->Config(); }. const ROOT::Fit::FitResult & GetFitResult() const; get reference to Fit Result object (NOTE: it will be invalid when class is deleted). { return fFitter->Result(); }. const ROOT::Fit::FitData & GetFitData() const; get reference to Fit Data object (NOTE: it will be invalid when class is deleted). { return *fFitData; }. » Author: L. Moneta 08/2008 » Copyright (c) 2008 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBackCompFitter.html:19567,error,error,19567,root/html602/TBackCompFitter.html,https://root.cern,https://root.cern/root/html602/TBackCompFitter.html,3,"['Error', 'error']","['ErrorDef', 'error']"
Availability," double * ex , const double * ey,; 113 const double * eval ) :; 114 FitData( n, dataX, dataY ),; 115 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 116 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 117 {; 118 assert( val );; 119 fDataPtr = val;; 120 ; 121 if ( nullptr != eval ); 122 {; 123 fDataErrorPtr = eval;; 124 ; 125 fErrorType = kValueError;; 126 ; 127 if ( nullptr != ex || nullptr != ey ); 128 {; 129 fCoordErrorsPtr.resize( 2 );; 130 ; 131 fCoordErrorsPtr[0] = ex;; 132 fCoordErrorsPtr[1] = ey;; 133 ; 134 fErrorType = kCoordError;; 135 }; 136 }; 137 else; 138 {; 139 fErrorType = kNoError;; 140 }; 141 ; 142 fpTmpCoordErrorVector = new double [ fDim ];; 143 ComputeSums();; 144 }; 145 ; 146 /**; 147 constructor from external data for 3D with errors on coordinate and value; 148 */; 149 BinData::BinData(unsigned int n, const double * dataX, const double * dataY,; 150 const double * dataZ, const double * val, const double * ex ,; 151 const double * ey , const double * ez , const double * eval ) :; 152 FitData( n, dataX, dataY, dataZ ),; 153 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 154 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 155 {; 156 assert( val );; 157 fDataPtr = val;; 158 ; 159 if ( nullptr != eval ); 160 {; 161 fDataErrorPtr = eval;; 162 ; 163 fErrorType = kValueError;; 164 ; 165 if ( nullptr != ex || nullptr != ey || nullptr != ez ); 166 {; 167 fCoordErrorsPtr.resize( 3 );; 168 ; 169 fCoordErrorsPtr[0] = ex;; 170 fCoordErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:4022,error,errors,4022,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['error'],['errors']
Availability," double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:10341,Error,Error,10341,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,4,['Error'],['Error']
Availability," double xmax=0);  scan likelihood value of parameter and fill the given graph. ;  ; void SetChi2AndNdf (double chi2, unsigned int npoints);  Set the chi2 and the ndf This function should be called when using an external FCN for fitting and one provides the chi2 and the number of fitting data points) to store and have them printed in the FitResult class. ;  ; void SetMinosError (unsigned int i, double elow, double eup);  set the Minos errors for parameter i (called by the Fitter class when running Minos) ;  ; int Status () const;  minimizer status code ;  ; bool Update (const std::shared_ptr< ROOT::Math::Minimizer > &min, const ROOT::Fit::FitConfig &fconfig, bool isValid, unsigned int ncalls=0);  Update the fit result with a new minimization status To be run only if same fit is performed with same configuration Note that in this case MINOS is not re-run. ;  ; double UpperError (unsigned int i) const;  upper Minos error. If Minos has not run for parameter i return the parabolic error ;  ; double Value (unsigned int i) const;  parameter value by index ;  . Protected Member Functions; std::shared_ptr< IModelFunction > ModelFunction ();  Return pointer non const pointer to model (fit) function with fitted parameter values. ;  ; void SetModelFunction (const std::shared_ptr< IModelFunction > &func);  . Protected Attributes; std::map< unsigned int, unsigned int > fBoundParams;  list of limited parameters ;  ; double fChi2;  fit chi2 value (different than fval in case of chi2 fits) ;  ; std::vector< double > fCovMatrix;  covariance matrix (size is npar*(npar+1)/2) where npar is total parameters ;  ; int fCovStatus;  covariance matrix status code ;  ; double fEdm;  expected distance from minimum ;  ; std::vector< double > fErrors;  errors ;  ; std::shared_ptr< FitData > fFitData;  ! data set used in the fit ;  ; std::shared_ptr< IModelFunction > fFitFunc;  ! model function resulting from the fit. ;  ; std::map< unsigned int, bool > fFixedParams;  list of fixed parameters ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:7655,error,error,7655,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['error'],['error']
Availability," double xmax=0);  scan likelihood value of parameter and fill the given graph. ;  ; void SetChi2AndNdf (double chi2, unsigned int npoints);  Set the chi2 and the ndf This function should be called when using an external FCN for fitting and one provides the chi2 and the number of fitting data points) to store and have them printed in the FitResult class. ;  ; void SetMinosError (unsigned int i, double elow, double eup);  set the Minos errors for parameter i (called by the Fitter class when running Minos) ;  ; int Status () const;  minimizer status code ;  ; bool Update (const std::shared_ptr< ROOT::Math::Minimizer > &min, const ROOT::Fit::FitConfig &fconfig, bool isValid, unsigned int ncalls=0);  Update the fit result with a new minimization status To be run only if same fit is performed with same configuration Note that in this case MINOS is not re-run. ;  ; double UpperError (unsigned int i) const;  upper Minos error. If Minos has not run for parameter i return the parabolic error ;  ; double Value (unsigned int i) const;  parameter value by index ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitResult.html:17177,error,error,17177,doc/master/classTFitResult.html,https://root.cern,https://root.cern/doc/master/classTFitResult.html,1,['error'],['error']
Availability," double xmin=0, double xmax=0);  scan function minimum for variable i. ;  ; virtual bool SetCovariance (std::span< const double > cov, unsigned int nrow);  set initial covariance matrix ;  ; virtual bool SetCovarianceDiag (std::span< const double > d2, unsigned int n);  set initial second derivatives ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (double up);  set scale for calculating the errors ;  ; void SetExtraOptions (const IOptions &extraOptions);  set only the extra options ;  ; virtual bool SetFixedVariable (unsigned int ivar, const std::string &name, double val);  set a new fixed variable (override if minimizer supports them ) ;  ; virtual void SetFunction (const ROOT::Math::IMultiGenFunction &func)=0;  set the function to minimize ;  ; virtual void SetHessianFunction (std::function< bool(std::span< const double >, double *)>);  set the function implementing Hessian computation (re-implemented by Minimizer using it) ;  ; virtual bool SetLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower, double upper);  set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default set an unlimited variable ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:9572,error,errors,9572,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['error'],['errors']
Availability," double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins. » Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: SparseData.h 31361 2009-11-21 09:14:42Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__SparseData.html:2300,error,error,2300,root/html526/ROOT__Fit__SparseData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__SparseData.html,1,['error'],['error']
Availability," double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins. » Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: SparseData.h 35349 2010-09-17 09:25:00Z moneta $ » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__SparseData.html:2300,error,error,2300,root/html528/ROOT__Fit__SparseData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__SparseData.html,1,['error'],['error']
Availability," double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins. » Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: SparseData.h 35349 2010-09-17 09:25:00Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__SparseData.html:2302,error,error,2302,root/html530/ROOT__Fit__SparseData.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__SparseData.html,1,['error'],['error']
Availability," double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins. » Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: SparseData.h 35349 2010-09-17 09:25:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__SparseData.html:2302,error,error,2302,root/html532/ROOT__Fit__SparseData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html,2,['error'],['error']
Availability," doubleCLb(int index) const; doubleCLbError(int index) const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; doubleCLs(int index) const; doubleCLsError(int index) const; doubleCLsplusb(int index) const; doubleCLsplusbError(int index) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tRooStats::SimpleInterval::ConfidenceLevel() const; RooStats::ConfIntervalRooStats::ConfInterval::ConfInterval(const char* name = 0); RooStats::ConfIntervalRooStats::ConfInterval::ConfInterval(const RooStats::ConfInterval&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; intExclusionCleanup(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); intFindIndex(double xvalue) const; doubleFindInterpolatedLimit(double target, bool lowSearch = false, double xmin = 1, double xmax = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::SamplingDistribution*GetAltTestStatDist(int index) const; RooStats::SamplingDistribution*GetBackgroundTestStatDist(int index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); doubleGetExpectedLowerLimit(double nsig = 0, const char* opt = """") const; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:1895,Error,Error,1895,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,2,['Error'],['Error']
Availability," doublefUpLimit; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitParameter(); default constructor standard with value/error = 0. {}. MinuitParameter(unsigned int num, const string& name, double val); constructor for constant Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err); constructor for standard Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); constructor for limited Parameter. ~MinuitParameter(); {}. MinuitParameter(const ROOT::Minuit2::MinuitParameter& par); {}. MinuitParameter& operator=(const ROOT::Minuit2::MinuitParameter& par). unsigned int Number() const; access methods. {return fNum;}. const std::string & GetName() const; new API returning a string. { return fName; }. const char * Name() const; return const char * for mantaining backward compatibility. {return fName.c_str();}. double Value() const; {return fValue;}. double Error() const; {return fError;}. void SetValue(double val); interaction. {fValue = val;}. void SetError(double err); {fError = err;}. void SetLimits(double low, double up). void SetUpperLimit(double up). void SetLowerLimit(double low). void RemoveLimits(). void Fix(); {fFix = true;}. void Release(); {fFix = false;}. bool IsConst() const; state of Parameter (fixed/const/limited). {return fConst;}. bool IsFixed() const; {return fFix;}. bool HasLimits() const; {return fLoLimValid || fUpLimValid; }. bool HasLowerLimit() const; {return fLoLimValid; }. bool HasUpperLimit() const; {return fUpLimValid; }. double LowerLimit() const; {return fLoLimit;}. double UpperLimit() const; {return fUpLimit;}. » Last changed: root/minuit2:$Id: MinuitParameter.h 38242 2011-02-28 11:07:54Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__MinuitParameter.html:3066,Error,Error,3066,root/html532/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__MinuitParameter.html,1,['Error'],['Error']
Availability," double ; value, . bool ; notifyClients = true . ). inlinefinalvirtual . Overwrite the value stored in this object's cache. ; This can be used to fake a computation that resulted in value. Parameters. [in]valueValue to write. ; [in]notifyClientsIf true, notify users of this object that its value changed. This is the default. . Reimplemented from RooAbsArg.; Definition at line 558 of file RooAbsReal.h. ◆ setData(). virtual bool RooAbsReal::setData ; (; RooAbsData & ; , . bool ; = true . ). inlinevirtual . Reimplemented in ProgressMonitor, RooAddition, RooConstraintSum, and RooAbsTestStatistic.; Definition at line 367 of file RooAbsReal.h. ◆ setEvalErrorLoggingMode(). void RooAbsReal::setEvalErrorLoggingMode ; (; RooAbsReal::ErrorLoggingMode ; m). static . Set evaluation error logging mode. ; Options are; PrintErrors - Print each error through RooMsgService() as it occurs CollectErrors - Accumulate errors, but do not print them. A subsequent call to printEvalErrors() will print a summary CountErrors - Accumulate error count, but do not print them. ; Definition at line 4316 of file RooAbsReal.cxx. ◆ setHideOffset(). void RooAbsReal::setHideOffset ; (; bool ; flag). static . Definition at line 191 of file RooAbsReal.cxx. ◆ setIntegratorConfig() [1/2]. void RooAbsReal::setIntegratorConfig ; (; ). Remove the specialized numeric integration configuration associated with this object. ; Definition at line 3346 of file RooAbsReal.cxx. ◆ setIntegratorConfig() [2/2]. void RooAbsReal::setIntegratorConfig ; (; const RooNumIntConfig & ; config). Set the given integrator configuration as default numeric integration configuration for this object. ; Definition at line 3335 of file RooAbsReal.cxx. ◆ setParameterizeIntegral(). void RooAbsReal::setParameterizeIntegral ; (; const RooArgSet & ; paramVars). Definition at line 4324 of file RooAbsReal.cxx. ◆ setPlotLabel(). void RooAbsReal::setPlotLabel ; (; const char * ; label). Set the label associated with this variable. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:145810,error,error,145810,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability," double ; value, . bool ; notifyClients = true . ). inlinefinalvirtual . Overwrite the value stored in this object's cache. ; This can be used to fake a computation that resulted in value. Parameters. [in]valueValue to write. ; [in]notifyClientsIf true, notify users of this object that its value changed. This is the default. . Reimplemented from RooAbsArg.; Definition at line 568 of file RooAbsReal.h. ◆ setData(). virtual bool RooAbsReal::setData ; (; RooAbsData & ; , . bool ; = true . ). inlinevirtual . Reimplemented in ProgressMonitor, RooAbsTestStatistic, RooAddition, and RooConstraintSum.; Definition at line 374 of file RooAbsReal.h. ◆ setEvalErrorLoggingMode(). void RooAbsReal::setEvalErrorLoggingMode ; (; RooAbsReal::ErrorLoggingMode ; m). static . Set evaluation error logging mode. ; Options are; PrintErrors - Print each error through RooMsgService() as it occurs CollectErrors - Accumulate errors, but do not print them. A subsequent call to printEvalErrors() will print a summary CountErrors - Accumulate error count, but do not print them. ; Definition at line 4392 of file RooAbsReal.cxx. ◆ setHideOffset(). void RooAbsReal::setHideOffset ; (; bool ; flag). static . Definition at line 168 of file RooAbsReal.cxx. ◆ setIntegratorConfig() [1/2]. void RooAbsReal::setIntegratorConfig ; (; ). Remove the specialized numeric integration configuration associated with this object. ; Definition at line 3428 of file RooAbsReal.cxx. ◆ setIntegratorConfig() [2/2]. void RooAbsReal::setIntegratorConfig ; (; const RooNumIntConfig & ; config). Set the given integrator configuration as default numeric integration configuration for this object. ; Definition at line 3417 of file RooAbsReal.cxx. ◆ setParameterizeIntegral(). void RooAbsReal::setParameterizeIntegral ; (; const RooArgSet & ; paramVars). Definition at line 4400 of file RooAbsReal.cxx. ◆ setPlotLabel(). void RooAbsReal::setPlotLabel ; (; const char * ; label). Set the label associated with this variable. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:147647,error,error,147647,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability," draw filled ellips. void DrawEllips2(Int_t x, Int_t y, Int_t rx, Int_t ry, Int_t angle, const char* col = ""#000000"", Int_t thick = 1); Draw an ellipse.; If thick < 0 - draw filled ellipse. void FloodFill(Int_t x, Int_t y, const char* col, const char* min_col, const char* max_col = 0); Flood fill. void Gray(Bool_t on = kTRUE); Convert RGB image to Gray image and vice versa. void FromWindow(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Create an image (screenshot) from specified window. void FromGLBuffer(UChar_t* buf, UInt_t w, UInt_t h); Creates an image (screenshot) from a RGBA buffer. void SetPaletteEnabled(Bool_t on = kTRUE); Switch on/off the image palette.; That also invokes calling vectorization of image. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Bool_t SetJpegDpi(const char* name, UInt_t dpi = 72); Set an image printing resolution in Dots Per Inch units.; name - the name of jpeg file.; set - dpi resolution.; Returns kFALSE in case of error. void GetFillAreaSpans(UInt_t npt, TPoint* ppt, UInt_t* nspans, TPoint** firstPoint, UInt_t** firstWidth). void SetEditable(Bool_t on = kTRUE); { fEditable = on; }. Bool_t IsEditable() const; { return fEditable; }. const char * GetIconName() const; { return GetTitle(); }. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0). Bool_t IsValid() const; { return fImage ? kTRUE : kFALSE; }. Bool_t IsGray() const; { return fIsGray; }. ASImage * GetImage() const; { return fImage; }. TImage * GetScaledImage() const; { return fScaledImage; }. » Author: Fons Rademakers, Reiner Rohlfs 28/11/2001 » Copyright (C) 1995-2001, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/asimage:$Id$ » Last generated: 2015-04-28 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TASImage.html:46222,error,error,46222,root/html534/TASImage.html,https://root.cern,https://root.cern/root/html534/TASImage.html,2,['error'],['error']
Availability," draw filled ellips. void DrawEllips2(Int_t x, Int_t y, Int_t rx, Int_t ry, Int_t angle, const char* col = ""#000000"", Int_t thick = 1); Draw an ellipse.; If thick < 0 - draw filled ellipse. void FloodFill(Int_t x, Int_t y, const char* col, const char* min_col, const char* max_col = 0); Flood fill. void Gray(Bool_t on = kTRUE); Convert RGB image to Gray image and vice versa. void FromWindow(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Create an image (screenshot) from specified window. void FromGLBuffer(UChar_t* buf, UInt_t w, UInt_t h); Creates an image (screenshot) from a RGBA buffer. void SetPaletteEnabled(Bool_t on = kTRUE); Switch on/off the image palette.; That also invokes calling vectorization of image. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Bool_t SetJpegDpi(const char* name, UInt_t dpi = 72); Set an image printing resolution in Dots Per Inch units.; name - the name of jpeg file.; set - dpi resolution.; Returns kFALSE in case of error. void GetFillAreaSpans(UInt_t npt, TPoint* ppt, UInt_t* nspans, TPoint** firstPoint, UInt_t** firstWidth). void SetEditable(Bool_t on = kTRUE); { fEditable = on; }. Bool_t IsEditable() const; { return fEditable; }. const char * GetIconName() const; { return GetTitle(); }. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0). Bool_t IsValid() const; { return fImage ? kTRUE : kFALSE; }. Bool_t IsGray() const; { return fIsGray; }. ASImage * GetImage() const; { return fImage; }. TImage * GetScaledImage() const; { return fScaledImage; }. » Author: Fons Rademakers, Reiner Rohlfs 28/11/2001 » Copyright (C) 1995-2001, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/asimage:$Id$ » Last generated: 2015-06-02 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TASImage.html:48363,error,error,48363,root/html604/TASImage.html,https://root.cern,https://root.cern/root/html604/TASImage.html,2,['error'],['error']
Availability," draw filled ellips. void DrawEllips2(Int_t x, Int_t y, Int_t rx, Int_t ry, Int_t angle, const char* col = ""#000000"", Int_t thick = 1); Draw an ellipse.; If thick < 0 - draw filled ellipse. void FloodFill(Int_t x, Int_t y, const char* col, const char* min_col, const char* max_col = 0); Flood fill. void Gray(Bool_t on = kTRUE); Convert RGB image to Gray image and vice versa. void FromWindow(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Create an image (screenshot) from specified window. void FromGLBuffer(UChar_t* buf, UInt_t w, UInt_t h); Creates an image (screenshot) from a RGBA buffer. void SetPaletteEnabled(Bool_t on = kTRUE); Switch on/off the image palette.; That also invokes calling vectorization of image. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Bool_t SetJpegDpi(const char* name, UInt_t dpi = 72); Set an image printing resolution in Dots Per Inch units.; name - the name of jpeg file.; set - dpi resolution.; Returns kFALSE in case of error. void GetFillAreaSpans(UInt_t npt, TPoint* ppt, UInt_t* nspans, TPoint** firstPoint, UInt_t** firstWidth). void SetEditable(Bool_t on = kTRUE); { fEditable = on; }. Bool_t IsEditable() const; { return fEditable; }. const char * GetIconName() const; { return GetTitle(); }. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0). Bool_t IsValid() const; { return fImage ? kTRUE : kFALSE; }. Bool_t IsGray() const; { return fIsGray; }. ASImage * GetImage() const; { return fImage; }. TImage * GetScaledImage() const; { return fScaledImage; }. » Author: Fons Rademakers, Reiner Rohlfs 28/11/2001 » Copyright (C) 1995-2001, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/asimage:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TASImage.html:47377,error,error,47377,root/html602/TASImage.html,https://root.cern,https://root.cern/root/html602/TASImage.html,2,['error'],['error']
Availability," draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");; ; // Now we have to somehow depict the sys errors; ; auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70. TGraphAsymmErrors; A TGraphAsymmErrors is like a TGraphErrors but the errors defined along X and Y are not symmetric: The left and right errors are different along X and the bottom and up errors are different along Y.; {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26. TGraphBentErrors; A TGraphBentErrors is like a TGraphAsymmErrors. An extra parameter allows to bend the error bars to better see them when several graphs are drawn on the same plot.; {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:14274,error,errors,14274,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,2,['error'],"['error', 'errors']"
Availability," drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutorial transpad.C for a variant; of this example. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; // create/fill draw h1; gStyle->SetOptStat(kFALSE);; TH1F *h1 = new TH1F(""h1"",""Supe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:12732,avail,available,12732,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,10,['avail'],['available']
Availability," drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizontal Bar': draw a horizontal bar chart. 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:2489,avail,available,2489,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,10,['avail'],['available']
Availability," dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPacketizer.html:1818,Error,Error,1818,root/html532/TPacketizer.html,https://root.cern,https://root.cern/root/html532/TPacketizer.html,1,['Error'],['Error']
Availability," dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:14210,error,error,14210,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,12,['error'],['error']
Availability," each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF2 *myfunc = gr->GetFunction(""myfunc"");. Access to the fit results. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts automatically to an; integer. If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; print errors (if e=1, v must be 1); c = 1; print Chisquare/Number of degress of freedom; p = 1; print Probability. For example: gStyle->SetOptFit(1011);; prints the fit probability, parameter names/values, and errors.; You can change the position of the statistics box with these lines; (where g is a pointer to the TGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph2D.html:25434,error,error,25434,root/html528/TGraph2D.html,https://root.cern,https://root.cern/root/html528/TGraph2D.html,10,['error'],['error']
Availability," each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:6722,error,error,6722,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['error'],['error']
Availability," each point for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with an extended p.d.f. and X-Y values dataset; The value of the function that defines the chi^2 in this form is takes as; the p.d.f. times the expected number of events. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE). RooXYChi2Var constructor with an extended p.d.f. and X-Y values dataset; The value of the function that defines the chi^2 in this form is takes as; the p.d.f. times the expected number of events. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:38858,error,error,38858,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,10,['error'],['error']
Availability," either ""%f"" or ""%e"" or ""%10f"" and so on . EnumeratorkSQL_NONE ; kSQL_CHAR ; kSQL_VARCHAR ; kSQL_INTEGER ; kSQL_FLOAT ; kSQL_DOUBLE ; kSQL_NUMERIC ; kSQL_BINARY ; kSQL_TIMESTAMP . Definition at line 60 of file TSQLServer.h. Constructor & Destructor Documentation. ◆ TSQLServer(). TSQLServer::TSQLServer ; (; ). inlineprotected . Definition at line 52 of file TSQLServer.h. ◆ ~TSQLServer(). virtual TSQLServer::~TSQLServer ; (; ). inlinevirtual . Definition at line 72 of file TSQLServer.h. Member Function Documentation. ◆ Class(). static TClass * TSQLServer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSQLServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSQLServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 117 of file TSQLServer.h. ◆ ClearError(). void TSQLServer::ClearError ; (; ). protected . reset error fields ; Definition at line 119 of file TSQLServer.cxx. ◆ Close(). virtual void TSQLServer::Close ; (; Option_t * ; option = """"). pure virtual . Implemented in TMySQLServer, TODBCServer, TPgSQLServer, and TSQLiteServer. ◆ Commit(). Bool_t TSQLServer::Commit ; (; ). virtual . submit ""COMMIT"" query to database return kTRUE, if successful ; Reimplemented in TMySQLServer, TODBCServer, and TSQLiteServer.; Definition at line 160 of file TSQLServer.cxx. ◆ Connect(). TSQLServer * TSQLServer::Connect ; (; const char * ; db, . const char * ; uid, . const char * ; pw . ). static . The db should be of the form: <dbms>://<host>[:<port>][/<database>], e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, pgsql://... or sqlite://<database>... The uid is the username and pw the password that should be used for the connection. ; Depending on the <dbms> the shared library (plugin) for the selected system will be loaded. When the connection could not be opened 0 is returned. ; Definition at line 61 of file TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLServer.html:14903,error,error,14903,doc/master/classTSQLServer.html,https://root.cern,https://root.cern/doc/master/classTSQLServer.html,1,['error'],['error']
Availability," elapsedSeconds) = RecordEvtCountAndTime();; 422 ; 423 if (fIsTTY); 424 std::cout << ""\r"";; 425 ; 426 PrintProgressBar(std::cout, eventCount);; 427 PrintStats(std::cout, eventCount, elapsedSeconds);; 428 ; 429 if (fIsTTY); 430 std::cout << std::flush;; 431 else; 432 std::cout << std::endl;; 433 }; 434 ; 435 std::size_t ComputeNEventsSoFar() const; 436 {; 437 std::unique_lock<std::mutex> lock(fSampleNameToEventEntriesMutex);; 438 std::size_t result = 0;; 439 for (const auto &item : fSampleNameToEventEntries); 440 result += item.second;; 441 return result;; 442 }; 443 ; 444 unsigned int ComputeCurrentFileIdx() const; 445 {; 446 std::unique_lock<std::mutex> lock(fSampleNameToEventEntriesMutex);; 447 return fSampleNameToEventEntries.size();; 448 }; 449};; 450} // namespace Experimental; 451} // namespace RDF; 452} // namespace ROOT; 453#endif; GraphUtils.hxx; RActionBase.hxx; RResultHandle.hxx; RResultMap.hxx; f#define f(i)Definition RSha256.hxx:104; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; N#define N; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; operator()TRObject operator()(const T1 &t1) constDefinition TRFunctionImport__oprtr.h:14; TypeTraits.hxx; ROOT::Detail::RDF::RLoopManager::Jitvoid Jit()Add RDF nodes that require just-in-time compilation to the computation graph.Definition RLoopManager.cxx:848; ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelperDefinition GraphUtils.hxx:57; ROOT::Internal::RDF::GraphDrawing::GraphCreato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:20827,error,error,20827,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['error'],['error']
Availability," elastic and inelastic scattering of ⁷Be+p. He then moved on to obtain his PhD in aerospace engineering from the University of Illinois at Urbana-Champaign, USA. Guilherme then worked for two years at São Paulo State University (UNESP) in collaboration with CERN and Fermilab before joining the ROOT Team in April of 2017. His responsibilities in ROOT include working on the build system, performance analysis and optimization, and support for SIMD vectorization.;  ; ; . Jakob Blomer ; ; Jakob joined CERN for the first time as a summer student in 2007. He graduated from the University of Karlsruhe and obtained a PhD in computer science from the Technical University of Munich. Jakob works on distributed systems and storage software. He created the CernVM File System, which he evolves ever since. Jakob has been a Marie Curie fellow and a visiting scholar at the RAMCloud research group at Stanford University. In the ROOT team, Jakob works on the columnar data storage for event data, searching for ever faster and more robust ways to read and write hierarchically nested ntuples.; ; . Lorenzo Moneta ; ; Lorenzo started working in 1989 as an experimental physicist for the ALEPH experiment working for data analysis and software event reconstruction. He graduated in Pisa in 1990 and he received his Ph.D. in particle physics in 1994 at the University of Florence. Afterwards, since 1997, he was working for data analysis of the CDF experiments and online software for the ATLAS experiment. In 2002 he joined the physics application software group of CERN, and since 2005 he joined the ROOT team with the responsibility of the Math work package, which provides development and support for the ROOT mathematical and statistical libraries. ; ; . Oksana Shadura ; ; Currently, I am employed as a software developer from the University of Nebraska-Lincoln (CMS), based at CERN and working as a core developer in the ROOT framework. My area of research is a various improvement for ROOT I/O, particu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:6557,robust,robust,6557,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['robust'],['robust']
Availability," else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208Double_t TMath::ErfInverse(Double_t x); 209{; 210 Int_t kMaxit = 50;; 211 Double_t kEps = 1e-14;; 212 Double_t kConst = 0.8862269254527579; // sqrt(pi)/2.0; 213 ; 214 if(TMath::Abs(x) <= kEps) return kConst*x;; 215 ; 216 // Newton iterations; 217 Double_t erfi, derfi, y0,y1,dy0,dy1;; 218 if(TMath::Abs(x) < 1.0) {; 219 erfi = kConst*TMath::Abs(x);; 220 y0 = TMath::Erf(0.9*erfi);; 221 derfi = 0.1*erfi;; 222 for (Int_t iter=0; iter<kMaxit; iter++) {; 223 y1 = 1. - TMath::Erfc(erfi);; 224 dy1 = TMath::Abs(x)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:5780,error,error,5780,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability," else {// we have fixed parameters; 1400 if (fENDFLG == 0) {; 1401 //... CHECK IF fiXING ON BOUND IS CORRECT; 1402 fENDFLG = 1;; 1403 fixFLG = 0;; 1404 ifix1=-1;; 1405 // release fixed parameters; 1406 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1407 fINDFLG[1] = 0;; 1408 // and repeat iteration; 1409 goto L19;; 1410 } else {; 1411 if( ifix1 >= 0) {; 1412 fi = fi + 1;; 1413 fENDFLG = 0;; 1414 }; 1415 }; 1416 }; 1417 } else { // fit does not converge; 1418 if( fixFLG != 0) {; 1419 if( fi > fixFLG ) {; 1420 //... CHECK IF fiXING ON BOUND IS CORRECT; 1421 fENDFLG = 1;; 1422 fixFLG = 0;; 1423 ifix1=-1;; 1424 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1425 fINDFLG[1] = 0;; 1426 goto L19;; 1427 } else {; 1428 fi = fi + 1;; 1429 fENDFLG = 0;; 1430 }; 1431 } else {; 1432 fi = fi + 1;; 1433 fENDFLG = 0;; 1434 }; 1435 }; 1436 }; 1437 ; 1438// L85:; 1439 // iteration number limit is exceeded; 1440 if(fENDFLG == 0 && nn3 >= fNmaxIter) fENDFLG=-3;; 1441 ; 1442 // fit errors are infinite;; 1443 if(fENDFLG > 0 && fINDFLG[1] > 0) fENDFLG=-2;; 1444 ; 1445 //MONITO (fS,fNpar,nn3,IT,fEPS,fGT,fAKAPPA,alambd);; 1446 if (fENDFLG == 0) { // make step; 1447 for ( i = 0; i < n; i++) fA[i] = fA[i] + fDA[i];; 1448 if (imax >= 0) fA[imax] = aiMAX;; 1449 olds=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:40733,error,errors,40733,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability," emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. Double_t weightSquared() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer weight. const RooArgSet* get() const; Return a RooArgSet with the coordinates of the current event. void add(const RooArgSet& row, Double_t weight = 1., Double_t weightError = 0); Add a data point, with its coordinates specified in the 'data' argset, to the data set.; Any variables present in 'data' but not in the dataset will be silently ignored. void add(const RooArgSet& row, Double_t w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:28016,Error,ErrorType,28016,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['Error'],['ErrorType']
Availability," emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. Double_t weightSquared() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer weight. const RooArgSet* get() const; Return a RooArgSet with the coordinates of the current event. void add(const RooArgSet& row, Double_t weight = 1.0, Double_t weightError = 0); Add a data point, with its coordinates specified in the 'data' argset, to the data set.; Any variables present in 'data' but not in the dataset will be silently ignored. void add(const RooArgSet& row, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:26752,Error,ErrorType,26752,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,1,['Error'],['ErrorType']
Availability," end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1611 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:134720,error,error,134720,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability," end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1639 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:136050,error,error,136050,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability," enough memory for worker thread connection array"";; 20108 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20109 ; 20110 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20111 mg_snprintf(NULL,; 20112 NULL, /* No truncation check for error buffers */; 20113 error->text,; 20114 error->text_buffer_size,; 20115 ""%s"",; 20116 err_msg);; 20117 }; 20118 free_context(ctx);; 20119 pthread_setspecific(sTlsKey, NULL);; 20120 return NULL;; 20121 }; 20122 ; 20123#if defined(ALTERNATIVE_QUEUE); 20124 ctx->client_wait_events =; 20125 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20126 sizeof(ctx->client_wait_events[0]),; 20127 ctx);; 20128 if (ctx->client_wait_events == NULL) {; 20129 const char *err_msg = ""Not enough memory for worker event array"";; 20130 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20131 mg_free(ctx->worker_threadids);; 20132 ; 20133 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20134 mg_snprintf(NULL,; 20135 NULL, /* No truncation check for error buffers */; 20136 error->text,; 20137 error->text_buffer_size,; 20138 ""%s"",; 20139 err_msg);; 20140 }; 20141 free_context(ctx);; 20142 pthread_setspecific(sTlsKey, NULL);; 20143 return NULL;; 20144 }; 20145 ; 20146 ctx->client_socks =; 20147 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20148 sizeof(ctx->client_socks[0]),; 20149 ctx);; 20150 if (ctx->client_socks == NULL) {; 20151 const char *err_msg = ""Not enough memory for worker socket array"";; 20152 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20153 mg_free(ctx->client_wait_events);; 20154 mg_free(ctx->worker_threadids);; 20155 ; 20156 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20157 mg_snprintf(NULL,; 20158 NULL, /* No truncation check for error buffers */; 20159 error->text,; 20160 error->text_buffer_size,; 20161 ""%s"",; 20162 err_msg);; 20163 }; 20164 free_context(ctx);; 20165 pthread_setspecific(sTlsKey, NULL);; 20166 return NULL;; 20167 }; 20168 ; 20169 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20170 ctx->clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:601910,error,error,601910,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:601943,error,error,601943,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," entered (default);; kNoEcho - do not display anything;; kPassword - display asterisks instead of the characters actually entered. The way in which typed characters are inserted in the text entry is defined by TGTextEntry::EInsertMode and can be toggled by the Insert key:. kInsert - typed character are inserted (cursor has shape of short line); kReplace - entered characters substitute already typed ones (cursor has the shape of filled rectangle). ; There ate different text alignment modes defined by TGWidget::ETextJustification. They are valid until text fits the frame width of the text entry field. kTextLeft - left-side text alignment; kTextRight - right-side text alignment; kTextCenterX - center text alignment along x direction; kTextTop - top-side text alignment; kTextBottom - bottom-side text alignment; kTextCenterY - center text alignment along y direction. 25.8.3 Number Entries; The TGNumberEntry class present number entry widgets. A number entry is a single-line field followed by two small, vertically arranged up-down buttons. Its purpose is to make a selection by either scrolling through a small set of meaningful predefined choices or typing numbers. The TGNumberFormat class contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry. It allows only numerical input. The widget supports numerous formats including integers, hex numbers, real numbers, fixed fraction real and time/date formats. It also allows to restrict input values to non-negative or positive numbers and to specify explicit limits. The following styles are supported:. kNESInteger - integer number; kNESRealOne - real number with one digit (no exponent); kNESRealTwo - real number with two digits (no exponent); kNESRealThree - real number with three digits (no exponent); kNESRealFour - real number with four digits (no exponent); kNESReal - arbitrary real number; kNESDegree - angle in degree:minutes:seconds format; kNESMinSec - time in minutes:seconds format;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1186703,down,down,1186703,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability," entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The axis x may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width.; Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:92797,error,errors,92797,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['error'],['errors']
Availability," enum  EStatusBits { kFileIsPipe = (1ULL << ( 23 )); };  ;  Public Types inherited from TFileHandler; enum  { kRead = 1; , kWrite = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TASLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TASLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ; virtual ~TASLogHandler ();  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady () const;  ; virtual Bool_t IsWriteReady () const;  ; Bool_t Notify () override;  Notify when event occurred on descriptor associated with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASLogHandler.html:1408,avail,available,1408,doc/master/classTASLogHandler.html,https://root.cern,https://root.cern/doc/master/classTASLogHandler.html,1,['avail'],['available']
Availability," error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:21738,error,errors,21738,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability," error and -2 in case of version mismatch. Bool_t IsRootFile(const char* filename) const; Return true if the file is local and is (likely) to be a ROOT file. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:32301,error,error,32301,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['error'],['error']
Availability," error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end of the error bars (when option 1 is used).; By default np=1. (np represents the number of pixels).; TGraphErrors; A TGraphErrors is a TGraph with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Picture; Source. {; TCanvas *c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->Draw(""ap"");; return c4;; }; The option ""3"" allows to shows the error as band. Picture; Source. {; TCanvas *c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:6080,error,error,6080,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability, error found - save the configuration ; : 1 | 0.70053 0.692869 0.629389 0.0419042 4255.43 0; : 2 | 0.694153 0.694394 0.642643 0.0421501 4163.24 1; : 3 | 0.689625 0.697522 0.642119 0.0416746 4163.58 2; : 4 | 0.681203 0.694822 0.637781 0.0412238 4190.71 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.623882 0.0409529 4288.69 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.616834 0.0410715 4342.07 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.607427 0.0404816 4409.59 0; : 8 | 0.616397 0.638352 0.60791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.598324 0.0405273 4481.92 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:16516,error,error,16516,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability," error of the mean value; of the histogram along X, Y or Z axis. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t GetMeanError(Int_t axis = 1) const; -*-*-*-*-*-*Return standard error of mean of this histogram along the X axis*-*-*-*-*. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Also note, that although the definition of standard error doesn't include the; assumption of normality, many uses of this feature implicitly assume it. Double_t GetRMS(Int_t axis = 1) const; For axis = 1,2 or 3 returns the Sigma value of the histogram along; X, Y or Z axis; For axis = 11, 12 or 13 returns the error of RMS estimation along; X, Y or Z axis for Normal distribution. Note that the mean value/sigma is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Note that this function returns the Standard Deviation (Sigma); of the distribution (not RMS).; The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2)); The name ""RMS"" was introduced many years ago (Hbook/PAW times).; We kept the name for continuity. Double_t GetRMSError(Int_t axis = 1) const; Return error of RMS e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:101932,error,error,101932,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['error'],['error']
Availability," error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:8519,error,error,8519,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,20,['error'],['error']
Availability," error value of sigma y parameter ; Definition at line 58 of file TSpectrum2Fit.h. ◆ fSigmaInitX. Double_t TSpectrum2Fit::fSigmaInitX. protected . initial value of sigma x parameter ; Definition at line 53 of file TSpectrum2Fit.h. ◆ fSigmaInitY. Double_t TSpectrum2Fit::fSigmaInitY. protected . initial value of sigma y parameter ; Definition at line 56 of file TSpectrum2Fit.h. ◆ fStatisticType. Int_t TSpectrum2Fit::fStatisticType. protected . type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood ; Definition at line 24 of file TSpectrum2Fit.h. ◆ fSxCalc. Double_t TSpectrum2Fit::fSxCalc. protected . calculated value of s parameter for 1D ridges in x direction ; Definition at line 75 of file TSpectrum2Fit.h. ◆ fSxErr. Double_t TSpectrum2Fit::fSxErr. protected . error value of s parameter for 1D ridges in x direction ; Definition at line 76 of file TSpectrum2Fit.h. ◆ fSxInit. Double_t TSpectrum2Fit::fSxInit. protected . initial value of s parameter for 1D ridges in x direction (relative amplitude of step), for details see html manual and references ; Definition at line 74 of file TSpectrum2Fit.h. ◆ fSxyCalc. Double_t TSpectrum2Fit::fSxyCalc. protected . calculated value of s parameter for 2D peaks ; Definition at line 66 of file TSpectrum2Fit.h. ◆ fSxyErr. Double_t TSpectrum2Fit::fSxyErr. protected . error value of s parameter for 2D peaks ; Definition at line 67 of file TSpectrum2Fit.h. ◆ fSxyInit. Double_t TSpectrum2Fit::fSxyInit. protected . initial value of s parameter for 2D peaks (relative amplitude of step), for details see html manual and references ; Definition at line 65 of file TSpectrum2Fit.h. ◆ fSyCalc. Double_t TSpectrum2Fit::fSyCalc. protected . calculated value of s parameter for 1D ridges in y direction ; Definition at line 78 of file TSpectrum2Fit.h. ◆ fSyErr. Double_t TSpect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:92276,error,error,92276,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability," errorbars to the graph. ;  ; void Apply (TF1 *f) override;  Apply function to all the data points \( y = f(x,y) \). ;  ; virtual void ApplyX (TF1 *f);  Apply function to all the data points \( x = f(x,y) \). ;  ; void ComputeRange (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;  Compute range. ;  ; Double_t GetErrorX (Int_t bin) const override;  It returns the error along X at point i. ;  ; Double_t GetErrorXhigh (Int_t bin) const override;  It returns the error along X at point i. ;  ; Double_t GetErrorXlow (Int_t bin) const override;  It returns the error along X at point i. ;  ; Double_t GetErrorY (Int_t bin) const override;  It returns the error along Y at point i. ;  ; Double_t GetErrorYhigh (Int_t bin) const override;  It returns the error along Y at point i. ;  ; Double_t GetErrorYlow (Int_t bin) const override;  It returns the error along Y at point i. ;  ; Double_t * GetEX () const override;  ; Double_t * GetEY () const override;  ; Int_t Merge (TCollection *list) override;  Adds all graphs with errors from the collection to this graph. ;  ; TGraphErrors & operator= (const TGraphErrors &gr);  TGraphErrors assignment operator. ;  ; void Print (Option_t *chopt="""") const override;  Print graph and errors values. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; void Scale (Double_t c1=1., Option_t *option=""y"") override;  Multiply the values and errors of a TGraphErrors by a constant c1. ;  ; virtual void SetPointError (Double_t ex, Double_t ey);  Set ex and ey values for point pointed by the mouse. ;  ; virtual void SetPointError (Int_t i, Double_t ex, Double_t ey);  Set ex and ey values for point number i. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGraph;  TGraph ();  Graph default constructor. ;  ;  TGraph (const char *filename, const char *format=""%lg %lg"", Option_t *op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:6390,error,errors,6390,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['error'],['errors']
Availability," errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower error for the case b1=b2.; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2966 of file TH1.cxx. ◆ Divide() [3/3]. Bool_t TH1::Divide ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalculated. ; Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; The function return kFALSE if the divide operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 2840 of file TH1.cxx. ◆ DoFillN(). void TH1::DoFillN ; (; Int_t ; ntimes, . const Double_t * ; x, . const Double_t * ; w, . Int_t ; stride = 1 . ). protectedvirtual . Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ; Definition at line 3473 of file TH1.cxx. ◆ DoIntegral(). Double_t TH1::DoIntegral ; (; Int_t ; ix1, . Int_t ; ix2, . Int_t ; iy1, . Int_t ; iy2, . Int_t ; iz1, . Int_t ; iz2, . Double_t & ; err, . Option_t * ; opt, . Bool_t ; doerr = kFALSE . ); const. protectedvirtual . Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ; Definition at line 7977 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:107374,error,errors,107374,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability," errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Scale; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2908 of file TH1.cxx. ◆ Divide() [2/3]. Bool_t TH1::Divide ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1, . Option_t * ; option = """" . ). virtual . Replace contents of this histogram by the division of h1 by h2. ; this = c1*h1/(c2*h2); If errors are defined (see TH1::Sumw2), errors are also recalculated Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. However, if option =""B"" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower error for the case b1=b2.; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2966 of file TH1.cxx. ◆ Divide() [3/3]. Bool_t TH1::Divide ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalculated. ; Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:106395,error,errors,106395,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability," errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4105 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected region . Verbose() Verbose output of GOF framework . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits. . SumCoefRange() Set the range in which to interpret the coefficients of RooAddPdf components . SplitRange() Fit ranges used in different ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:71671,error,errors,71671,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['errors']
Availability," errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected region . Verbose() Verbose output of GOF framework . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits. . SumCoefRange() Set the range in which to interpret the coefficients of RooAddPdf components . SplitRange() Fit ranges used in different ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:72939,error,errors,72939,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['errors']
Availability," errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84317,error,errors,84317,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability, errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9718,error,errors,9718,doc/master/rf606__nllerrorhandling_8C.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html,4,['error'],"['error', 'errors']"
Availability," estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221589,error,error,221589,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['error', 'reliab']","['error', 'reliable']"
Availability," estimation of new value in the; channel ��;  ; Algorithm based on Successive; Comparisons; It is an extension of; one-dimensional SNIP algorithm to another dimension. For details we refer to; [2].;  ; Algorithm based on One Step; Filtering; The algorithm is analogous to; that for 2-dimensional data. For details we refer to TSpectrum2. New value in; the estimated channel is calculated as;  .  ; where p = 1, 2, �,; number_of_iterations. ;  ; Function:; const char*; TSpectrum3::Background; (float; ***fSpectrum, int fSizex, int; fSizey, int fSizez, int fNumberIterationsX, int; fNumberIterationsY, int fNumberIterationsZ, �int; fDirection, int fFilterType)� ;  ; This function calculates; background spectrum from the source spectrum.� The result is placed in the matrix; pointed by fSpectrum pointer.� One can also switch the direction of the change; of the clipping window and to select one of the two above given algorithms. On; successful completion it returns 0. On error it returns pointer to the string; describing error.;  ; Parameters:; ������� fSpectrum-pointer to the matrix of source; spectrum����������������� ; ������� fSizex, fSizey, fSizez -lengths of the; spectrum matrix�������������������������������� ; ������� fNumberIterationsX,; fNumberIterationsY, fNumberIterationsZ maximal; ������� widths of clipping window,��������������������������������. ������� fDirection- direction of change of clipping; window����������������� ; �������������� - possible; values=kBackIncreasingWindow��������������������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� fFilterType-type of the clipping algorithm,����������; �������������������; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]� C. G Ryan et al.: SNIP, a; statistics-sensitive background treatment for the quantitative analysis of PIXE; spectra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:13184,error,error,13184,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,12,['error'],['error']
Availability," estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - f(x-h)}{2h}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.; AuthorAnna Kreshuk ; Definition at line 1113 of file TF1.cxx. ◆ Derivative2(). Double_t TF1::Derivative2 ; (; Double_t ; x, . Double_t * ; params = nullptr, . Double_t ; eps = 0.001 . ); const. virtual . Returns the second derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:63210,error,error,63210,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['error'],['error']
Availability," event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleCli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTree.html:32503,mask,mask,32503,root/html528/TGListTree.html,https://root.cern,https://root.cern/root/html528/TGListTree.html,20,['mask'],['mask']
Availability," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:9733,error,error,9733,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,30,['error'],"['error', 'errors']"
Availability," exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500///////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:50224,error,errors,50224,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability," exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. TMinuit(); TMinuit(Int_t maxpar); virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:13382,error,error,13382,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['error'],['error']
Availability," exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:13380,error,error,13380,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['error'],['error']
Availability," explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:64708,error,error,64708,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability," explanation of parameters) ;  ;  TH3I (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup);  Constructor for fix bin size 3-D histograms (see TH3::TH3 for explanation of parameters) ;  ;  TH3I (const TH3I &h3i);  Copy constructor. ;  ;  ~TH3I () override;  Destructor. ;  ; void AddBinContent (Int_t bin) override;  Increment bin content by 1. ;  ; void AddBinContent (Int_t bin, Double_t w) override;  Increment bin content by w. ;  ; void AddBinContent (Int_t binx, Int_t biny, Int_t binz) override;  Increment 3D bin content by 1. ;  ; void AddBinContent (Int_t binx, Int_t biny, Int_t binz, Double_t w) override;  Increment 3D bin content by a weight w. ;  ; void Copy (TObject &hnew) const override;  Copy this 3-D histogram structure to newth3. ;  ; TClass * IsA () const override;  ; TH3I & operator= (const TH3I &h1);  Operator =. ;  ; void Reset (Option_t *option="""") override;  Reset this histogram: contents, errors, etc. ;  ; void SetBinsLength (Int_t n=-1) override;  Set total number of bins including under/overflow Reallocate bin contents array. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH3. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH3;  ~TH3 () override;  Destructor. ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; virtual Int_t Fill (const char *namex, const char *namey, const char *namez, Double_t w);  Increment cell defined by namex,namey,namez by a weight w. ;  ; virtual Int_t Fill (const char *namex, const char *namey, Double_t z, Double_t w);  Increment cell defined by namex,namey,z by a weight w. ;  ; virtual Int_t Fill (const char *namex, Double_t y, const char *namez, Double_t w);  Increment cell defined by namex,y,namez by a weight w. ;  ; virtual Int_t Fill (const char *namex, Double_t y, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3I.html:1986,error,errors,1986,doc/master/classTH3I.html,https://root.cern,https://root.cern/doc/master/classTH3I.html,1,['error'],['errors']
Availability," explanation of parameters) ;  ;  TH3L (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup);  Constructor for fix bin size 3-D histograms (see TH3::TH3 for explanation of parameters) ;  ;  TH3L (const TH3L &h3l);  Copy constructor. ;  ;  ~TH3L () override;  Destructor. ;  ; void AddBinContent (Int_t bin) override;  Increment bin content by 1. ;  ; void AddBinContent (Int_t bin, Double_t w) override;  Increment bin content by w. ;  ; void AddBinContent (Int_t binx, Int_t biny, Int_t binz) override;  Increment 3D bin content by 1. ;  ; void AddBinContent (Int_t binx, Int_t biny, Int_t binz, Double_t w) override;  Increment 3D bin content by a weight w. ;  ; void Copy (TObject &hnew) const override;  Copy this 3-D histogram structure to newth3. ;  ; TClass * IsA () const override;  ; TH3L & operator= (const TH3L &h1);  Operator =. ;  ; void Reset (Option_t *option="""") override;  Reset this histogram: contents, errors, etc. ;  ; void SetBinsLength (Int_t n=-1) override;  Set total number of bins including under/overflow Reallocate bin contents array. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH3. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH3;  ~TH3 () override;  Destructor. ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; virtual Int_t Fill (const char *namex, const char *namey, const char *namez, Double_t w);  Increment cell defined by namex,namey,namez by a weight w. ;  ; virtual Int_t Fill (const char *namex, const char *namey, Double_t z, Double_t w);  Increment cell defined by namex,namey,z by a weight w. ;  ; virtual Int_t Fill (const char *namex, Double_t y, const char *namez, Double_t w);  Increment cell defined by namex,y,namez by a weight w. ;  ; virtual Int_t Fill (const char *namex, Double_t y, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3L.html:1988,error,errors,1988,doc/master/classTH3L.html,https://root.cern,https://root.cern/doc/master/classTH3L.html,1,['error'],['errors']
Availability," exponential decay after some time t and a number of events with timestamps for which we want to evaluate this function.; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);; ; for (auto & event : events) {; tf.Eval(event.t);; }; The distinction between variables and parameters arose from the TFormula's application in fitting. There parameters are fitted to the data provided through variables. In other applications this distinction can go away.; Parameter values can be provided dynamically using TFormula::EvalPar instead of TFormula::Eval. In this way parameters can be used identically to variables. See below for an example that uses only parameters to model a function.; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; ; tf.EvalPar(nullptr, params);; int. A note on operators; All operators of C/C++ are allowed in a TFormula with a few caveats.; The operators |, &, % can be used but will raise an error if used in conjunction with a variable or a parameter. Variables and parameters are treated as doubles internally for which these operators are not defined. This means the following command will run successfully -l -q -e TFormula("""", ""x+(10%3)"").Eval(0); but not -l -q -e TFormula("""", ""x%10"").Eval(0); .; The operator ^ is defined to mean exponentiation instead of the C/C++ interpretation xor. ** is added, also meaning exponentiation.; The operators ++ and @ are added, and are shorthand for the a linear function. That means the expression x@2 will be expanded to [n]*x + [n+1]*2; nconst Int_t nDefinition legend1.C:16; where n is the first previously unused parameter number. ; Definition at line 88 of file TFormula.h. Public Types; using CladStorage = std::vector< Double_t >;  ; enum  EStatusBits { kNotGlobal = (1ULL << ( 10 )); , kNormalized = (1ULL << ( 14 )); , kLinear = (1ULL << ( 16 )); , kLambda = (1ULL << ( 17 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:7380,error,error,7380,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['error'],['error']
Availability," eyH);; 180 else; 181 fEyH[0].Reset(0.);; 182 ; 183 CalcYErrorsSum();; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// TGraphMultiErrors normal constructor with name, title, `np` points and a single y-error.; 188///; 189/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 190 ; 191TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Double_t *x,; 192 const Double_t *y, const Double_t *exL, const Double_t *exH, const Double_t *eyL,; 193 const Double_t *eyH, Int_t m); 194 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 195{; 196 SetNameTitle(name, title);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 201///; 202/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 203/// The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 206 const Float_t *exH, std::vector<std::vector<Float_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:7369,error,errors,7369,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability," f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TMethodCall.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TNamed.h; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:14697,error,errorDefinition,14697,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['error'],['errorDefinition']
Availability," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run. » Last changed: root/foam:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFoamMaxwt.html:6290,toler,tolerance,6290,root/html534/TFoamMaxwt.html,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html,4,['toler'],['tolerance']
Availability," f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:361566,error,error,361566,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['error'],['error']
Availability," f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:364204,error,error,364204,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['error'],['error']
Availability," f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoTube::SetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::SetShapeBit(UInt_t f); voidTGeoShape::SetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTGeoShape::SetTransform(TGeoMatrix* matrix); voidTGeoTube::SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tTGeoShape::ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidTGeoTube::Sizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTGeoShape::TestShapeBit(UInt_t f) const; Int_tTGeoShape::TestShapeBits(UInt_t f) const; static Double_tTGeoShape::Tolerance(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltu.html:10390,Toler,Tolerance,10390,root/html532/TGeoEltu.html,https://root.cern,https://root.cern/root/html532/TGeoEltu.html,1,['Toler'],['Tolerance']
Availability," fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__BinData.html:6603,Error,ErrorType,6603,root/html534/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html,1,['Error'],['ErrorType']
Availability," fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49697,error,errors,49697,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability," fLimit(8 * std::numeric_limits<double>::epsilon()); 125 {};; 126 ; 127 void operator() (double value); 128 {; 129 if ( fabs(value- (*fIter)) < fLimit ); 130// if ( TMath::AreEqualRel(value, (*fIter), fLimit) ); 131 fThereIsArea = false;; 132 ; 133 ++fIter;; 134 }; 135 ; 136 bool IsThereArea() { return fThereIsArea; }; 137 ; 138 private:; 139 bool fThereIsArea;; 140 vector<double>::iterator fIter;; 141 double fLimit;; 142 };; 143 ; 144 ; 145 // This is the key of the SparseData structure. This method; 146 // will, by recursion, divide the area passed as an argument in; 147 // min and max into pieces to insert the Box defined by bmin and; 148 // bmax. It will do so from the highest dimension until it gets; 149 // to 1 and create the corresponding boxes to divide the; 150 // original space.; 151 void DivideBox( const vector<double>& min, const vector<double>& max,; 152 const vector<double>& bmin, const vector<double>& bmax,; 153 const unsigned int size, const unsigned int n,; 154 list<Box>& l, const double val, const double error); 155 {; 156 vector<double> boxmin(min);; 157 vector<double> boxmax(max);; 158 ; 159 boxmin[n] = min[n];; 160 boxmax[n] = bmin[n];; 161 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 162 l.push_back(Box(boxmin, boxmax));; 163 ; 164 boxmin[n] = bmin[n];; 165 boxmax[n] = bmax[n];; 166 if ( n == 0 ); 167 {; 168 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 169 l.push_back(Box(boxmin, boxmax, val, error));; 170 }; 171 else; 172 DivideBox(boxmin, boxmax, bmin, bmax, size, n-1, l, val, error);; 173 ; 174 boxmin[n] = bmax[n];; 175 boxmax[n] = max[n];; 176 if ( for_each(boxmin.begin(), boxmin.end(), AreaComparer(boxmax.begin())).IsThereArea() ); 177 l.push_back(Box(boxmin, boxmax));; 178 }; 179 ; 180 class ProxyListBox; 181 {; 182 public:; 183 void PushBack(Box& box) { fProxy.push_back(box); }; 184 list<Box>::iterator Begin() { return fProxy.begin(); }; 185 list<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:4866,error,error,4866,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['error'],['error']
Availability," fM[kXX] = T(1);; 949 fM[kXY] = T(0);; 950 fM[kXZ] = T(0);; 951 fM[kDX] = v.X();; 952 fM[kYX] = T(0);; 953 fM[kYY] = T(1);; 954 fM[kYZ] = T(0);; 955 fM[kDY] = v.Y();; 956 fM[kZX] = T(0);; 957 fM[kZY] = T(0);; 958 fM[kZZ] = T(1);; 959 fM[kDZ] = v.Z();; 960 }; 961 ; 962 /**; 963 Set identity transformation (identity rotation , zero translation); 964 */; 965 void SetIdentity(); 966 {; 967 // set identity ( identity rotation and zero translation); 968 fM[kXX] = T(1);; 969 fM[kXY] = T(0);; 970 fM[kXZ] = T(0);; 971 fM[kDX] = T(0);; 972 fM[kYX] = T(0);; 973 fM[kYY] = T(1);; 974 fM[kYZ] = T(0);; 975 fM[kDY] = T(0);; 976 fM[kZX] = T(0);; 977 fM[kZY] = T(0);; 978 fM[kZZ] = T(1);; 979 fM[kDZ] = T(0);; 980 }; 981 ; 982 /**; 983 Set identity transformation (identity rotation , zero translation); 984 vectorised version that sets using a mask; 985 */; 986 template <typename SCALAR = T, typename std::enable_if<!std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 987 void SetIdentity(const typename SCALAR::mask_type m); 988 {; 989 // set identity ( identity rotation and zero translation); 990 fM[kXX](m) = T(1);; 991 fM[kXY](m) = T(0);; 992 fM[kXZ](m) = T(0);; 993 fM[kDX](m) = T(0);; 994 fM[kYX](m) = T(0);; 995 fM[kYY](m) = T(1);; 996 fM[kYZ](m) = T(0);; 997 fM[kDY](m) = T(0);; 998 fM[kZX](m) = T(0);; 999 fM[kZY](m) = T(0);; 1000 fM[kZZ](m) = T(1);; 1001 fM[kDZ](m) = T(0);; 1002 }; 1003 ; 1004private:; 1005 T fM[12]; // transformation elements (3x4 matrix); 1006};; 1007 ; 1008 ; 1009 ; 1010 ; 1011// inline functions (combination of transformations); 1012 ; 1013template <class T>; 1014inline Transform3D<T> &Transform3D<T>::operator*=(const Transform3D<T> &t); 1015{; 1016 // combination of transformations; 1017 ; 1018 SetComponents(fM[kXX]*t.fM[kXX]+fM[kXY]*t.fM[kYX]+fM[kXZ]*t.fM[kZX],; 1019 fM[kXX]*t.fM[kXY]+fM[kXY]*t.fM[kYY]+fM[kXZ]*t.fM[kZY],; 1020 fM[kXX]*t.fM[kXZ]+fM[kXY]*t.fM[kYZ]+fM[kXZ]*t.fM[kZZ],; 1021 fM[kXX]*t.fM[kDX]+fM[kXY]*t.fM[kDY]+fM[kXZ]*t.fM[kDZ]+fM[kDX],; 1022 ; 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:33614,mask,mask,33614,doc/master/GenVector_2Transform3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html,1,['mask'],['mask']
Availability," fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCondition.html:6563,error,error,6563,root/html528/TCondition.html,https://root.cern,https://root.cern/root/html528/TCondition.html,2,['error'],['error']
Availability," fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCondition.html:6632,error,error,6632,root/html530/TCondition.html,https://root.cern,https://root.cern/root/html530/TCondition.html,2,['error'],['error']
Availability," fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCondition.html:6632,error,error,6632,root/html532/TCondition.html,https://root.cern,https://root.cern/root/html532/TCondition.html,4,['error'],['error']
Availability," fNpoints; i++) {; 836 fEX[i] = ex[i];; 837 fEY[i] = ey[i];; 838 }; 839 delete [] ey;; 840 delete [] ex;; 841 } else {; 842 b.ReadFastArray(fEX, fNpoints);; 843 b.ReadFastArray(fEY, fNpoints);; 844 }; 845 b.CheckByteCount(R__s, R__c, TGraphErrors::IsA());; 846 //====end of old versions; 847 ; 848 } else {; 849 b.WriteClassBuffer(TGraphErrors::Class(), this);; 850 }; 851}; 852 ; 853////////////////////////////////////////////////////////////////////////////////; 854/// Swap points.; 855 ; 856void TGraphErrors::SwapPoints(Int_t pos1, Int_t pos2); 857{; 858 SwapValues(fEX, pos1, pos2);; 859 SwapValues(fEY, pos1, pos2);; 860 TGraph::SwapPoints(pos1, pos2);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Update the fX, fY, fEX, and fEY arrays with the sorted values.; 865 ; 866void TGraphErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 867{; 868 std::vector<Double_t> fEXSorted(numSortedPoints);; 869 std::vector<Double_t> fEYSorted(numSortedPoints);; 870 ; 871 // Fill the sorted X and Y error values based on the sorted indices; 872 std::generate(fEXSorted.begin(), fEXSorted.end(),; 873 [begin = low, &sorting_indices, this]() mutable { return fEX[sorting_indices[begin++]]; });; 874 std::generate(fEYSorted.begin(), fEYSorted.end(),; 875 [begin = low, &sorting_indices, this]() mutable { return fEY[sorting_indices[begin++]]; });; 876 ; 877 // Copy the sorted X and Y error values back to the original arrays; 878 std::copy(fEXSorted.begin(), fEXSorted.end(), fEX + low);; 879 std::copy(fEYSorted.begin(), fEYSorted.end(), fEY + low);; 880 ; 881 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 882}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:27808,error,error,27808,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability," fXaxis.GetLast();; 2761 Int_t jfirst = fYaxis.GetFirst();; 2762 Int_t jlast = fYaxis.GetLast();; 2763 ; 2764 // Determine the size of the bin buffer(s) needed; 2765 Double_t nentries = fEntries;; 2766 Int_t nx = GetNbinsX();; 2767 Int_t ny = GetNbinsY();; 2768 Int_t bufSize = (nx+2)*(ny+2);; 2769 Double_t *buf = new Double_t[bufSize];; 2770 Double_t *ebuf = nullptr;; 2771 if (fSumw2.fN) ebuf = new Double_t[bufSize];; 2772 ; 2773 // Copy all the data to the temporary buffers; 2774 Int_t i,j,bin;; 2775 for (i=ifirst; i<=ilast; i++){; 2776 for (j=jfirst; j<=jlast; j++){; 2777 bin = GetBin(i,j);; 2778 buf[bin] = RetrieveBinContent(bin);; 2779 if (ebuf) ebuf[bin]=GetBinError(bin);; 2780 }; 2781 }; 2782 ; 2783 // Kernel tail sizes (kernel sizes must be odd for this to work!); 2784 Int_t x_push = (ksize_x-1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:113987,error,error,113987,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability," fa). Return information about the font attributes as an array of strings. ; An array of FONT_NUMFIELDS strings is returned holding the value of the font attributes in the following order: family size weight slant underline overstrike ; Definition at line 1805 of file TGFont.cxx. ◆ GetFont() [1/4]. TGFont * TGFontPool::GetFont ; (; const char * ; family, . Int_t ; ptsize, . Int_t ; weight, . Int_t ; slant . ). Returns font specified bay family, pixel/point size, weight and slant negative value of ptsize means size in pixels positive value of ptsize means size in points. ; For example: TGFont *font = fpool->GetFont(""helvetica"", -9, kFontWeightNormal, kFontSlantRoman); font->Print(); ; Definition at line 1696 of file TGFont.cxx. ◆ GetFont() [2/4]. TGFont * TGFontPool::GetFont ; (; const char * ; font, . Bool_t ; fixedDefault = kTRUE . ). Get the specified font. ; The font can be one of the following forms: XLFD (see X documentation) ""Family [size [style] [style ...]]"" Returns 0 if error or no font can be found. If fixedDefault is false the ""fixed"" font will not be substituted as fallback when the asked for font does not exist. ; Definition at line 1558 of file TGFont.cxx. ◆ GetFont() [3/4]. TGFont * TGFontPool::GetFont ; (; const TGFont * ; font). Use font, i.e. ; increases ref count of specified font. Returns 0 if font is not found. ; Definition at line 1655 of file TGFont.cxx. ◆ GetFont() [4/4]. TGFont * TGFontPool::GetFont ; (; FontStruct_t ; font). Use font, i.e. increases ref count of specified font. ; Definition at line 1670 of file TGFont.cxx. ◆ GetFontFamilies(). char ** TGFontPool::GetFontFamilies ; (; ). Return information about the font families that are available on the current display. ; An array of strings is returned holding a list of all the available font families. The array is terminated with a NULL pointer. ; Definition at line 2274 of file TGFont.cxx. ◆ GetFontFromAttributes(). TGFont * TGFontPool::GetFontFromAttributes ; (; FontAttributes_t * ; fa,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFontPool.html:18357,error,error,18357,doc/master/classTGFontPool.html,https://root.cern,https://root.cern/doc/master/classTGFontPool.html,1,['error'],['error']
Availability," file FitResult.h. ◆ fFitFunc. std::shared_ptr<IModelFunction> ROOT::Fit::FitResult::fFitFunc. protected . ! model function resulting from the fit. ; Definition at line 355 of file FitResult.h. ◆ fFixedParams. std::map<unsigned int, bool> ROOT::Fit::FitResult::fFixedParams. protected . list of fixed parameters ; Definition at line 357 of file FitResult.h. ◆ fGlobalCC. std::vector<double> ROOT::Fit::FitResult::fGlobalCC. protected . global Correlation coefficient ; Definition at line 363 of file FitResult.h. ◆ fMinimizer. std::shared_ptr<ROOT::Math::Minimizer> ROOT::Fit::FitResult::fMinimizer. protected . ! minimizer object used for fitting ; Definition at line 353 of file FitResult.h. ◆ fMinimType. std::string ROOT::Fit::FitResult::fMinimType. protected . string indicating type of minimizer ; Definition at line 365 of file FitResult.h. ◆ fMinosErrors. std::map<unsigned int, std::pair<double,double> > ROOT::Fit::FitResult::fMinosErrors. protected . map contains the two Minos errors ; Definition at line 364 of file FitResult.h. ◆ fNCalls. unsigned int ROOT::Fit::FitResult::fNCalls. protected . number of function calls ; Definition at line 347 of file FitResult.h. ◆ fNdf. unsigned int ROOT::Fit::FitResult::fNdf. protected . number of degree of freedom ; Definition at line 346 of file FitResult.h. ◆ fNFree. unsigned int ROOT::Fit::FitResult::fNFree. protected . number of fit free parameters (total parameters are in size of parameter vector) ; Definition at line 345 of file FitResult.h. ◆ fNormalized. bool ROOT::Fit::FitResult::fNormalized. protected . flag for indicating is errors are normalized ; Definition at line 344 of file FitResult.h. ◆ fObjFunc. std::shared_ptr<ROOT::Math::IMultiGenFunction> ROOT::Fit::FitResult::fObjFunc. protected . ! objective function used for fitting ; Definition at line 354 of file FitResult.h. ◆ fParamBounds. std::vector<std::pair<double,double> > ROOT::Fit::FitResult::fParamBounds. protected . parameter bounds ; Definition at line 359 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:26880,error,errors,26880,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['error'],['errors']
Availability," file RooFitResult.cxx. ◆ lastMinuitFit(). RooFitResult * RooFitResult::lastMinuitFit ; (; const RooArgList & ; varList = RooArgList()). static . Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ; Definition at line 917 of file RooFitResult.cxx. ◆ minNll(). double RooFitResult::minNll ; (; ); const. inline . Return minimized -log(L) value. ; Definition at line 99 of file RooFitResult.h. ◆ numInvalidNLL(). Int_t RooFitResult::numInvalidNLL ; (; ); const. inline . Return number of NLL evaluations with problems. ; Definition at line 91 of file RooFitResult.h. ◆ numStatusHistory(). UInt_t RooFitResult::numStatusHistory ; (; ); const. inline . Definition at line 82 of file RooFitResult.h. ◆ plotOn() [1/2]. RooPlot * RooFitResult::plotOn ; (; RooPlot * ; frame, . const RooAbsArg & ; par1, . const RooAbsArg & ; par2, . const char * ; options = ""ME"" . ); const. inline . Add objects to a 2D plot. ; Plot error ellipse in par1 and par2 on frame. ; Definition at line 144 of file RooFitResult.h. ◆ plotOn() [2/2]. RooPlot * RooFitResult::plotOn ; (; RooPlot * ; frame, . const char * ; parName1, . const char * ; parName2, . const char * ; options = ""ME"" . ); const. Add objects to a 2D plot that represent the fit results for the two named parameters. ; The input frame with the objects added is returned, or zero in case of an error. Which objects are added are determined by the options string which should be a concatenation of the following (not case sensitive):. M - a marker at the best fit result; E - an error ellipse calculated at 1-sigma using the error matrix at the minimum; 1 - the 1-sigma error bar for parameter 1; 2 - the 1-sigma error bar for parameter 2; B - the bounding box for the error ellipse; H - a line and horizontal axis for reading off the correlation coefficient; V - a line and vertical axis for reading off the correlation coefficient; A - draw axes for reading off the correlation coeffici",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:31621,error,error,31621,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['error'],['error']
Availability," file TAuthenticate.h. ◆ GetUserPasswd(). Bool_t TAuthenticate::GetUserPasswd ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwhash, . Bool_t ; srppwd . ). private . Try to get user name and passwd from several sources. ; Definition at line 810 of file TAuthenticate.cxx. ◆ GetVersion(). Int_t TAuthenticate::GetVersion ; (; ); const. inlineprivate . Definition at line 83 of file TAuthenticate.h. ◆ HasHostAuth(). THostAuth * TAuthenticate::HasHostAuth ; (; const char * ; host, . const char * ; user, . Option_t * ; opt = ""R"" . ). static . Checks if a THostAuth with exact match for {host,user} exists in the fgAuthInfo list If opt = ""P"" use ProofAuthInfo list instead Returns pointer to it or 0. ; Definition at line 2049 of file TAuthenticate.cxx. ◆ HasTimedOut(). Int_t TAuthenticate::HasTimedOut ; (; ); const. inline . Definition at line 147 of file TAuthenticate.h. ◆ InitRandom(). void TAuthenticate::InitRandom ; (; ). static . Initialize random machine using seed from /dev/urandom (or current time if /dev/urandom not available). ; Definition at line 2473 of file TAuthenticate.cxx. ◆ IsA(). TClass * TAuthenticate::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 207 of file TAuthenticate.h. ◆ MergeHostAuthList(). void TAuthenticate::MergeHostAuthList ; (; TList * ; std, . TList * ; nin, . Option_t * ; opt = """" . ). static . Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ; 'nin' info has priority. 'std' is cleaned from inactive members. 'nin' members used to update existing members in 'std' are removed from 'nin', do that they do not leak opt = ""P"" for proofauthinfo. ; Definition at line 3611 of file TAuthenticate.cxx. ◆ PromptPasswd(). char * TAuthenticate::PromptPasswd ; (; const char * ; prompt = ""Password: ""). static . Static method to prompt for the user's passwd to be used for a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:33083,avail,available,33083,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['avail'],['available']
Availability," file TDSet.cxx. ◆ Draw() [3/3]. void TDSet::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 216 of file TDSet.h. ◆ ElementsValid(). Bool_t TDSet::ElementsValid ; (; ). Check if all elements are valid. ; Definition at line 1555 of file TDSet.cxx. ◆ ExportFileList(). Int_t TDSet::ExportFileList ; (; const char * ; fpath, . Option_t * ; opt = """" . ). Export TDSetElements files as list of TFileInfo objects in file 'fpath'. ; If the file exists already the action fails, unless 'opt == ""F""'. Return 0 on success, -1 otherwise ; Definition at line 1277 of file TDSet.cxx. ◆ GetDirectory(). const char * TDSet::GetDirectory ; (; ); const. inline . Definition at line 230 of file TDSet.h. ◆ GetEntries(). Long64_t TDSet::GetEntries ; (; Bool_t ; isTree, . const char * ; filename, . const char * ; path, . TString & ; objname . ). static . Returns number of entries in tree or objects in file. ; Returns -1 in case of error. ; Definition at line 1382 of file TDSet.cxx. ◆ GetEntryList(). TObject * TDSet::GetEntryList ; (; ); const. inline . Definition at line 251 of file TDSet.h. ◆ GetListOfElements(). TList * TDSet::GetListOfElements ; (; ); const. inline . Definition at line 231 of file TDSet.h. ◆ GetNumOfFiles(). Int_t TDSet::GetNumOfFiles ; (; ). Return the number of files in the dataset. ; Definition at line 2018 of file TDSet.cxx. ◆ GetObjName(). const char * TDSet::GetObjName ; (; ); const. inline . Definition at line 229 of file TDSet.h. ◆ GetOutput(). TObject * TDSet::GetOutput ; (; const char * ; name). Get specified object that has been produced during the processing (see Process()). ; Definition at line 988 of file TDSet.cxx. ◆ GetOutputList(). TList * TDSet::GetOutputList ; (; ). Get list with all object created during processing (see Process()). ; Definition at line 998 of file TDSet.cxx. ◆ GetTreeHeader(). TTree * TDSet::GetTreeHeader ; (; TProof * ; proof). virtual . Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:23964,error,error,23964,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['error'],['error']
Availability," file TGDoubleSlider.h. ◆ fPressPoint. Int_t TGDoubleSlider::fPressPoint. protected . mouse position at button press event ; Definition at line 51 of file TGDoubleSlider.h. ◆ fPressSmax. Double_t TGDoubleSlider::fPressSmax. protected . logical max position at button press event ; Definition at line 53 of file TGDoubleSlider.h. ◆ fPressSmin. Double_t TGDoubleSlider::fPressSmin. protected . logical min position at button press event ; Definition at line 52 of file TGDoubleSlider.h. ◆ fRelPos. Int_t TGDoubleSlider::fRelPos. protected . slider position in pixel coordinates ; Definition at line 46 of file TGDoubleSlider.h. ◆ fReversedScale. Bool_t TGDoubleSlider::fReversedScale. protected . reverse which end is min and max ; Definition at line 58 of file TGDoubleSlider.h. ◆ fScale. Int_t TGDoubleSlider::fScale. protected . tick mark scale ; Definition at line 49 of file TGDoubleSlider.h. ◆ fScaleType. Int_t TGDoubleSlider::fScaleType. protected . tick mark scale type (no, downright, both) ; Definition at line 50 of file TGDoubleSlider.h. ◆ fSliderPic. const TGPicture* TGDoubleSlider::fSliderPic. protected . picture to draw slider ends ; Definition at line 60 of file TGDoubleSlider.h. ◆ fSmax. Double_t TGDoubleSlider::fSmax. protected . logical position of max value of Slider ; Definition at line 45 of file TGDoubleSlider.h. ◆ fSmin. Double_t TGDoubleSlider::fSmin. protected . logical position of min value of Slider ; Definition at line 44 of file TGDoubleSlider.h. ◆ fVmax. Double_t TGDoubleSlider::fVmax. protected . logical upper limit of slider ; Definition at line 48 of file TGDoubleSlider.h. ◆ fVmin. Double_t TGDoubleSlider::fVmin. protected . logical lower limit of slider ; Definition at line 47 of file TGDoubleSlider.h. Libraries for TGDoubleSlider:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGDoubleSlider.h; gui/gui/src/TGDoubleSlider.cxx. TGDoubleSlider. ROOT master - Reference Guide Generated on Tue Nov 5 2024 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDoubleSlider.html:40363,down,downright,40363,doc/master/classTGDoubleSlider.html,https://root.cern,https://root.cern/doc/master/classTGDoubleSlider.html,1,['down'],['downright']
Availability," file TGLSAViewer.cxx. ◆ CreateFrames(). void TGLSAViewer::CreateFrames ; (; ). private . Internal frames creation. ; Definition at line 440 of file TGLSAViewer.cxx. ◆ CreateGLWidget(). void TGLSAViewer::CreateGLWidget ; (; ). overridevirtual . Create a GLwidget, it is an error if it is already created. ; This is needed for frame-swapping on mac. ; Reimplemented from TGLViewer.; Definition at line 334 of file TGLSAViewer.cxx. ◆ CreateMenus(). void TGLSAViewer::CreateMenus ; (; ). private . File/Camera/Help menus. ; Definition at line 375 of file TGLSAViewer.cxx. ◆ DeclFileName(). static const char * TGLSAViewer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 132 of file TGLSAViewer.h. ◆ DeleteMenuBar(). void TGLSAViewer::DeleteMenuBar ; (; ). Delete the menu bar. ; Definition at line 519 of file TGLSAViewer.cxx. ◆ DestroyGLWidget(). void TGLSAViewer::DestroyGLWidget ; (; ). overridevirtual . Destroy the GLwidget, it is an error if it does not exist. ; This is needed for frame-swapping on mac. ; Reimplemented from TGLViewer.; Definition at line 357 of file TGLSAViewer.cxx. ◆ DisableCloseMenuEntries(). void TGLSAViewer::DisableCloseMenuEntries ; (; ). Deactivate menu entries for closing the GL window and exiting ROOT. ; Definition at line 527 of file TGLSAViewer.cxx. ◆ DisableMenuBarHiding(). void TGLSAViewer::DisableMenuBarHiding ; (; ). Disable hiding of menu bar. ; Definition at line 559 of file TGLSAViewer.cxx. ◆ EnableMenuBarHiding(). void TGLSAViewer::EnableMenuBarHiding ; (; ). Enable hiding of menu bar. ; Definition at line 536 of file TGLSAViewer.cxx. ◆ GetFormat(). TGLFormat * TGLSAViewer::GetFormat ; (; ); const. inline . Definition at line 124 of file TGLSAViewer.h. ◆ GetFrame(). TGCompositeFrame * TGLSAViewer::GetFrame ; (; ); const. Return the main-frame. ; Definition at line 325 of file TGLSAViewer.cxx. ◆ GetLeftVerticalFrame(). TGCompositeFrame * TGLSAViewer::GetLeftVerticalFrame ; (; );",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:43656,error,error,43656,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['error'],['error']
Availability," file TProfile2D.cxx. ◆ GetBinError() [2/3]. Double_t TProfile2D::GetBinError ; (; Int_t ; binx, . Int_t ; biny . ); const. inlineoverridevirtual . Reimplemented from TH1.; Definition at line 117 of file TProfile2D.h. ◆ GetBinError() [3/3]. Double_t TProfile2D::GetBinError ; (; Int_t ; binx, . Int_t ; biny, . Int_t ;  . ); const. inlineoverridevirtual . Reimplemented from TH1.; Definition at line 118 of file TProfile2D.h. ◆ GetBinErrorSqUnchecked(). Double_t TProfile2D::GetBinErrorSqUnchecked ; (; Int_t ; bin); const. inlineoverrideprotectedvirtual . Reimplemented from TH1.; Definition at line 60 of file TProfile2D.h. ◆ GetBinSumw2() [1/2]. virtual TArrayD * TProfile2D::GetBinSumw2 ; (; ). inlinevirtual . Definition at line 121 of file TProfile2D.h. ◆ GetBinSumw2() [2/2]. virtual const TArrayD * TProfile2D::GetBinSumw2 ; (; ); const. inlinevirtual . Definition at line 122 of file TProfile2D.h. ◆ GetErrorOption(). Option_t * TProfile2D::GetErrorOption ; (; ); const. Return option to compute profile2D errors. ; Definition at line 889 of file TProfile2D.cxx. ◆ GetNumberOfBins(). Double_t TProfile2D::GetNumberOfBins ; (; ). inline . Definition at line 151 of file TProfile2D.h. ◆ GetStats(). void TProfile2D::GetStats ; (; Double_t * ; stats); const. overridevirtual . Fill the array stats from the contents of this profile. ; The array stats must be correctly dimensioned in the calling program. stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range. ; Reimplemented from TH2.; Definition at line 916 of file TProfile2D.cxx. ◆ GetW(). Double_t * TProfile2D::GetW ; (; ). inlineprivate . Definition at line 65 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:89965,error,errors,89965,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['error'],['errors']
Availability," file TProofOutputFile.cxx. ◆ IsA(). TClass * TProofOutputFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 124 of file TProofOutputFile.h. ◆ IsMerge(). Bool_t TProofOutputFile::IsMerge ; (; ); const. inline . Definition at line 107 of file TProofOutputFile.h. ◆ IsMerged(). Bool_t TProofOutputFile::IsMerged ; (; ); const. inline . Definition at line 108 of file TProofOutputFile.h. ◆ IsRegister(). Bool_t TProofOutputFile::IsRegister ; (; ); const. inline . Definition at line 109 of file TProofOutputFile.h. ◆ IsRetrieve(). Bool_t TProofOutputFile::IsRetrieve ; (; ); const. inline . Definition at line 111 of file TProofOutputFile.h. ◆ Merge(). Long64_t TProofOutputFile::Merge ; (; TCollection * ; list). Merge objects from the list into this object. ; Definition at line 314 of file TProofOutputFile.cxx. ◆ NotifyError(). void TProofOutputFile::NotifyError ; (; const char * ; errmsg). private . Notify error message. ; Definition at line 450 of file TProofOutputFile.cxx. ◆ OpenFile(). TFile * TProofOutputFile::OpenFile ; (; const char * ; opt). Open the file using the unique temporary name. ; Definition at line 256 of file TProofOutputFile.cxx. ◆ operator=(). TProofOutputFile & TProofOutputFile::operator= ; (; const TProofOutputFile & ; ). private . ◆ Print(). void TProofOutputFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Dump the class content. ; Reimplemented from TNamed.; Definition at line 422 of file TProofOutputFile.cxx. ◆ ResetFileCollection(). void TProofOutputFile::ResetFileCollection ; (; ). inline . Definition at line 120 of file TProofOutputFile.h. ◆ SetDir(). void TProofOutputFile::SetDir ; (; const char * ; dir, . Bool_t ; raw = kFALSE . ). inlineprivate . Definition at line 71 of file TProofOutputFile.h. ◆ SetFileName(). void TProofOutputFile::SetFileName ; (; const char * ; name). inlineprivate . Definition at line 70 of file TProofOutputFile.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofOutputFile.html:20104,error,error,20104,doc/master/classTProofOutputFile.html,https://root.cern,https://root.cern/doc/master/classTProofOutputFile.html,1,['error'],['error']
Availability," file cache. ; The file will be downloaded to the cache and opened from there. If the download fails, it will be opened remotely. The file will be downloaded to the directory specified by SetCacheFileDir(). ; Definition at line 3874 of file TFile.cxx. ◆ operator=(). void TFile::operator= ; (; const TFile & ; ). privatedelete . ◆ Paint(). void TFile::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint all objects in the file. ; Reimplemented from TDirectory.; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1698 of file TFile.cxx. ◆ Print(). void TFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print all objects in the file. ; Reimplemented from TDirectory.; Reimplemented in TSQLFile, TXMLFile, TNetFile, and TMemFile.; Definition at line 1706 of file TFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). virtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1770 of file TFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:85904,failure,failure,85904,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['failure'],['failure']
Availability," file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t Echo(const TObject* obj); Sends an object to master and workers and expect them to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:66177,Echo,Echo,66177,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['Echo'],['Echo']
Availability," file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permission",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:10561,failure,failure,10561,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,10,['failure'],['failure']
Availability," file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MisClassificationError. class TMVA::MisClassificationError: public TMVA::SeparationBase. Implementation of the MisClassificationError as separation criterion. Function Members (Methods); public:. virtual~MisClassificationError(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::MisClassificationErrorMisClassificationError(); TMVA::MisClassificationErrorMisClassificationError(const TMVA::MisClassificationError& g); TMVA::MisClassificationError&operator=(const TMVA::MisClassificationError&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Misclassifiacton error criterion: 1-max(p, 1-p) (p: purity= s/(s+b)). MisClassificationError(); consturctor for the Misclassification error. { fName = ""MisCl""; }. MisClassificationError(const TMVA::MisClassificationError& g); copy constructor. {}. virtual ~MisClassificationError(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MisClassificationError.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MisClassificationError.html:1476,error,error,1476,root/html528/TMVA__MisClassificationError.html,https://root.cern,https://root.cern/root/html528/TMVA__MisClassificationError.html,2,['error'],['error']
Availability," filename). pure virtual . Implemented in TDOMParser, and TSAXParser. ◆ ReleaseUnderlying(). void TXMLParser::ReleaseUnderlying ; (; ). protectedvirtual . To release any existing document. ; Reimplemented in TDOMParser.; Definition at line 92 of file TXMLParser.cxx. ◆ SetParseCode(). void TXMLParser::SetParseCode ; (; Int_t ; errorcode). protectedvirtual . Set the parse code: . 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occurred while parsing file; -4: A fatal error occurred while parsing file; -5: Document is not well-formed . Definition at line 181 of file TXMLParser.cxx. ◆ SetReplaceEntities(). void TXMLParser::SetReplaceEntities ; (; Bool_t ; val = kTRUE). The parser will replace/expand entities. ; Definition at line 84 of file TXMLParser.cxx. ◆ SetStopOnError(). void TXMLParser::SetStopOnError ; (; Bool_t ; stop = kTRUE). Set parser stops in case of error: . stop = true, stops on error; stop = false, continue parsing on error... . Definition at line 191 of file TXMLParser.cxx. ◆ SetValidate(). void TXMLParser::SetValidate ; (; Bool_t ; val = kTRUE). The parser will validate the xml file if val = true. ; Definition at line 76 of file TXMLParser.cxx. ◆ StopParser(). void TXMLParser::StopParser ; (; ). virtual . Stops parsing. ; Definition at line 166 of file TXMLParser.cxx. ◆ Streamer(). void TXMLParser::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TXMLParser::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 69 of file TXMLParser.h. Member Data Documentation. ◆ fContext. _xmlParserCtxt* TXMLParser::fContext. protected . Parse the xml file. ; Definition at line 31 of file TXMLParser.h. ◆ fParseCode. Int_t TXMLParser::fParseCode. protected . To keep track of the errorcodes. ; Definition at line 37 of file TXMLParser.h. ◆ fReplaceEntities.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:21023,error,error,21023,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,2,['error'],['error']
Availability," files are verified (default no; verification).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31082,avail,available,31082,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,4,['avail'],['available']
Availability," fill area will be drawn Otherwise line width will be scaled proportional to current font size If not specified - default line width will be used. ;  ; TLatexFormSize FirstParse (Double_t angle, Double_t size, const Char_t *text);  First parsing of the analyse sequence. ;  ; TLatex & operator= (const TLatex &);  assignment operator ;  ; Int_t PaintLatex1 (Double_t x, Double_t y, Double_t angle, Double_t size, const char *text);  Drawing function. ;  ; TLatexFormSize Readfs ();  Read fs in fTabSize. ;  ; void Savefs (TLatexFormSize *fs);  Save fs values in array fTabSize. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const Char_t * fError {nullptr};  ! error code ;  ; Double_t fFactorPos;  ! Relative position of subscripts and superscripts ;  ; Double_t fFactorSize;  ! Relative size of subscripts and superscripts ;  ; Bool_t fItalic;  ! Currently inside italic operator ;  ; Int_t fLimitFactorSize;  lower bound for subscripts/superscripts size ;  ; Double_t fOriginSize;  Font size of the starting font. ;  ; Bool_t fShow;  ! is true during the second pass (Painting) ;  ; std::vector< TLatexFormSize > fTabSize;  ! array of values for the different zones ;  ;  Protected Attributes inherited from TText; void * fWcsTitle {nullptr};  !Used by TMathText ;  ; Double_t fX {0};  X position of text (left,center,etc..) ;  ; Double_t fY {0};  Y position of text (left,center,etc..) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttText; Short_t fTextAlign;  Text alignment. ;  ; Float_t fTextAngle;  Text angle. ;  ; Color_t fTextColor;  Text color. ;  ; Font_t fTextFont;  Text font. ;  ; Float_t fTextSize;  Text size. ;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLatex.html:30840,error,error,30840,doc/master/classTLatex.html,https://root.cern,https://root.cern/doc/master/classTLatex.html,1,['error'],['error']
Availability, fill style is modified by the user. void ModFrameLineColor(); Slot called whenever the frame line color is modified by the user. void ModFrameLineWidth(); Slot called whenever the frame line width is modified by the user. void ModFrameLineStyle(); Slot called whenever the frame line style is modified by the user. void ModPaletteEdit(); Slot called whenever the palette editor is opened by the user. void ModFrameBorderMode(); Slot called whenever the frame border mode is modified by the user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:68024,error,error,68024,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,10,['error'],['error']
Availability," fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194165,error,errors,194165,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['errors']
Availability," filled as h[i *ndim + j]. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ivar) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. bool GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; (This feature is not yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. bool Scan(unsigned int ivar, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:10405,error,error,10405,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,18,['error'],"['error', 'errors']"
Availability," final;  Delete key buffer(s). ;  ; void FillBuffer (char *&) final;  Encode key header into output buffer. ;  ; char * GetBuffer () const final;  ; Long64_t GetDBDirId () const;  return sql id of parent directory ;  ; Long64_t GetDBKeyId () const;  ; Long64_t GetDBObjId () const;  ; Long64_t GetSeekKey () const final;  ; Long64_t GetSeekPdir () const final;  ; TClass * IsA () const override;  ; Bool_t IsKeyModified (const char *keyname, const char *keytitle, const char *keydatime, Int_t cycle, const char *classname);  Compares keydata with provided and return kTRUE if key was modified Used in TFile::StreamKeysForDirectory() method to verify data for that keys should be updated. ;  ; void Keep () final;  Set the ""KEEP"" status. ;  ; Int_t Read (TObject *obj) final;  To read an object from the file. ;  ; void ReadBuffer (char *&) final;  Decode input buffer. ;  ; Bool_t ReadFile () final;  Read the key structure from the file. ;  ; TObject * ReadObj () final;  Read object derived from TObject class If it is not TObject or in case of error, return 0. ;  ; void * ReadObjectAny (const TClass *expectedClass) final;  Read object of any type from SQL database. ;  ; TObject * ReadObjWithBuffer (char *bufferRead) final;  Read object derived from TObject class If it is not TObject or in case of error, return 0. ;  ; void SetBuffer () final;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t WriteFile (Int_t=1, TFile *=nullptr) final;  Write the encoded object supported by this key. ;  ;  Public Member Functions inherited from TKey;  TKey ();  TKey default constructor. ;  ;  TKey (const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory *motherDir);  Create a TKey object with the specified name, title for the given class. ;  ;  TKey (const TObject *obj, const char *name, Int_t bufsize, TDirectory *motherDir);  Create a TKey object for a TObject* and fill output buffer. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKeySQL.html:2404,error,error,2404,doc/master/classTKeySQL.html,https://root.cern,https://root.cern/doc/master/classTKeySQL.html,1,['error'],['error']
Availability," find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conversion; [#7782] - [RF] Allow to set nbins for RooPlot (or disallow); [#9838] - [RF] RooCurve::Average() overestimating average values of standard precision curves on small; [#11565] - [RF] Crash in RooStats::ToyMCSample::GenerateToyData; [#13387] - Please recover SrvAuthenticate from libSrvAuth library; [#14541] - [ROOT-6193] Editor for palette axis cannot set title properties; [#15104] - new PyROOT/cppyy fails to pickle enums; [#15161] - Attribute (getitem) differences for PyROOT objects in ROOT master; [#15234] - cppyy - wrong object type when iterating over a polymorphic container; [#15269] - Iterators in pyROOT working differently in ROOT master compared to 6.30/02; [#15315] - PyROOT Example with inheriting from ROOT.Math.IMultiGenFunction doesn’t work after recent cppyy upgrade; [#15425] - TTreeProcessorMP processes events multiple times when there are more threads than entries; [#15755] - [RF][HS3] Higgs discovery workspaces roundtrip; [#15874] - [Hist] Backwards compatibility broken for THnSparseL in 6.32; [#15887] - Broken plot .C macros for default Name() argument in plotOn(); [#15977] - [gui] Event StatusBar does not work well when TMarker outside of zoom region; [#15986] - Problems with TUri compilation; [#16031] - VecOps binary functions not using the right types; [#16038] - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:44565,recover,recover,44565,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['recover'],['recover']
Availability," finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:37258,Recover,Recover,37258,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['Recover'],['Recover']
Availability," findy. void AddItem(TGListTreeItem* parent, TGListTreeItem* item); Add given item to list tree. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. Returns new item. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, void* userData, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. If item with same userData already exists; don't add it. Returns new item. void RenameItem(TGListTreeItem* item, const char* string); Rename item in list tree. Int_t DeleteItem(TGListTreeItem* item); Delete item from list tree. void OpenItem(TGListTreeItem* item); Open item in list tree (i.e. show child items). void CloseItem(TGListTreeItem* item); Close item in list tree (i.e. hide child items). Int_t RecursiveDeleteItem(TGListTreeItem* item, void* userData); Delete item with fUserData == ptr. Search tree downwards starting; at item. void SetToolTipItem(TGListTreeItem* item, const char* string); Set tooltip text for this item. By default an item for which the; userData is a pointer to an TObject the TObject::GetTitle() will; be used to get the tip text. Int_t DeleteChildren(TGListTreeItem* item); Delete children of item from list. Int_t Reparent(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of item. Int_t ReparentChildren(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of the children of item. Int_t Sort(TGListTreeItem* item); Sort items starting with item. Int_t SortSiblings(TGListTreeItem* item); Sort siblings of item. Int_t SortChildren(TGListTreeItem* item); Sort children of item. TGListTreeItem * FindSiblingByName(TGListTreeItem* item, const char* name); Find sibling of item by name. TGListTreeItem * FindSiblingByData(TGListTreeItem* item, void* userData); Find sibling of item by userData. TGListTreeItem * FindChildByName(TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTree.html:37054,down,downwards,37054,root/html528/TGListTree.html,https://root.cern,https://root.cern/root/html528/TGListTree.html,10,['down'],['downwards']
Availability," first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Int_t, Int_t, Double_t content)Definition TH1.h:368; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:73288,error,error,73288,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['error'],['error']
Availability," firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:102611,error,error,102611,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability," fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:11868,error,error,11868,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['error'],['error']
Availability," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:5096,error,error,5096,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['error'],['error']
Availability," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:5370,error,error,5370,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,5,['error'],['error']
Availability," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:5380,error,error,5380,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,4,['error'],['error']
Availability," fit.; 1031 * \warning Prefitting may give bad results when used in binned analysis.; 1032 *; 1033 * <tr><th><th> Options to control informational output; 1034 * <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit).; 1035 * <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default.; 1036 * <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 to 3, default is 1). At -1 all RooFit informational messages are suppressed as well.; 1037 * See RooMinimizer::PrintLevel for the meaning of the levels.; 1038 * <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 1039 * <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation.; 1040 * A negative value suppresses output completely, a zero value will only print the error count per p.d.f component,; 1041 * a positive value will print details of each error up to `numErr` messages per p.d.f component.; 1042 * <tr><td> `Parallelize(Int_t nWorkers)` <td> Control global parallelization settings. Arguments 1 and above enable the use of RooFit's parallel minimization; 1043 * backend and uses the number given as the number of workers to use in the parallelization. -1 also enables; 1044 * RooFit's parallel minimization backend, and sets the number of workers to the number of available processes.; 1045 * 0 disables this feature.; 1046 * In case parallelization is requested, this option implies `ModularL(true)` in the internal call to the NLL creation method.; 1047 * <tr><td> `ParallelGradientOptions(bool enable=true, int orderStrategy=0, int chainFactor=1)` <td> **Experimental** - Control gradient parallelization settings. The first argument; 1048 * only disables or enables gradient parallelization, this is on by default.; 1049 * The second argument determines the internal partial derivative calculation; 1050 * ordering strate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:50646,error,error,50646,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['error'],['error']
Availability," fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:12707,error,errors,12707,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,8,['error'],['errors']
Availability," flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). EvalErrorIter evalErrorIter(). Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kFALSE ; }. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; { return 0 ; }. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t setData(RooAbsData& , Bool_t = kTRUE); { return kTRUE ; }. Bool_t traceEvalHook(Double_t ) const; Hook function to add functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:80672,error,error,80672,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['error'],['error']
Availability," flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). EvalErrorIter evalErrorIter(). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t setData(RooAbsData& , Bool_t = kTRUE); { return kTRUE ; }. Bool_t traceEvalHook(Double_t ) const; Hook function to add functionality to evaluation tracing in derived classes. Double_t evaluate() const. void syncCache(const RooArgSet* set = 0); { getVal(set) ; }. void selectComp(Bool_t flag); If flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsReal.html:79849,error,error,79849,root/html530/RooAbsReal.html,https://root.cern,https://root.cern/root/html530/RooAbsReal.html,1,['error'],['error']
Availability," flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). Int_t numEvalErrorItems(); { return _evalErrorList.size() ; }. EvalErrorIter evalErrorIter(); { return _evalErrorList.begin() ; }. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t traceEvalHook(Double_t ) const; Hook function to add functionality to evaluation tracing in derived classes. Double_t evaluate() const. void syncCache(const RooArgSet* set = 0); { getVal(set) ; }. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:79709,error,error,79709,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,1,['error'],['error']
Availability," flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void DeclareCompatibilityOptions ();  options that are used ONLY for the READER to ensure backward compatibility ;  ; void DeclareOptions ();  Declare MethodPDEFoam options. ;  ; void Init (void);  default initialization called by all constructors ;  ; void PrintCoefficients (void);  ; void ProcessOptions ();  process user options ;  ; template<typename T > ; T Sqr (T x) const;  . Private Attributes; Bool_t fCompress;  compress foam output file ;  ; Bool_t fCutNmin;  Keep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default) ;  ; Float_t fDiscrErrCut;  cut on discriminant error ;  ; TString fDTLogic;  use DT algorithm to split cells ;  ; EDTSeparation fDTSeparation;  enum which specifies the separation to use for the DT logic ;  ; Int_t fEvPerBin;  Maximum events (equiv.) per bin in build-up (1000) ;  ; Bool_t fFillFoamWithOrigWeights;  fill the foam with boost weights ;  ; std::vector< PDEFoam * > fFoam;  grown PDEFoams ;  ; Float_t fFrac;  Fraction used for calc of Xmin, Xmax. ;  ; EKernel fKernel;  Kernel for GetMvaValue() ;  ; PDEFoamKernelBase * fKernelEstimator;  Kernel estimator. ;  ; TString fKernelStr;  Kernel for GetMvaValue() (option string) ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; Bool_t fMultiTargetRegression;  do regression on multiple targets ;  ; Int_t fnActiveCells;  Number of active cells. ;  ; Int_t fnBin;  Number of bins in build-up (100) ;  ; Int_t fnCells;  Number of Cells (1000) ;  ; UInt_t fNmin;  minimal number of events in cell necessary to split cell"" ;  ; Int_t fnSampl;  Number of MC events per cell ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDEFoam.html:30203,error,error,30203,doc/master/classTMVA_1_1MethodPDEFoam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDEFoam.html,1,['error'],['error']
Availability," flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::ExecuteSetCommandInt_t ExecuteSetCommand(Int_t)Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"".Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::fEPSDouble_t fEPSfEPS - required precision of parameters. If fEPS<0 t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8h_source.html:11795,error,errors,11795,doc/master/TFumili_8h_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html,1,['error'],['errors']
Availability," flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::TFumiliTFumili(Int_t maxpar=25)Definition TFumili.cxx:129; TFumili::ExecuteSetCommandInt_t ExecuteSetCommand(Int_t)Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"".Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:73968,error,errors,73968,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['error'],['errors']
Availability," fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; set<string,less<string>,allocator<string> >::iteratorfIter!iterator in messages; set<string>fMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. TStatus(). virtual ~TStatus(); { }. Bool_t IsOk() const; { return fMsgs.empty(); }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TStatus.h 40186 2011-07-11 12:00:50Z ganis $ » Last generated: 2011-11-03 20:23; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStatus.html:6550,error,error,6550,root/html532/TStatus.html,https://root.cern,https://root.cern/root/html532/TStatus.html,2,['error'],['error']
Availability, follows.; Parameter values: Abkg=0.024352 Asig=0.0100451 p_ph_bkg_gamma_bin_0=0.351482 p_ph_bkg_gamma_bin_1=0.352595 p_ph_bkg_gamma_bin_10=0.342683 p_ph_bkg_gamma_bin_11=0.368891 p_ph_bkg_gamma_bin_12=0.38197 p_ph_bkg_gamma_bin_13=0.365529 p_ph_bkg_gamma_bin_14=0.358098 p_ph_bkg_gamma_bin_15=0.358584 p_ph_bkg_gamma_bin_16=0.367344 p_ph_bkg_gamma_bin_17=0.356263 p_ph_bkg_gamma_bin_18=0.362211 p_ph_bkg_gamma_bin_19=0.340063 p_ph_bkg_gamma_bin_2=0.35054 p_ph_bkg_gamma_bin_20=0.352376 p_ph_bkg_gamma_bin_21=0.351589 p_ph_bkg_gamma_bin_22=0.351615 p_ph_bkg_gamma_bin_23=0.344488 p_ph_bkg_gamma_bin_24=0.365687 p_ph_bkg_gamma_bin_3=0.355197 p_ph_bkg_gamma_bin_4=0.347776 p_ph_bkg_gamma_bin_5=0.348629 p_ph_bkg_gamma_bin_6=0.357616 p_ph_bkg_gamma_bin_7=0.351061 p_ph_bkg_gamma_bin_8=0.342678 p_ph_bkg_gamma_bin_9=0.357292 p_ph_sig_gamma_bin_11=0.3339 p_ph_sig_gamma_bin_12=0.341347 p_ph_sig_gamma_bin_13=0.333434 p_ph_sig_gamma_bin_14=0.328932 p_ph_sig_gamma_bin_15=0.328666; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=0.327409 Asig=0.26768 p_ph_bkg_gamma_bin_0=0.63877 p_ph_bkg_gamma_bin_1=0.639509 p_ph_bkg_gamma_bin_10=0.632897 p_ph_bkg_gamma_bin_11=0.650254 p_ph_bkg_gamma_bin_12=0.658769 p_ph_bkg_gamma_bin_13=0.648049 p_ph_bkg_gamma_bin_14=0.643155 p_ph_bkg_gamma_bin_15=0.643476 p_ph_bkg_gamma_bin_16=0.64924 p_ph_bkg_gamma_bin_17=0.641941 p_ph_bkg_gamma_bin_18=0.645868 p_ph_bkg_gamma_bin_19=0.63114 p_ph_bkg_gamma_bin_2=0.638144 p_ph_bkg_gamma_bin_20=0.639364 p_ph_bkg_gamma_bin_21=0.638841 p_ph_bkg_gamma_bin_22=0.638858 p_ph_bkg_gamma_bin_23=0.634106 p_ph_bkg_gamma_bin_24=0.648153 p_ph_bkg_gamma_bin_3=0.641235 p_ph_bkg_gamma_bin_4=0.636302 p_ph_bkg_gamma_bin_5=0.636871 p_ph_bkg_gamma_bin_6=0.642836 p_ph_bkg_gamma_bin_7=0.63849 p_ph_bkg_gamma_bin_8=0.632894 p_ph_bkg_gamma_bin_9=0.642622 p_ph_sig_gamma_bin_11=0.626988 p_ph_sig_gamma_bin_12=0.6,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:15605,error,error,15605,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability, fonts; [#14032] - TPaveText has problems when label is set; [#14030] - Allow zero-copy RNTuple bulk reading; [#13965] - [Cling] Assertion fails with wrong but innocent code; [#13962] - THnSparse::Scale() unsparsifies; [#13877] - [ntuple] Segfault when processing recursive classes; [#13865] - [FreeBSD] cling cmake error; [#13861] - Remove all traces of Python2 from the ROOT codebase in preparation for 6.32/00; [#13851] - Test crash with GCC 13 and C++20; [#13834] - Can’t open TBrowser locally after upgrading macos “Apple M2 14.0 (23A344)”; [#13825] - builtin libpng too old; [#13815] - Cling (rightfully) confused about forward-declared template specializations; [#13697] - Unexpected behaviour of KSTest with toys (“X” option) for identical histograms; [#13659] - rootprint/rootls missing recursive traversal; [#13623] - Add directory wildcarding in TChain; [#13531] - Huge RAM consumption of the hadd command for input files with several directories; [#13511] - TMapFile can’t work; [#13497] - Assertion failure in TMVA with vector iterators incompatible error on Windows; [#13441] - error in root-generated code for cubic spline (TSpline3); [#13421] - [MSVC] ROOT builds under msvc option /permissive- with error C4576; [#13359] - Bug in TFileMerger class for a single input file and a selective list of objects to be merged in output file; [#13288] - [cling] long double type incorrectly parsed by interpreter; [#13155] - TMVA doesn’t compile with pytorch 2.0.1; [#13130] - Valgrind reports leak when constructing TChain; [#13110] - Bug in TDecompBase::DiagProd; [#13079] - Builtin TBB library sometimes not found (or more exactly the one install in /usr/lib sometimes take priority); [#13041] - TVirtualFitter::GetFitter() unexpectedly returns NULL on macOS 12 and 13 with Xcode 14; [#13019] - LLVM assertion failure in HandleUnionActiveMemberChange; [#12993] - std::source_location not working in the interpreter; [#12959] - [ntuple] Distinguish between connecting a page sink and a page s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:32187,failure,failure,32187,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,4,"['error', 'failure']","['error', 'failure']"
Availability," for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Normal Constructor for Profile histograms.; 106///; 107/// The first five parameters are similar to TH1D::TH1D.; 108/// All values of y are accepted at filling time.; 109/// To fill a profile histogram, one must use TProfile::Fill function.; 110///; 111/// Note that when filling the profile histogram the function Fill; 112/// checks if the variable y is between fYmin and fYmax.; 113/// If a minimum or maximum value is set for the Y scale before filling,; 114/// then all values below ymin or above ymax will be discarded.; 115/// Setting the minimum or maximum value for the Y scale before filling; 116/// has the same effect as calling the special TProfile constructor below; 117/// where ymin and ymax are specified.; 118///; 119/// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; 120/// (spread option), or e(j) if `CHOPT`='' (error on mean).; 121///; 122/// See TProfile::BuildOptions() for explanation of parameters; 123///; 124/// see also comments in the TH1 base class constructors; 125 ; 126TProfile::TProfile(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup,Option_t *option); 127: TH1D(name,title,nbins,xlow,xup); 128{; 129 BuildOptions(0,0,option);; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// Constructor for Profile histograms with variable bin size.; 134///; 135/// See TProfile::BuildOptions() for more explanations on errors; 136/// see also comments in the TH1 base class constructors; 137 ; 138TProfile::TProfile(const char *name,const char *title,Int_t nbins,const Float_t *xbins,Option_t *option); 139: TH1D(name,title,nbins,xbins); 140{; 141 BuildOptions(0,0,option);; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Constructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:5080,error,errors,5080,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability," for a Beta distribution.Definition TEfficiency.cxx:1348; TEfficiency::Normalstatic Double_t Normal(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distr...Definition TEfficiency.cxx:2952; TEfficiency::Wilsonstatic Double_t Wilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:76593,error,error,76593,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],['error']
Availability," for a dialog window. ; Definition at line 2488 of file TVirtualX.cxx. ◆ Bell(). void TVirtualX::Bell ; (; Int_t ; percent). virtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1517 of file TVirtualX.cxx. ◆ ChangeActivePointerGrab(). void TVirtualX::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). virtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2424 of file TVirtualX.cxx. ◆ ChangeGC(). void TVirtualX::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). virtual . Changes the components specified by the mask in gval for the specified GC. ; Parameters. [in]gcspecifies the GC to be changed ; [in]gvalspecifies the mask and the values to be set. (see also the GCValues_t structure) ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1339 of file TVirtualX.cxx. ◆ ChangeProperties(). void TVirtualX::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). virtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 2448 of file TVirtualX.cxx. ◆ ChangeProperty(). void TVirtualX::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). virtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:51976,mask,mask,51976,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['mask']
Availability," for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }; 5527 ; 5528 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5529 ; 5530 if (interp[0] != '\0') {; 5531 /* This is an interpreted script file. We must call the interpreter. */; 5532 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5533 mg_snprintf(conn,; 5534 &truncated,; 5535 cmdline,; 5536 sizeof(cmdline),; 5537 ""\""%s\"" %s \""%s\\%s\"""",; 5538 interp,; 5539 interp_arg,; 5540 full_dir,; 5541 prog);; 5542 } else {; 5543 mg_snprintf(conn,; 5544 &truncated,; 5545 cmdline,; 5546 sizeof(cmdline),; 5547 ""\""%s\"" \""%s\\%s\"""",; 5548 interp,; 5549 full_dir,; 5550 prog);; 5551 }; 5552 } else {; 5553 /* This is (probably) a compiled program. We call it directly. */; 5554 mg_snprintf(conn,; 5555 &truncated,; 5556 cmdline,; 5557 sizeof(cmdline),; 5558 ""\""%s\\%s\"""",; 5559 full_dir,; 5560 prog);; 5561 }; 5562 ; 5563 if (truncated) {; 5564 pi.hProcess = (pid_t)-1;; 5565 goto spawn_cleanup;; 5566 }; 5567 ; 5568 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:163006,error,error,163006,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }; 5528 ; 5529 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5530 ; 5531 if (interp[0] != '\0') {; 5532 /* This is an interpreted script file. We must call the interpreter. */; 5533 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5534 mg_snprintf(conn,; 5535 &truncated,; 5536 cmdline,; 5537 sizeof(cmdline),; 5538 ""\""%s\"" %s \""%s\\%s\"""",; 5539 interp,; 5540 interp_arg,; 5541 full_dir,; 5542 prog);; 5543 } else {; 5544 mg_snprintf(conn,; 5545 &truncated,; 5546 cmdline,; 5547 sizeof(cmdline),; 5548 ""\""%s\"" \""%s\\%s\"""",; 5549 interp,; 5550 full_dir,; 5551 prog);; 5552 }; 5553 } else {; 5554 /* This is (probably) a compiled program. We call it directly. */; 5555 mg_snprintf(conn,; 5556 &truncated,; 5557 cmdline,; 5558 sizeof(cmdline),; 5559 ""\""%s\\%s\"""",; 5560 full_dir,; 5561 prog);; 5562 }; 5563 ; 5564 if (truncated) {; 5565 pi.hProcess = (pid_t)-1;; 5566 goto spawn_cleanup;; 5567 }; 5568 ; 5569 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:163038,error,error,163038,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:41864,error,errors,41864,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,4,['error'],['errors']
Availability," for details see html manual and references; TStringTNamed::fTitleobject title; Int_tfXmaxlast fitted channel; Int_tfXminfirst fitted channel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrumFit(); default constructor. TSpectrumFit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks is .  ;  ;  ;  ;  ;  ;  ;  . where a represents vector of; fitted parameters (positions p(j), amplitudes A(j), sigma, relative amplitudes; T, S and slope B).;  . ~TSpectrumFit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Deramp(Double_t i, Double_t i0, Double_t sigma, Double_t t, Double_t s, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of peak shape function (see manual); according to amplitude of peak.; Function parameters:; -i-channel; -i0-position of peak; -sigma-sigma of peak; -t, s-relative amplitudes; -b-slope. Double_t Deri0(Double_t i, Double_t amp, Double_t i0, Double_t sigma, Double_t t, Double_t s, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of peak shape function (see manual); according to peak position.; Function parameters:; -i-channel; -amp-amplitude of peak; -i0-position of peak; -sigma-sigma of peak; -t, s-relative amplitudes; -b-slope. Double_t Derderi0(Double_t i, Double_t amp, Double_t i0, Double_t sigma). AUXILIARY FUNCTION. This function calculates second derivative of peak shape function; (see manual) according to peak position.; Function parameters:; -i-channel; -amp-amplitude of peak; -i0-p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:13899,error,error,13899,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,6,['error'],['error']
Availability," for details see references ; Definition at line 28 of file TSpectrum2Fit.h. ◆ fAlphaOptim. Int_t TSpectrum2Fit::fAlphaOptim. protected . optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal ; Definition at line 25 of file TSpectrum2Fit.h. ◆ fAmpCalc. Double_t* TSpectrum2Fit::fAmpCalc. protected . [fNPeaks] array of calculated values of amplitudes of 2D peaks, output parameters ; Definition at line 43 of file TSpectrum2Fit.h. ◆ fAmpCalcX1. Double_t* TSpectrum2Fit::fAmpCalcX1. protected . [fNPeaks] array of calculated values of amplitudes of 1D ridges in x direction, output parameters ; Definition at line 46 of file TSpectrum2Fit.h. ◆ fAmpCalcY1. Double_t* TSpectrum2Fit::fAmpCalcY1. protected . [fNPeaks] array of calculated values of amplitudes of 1D ridges in y direction, output parameters ; Definition at line 49 of file TSpectrum2Fit.h. ◆ fAmpErr. Double_t* TSpectrum2Fit::fAmpErr. protected . [fNPeaks] array of amplitudes errors of 2D peaks, output parameters ; Definition at line 44 of file TSpectrum2Fit.h. ◆ fAmpErrX1. Double_t* TSpectrum2Fit::fAmpErrX1. protected . [fNPeaks] array of amplitudes errors of 1D ridges in x direction, output parameters ; Definition at line 47 of file TSpectrum2Fit.h. ◆ fAmpErrY1. Double_t* TSpectrum2Fit::fAmpErrY1. protected . [fNPeaks] array of amplitudes errors of 1D ridges in y direction, output parameters ; Definition at line 50 of file TSpectrum2Fit.h. ◆ fAmpInit. Double_t* TSpectrum2Fit::fAmpInit. protected . [fNPeaks] array of initial values of amplitudes of 2D peaks, input parameters ; Definition at line 42 of file TSpectrum2Fit.h. ◆ fAmpInitX1. Double_t* TSpectrum2Fit::fAmpInitX1. protected . [fNPeaks] array of initial values of amplitudes of 1D ridges in x direction, input parameters ; Definition at line 45 of file TSpectrum2Fit.h. ◆ fAmpInitY1. Double_t* TSpectrum2Fit::fAmpInitY1. protected . [fNPeaks] array of initial values of amplitudes of 1D ridges in y direction, input parameters ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:79293,error,errors,79293,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['errors']
Availability," for dsetname is name[#[dir/]objname], e.g. ""mydset"" analysis of the first tree in the top dir of the dataset named ""mydset"" ""mydset#T"" analysis tree ""T"" in the top dir of the dataset named ""mydset"" ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset named ""mydset"" ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the dataset named ""mydset"" The last argument 'enl' specifies an entry- or event-list to be used as event selection. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Definition at line 6182 of file TProof.cxx. ◆ DrawSelect() [2/2]. Long64_t TProof::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). virtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data set object using TDSet::SetEntryList. Returns -1 in case of error or number of selected events otherwise. ; Reimplemented in TProofLite.; Definition at line 6146 of file TProof.cxx. ◆ Echo() [1/2]. Int_t TProof::Echo ; (; const char * ; str). virtual . Sends a string to master and workers and expect them to echo it back to the client via a message. ; It is a special case of the generic Echo() that works with TObjects. Returns -1 on error, the number of workers that received the message on success. ; Definition at line 7042 of file TProof.cxx. ◆ Echo() [2/2]. Int_t TProof::Echo ; (; const TObject * ; obj). virtual . Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ; Returns -1 on error, the number of workers that received the objects on success. ; Definition at line 7028 of file TProof.cxx. ◆ EnablePackage() [1/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:84947,error,error,84947,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability," for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:4986,error,error,4986,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['error'],['error']
Availability," for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all oth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctions.html:13412,avail,available,13412,root/html604/TListOfFunctions.html,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html,2,['avail'],['available']
Availability," for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctions.html:13359,avail,available,13359,root/html602/TListOfFunctions.html,https://root.cern,https://root.cern/root/html602/TListOfFunctions.html,2,['avail'],['available']
Availability," for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:13533,avail,available,13533,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,4,['avail'],['available']
Availability," for further usage. ;  ;  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ;  df020_helpers.C;   Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ;  ;  df021_createTGraph.C;   Fill a TGraph using RDataFrame. ;  ;  df021_createTGraph.py;   Fill a TGraph using RDataFrame. ;  ;  df022_useKahan.C;   Implement a custom action that evaluates a Kahan sum. ;  ;  df023_aggregate.C;   Use the Aggregate action to specify arbitrary data aggregations. ;  ;  df024_Display.C;   Use the Display action to inspect entry values. ;  ;  df024_Display.py;   Use the Display action to inspect entry values. ;  ;  df025_RNode.C;   Manipulate RDF objects in functions, loops and conditional branches. ;  ;  df026_AsNumpyArrays.py;   Read data from RDataFrame into Numpy arrays. ;  ;  df027_SQliteDependencyOverVersion.C;   Plot the ROOT downloads based on the version reading a remote sqlite3 file. ;  ;  df028_SQliteIPLocation.C;   Plot the location of ROOT downloads reading a remote sqlite3 file. ;  ;  df029_SQlitePlatformDistribution.C;   Use RDataFrame to display data about ROOT downloads. ;  ;  df030_SQliteVersionsOfROOT.C;   Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ;  ;  df031_Stats.C;   Use the Stats action to extract the statistics of a column. ;  ;  df031_Stats.py;   Use the Stats action to extract the statistics of a column. ;  ;  df032_RDFFromNumpy.py;   Read data from Numpy arrays into RDataFrame. ;  ;  df033_Describe.py;   Get information about the dataframe with the convenience method Describe. ;  ;  df034_SaveGraph.C;   Basic SaveGraph usage. ;  ;  df034_SaveGraph.py;   Basic SaveGraph usage. ;  ;  df035_RDFFromPandas.py;   Read data from Pandas Data Frame into RDataFrame. ;  ;  df036_missingBranches.C;   ;  ;  df036_missingBranches.py;  ;  df037_TTreeEventMatching.C;   ;  ;  df037_TTreeEventMatching.py;  ;  df101_h1Analysis.C;   Show how to express ROOT's standard H1 analysis with RDataFra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:3865,down,downloads,3865,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,1,['down'],['downloads']
Availability," for meaning of return values. void Terminate(Int_t status = 0); Terminate the application by call TSystem::Exit() unless application has; been told to return from Run(), by a call to SetReturnFromRun(). void LineProcessed(const char* line); Emit signal when a line has been processed. void KeyPressed(Int_t key); Emit signal when console keyboard key was pressed. void ReturnPressed(char* text); Emit signal when return key was pressed. void SetEchoMode(Bool_t mode); Set console echo mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. void CreateApplication(); Static function used to create a default application environment. TApplication * Open(const char* url, Int_t debug, const char* script); Static function used to attach to an existing remote application; or to start one. void Close(TApplication* app); Static function used to close a remote application. void ls(Option_t* option = """") const; Show available sessions. TList * GetApplications(); Static method returning the list of available applications. TApplication(const TApplication& ). TApplication& operator=(const TApplication& ). void SetSignalHandler(TSignalHandler* sh); { fSigHandler = sh; }. TApplication * Open(const char* url, Int_t debug, const char* script). TSignalHandler * GetSignalHandler() const; { return fSigHandler; }. Bool_t HandleTermInput(); { return kFALSE; }. void Init(); { fAppImp->Init(); }. const char * GetIdleCommand() const; { return fIdleCommand; }. const char * ApplicationName() const; { return fAppImp->ApplicationName(); }. void Show(); { fAppImp->Show(); }. void Hide(); { fAppImp->Hide(); }. void Iconify(); { fAppImp->Iconify(); }. void Raise(); { fAppImp->Raise(); }. void Lower(); { fAppImp->Lower(); }. Bool_t IsCmdThread(); { return fAppImp ? fAppImp->IsCmdThread() : kTRUE; }. TApplicationImp * GetApplicationImp(); { return fAppImp;}. Int_t Argc() const; { return fArgc; }. char ** Argv() const; { return fArgv; }. Bool_t NoLogOpt() const; { return fNoLog; }. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TApplication.html:19490,avail,available,19490,root/html530/TApplication.html,https://root.cern,https://root.cern/root/html530/TApplication.html,9,['avail'],['available']
Availability," for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:39499,error,error,39499,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,2,['error'],['error']
Availability," for parameter i (called by the Fitter class when running Minos) ; Definition at line 346 of file FitResult.cxx. ◆ SetModelFunction(). void ROOT::Fit::FitResult::SetModelFunction ; (; const std::shared_ptr< IModelFunction > & ; func). inlineprotected . Definition at line 338 of file FitResult.h. ◆ Status(). int ROOT::Fit::FitResult::Status ; (; ); const. inline . minimizer status code ; Definition at line 128 of file FitResult.h. ◆ Update(). bool ROOT::Fit::FitResult::Update ; (; const std::shared_ptr< ROOT::Math::Minimizer > & ; min, . const ROOT::Fit::FitConfig & ; fconfig, . bool ; isValid, . unsigned int ; ncalls = 0 . ). Update the fit result with a new minimization status To be run only if same fit is performed with same configuration Note that in this case MINOS is not re-run. ; If one wants to run also MINOS a new result must be created ; Definition at line 224 of file FitResult.cxx. ◆ UpperError(). double ROOT::Fit::FitResult::UpperError ; (; unsigned int ; i); const. upper Minos error. If Minos has not run for parameter i return the parabolic error ; Definition at line 339 of file FitResult.cxx. ◆ Value(). double ROOT::Fit::FitResult::Value ; (; unsigned int ; i); const. inline . parameter value by index ; Definition at line 172 of file FitResult.h. Friends And Related Symbol Documentation. ◆ Fitter. friend class Fitter. friend . Definition at line 340 of file FitResult.h. Member Data Documentation. ◆ fBoundParams. std::map<unsigned int, unsigned int> ROOT::Fit::FitResult::fBoundParams. protected . list of limited parameters ; Definition at line 358 of file FitResult.h. ◆ fChi2. double ROOT::Fit::FitResult::fChi2. protected . fit chi2 value (different than fval in case of chi2 fits) ; Definition at line 352 of file FitResult.h. ◆ fCovMatrix. std::vector<double> ROOT::Fit::FitResult::fCovMatrix. protected . covariance matrix (size is npar*(npar+1)/2) where npar is total parameters ; Definition at line 362 of file FitResult.h. ◆ fCovStatus. int ROOT::Fit::Fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:24392,error,error,24392,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['error'],['error']
Availability," for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& b); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits to show when printing RooRealVars. TObject* clone(const char* newname) const; { return new RooRealVar(*this,newname); }. Double_t getError() const; { return _error>=0?_error:0. ; }. Bool_t hasError(Bool_t allowZero = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:43207,error,errors,43207,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,6,['error'],['errors']
Availability," for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 30859 2009-10-24 14:53:07Z ganis $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterTree.html:7664,error,error,7664,root/html528/TEventIterTree.html,https://root.cern,https://root.cern/root/html528/TEventIterTree.html,1,['error'],['error']
Availability," for the Define() and Filter() calls, users are not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and complex functors. The callable can be applied to zero or more existing columns and it will always receive their nominal value in input.; Varying multiple columns in lockstep; In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or ""in lockstep"":; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist.; The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; Combining multiple variations; Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced by applying multiple systematic variations at the same time. For example, in the following example snippet, the RResultMap instance all_h will contain keys ""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);; ; auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::VaryRInterface< RDFDetail::RLoopManager, DS_t > Vary(std::string_view colName, F &&expression, const ColumnNames_t &inputColumns, const std::vector< std::string > &variationTags, std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:56197,down,down,56197,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['down'],['down']
Availability," for the alt; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(RooAbsData& data, RooStats::ModelConfig& b, RooStats::ModelConfig& sb, RooRealVar* scannedVariable = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.05); Constructor from a model for B model and a model for S+B.; An HypoTestCalculator (Hybrid of Frequentis) will be created using the; S+B model as the null and the B model as the alternate; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(const RooStats::HypoTestInverter& rhs); copy-constructor; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax) const; Run a Fixed scan ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:7814,alive,alive,7814,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,3,['alive'],['alive']
Availability," for the alt; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(RooAbsData& data, RooStats::ModelConfig& sb, RooStats::ModelConfig& b, RooRealVar* scannedVariable = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.05); Constructor from a model for B model and a model for S+B.; An HypoTestCalculator (Hybrid of Frequentis) will be created using the; S+B model as the null and the B model as the alternate; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(const RooStats::HypoTestInverter& rhs); copy-constructor; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:8451,alive,alive,8451,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,2,['alive'],['alive']
Availability," for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const char *name, const char* title, RooAbsPdf& extPdf, RooDataSet& xydata, RooRealVar& yvar, Bool_t integrate). RooXYChi2Var constructor with an extended p.d.f. and X-Y values dataset; The value of the function that defines the chi^2 in this form is takes as; the p.d.f. times the expected number of events. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin vol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:39557,error,error,39557,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,1,['error'],['error']
Availability," for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e. no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for example, for an error; only in Minos but not in Migrad a fitStatus of 40 will be returned.; Minuit2 will return also 0 in case of success and different values in migrad, minos or; hesse depending on the error. See in this case the documentation of; Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the; minosResult and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:30152,error,error,30152,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,6,['error'],['error']
Availability," for the window wid. ;  ; void SetCursor (Int_t wid, ECursor cursor) override;  Set the cursor. ;  ; void SetCursor (Window_t id, Cursor_t curid) override;  Set the specified cursor. ;  ; void SetDashes (GContext_t gc, Int_t offset, const char *dash_list, Int_t n) override;  Specify a dash pattertn. ;  ; void SetDNDAware (Window_t win, Atom_t *typelist) override;  Add XdndAware property and the list of drag and drop types to the Window win. ;  ; void SetDoubleBuffer (Int_t wid, Int_t mode) override;  Set the double buffer on/off on window wid. ;  ; void SetDoubleBufferOFF () override;  Turn double buffer mode off. ;  ; void SetDoubleBufferON () override;  Turn double buffer mode on. ;  ; void SetDrawMode (EDrawMode mode) override;  Set the drawing mode. ;  ; void SetFillColor (Color_t cindex) override;  Set color index for fill areas. ;  ; void SetFillStyle (Style_t style) override;  Set fill area style. ;  ; void SetForeground (GContext_t gc, ULong_t foreground) override;  Set foreground color in graphics context (shortcut for ChangeGC with only foreground mask set). ;  ; void SetIconName (Window_t id, char *name) override;  Set window icon name. ;  ; void SetIconPixmap (Window_t id, Pixmap_t pic) override;  Set pixmap the WM can use when the window is iconized. ;  ; void SetInputFocus (Window_t id) override;  Set keyboard input focus to window id. ;  ; void SetKeyAutoRepeat (Bool_t on=kTRUE) override;  Turn key auto repeat on or off. ;  ; void SetLineColor (Color_t cindex) override;  Set color index for lines. ;  ; void SetLineStyle (Style_t linestyle) override;  Set line style. ;  ; void SetLineType (Int_t n, Int_t *dash) override;  Set line type. ;  ; void SetLineWidth (Width_t width) override;  Set line width. ;  ; void SetMarkerColor (Color_t cindex) override;  Set color index for markers. ;  ; void SetMarkerSize (Float_t markersize) override;  Set marker size index. ;  ; void SetMarkerStyle (Style_t markerstyle) override;  Set marker style. ;  ; void SetMWMHin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:20037,mask,mask,20037,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['mask'],['mask']
Availability," for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. See the other TH1::Divide that gives the possibility to optionally compute binomial errors.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Scale; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2908 of file TH1.cxx. ◆ Divide() [2/3]. Bool_t TH1::Divide ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1, . Option_t * ; option = """" . ). virtual . Replace contents of this histogram by the division of h1 by h2. ; this = c1*h1/(c2*h2); If errors are defined (see TH1::Sumw2), errors are also recalculated Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. However, if option =""B"" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower error for the case b1=b2.; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2966 of file TH1.cxx. ◆ Divide() [3/3]. Bool_t TH1::Divide ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:106161,error,errors,106161,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability," for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:69359,error,error,69359,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['error'],['error']
Availability," for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. ◆ Select() [2/3]. TSocket * TMonitor::Select ; (; Long_t ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. ◆ Select() [3/3]. Int_t TMonitor::Select ; (; TList * ; rdready, . TList * ; wrready, . Long_t ; timeout . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. ◆ SetInterest(). void TMonitor::SetInterest ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Set interest mask for socket sock to interest. ; If the socket is not in the active list move it or add it there. If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 180 of file TMonitor.cxx. ◆ SetReady(). void TMonitor::SetReady ; (; TSocket * ; sock). private . Called by TSocketHandler::Notify() to signal which socket is ready to be read or written. ; User should not call this routine. The ready socket will be returned via the Select() user function. The Ready(TSocket *sock) signal is emitted. ; Definition at line 423 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:22540,error,error,22540,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['error'],['error']
Availability," frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:2965,error,error,2965,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,3,"['avail', 'error']","['available', 'error']"
Availability, frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPositionfPressPospsotion of frame on button press event; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGColorSelect.html:21638,down,down,21638,root/html530/TGColorSelect.html,https://root.cern,https://root.cern/root/html530/TGColorSelect.html,9,['down'],['down']
Availability, frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPositionfPressPospsotion of frame on button press event; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorSelect.html:21300,down,down,21300,root/html528/TGColorSelect.html,https://root.cern,https://root.cern/root/html528/TGColorSelect.html,1,['down'],['down']
Availability," from RooStats::HypoTestResult.; Definition at line 147 of file HybridResult.cxx. ◆ Class(). static TClass * RooStats::HybridResult::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooStats::HybridResult::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooStats::HybridResult::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 88 of file HybridResult.h. ◆ CLbError(). double HybridResult::CLbError ; (; ); const. The error on the ""confidence level"" of the null hypothesis. ; Returns an estimate of the error on \(CL_{b}\) assuming a binomial error on \(CL_{b}\):. \[; \sigma_{CL_{b}} = \sqrt{CL_{b} \left( 1 - CL_{b} \right) / n_{toys}}; \]. Definition at line 181 of file HybridResult.cxx. ◆ CLsError(). double HybridResult::CLsError ; (; ); const. The error on the ratio \(CL_{s+b}/CL_{b}\). ; Returns an estimate of the error on \(CL_{s}\) through combination of the errors on \(CL_{b}\) and \(CL_{s+b}\):. \[; \sigma_{CL_s} = CL_s \sqrt{\left( \frac{\sigma_{CL_{s+b}}}{CL_{s+b}} \right)^2 + \left( \frac{\sigma_{CL_{b}}}{CL_{b}} \right)^2}; \]. Definition at line 207 of file HybridResult.cxx. ◆ CLsplusbError(). double HybridResult::CLsplusbError ; (; ); const. The error on the ""confidence level"" of the alternative hypothesis. ; Returns an estimate of the error on \(CL_{s+b}\) assuming a binomial error on \(CL_{s+b}\):. \[; \sigma_{CL_{s+b}} = \sqrt{CL_{s+b} \left( 1 - CL_{s+b} \right) / n_{toys}}; \]. Definition at line 194 of file HybridResult.cxx. ◆ DeclFileName(). static const char * RooStats::HybridResult::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file HybridResult.h. ◆ GetPlot(). HybridPlot * HybridResult::GetPlot ; (; const char * ; name, . const char * ; title, . int ; n_bins . ). prepare a plot showing a result and return a pointer to a HybridPlot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridResult.html:19996,error,error,19996,doc/master/classRooStats_1_1HybridResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridResult.html,2,['error'],"['error', 'errors']"
Availability," from TH3.; Definition at line 1054 of file TProfile3D.cxx. ◆ ProjectionXYZ(). TH3D * TProfile3D::ProjectionXYZ ; (; const char * ; name = ""_pxyz"", . Option_t * ; option = ""e"" . ); const. virtual . Project this profile3D into a 3-D histogram along X,Y,Z. ; The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""E"" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH2D using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option ""W"") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable (TProfile2D::fSumw2[bin] ); Note that the axis range is not considered when doing the projection . Definition at line 961 of file TProfile3D.cxx. ◆ PutStats(). void TProfile3D::PutStats ; (; Double_t * ; stats). overridevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:96873,error,errors,96873,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,2,['error'],['errors']
Availability," from TNamed.; Definition at line 106 of file TPackMgr.h. ◆ IsEnabled(). Bool_t TPackMgr::IsEnabled ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Check if the package is enabled; priority is given to packmgr, if defined. ; Returns kTRUE if enabled ; Definition at line 961 of file TPackMgr.cxx. ◆ IsInDir(). Bool_t TPackMgr::IsInDir ; (; const char * ; path). Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ; Definition at line 478 of file TPackMgr.cxx. ◆ IsPackageEnabled(). Bool_t TPackMgr::IsPackageEnabled ; (; const char * ; pack). inline . Definition at line 82 of file TPackMgr.h. ◆ Load() [1/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . const char * ; opts . ). Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ; Definition at line 206 of file TPackMgr.cxx. ◆ Load() [2/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . TList * ; optls = 0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; pack = 0, . Bool_t ; dolock = kTRUE . ). Remove package 'pack' If 'pack' is null or empty all packages are cleared. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:21549,error,error,21549,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['error'],['error']
Availability," from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclContLines is kTRUE, all continuation lines; marked by the '\\' token are zapped as well. Bool_t expectToken(const TString& expected, Bool_t zapOnError = kFALSE); Read the next token and return kTRUE if it is identical to the given 'expected' token. Bool_t readDouble(Double_t& value, Bool_t zapOnError = kFALSE); Read the next token and convert it to a Double_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToDouble(const TString& token, Double_t& value); Convert given string to a double. Return true if the conversion fails. Bool_t readInteger(Int_t& value, Bool_t zapOnError = kFALSE); Read a token and convert it to an Int_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToInteger(const TString& token, Int_t& value); Convert given string to an Int_t. Returns true if an error; occurred in conversion. Bool_t readString(TString& value, Bool_t zapOnError = kFALSE); Read a string token. Returns true if an error occurred in reading; or conversion. If a the read token is enclosed in quotation; marks those are stripped in the returned value. Bool_t convertToString(const TString& token, TString& string); Convert given token to a string (i.e. remove eventual quotation marks). RooStreamParser(istream& is); Constructors, assignment etc. TString getPunctuation() const; { return _punct ; }. Bool_t atEOF(); { return _atEOF ; }. » Last changed: Mon Dec 7 13:49:32 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStreamParser.html:4203,error,error,4203,root/html526/RooStreamParser.html,https://root.cern,https://root.cern/root/html526/RooStreamParser.html,3,['error'],['error']
Availability," from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclContLines is kTRUE, all continuation lines; marked by the '\\' token are zapped as well. Bool_t expectToken(const TString& expected, Bool_t zapOnError = kFALSE); Read the next token and return kTRUE if it is identical to the given 'expected' token. Bool_t readDouble(Double_t& value, Bool_t zapOnError = kFALSE); Read the next token and convert it to a Double_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToDouble(const TString& token, Double_t& value); Convert given string to a double. Return true if the conversion fails. Bool_t readInteger(Int_t& value, Bool_t zapOnError = kFALSE); Read a token and convert it to an Int_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToInteger(const TString& token, Int_t& value); Convert given string to an Int_t. Returns true if an error; occurred in conversion. Bool_t readString(TString& value, Bool_t zapOnError = kFALSE); Read a string token. Returns true if an error occurred in reading; or conversion. If a the read token is enclosed in quotation; marks those are stripped in the returned value. Bool_t convertToString(const TString& token, TString& string); Convert given token to a string (i.e. remove eventual quotation marks). RooStreamParser(istream& is); Constructors, assignment etc. TString getPunctuation() const; { return _punct ; }. Bool_t atEOF(); { return _atEOF ; }. » Last changed: Mon Jul 4 15:24:36 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStreamParser.html:4189,error,error,4189,root/html530/RooStreamParser.html,https://root.cern,https://root.cern/root/html530/RooStreamParser.html,3,['error'],['error']
Availability," from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclContLines is kTRUE, all continuation lines; marked by the '\\' token are zapped as well. Bool_t expectToken(const TString& expected, Bool_t zapOnError = kFALSE); Read the next token and return kTRUE if it is identical to the given 'expected' token. Bool_t readDouble(Double_t& value, Bool_t zapOnError = kFALSE); Read the next token and convert it to a Double_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToDouble(const TString& token, Double_t& value); Convert given string to a double. Return true if the conversion fails. Bool_t readInteger(Int_t& value, Bool_t zapOnError = kFALSE); Read a token and convert it to an Int_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToInteger(const TString& token, Int_t& value); Convert given string to an Int_t. Returns true if an error; occurred in conversion. Bool_t readString(TString& value, Bool_t zapOnError = kFALSE); Read a string token. Returns true if an error occurred in reading; or conversion. If a the read token is enclosed in quotation; marks those are stripped in the returned value. Bool_t convertToString(const TString& token, TString& string); Convert given token to a string (i.e. remove eventual quotation marks). RooStreamParser(istream& is); Constructors, assignment etc. TString getPunctuation() const; { return _punct ; }. Bool_t atEOF(); { return _atEOF ; }. » Last changed: Sat Oct 9 06:58:48 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStreamParser.html:4189,error,error,4189,root/html528/RooStreamParser.html,https://root.cern,https://root.cern/root/html528/RooStreamParser.html,3,['error'],['error']
Availability," from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclContLines is kTRUE, all continuation lines; marked by the '\\' token are zapped as well. Bool_t expectToken(const TString& expected, Bool_t zapOnError = kFALSE); Read the next token and return kTRUE if it is identical to the given 'expected' token. Bool_t readDouble(Double_t& value, Bool_t zapOnError = kFALSE); Read the next token and convert it to a Double_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToDouble(const TString& token, Double_t& value); Convert given string to a double. Return true if the conversion fails. Bool_t readInteger(Int_t& value, Bool_t zapOnError = kFALSE); Read a token and convert it to an Int_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToInteger(const TString& token, Int_t& value); Convert given string to an Int_t. Returns true if an error; occurred in conversion. Bool_t readString(TString& value, Bool_t zapOnError = kFALSE); Read a string token. Returns true if an error occurred in reading; or conversion. If a the read token is enclosed in quotation; marks those are stripped in the returned value. Bool_t convertToString(const TString& token, TString& string); Convert given token to a string (i.e. remove eventual quotation marks). RooStreamParser(istream& is); Constructors, assignment etc. TString getPunctuation() const; { return _punct ; }. Bool_t atEOF(); { return _atEOF ; }. » Last changed: Thu Nov 3 20:09:53 2011 » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStreamParser.html:4189,error,error,4189,root/html532/RooStreamParser.html,https://root.cern,https://root.cern/root/html532/RooStreamParser.html,6,['error'],['error']
Availability," from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclContLines is kTRUE, all continuation lines; marked by the '\\' token are zapped as well. Bool_t expectToken(const TString& expected, Bool_t zapOnError = kFALSE); Read the next token and return kTRUE if it is identical to the given 'expected' token. Bool_t readDouble(Double_t& value, Bool_t zapOnError = kFALSE); Read the next token and convert it to a Double_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToDouble(const TString& token, Double_t& value); Convert given string to a double. Return true if the conversion fails. Bool_t readInteger(Int_t& value, Bool_t zapOnError = kFALSE); Read a token and convert it to an Int_t. Returns true; if an error occurred in reading or conversion. Bool_t convertToInteger(const TString& token, Int_t& value); Convert given string to an Int_t. Returns true if an error; occurred in conversion. Bool_t readString(TString& value, Bool_t zapOnError = kFALSE); Read a string token. Returns true if an error occurred in reading; or conversion. If a the read token is enclosed in quotation; marks those are stripped in the returned value. Bool_t convertToString(const TString& token, TString& string); Convert given token to a string (i.e. remove eventual quotation marks). RooStreamParser(istream& is); Constructors, assignment etc. TString getPunctuation() const; { return _punct ; }. Bool_t atEOF(); { return _atEOF ; }. » Last changed: Tue Jun 2 15:36:00 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStreamParser.html:4219,error,error,4219,root/html604/RooStreamParser.html,https://root.cern,https://root.cern/root/html604/RooStreamParser.html,6,['error'],['error']
Availability," from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:27300,error,error,27300,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,4,['error'],['error']
Availability," from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:27640,error,error,27640,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['error'],['error']
Availability," from internal coordinates (PINT) to external (U) ; The minimising routines which work in internal coordinates call this routine before calling FCN. ; Definition at line 4506 of file TMinuit.cxx. ◆ mninit(). void TMinuit::mninit ; (; Int_t ; i1, . Int_t ; i2, . Int_t ; i3 . ). virtual . Main initialization member function for MINUIT. ; It initializes some constants (including the logical I/O unit nos.), ; Definition at line 4526 of file TMinuit.cxx. ◆ mnlims(). void TMinuit::mnlims ; (; ). virtual . Interprets the SET LIM command, to reset the parameter limits. ; Called from MNSET ; Definition at line 4616 of file TMinuit.cxx. ◆ mnline(). void TMinuit::mnline ; (; Double_t * ; start, . Double_t ; fstart, . Double_t * ; step, . Double_t ; slope, . Double_t ; toler . ). virtual . Perform a line search from position START. ; along direction STEP, where the length of vector STEP gives the expected position of minimum.; FSTART is value of function at START; SLOPE (if non-zero) is df/dx along STEP at START; TOLER is initial tolerance of minimum in direction STEP. SLAMBG and ALPHA control the maximum individual steps allowed. The first step is always =1. The max length of second step is SLAMBG. The max size of subsequent steps is the maximum previous successful step multiplied by ALPHA + the size of most recent successful step, but cannot be smaller than SLAMBG. ; Definition at line 4736 of file TMinuit.cxx. ◆ mnmatu(). void TMinuit::mnmatu ; (; Int_t ; kode). virtual . Prints the covariance matrix v when KODE=1. ; always prints the global correlations, and calculates and prints the individual correlation coefficients ; Definition at line 4968 of file TMinuit.cxx. ◆ mnmigr(). void TMinuit::mnmigr ; (; ). virtual . Performs a local function minimization. ; Performs a local function minimization using basically the method of Davidon-Fletcher-Powell as modified by Fletcher; ref. – Fletcher, Comp.J. 13,317 (1970) ""switching method"" ; Definition at line 5048 of file TMinuit.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:55495,toler,tolerance,55495,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['toler'],['tolerance']
Availability," from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:162631,error,errors,162631,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability," from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front();}. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coeffic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitResult.html:6896,error,errors,6896,root/html526/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitResult.html,1,['error'],['errors']
Availability," from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:7045,error,errors,7045,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,11,"['Error', 'error']","['Errors', 'errors']"
Availability," from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:17101,toler,tolerances,17101,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['toler'],['tolerances']
Availability," from the number of effective entries for all the cells included in the projection.; NOTE 4: underflow/overflow are by default excluded from the projection (Note that this is a different default behavior compared to the projection to an histogram) To include the underflow and/or overflow use option ""UF"" and/or ""OF"" ; Reimplemented in TProfile3D.; Definition at line 2806 of file TH3.cxx. ◆ ProjectionX(). TH1D * TH3::ProjectionX ; (; const char * ; name = ""_px"", . Int_t ; iymin = 0, . Int_t ; iymax = -1, . Int_t ; izmin = 0, . Int_t ; izmax = -1, . Option_t * ; option = """" . ); const. virtual . Project a 3-D histogram into a 1-D histogram along X. ; The projection is always of the type TH1D. The projection is made from the cells along the X axis ranging from iymin to iymax and izmin to izmax included. By default, underflow and overflows are included in both the Y and Z axis. By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow in Y will be excluded By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded; if option ""e"" is specified, the errors are computed. if option ""d"" is specified, the projection is drawn in the current pad. if option ""o"" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.; NOTE that if a TH1D named ""name"" exists in the current directory or pad the histogram is reset and filled again with the projected contents of the TH3.; implemented using Project3D ; Definition at line 1747 of file TH3.cxx. ◆ ProjectionY(). TH1D * TH3::ProjectionY ; (; const char * ; name = ""_py"", . Int_t ; ixmin = 0, . Int_t ; ixmax = -1, . Int_t ; izmin = 0, . Int_t ; izmax = -1, . Option_t * ; option = """" . ); const. virtual . Project a 3-D histogram into a 1-D histogram along Y. ; The projection is always of the type TH1D. The projection is made from the cells along the Y axis ranging from ixmin to ixmax and izmin to izmax included. By default, underflow and overflow are incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:95716,error,errors,95716,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['error'],['errors']
Availability," func, RooRealVar& x, const RooArgSet& nset, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:24385,Error,ErrorLoggingMode,24385,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,2,['Error'],['ErrorLoggingMode']
Availability," function (must implement multi-dim function interface: IBaseFunctionMultiDim) ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 63 of file AdaptiveIntegratorMultiDim.cxx. ◆ SetMaxPts(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetMaxPts ; (; unsigned int ; n). inline . set max points ; Definition at line 167 of file AdaptiveIntegratorMultiDim.h. ◆ SetMinPts(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetMinPts ; (; unsigned int ; n). inline . set min points ; Definition at line 164 of file AdaptiveIntegratorMultiDim.h. ◆ SetOptions(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetOptions ; (; const ROOT::Math::IntegratorMultiDimOptions & ; opt). overridevirtual . set the options ; Reimplemented from ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 401 of file AdaptiveIntegratorMultiDim.cxx. ◆ SetRelTolerance(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetRelTolerance ; (; double ; relTol). overridevirtual . set relative tolerance ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 70 of file AdaptiveIntegratorMultiDim.cxx. ◆ SetSize(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetSize ; (; unsigned int ; size). inline . set workspace size ; Definition at line 161 of file AdaptiveIntegratorMultiDim.h. ◆ Status(). int ROOT::Math::AdaptiveIntegratorMultiDim::Status ; (; ); const. inlineoverridevirtual . return status of integration . status = 0 successful integration; status = 1 MAXPTS is too small for the specified accuracy EPS. The result contain the values obtainable for the specified value of MAXPTS.; status = 2 size is too small for the specified number MAXPTS of function evaluations.; status = 3 wrong dimension , N<2 or N > 15. Returned result and error are zero . Implements ROOT::Math::VirtualIntegrator.; Definition at line 149 of file AdaptiveIntegratorMultiDim.h. Member Data Documentation. ◆ fAbsTol. double ROOT::Math::AdaptiveIntegratorMultiDim::fAbsTol. private . absolute tolerance ; Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:11513,toler,tolerance,11513,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['toler'],['tolerance']
Availability," function calculates the background spectrum in this histogram. ;  ; Int_t ShowPeaks (Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) override;  Interface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. ;  ; void Smooth (Int_t ntimes=1, Option_t *option="""") override;  Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH2. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:11404,error,errors,11404,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,2,['error'],['errors']
Availability," function checks if there is a bin without a label if all bins have labels, the axis can / will become alphanumeric. ; Definition at line 646 of file TAxis.cxx. ◆ ImportAttributes(). void TAxis::ImportAttributes ; (; const TAxis * ; axis). virtual . Copy axis attributes to this. ; Definition at line 680 of file TAxis.cxx. ◆ IsA(). TClass * TAxis::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 177 of file TAxis.h. ◆ IsAlphanumeric(). Bool_t TAxis::IsAlphanumeric ; (; ); const. inline . Definition at line 88 of file TAxis.h. ◆ IsVariableBinSize(). Bool_t TAxis::IsVariableBinSize ; (; ); const. inline . Definition at line 142 of file TAxis.h. ◆ LabelsOption(). void TAxis::LabelsOption ; (; Option_t * ; option = ""h""). virtual . Set option(s) to draw axis with labels option can be: . ""a"" sort by alphabetic order; "">"" sort by decreasing values; ""<"" sort by increasing values; ""h"" draw labels horizontal; ""v"" draw labels vertical; ""u"" draw labels up (end of label right adjusted); ""d"" draw labels down (start of label left adjusted) . Definition at line 662 of file TAxis.cxx. ◆ operator=(). TAxis & TAxis::operator= ; (; const TAxis & ; axis). Assignment operator. ; Definition at line 118 of file TAxis.cxx. ◆ RotateTitle(). void TAxis::RotateTitle ; (; Bool_t ; rotate = kTRUE). inline . Rotate title by 180 degrees. ; By default the title is drawn right adjusted. If rotate is TRUE, the title is left adjusted at the end of the axis and rotated by 180 degrees ; Definition at line 203 of file TAxis.h. ◆ SaveAttributes(). void TAxis::SaveAttributes ; (; std::ostream & ; out, . const char * ; name, . const char * ; subname . ). overridevirtual . Save axis attributes as C++ statement(s) on output stream out. ; Reimplemented from TAttAxis.; Definition at line 710 of file TAxis.cxx. ◆ Set() [1/3]. void TAxis::Set ; (; Int_t ; nbins, . const Double_t * ; xbins . ). virtual . Initialize axis with variabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis.html:38126,down,down,38126,doc/master/classTAxis.html,https://root.cern,https://root.cern/doc/master/classTAxis.html,1,['down'],['down']
Availability," function for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char *function, const char *params, int *error); Execute a global function with arguments params. void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error); Execute a method from class cl with arguments params. void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of the currently interpreted file,; included or not. Example to illustrate the difference between; GetCurrentMacroName() and GetTopLevelMacroName():. ; inclfile.h. #include <iostream>; void inclfunc() {; std::cout << ""In inclfile.h"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:25425,error,error,25425,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,1,['error'],['error']
Availability," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. RooMinimizer(RooAbsReal& function); virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:1153,avail,available,1153,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,5,['avail'],['available']
Availability," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizer.html:1153,avail,available,1153,root/html602/RooMinimizer.html,https://root.cern,https://root.cern/root/html602/RooMinimizer.html,4,['avail'],['available']
Availability," function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinimizer. class RooMinimizer: public TObject. RooMinimizer is a wrapper class around ROOT::Fit:Fitter that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; ; By default the Minimizer is MINUIT.; ; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . This class is also known as (typedefs to this class)MINIMIZER. Function Members (Methods); public:. RooMinimizer(RooAbsReal& function); virtual~RooMinimizer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizer.html:1153,avail,available,1153,root/html534/RooMinimizer.html,https://root.cern,https://root.cern/root/html534/RooMinimizer.html,2,['avail'],['available']
Availability," function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:28898,error,error,28898,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,10,['error'],['error']
Availability," function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CalcYErrorsSum () const;  Recalculates the summed y error arrays. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set Note: This function should be called only from the constructor since it does not delete previously existing arrays. ;  ; Bool_t DoMerge (const TGraph *tg) override;  Protected function to perform the merge operation of a graph with multiple asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:40623,error,errors,40623,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['errors']
Availability," function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Int_t Merge(TCollection* list); Adds all graphs with errors from the collection to this graph.; Returns the total number of poins in the result or -1 in case of an error. void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t ex, Double_t ey); Set ex and ey values for point pointed by the mouse. void SetPointError(Int_t i, Double_t ex, Double_t ey); Set ex and ey values for point number i. void Streamer(TBuffer& ); Stream an object of class TGraphErrors. void SwapPoints(Int_t pos1, Int_t pos2); Swap points. Double_t ** Allocate(Int_t size). Double_t * GetEX() const; {return fEX;}. Double_t * GetEY() const; {return fEY;}. » Author: Rene Brun 15/09/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:05; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraphErrors.html:20068,error,errors,20068,root/html604/TGraphErrors.html,https://root.cern,https://root.cern/root/html604/TGraphErrors.html,2,['error'],['errors']
Availability," function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Int_t Merge(TCollection* list); Adds all graphs with errors from the collection to this graph.; Returns the total number of poins in the result or -1 in case of an error. void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t ex, Double_t ey); Set ex and ey values for point pointed by the mouse. void SetPointError(Int_t i, Double_t ex, Double_t ey); Set ex and ey values for point number i. void Streamer(TBuffer& ); Stream an object of class TGraphErrors. void SwapPoints(Int_t pos1, Int_t pos2); Swap points. Double_t ** Allocate(Int_t size). Double_t * GetEX() const; {return fEX;}. Double_t * GetEY() const; {return fEY;}. » Author: Rene Brun 15/09/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphErrors.html:20068,error,errors,20068,root/html602/TGraphErrors.html,https://root.cern,https://root.cern/root/html602/TGraphErrors.html,2,['error'],['errors']
Availability," function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 100000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& b); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:61492,error,errors,61492,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,3,['error'],['errors']
Availability," functions or lambdas.; This illustrates the usage of lambdas:; {; TProcPool pool;; auto ten = pool.MapReduce([]() { return 1; }, 10, [](std::vector<int> v) { return std::accumulate(v.begin(), v.end(), 0); }); }; And this how it can be used to generate ten histos and merge them:; {; TObject *CreateAndFillHists(); {. TH1F *h = new TH1F(""h"", """", 100, -3., 3.);; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore.; Language Bindings; Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel. We made it easier to use ROOT notebooks locally, by providing a ‘root –notebook’ command option to start a local notebook server customised with all the ROOT features.; New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found here and many more snippets here.; Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added.; JavaScript ROOT. support registered in THttpServer commands with arguments.; provide workaround for websites using require.js and older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:21797,avail,available,21797,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avail'],['available']
Availability," functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:79841,error,errors,79841,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,6,['error'],['errors']
Availability," g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:1653,error,errors,1653,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['error'],['errors']
Availability," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35464,recover,recovered,35464,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['recover'],['recovered']
Availability," gROOT#define gROOTDefinition TROOT.h:406; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TF11-Dim function classDefinition TF1.h:233; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphBentErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, and fEYhighd array...Definition TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:26493,error,errorsDefinition,26493,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errorsDefinition']
Availability," gTws->fHeight = h;; 1867}; 1868 ; 1869////////////////////////////////////////////////////////////////////////////////; 1870/// Resize a pixmap.; 1871///; 1872/// \param [in] wid : pixmap to be resized; 1873/// \param [in] w,h : Width and height of the pixmap; 1874 ; 1875int TGX11::ResizePixmap(int wid, unsigned int w, unsigned int h); 1876{; 1877 Window root;; 1878 unsigned int wval, hval;; 1879 int xx, yy, i;; 1880 unsigned int ww, hh, border, depth;; 1881 wval = w;; 1882 hval = h;; 1883 ; 1884 gTws = &fWindows[wid];; 1885 ; 1886 // don't do anything when size did not change; 1887 // if (gTws->fWidth == wval && gTws->fHeight == hval) return 0;; 1888 ; 1889 // due to round-off errors in TPad::Resize() we might get +/- 1 pixel; 1890 // change, in those cases don't resize pixmap; 1891 if (gTws->fWidth >= wval-1 && gTws->fWidth <= wval+1 &&; 1892 gTws->fHeight >= hval-1 && gTws->fHeight <= hval+1) return 0;; 1893 ; 1894 // don't free and recreate pixmap when new pixmap is smaller; 1895 if (gTws->fWidth < wval || gTws->fHeight < hval) {; 1896 XFreePixmap((Display*)fDisplay, gTws->fWindow);; 1897 gTws->fWindow = XCreatePixmap((Display*)fDisplay, fRootWin, wval, hval, fDepth);; 1898 }; 1899 XGetGeometry((Display*)fDisplay, gTws->fWindow, &root, &xx, &yy, &ww, &hh, &border, &depth);; 1900 ; 1901 for (i = 0; i < kMAXGC; i++); 1902 XSetClipMask((Display*)fDisplay, gGClist[i], None);; 1903 ; 1904 SetColor(gGCpxmp, 0);; 1905 XFillRectangle((Display*)fDisplay, gTws->fWindow, *gGCpxmp, 0, 0, ww, hh);; 1906 SetColor(gGCpxmp, 1);; 1907 ; 1908 // Initialise the window structure; 1909 gTws->fDrawing = gTws->fWindow;; 1910 gTws->fWidth = wval;; 1911 gTws->fHeight = hval;; 1912 ; 1913 return 1;; 1914}; 1915 ; 1916////////////////////////////////////////////////////////////////////////////////; 1917/// Resize the current window if necessary.; 1918 ; 1919void TGX11::ResizeWindow(Int_t wid); 1920{; 1921 int i;; 1922 int xval=0, yval=0;; 1923 Window win, root=0;; 1924 unsigned int wval=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:60335,error,errors,60335,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['error'],['errors']
Availability," gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); virtual~TQpVar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Double_tGetMu(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpVar.html:1620,Error,Error,1620,root/html532/TQpVar.html,https://root.cern,https://root.cern/root/html532/TQpVar.html,2,['Error'],['Error']
Availability," generated includes:; 2672/// - <em>dirnameProjectHeaders.h</em>, which contains one `#include` statement per generated header file; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__Vertex_int_.h; 2678///; 2679/// In the generated classes, map, multimap when the first template parameter is a class; 2680/// are replaced by a vector of pair. set and multiset when the tempalte parameter; 2681/// is a class are replaced by a vector. This is required since we do not have the; 2682/// code needed to order and/or compare the object of the classes.; 2683/// This is a quick explanation of the options available:; 2684/// Option | Details; 2685/// -------|--------; 2686/// new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.; 2687/// recreate | If dirname does not exist, it is created (like in ""new""). If dirname already exist, all existing files in dirname are deleted before creating the new files.; 2688/// update | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as ""new"".; 2689/// genreflex | Use genreflex rather than rootcint to generate the dictionary.; 2690/// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:95570,avail,available,95570,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avail'],['available']
Availability," geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something inside.”; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1006432,down,down,1006432,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability," given; value. This function overrides the default value; that is taken in the RooMinimizer constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. void setOffsetting(Bool_t flag); Enable internal likelihood offsetting for enhanced numeric precision. void setMinimizerType(const char* type); Choose the minimzer algorithm. ROOT::Fit::Fitter* fitter(); Return underlying ROOT fitter object. const ROOT::Fit::Fitter* fitter() const; Return underlying ROOT fitter object. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. m - Run Migrad only; h - Run Hesse to estimate errors; v - Verbose mode; l - Log parameters after each Minuit steps to file; t - Activate profile timer; r - Save fit result; 0 - Run Migrad with strategy 0. Int_t minimize(const char* type, const char* alg = 0). Int_t migrad(); Execute MIGRAD. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizer.html:10475,error,errors,10475,root/html534/RooMinimizer.html,https://root.cern,https://root.cern/root/html534/RooMinimizer.html,6,['error'],['errors']
Availability," gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option ROB. See the tutorial fitLinearRobust.C. Notes on TGraph/TGraphErrors Fitting:. By using the ""effective variance"" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.; The effective variance technique assumes that there is no correlation between the x and y coordinate.; The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option ""EX0""; The linear fitter doesn't take into account the errors in x. When fitting a TGraphErrors with a linear functions the errors in x will not be considered. If errors in x are important, use option ""F"" for linear function fitting.; When fitting a TGraph (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: parameter_error *= sqrt(chisquare/(ndf-1)). General Fitting documentation; See in TH1::Fit for the documentation of; Fit Result; Fit Status; Fit Statistics Box; Fitting in a Range; Setting Initial Conditions . Definition at line 1231 of file TGraph.cxx. ◆ FitPanel(). void TGraph::FitPanel ; (; ). virtual . Display a GUI panel with all graph fit options. ; See class TFitEditor for example ; Definition at line 1274 of file TGraph.cxx. ◆ GetCorrelationFactor(). Double_t TGraph::GetCorrelationFactor ; (; ); const. virtual . Return graph correlation factor. ; Definition at line 1296 of file TGraph.cxx. ◆ GetCovariance(). Double_t TGraph::GetCovariance ; (; ); const. virtual . Return covariance of vectors x,y. ; Definition at line 1308 of file TGraph.cxx. ◆ GetEditable(). Bool_t TGraph::GetEditable ; (; ); const. Return kTRUE if kNotEditable bit is not set, kFALSE otherwise. ; Definition at line 2292 of file TGraph.cxx. ◆ GetErrorX(). Double_t TGraph::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:52423,error,errors,52423,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,2,['error'],['errors']
Availability," gr->Draw(""AB"");; 190 c47->cd(2); gr->Draw(""AB1"");; 191}; 192End_Macro; 193 ; 194\anchor GrP2; 195### Exclusion graphs; 196 ; 197When a graph is painted with the option `C` or `L` it is; 198possible to draw a filled area on one side of the line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interestin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:7677,error,error,7677,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,3,"['avail', 'error']","['available', 'error']"
Availability," graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""0""; By default, when a data point is outside the visible range along the Y axis the error; bars are not drawn. Combined with other options, this option forces error bars'; drawing for the data points outside the visible range along the Y axis. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end of the error bars (when option 1 is used).; By default np=1. (np represents the number of pixels).; TGraphErrors; A TGraphErrors is a TGraph with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Picture; Source. {; TCanvas *c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->Draw(""ap"");; return c4;; }; The option ""3"" allows to shows the error as band. Picture; Source. {; TCanvas *c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetFillColor(4);; ge->SetFillStyle(3010);; g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphPainter.html:6513,error,error,6513,root/html530/TGraphPainter.html,https://root.cern,https://root.cern/root/html530/TGraphPainter.html,1,['error'],['error']
Availability," graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:40151,error,errors,40151,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,2,"['error', 'robust']","['errors', 'robust']"
Availability," graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end of the error bars (when option 1 is used).; By default np=1. (np represents the number of pixels).; TGraphErrors; A TGraphErrors is a TGraph with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Picture; Source. {; TCanvas *c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->Draw(""ap"");; return c4;; }; The option ""3"" allows to shows the error as band. Picture; Source. {; TCanvas *c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; return c41;; }; The option ""4"" is similar to the option ""3"" except that the band is smoothed.; As the following picture shows, this option should be used carefuly because; the smoothing algorithm may show some (huge) ""bouncing"" effects. In some case; looks nicer than the option ""3"" (because it is smooth) but it can be; misleading. Picture; Source. {; TCanvas *c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:6911,error,error,6911,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability," group size; and their unique id. Returns number of active slaves.; Returns -1 in case of error. Bool_t GetFileInCmd(const char* cmd, TString& fn); Static method to extract the filename (if any) form a CINT command.; Returns kTRUE and the filename in 'fn'; returns kFALSE if not found or not; appliable. Int_t Exec(const char* cmd, Bool_t plusMaster = kFALSE); Send command to be executed on the PROOF master and/or slaves.; If plusMaster is kTRUE then exeucte on slaves and master too.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. Int_t SendCurrentState(TProof::ESlaves list = kActive); Transfer the current state of the master to the active slave servers.; The current state includes: the current working directory, etc.; Returns the number of active slaves. Returns -1 in case of error. Int_t SendInitialState(); Transfer the initial (i.e. current) state of the master to all; slave servers. Currently the initial state includes: log level.; Returns the number of active slaves. Returns -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:54184,error,error,54184,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," h_higgs = static_cast<TH1 *>(df_higgs->Clone());; stack->Add(h_higgs);; stack->Draw(""HIST"");; ; // stack histogram can be accessed only after drawing; stack->GetHistogram()->SetTitle("""");; stack->GetHistogram()->GetXaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetXaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetXaxis()->SetTitleOffset(1.3);; stack->GetHistogram()->GetXaxis()->SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]"");; stack->GetHistogram()->GetYaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetYaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetYaxis()->SetTitle(""Events"");; stack->SetMaximum(35);; stack->GetHistogram()->GetYaxis()->ChangeLabel(1, -1, 0);; ; // Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(kBlack);; histos_mc[""nominal""].SetFillStyle(3254);; auto h_nominal = histos_mc[""nominal""].DrawClone(""E2 same"");; histos_mc[""weight:up""].SetLineColor(kGreen + 2);; auto h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST same"");; histos_mc[""weight:down""].SetLineColor(kBlue + 2);; auto h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST same"");; ; // Draw data histogram; df_h_mass_data->SetMarkerStyle(20);; df_h_mass_data->SetMarkerSize(1.);; df_h_mass_data->SetLineWidth(2);; df_h_mass_data->SetLineColor(kBlack);; df_h_mass_data->SetStats(false);; auto h_mass_data = df_h_mass_data->DrawClone(""E sames"");; ; // Add legend; auto legend = new TLegend(0.57, 0.65, 0.94, 0.94);; legend->SetTextFont(42);; legend->SetFillStyle(0);; legend->SetBorderSize(0);; legend->SetTextSize(0.025);; legend->SetTextAlign(32);; legend->AddEntry(h_mass_data, ""Data"", ""lep"");; legend->AddEntry(h_higgs, ""Higgs MC"", ""f"");; legend->AddEntry(h_zz, ""ZZ MC"", ""f"");; legend->AddEntry(h_other, ""Other MC"", ""f"");; legend->AddEntry(h_weight_down, ""Total MC Variations Down"", ""l"");; legend->AddEntry(h_weight_up, ""Total MC Variations Up"", ""l"");; legend->AddEntry(h_nominal, ""Total MC Uncertainty"", ""f"");; legend->Draw();; ; // Add ATLAS label; TLatex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:11535,down,down,11535,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['down'],['down']
Availability," handles menu events ;  ; GContext_t fNormGC;  normal drawing graphics context ;  ; Bool_t fPoppedUp;  true if menu is currently popped up ;  ; GContext_t fSelbackGC;  graphics context for drawing selection background ;  ; GContext_t fSelGC;  graphics context for drawing selections ;  ; TGSplitButton * fSplitButton;  split button (if any) ;  ; Bool_t fStick;  stick mode (popup menu stays sticked on screen) ;  ; UInt_t fXl;  Max width of all menu entries. ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Static Protected Attributes; static const TGFont * fgDefaultFont = nullptr;  ; static const TGGC * fgDefaultGC = nullptr;  ; static const TGGC * fgDefaultSelectedBackgroundGC = nullptr;  ; static const TGGC * fgDefaultSelectedGC = nullptr;  ; static const TGFont * fgHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGPopupMenu.html:29611,mask,mask,29611,doc/master/classTGPopupMenu.html,https://root.cern,https://root.cern/doc/master/classTGPopupMenu.html,1,['mask'],['mask']
Availability," handles menu events ;  ; GContext_t fNormGC;  normal drawing graphics context ;  ; Bool_t fPoppedUp;  true if menu is currently popped up ;  ; GContext_t fSelbackGC;  graphics context for drawing selection background ;  ; GContext_t fSelGC;  graphics context for drawing selections ;  ; TGSplitButton * fSplitButton;  split button (if any) ;  ; Bool_t fStick;  stick mode (popup menu stays sticked on screen) ;  ; UInt_t fXl;  Max width of all menu entries. ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Protected Attributes inherited from TContextMenuImp; TContextMenu * fContextMenu {nullptr};  ;  Static Protected Attributes inherited from TGPopupMenu; static const TGFont * fgDefaultFont = nullptr;  ; static const TGGC * fgDefaultGC = nullptr;  ; static const TGGC * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootContextMenu.html:33661,mask,mask,33661,doc/master/classTRootContextMenu.html,https://root.cern,https://root.cern/doc/master/classTRootContextMenu.html,1,['mask'],['mask']
Availability," happens, try switching it off.; 998 * <tr><td> `RecoverFromUndefinedRegions(double strength)` <td> When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region.; 999 * `strength` controls the magnitude of the penalty term. Leaving out this argument defaults to 10. Switch off with `strength = 0.`.; 1000 *; 1001 * <tr><td> `SumW2Error(bool flag)` <td> Apply correction to errors and covariance matrix.; 1002 * This uses two covariance matrices, one with the weights, the other with squared weights,; 1003 * to obtain the correct errors for weighted likelihood fits. If this option is activated, the; 1004 * corrected covariance matrix is calculated as \f$ V_\mathrm{corr} = V C^{-1} V \f$, where \f$ V \f$ is the original; 1005 * covariance matrix and \f$ C \f$ is the inverse of the covariance matrix calculated using the; 1006 * squared weights. This allows to switch between two interpretations of errors:; 1007 * <table>; 1008 * <tr><th> SumW2Error <th> Interpretation; 1009 * <tr><td> true <td> The errors reflect the uncertainty of the Monte Carlo simulation.; 1010 * Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; 1011 *; 1012 * **Example**: Simulation with 1000 events, the average weight is 0.1.; 1013 * The errors are as big as if one fitted to 1000 events.; 1014 * <tr><td> false <td> The errors reflect the errors of a dataset, which is as big as the sum of weights.; 1015 * Use this if you want to know what statistical errors you would get if you had a dataset with as many; 1016 * events as the (weighted) Monte Carlo simulation represents.; 1017 *; 1018 * **Example** (Data as above):; 1019 * The errors are as big as if one fitted to 100 events.; 1020 * </table>; 1021 * \note If the `SumW2Error` correction is enabled, the covariance matrix quality stored in the RooFitResult; 1022 * object will be the minimum of the original covariance matrix quality and the quality of the covari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:47824,error,errors,47824,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['error'],['errors']
Availability," has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:11622,recover,recovers,11622,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['recover'],['recovers']
Availability," has to be applied for the functions where the; role of ""up"" and ""down"" is reversed.; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fE*** to arrays[***]; or to f*** Copy points. Bool_t CtorAllocate(void); Should be called from ctors after fNpoints has been set. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; Get high error on X[i]. Double_t GetErrorXlow(Int_t bin) const; Get low error on X[i]. Double_t GetErrorYhigh(Int_t bin) const; Get high error on Y[i]. Double_t GetErrorYlow(Int_t bin) const; Get low error on Y[i]. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end). void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld = 0, Double_t exhd = 0, Double_t eyld = 0, Double_t eyhd = 0); Set ex and ey values for point pointed by the mouse. void SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld = 0, Double_t exhd = 0, Double_t eyld = 0, Double_t eyhd = 0); Set ex and ey values for point number i. void SwapPoints(Int_t pos1, Int_t pos2); Swap points. Double_t ** Allocate(Int_t size). Double_t * GetEXlow() const; {return fEXlow;}. Double_t * GetEXhigh() const; {return fEXhigh;}. D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphBentErrors.html:17532,error,error,17532,root/html528/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html528/TGraphBentErrors.html,4,['error'],['error']
Availability," have activated the following line in system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootgeom_8C.html:6059,down,down,6059,doc/master/rootgeom_8C.html,https://root.cern,https://root.cern/doc/master/rootgeom_8C.html,1,['down'],['down']
Availability," have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9494,error,error,9494,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['error'],['error']
Availability," header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TArcBall. class TArcBall. Implements the arc-ball rotation manipulator.; Used by plot-painters. Function Members (Methods); public:. TArcBall(UInt_t NewWidth = 100, UInt_t NewHeight = 100); virtual~TArcBall(); static TClass*Class(); voidClick(const TPoint& NewPt); voidDrag(const TPoint& NewPt); const Double_t*GetRotMatrix() const; virtual TClass*IsA() const; voidSetBounds(UInt_t NewWidth, UInt_t NewHeight); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidMapToSphere(const TPoint& NewPt, Double_t* NewVec) const. private:. TArcBall(const TArcBall&); TArcBall&operator=(const TArcBall&); voidResetMatrices(). Data Members; private:. Double_tfAdjustHeightMouse bounds height; Double_tfAdjustWidthMouse bounds width; Double_tfEnVec[3]Saved drag vector; Double_tfLastRot[9]; Double_tfStVec[3]Saved click vector; Double_tfThisRot[9]; Double_tfTransform[16]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void MapToSphere(const TPoint& NewPt, Double_t* NewVec) const; map to sphere. TArcBall(UInt_t NewWidth = 100, UInt_t NewHeight = 100); constructor. void Click(const TPoint& NewPt); Mouse down. void Drag(const TPoint& NewPt); Mouse drag, calculate rotation. void ResetMatrices(); Set rotation matrix as union. TArcBall(const TArcBall& ); Non-copyable. virtual ~TArcBall(); { }. void SetBounds(UInt_t NewWidth, UInt_t NewHeight). const Double_t * GetRotMatrix() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TArcBall.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 13:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TArcBall.html:1477,down,down,1477,root/html526/TArcBall.html,https://root.cern,https://root.cern/root/html526/TArcBall.html,1,['down'],['down']
Availability," height if HMAXIM; 10678 // has not been called.; 10679 // MAX% is the value in percent which has been set in HPLSET; 10680 // (default is 90%).; 10681 if (!maximum) {; 10682 zmax += yMARGIN*(zmax-zmin);; 10683 }; 10684 ; 10685 // final adjustment of ymin for linear scale.; 10686 // if minimum is not set , then ymin is set to zero if >0; 10687 // or to ymin - yMARGIN if <0.; 10688 if (!minimum) {; 10689 if (Hoption.MinimumZero) {; 10690 if (zmin >= 0) zmin = 0;; 10691 else zmin -= yMARGIN*(zmax-zmin);; 10692 } else {; 10693 Double_t dzmin = yMARGIN*(zmax-zmin);; 10694 if (zmin >= 0 && (zmin-dzmin <= 0)) zmin = 0;; 10695 else zmin -= dzmin;; 10696 }; 10697 }; 10698 ; 10699LZMIN:; 10700 Hparam.zmin = zmin;; 10701 Hparam.zmax = zmax;; 10702 ; 10703 // Set bar offset and width; 10704 Hparam.baroffset = fH->GetBarOffset();; 10705 Hparam.barwidth = fH->GetBarWidth();; 10706 ; 10707 return 1;; 10708}; 10709 ; 10710////////////////////////////////////////////////////////////////////////////////; 10711/// This function returns the best format to print the error value (e); 10712/// knowing the parameter value (v) and the format (f) used to print it.; 10713 ; 10714const char * THistPainter::GetBestFormat(Double_t v, Double_t e, const char *f); 10715{; 10716 ; 10717 static TString ef;; 10718 TString tf, tv;; 10719 ; 10720 // print v with the format f in tv.; 10721 tf.Form(""%s%s"",""%"",f);; 10722 tv.Form(tf.Data(),v);; 10723 ; 10724 // Analyse tv.; 10725 int ie = tv.Index(""e"");; 10726 int iE = tv.Index(""E"");; 10727 int id = tv.Index(""."");; 10728 ; 10729 // v has been printed with the exponent notation.; 10730 // There is 2 cases, the exponent is positive or negative; 10731 if (ie >= 0 || iE >= 0) {; 10732 if (tv.Index(""+"") >= 0) {; 10733 if (e < 1) {; 10734 ef.Form(""%s.1f"",""%"");; 10735 } else {; 10736 if (ie >= 0) {; 10737 ef.Form(""%s.%de"",""%"",ie-id-1);; 10738 } else {; 10739 ef.Form(""%s.%dE"",""%"",iE-id-1);; 10740 }; 10741 }; 10742 } else {; 10743 if (ie >= 0) {; 10744 ef.Form(""%s.%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:384729,error,error,384729,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability," hints ;  ; TGLayoutHints * fLHint;  ; TGCompositeFrame * fRight;  left and right parts of MDI menu bar ;  ; TGLayoutHints * fRightHint;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Friends; class TGMdiMainFrame;  . Additional Inherited Members;  Public Types inherited from TGWindow; enum  EEditMode { ;   kEditEnable = 0; , kEditDisable = (1ULL << ( 0 )); , kEditDisableEvents = (1ULL << ( 1 )); , kEditDisableGrab = (1ULL << ( 2 )); , ;   kEditDisa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMdiMenuBar.html:26751,mask,mask,26751,doc/master/classTGMdiMenuBar.html,https://root.cern,https://root.cern/doc/master/classTGMdiMenuBar.html,1,['mask'],['mask']
Availability," histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/testSmooth_8C.html:1941,error,error,1941,doc/master/testSmooth_8C.html,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html,1,['error'],['error']
Availability," histogram to the current histogram; Additions of two histograms with coefficients and storage into the current histogram; Multiplications and divisions are supported in the same way as additions.; The Add , Divide and Multiply methods also exist to add, divide or multiply a histogram by a function. Histograms objects (not pointers) TH1F h1 can be multiplied by a constant using:; h1.Scale(const); A new histogram can be created without changing the original one by doing:; TH1F h3 = 8*h1;; To multiply two histogram objects and put the result in a 3rd one do:; TH1F h3 = h1*h2;; The same operations can be done with histogram pointers TH1F *h1, *h2 following way:; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; Of course, the TH1 methods Add , Multiply and Divide can be used instead of these operators.; If a histogram has associated error bars ( TH1::Sumw2() has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, binomial errors are also supported.; 3.7 Projections; One can make:. a 1-D projection of a 2-D histogram or profile. See TH2::ProfileX, TH2::ProfileY,TProfile::ProjectionX, TProfile2D::ProjectionXY, TH2::ProjectionX, TH2::ProjectionY .; a 1-D, 2-D or profile out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:81072,error,errors,81072,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['errors']
Availability," histograms; 1025 ; 1026 ; 1027double ROOT::Fit::Chisquare(const TH1 & h1, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type) {; 1028 return HFit::ComputeChi2(h1,f1,useRange, type);; 1029}; 1030 ; 1031double ROOT::Fit::Chisquare(const TGraph & g, TF1 & f1, bool useRange) {; 1032 return HFit::ComputeChi2(g,f1, useRange, ROOT::Fit::EChisquareType::kNeyman);; 1033}; 1034 ; 1035template<class FitObject>; 1036double HFit::ComputeChi2(const FitObject & obj, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type ) {; 1037 ; 1038 // implement using the fitting classes; 1039 ROOT::Fit::DataOptions opt;; 1040 opt.fUseEmpty = (type != ROOT::Fit::EChisquareType::kNeyman); // use empty bin when not using Neyman chisquare (observed error); 1041 opt.fExpErrors = (type == ROOT::Fit::EChisquareType::kPearson);; 1042 opt.fErrors1 = (type == ROOT::Fit::EChisquareType::kPearson); // not using observed errors in Pearson chi2; 1043 ; 1044 ROOT::Fit::DataRange range;; 1045 // get range of function; 1046 if (useRange) HFit::GetFunctionRange(f1,range);; 1047 // fill the data set; 1048 ROOT::Fit::BinData data(opt,range);; 1049 ROOT::Fit::FillData(data, &obj, &f1);; 1050 if (data.Size() == 0 ) {; 1051 Warning(""Chisquare"",""data set is empty - return -1"");; 1052 return -1;; 1053 }; 1054 ROOT::Math::WrappedMultiTF1 wf1(f1);; 1055 if (type == ROOT::Fit::EChisquareType::kPLikeRatio) {; 1056 // use the poisson log-lokelihood (Baker-Cousins chi2); 1057 ROOT::Fit::PoissonLLFunction nll(data, wf1);; 1058 return 2.* nll( f1.GetParameters() ) ;; 1059 }; 1060 ROOT::Fit::Chi2Function chi2(data, wf1);; 1061 return chi2(f1.GetParameters() );; 1062 ; 1063}; BinData.h; Chi2FCN.h; FitConfig.h; Fitter.h; HFitInterface.h; MinimizerOptions.h; Minimizer.h; PoissonLikelihoodFCN.h; g#define g(i)Definition RSha256.hxx:105; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:39730,error,errors,39730,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['error'],['errors']
Availability," how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; & & x_{ij} & ... & x_{ik} \\; & & x_{lj} & ... & x_{lk} \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. 14.5.1 View Operators; For the matrix views TMatrixDRow, TMatrixDColumn and TMatrixDDiag, the necessary assignment operators are available to interact with the vector class TVectorD. The sub matrix view TMatrixDSub has links to the matrix classes TMatrixD and TMatrixDSym. The next table summarizes how the access individual matrix elements in the matrix views:. Format; Comment. TMatrixDRow(A,i)(j) TMatrixDRow(A,i)[j]; element \(A_{ij}\). TMatrixDColumn(A,j)(i) TMatrixDColumn(A,j)[i]; element \(A_{ij}\). TMatrixDDiag(A(i) TMatrixDDiag(A[i]; element \(A_{ij}\). TMatrixDSub(A(i) TMatrixDSub(A,rl,rh,cl,ch)(i,j); element \(A_{ij}\); element \(A_{rl+i,cl+j}\). The next two tables show the possible operations with real numbers, and the operations between the matrix views:. Description; Format; Comment. assign real; TMatrixDRow(A,i) = r; row \(i\). TMatrixDColumn(A,j) = r; column \(j\). TMatrixDDiag(A) = r; matrix diagonal. TMatrixDSub(A,i,l,j,k) = r; sub matrix. add real; TMatrixDRow(A,i) += r; row \(i\). TMatrixDColumn(A,j) += r; column \(j\). TMatrixDDiag(A) += r; matrix diagonal. TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:785163,avail,available,785163,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability," i); const. overridevirtual . Get low error on x coordinate for point i. ; Reimplemented from TGraph.; Definition at line 1481 of file TGraphMultiErrors.cxx. ◆ GetErrorY() [1/2]. Double_t TGraphMultiErrors::GetErrorY ; (; Int_t ; i); const. overridevirtual . Get error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. In case of asymmetric errors the mean of the square sum is returned ; Reimplemented from TGraph.; Definition at line 1454 of file TGraphMultiErrors.cxx. ◆ GetErrorY() [2/2]. Double_t TGraphMultiErrors::GetErrorY ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get error e on y coordinate for point i. ; In case of asymmetric errors the mean of the square sum is returned ; Definition at line 1468 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [1/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i); const. overridevirtual . Get high error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1530 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [2/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get high error e on y coordinate for point i. ; Definition at line 1566 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [1/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i); const. overridevirtual . Get low error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1504 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [2/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get low error e on y coordinate for point i. ; Definition at line 1555 of file TGraphMultiErrors.cxx. ◆ GetEXhigh(). Double_t * TGraphMultiErrors::GetEXhigh ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:63375,error,errors,63375,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['errors']
Availability," i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:84074,error,errors,84074,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability," i-th daughters of the volume specified by volName; According to A. Morsch' G3toRoot class. Int_t VolId2Mate(Int_t id) const. Return material number for a given volume id. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Returns the Transformation matrix between the volume specified; by the path volumePath and the Top or mater volume. The format; of the path volumePath is as follows (assuming ALIC is the Top volume); ""/ALIC_1/DDIP_1/S05I_2/S05H_1/S05G_3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:19348,error,error,19348,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,10,['error'],['error']
Availability," i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87729,error,errors,87729,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability," i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; Now, let’s see how the tree looks like in the tree viewer. The tree viewer with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:581021,alive,alive,581021,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['alive'],['alive']
Availability," i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the TTree::Branch() call, even though the formal argument is declared a ’void*'. In the case of ROOT objects, similar pointer manipulation is unnecessary, because the full type information is available, and TTree::Branch() has been Pythonized to take care of the call details. However, data members of such objects that are of built-in types, still require something extra since they are normally translated to Python primitive types on access and hence their address cannot be taken. For that purpose, there is the AddressOf() function. As an example:; from ROOT import TFile, TTree; from ROOT import gROOT, AddressOf. gROOT.ProcessLine(; ""struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1071177,avail,available,1071177,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability," id2 << "" "" << name1 << "" "" << name2 << std::endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:8836,avail,available,8836,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,4,['avail'],['available']
Availability," identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgSet& sumSet, Bool_t takeOwnerShip = kFALSE); Constructor with a single set of RooAbsReals. The value of the function will be; the sum of the values in sumSet. If takeOwnership is true the RooAddition object; will take ownership of the arguments in sumSet. RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE); Constructor with two set of RooAbsReals. The value of the function will be. A = sum_i sumSet1(i)*sumSet2(i). If takeOwnership is true the RooAddition object will take ownership of the arguments in sumSet. RooAddition(const RooAddition& other, const char* name = 0); Copy constructor. ~RooAddition(); Destructor. Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddition to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set1 ; }. const RooArgList& list2() const; { return _set2 ; }. » Last changed: Mon Dec 7 13:45:57 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:33761,error,error,33761,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,2,['error'],['error']
Availability," idx = 0) const. Double_t GetBinError2(Long64_t linidx) const. Long64_t GetBin(const Int_t* idx) const. Long64_t GetBin(const Double_t* x) const. Long64_t GetBin(const char*[] name) const. Long64_t GetBin(const Int_t* idx, Bool_t = kTRUE). Long64_t GetBin(const Double_t* x, Bool_t = kTRUE). Long64_t GetBin(const char*[] name, Bool_t = kTRUE). void SetBinContent(const Int_t* idx, Double_t v); { SetBinContent(GetBin(idx), v); }. void SetBinContent(Long64_t bin, Double_t v). void SetBinError2(Long64_t bin, Double_t e2). void AddBinError2(Long64_t bin, Double_t e2). void AddBinContent(Long64_t bin, Double_t v = 1.). Double_t GetSumw() const; { return fTsumw; }. Double_t GetSumw2() const; { return fTsumw2; }. Double_t GetSumwx(Int_t dim) const; { return fTsumwx[dim]; }. Double_t GetSumwx2(Int_t dim) const; { return fTsumwx2[dim]; }. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. {xDim, yDim}. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnBase.html:22003,error,errors,22003,root/html602/THnBase.html,https://root.cern,https://root.cern/root/html602/THnBase.html,4,['error'],['errors']
Availability," if (!reg.IsNull() && s.Index(re) == kNPOS); 1216 continue;; 1217 bool first = (lnk->Prev() == nullptr) || (s != lnk->Prev()->GetObject()->GetName());; 1218 bool hasbackup = (lnk->Next() != nullptr) && (s == lnk->Next()->GetObject()->GetName());; 1219 if (first); 1220 if (hasbackup); 1221 key->ls(true);; 1222 else; 1223 key->ls();; 1224 else; 1225 key->ls(false);; 1226 }; 1227 }; 1228 TROOT::DecreaseDirLevel();; 1229}; 1230 ; 1231////////////////////////////////////////////////////////////////////////////////; 1232/// Interface to TFile::Open; 1233 ; 1234TFile *TDirectoryFile::OpenFile(const char *name, Option_t *option,const char *ftitle, Int_t compress, Int_t netopt); 1235{; 1236 return TFile::Open(name,option,ftitle,compress,netopt);; 1237 ; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1242///; 1243/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1244/// name already exists.; 1245/// returnExistingDirectory returns a pointer to an already existing sub-directory instead of 0.; 1246/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1247/// the hierarchy (in the above example, the returned TDirectory * always points; 1248/// to ""a"").; 1249 ; 1250TDirectory *TDirectoryFile::mkdir(const char *name, const char *title, Bool_t returnExistingDirectory); 1251{; 1252 if (!name || !title || !name[0]) return nullptr;; 1253 if (!title[0]) title = name;; 1254 if (GetKey(name)) {; 1255 if (returnExistingDirectory); 1256 return (TDirectoryFile*) GetDirectory(name);; 1257 else {; 1258 Error(""mkdir"",""An object with name %s exists already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(work",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:41975,error,error,41975,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['error'],['error']
Availability," if (fClass->GetCollectionType() > ROOT::kNotSTL) {; 780 const bool isOldRVec = fClass->GetCollectionType() == ROOT::kROOTRVec && (fElements->GetEntries() == 1) &&; 781 !strcmp(fElements->At(0)->GetName(), ""fData"");; 782 if (!isOldRVec && TClassEdit::IsSTLCont(fClass->GetName())) {; 783 // We have a collection that is indeed an STL collection,; 784 // we know we don't need its streamerInfo.; 785 SetBit(kCanDelete);; 786 return;; 787 }; 788 }; 789 bool isStdPair = TClassEdit::IsStdPair(GetName());; 790 ; 791 if (0 == strcmp(""string"",fClass->GetName())) {; 792 // We know we do not need any offset check for a string; 793 SetBit(kCanDelete);; 794 return;; 795 }; 796 ; 797 const TObjArray *array = fClass->GetStreamerInfos();; 798 TStreamerInfo* info = 0;; 799 ; 800 if (fClass->GetState() == TClass::kNoInfo && array->IsEmpty()) {; 801 // We have an emulated class that has no TStreamerInfo, this; 802 // means it was created to insert a (default) rule. Consequently; 803 // the error message about the missing dictionary was not printed.; 804 // For consistency, let's print it now!; 805 ; 806 ::Warning(""TClass::TClass"", ""no dictionary for class %s is available"", GetName());; 807 }; 808 ; 809 // Case of a custom collection (the user provided a CollectionProxy; 810 // for a class that is not an STL collection).; 811 if (GetElements()->GetEntriesFast() == 1) {; 812 TObject *element = GetElements()->UncheckedAt(0);; 813 Bool_t isstl = element && strcmp(""This"",element->GetName())==0;; 814 if (isstl && !fClass->GetCollectionProxy()) {; 815 if (element->GetTitle()[0] == '<') {; 816 // We know the content.; 817 TString content = element->GetTitle();; 818 Int_t level = 1;; 819 for(Int_t c = 1; c < content.Length(); ++c) {; 820 if (content[c] == '<') ++level;; 821 else if (content[c] == '>') --level;; 822 if (level == 0) {; 823 content.Remove(c+1);; 824 break;; 825 }; 826 }; 827 content.Prepend(""vector"");; 828 TClass *clequiv = TClass::GetClass(content);; 829 TVirtualCollectionProxy *pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:29547,error,error,29547,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['error'],['error']
Availability," if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:9988,error,errors,9988,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['error'],['errors']
Availability," if (hname == ""_py"") hname = TString::Format(""%s%s"", GetName(), name);; 1785 TString title = TString::Format(""%s ( Projection Y )"",GetTitle());; 1786 ; 1787 // when projecting in Z outer axis are X and Y (order is important. It is defined in the DoProject1D function); 1788 return DoProject1D(hname, title, ixmin, ixmax, izmin, izmax, &fYaxis, &fXaxis, &fZaxis, option);; 1789}; 1790 ; 1791////////////////////////////////////////////////////////////////////////////////; 1792/// Project a 3-D histogram into a 1-D histogram along Z.; 1793///; 1794/// The projection is always of the type TH1D.; 1795/// The projection is made from the cells along the Z axis; 1796/// ranging from ixmin to ixmax and iymin to iymax included.; 1797/// By default, bins 1 to nx and 1 to ny are included; 1798/// By default, underflow and overflow are included in both the X and Y axis.; 1799/// By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; 1800/// By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded; 1801///; 1802/// if option ""e"" is specified, the errors are computed.; 1803/// if option ""d"" is specified, the projection is drawn in the current pad.; 1804/// if option ""o"" original axis range of the target axes will be; 1805/// kept, but only bins inside the selected range will be filled.; 1806///; 1807/// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; 1808/// the histogram is reset and filled again with the projected contents of the TH3.; 1809///; 1810/// implemented using Project3D; 1811 ; 1812TH1D *TH3::ProjectionZ(const char *name, Int_t ixmin, Int_t ixmax,; 1813 Int_t iymin, Int_t iymax, Option_t *option) const; 1814{; 1815 ; 1816 TString hname = name;; 1817 if (hname == ""_pz"") hname = TString::Format(""%s%s"", GetName(), name);; 1818 TString title = TString::Format(""%s ( Projection Z )"",GetTitle());; 1819 ; 1820 // when projecting in Z outer axis are X and Y (order is important. It is defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:71769,error,errors,71769,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['error'],['errors']
Availability," if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:32078,error,errors,32078,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['error'],['errors']
Availability," if (ngood == 0 && nbad == 0) goto L700;; 5430 if (ngood > 0 && nbad == 0) fCstatu = ""SUCCESSFUL"";; 5431 if (ngood == 0 && nbad > 0) fCstatu = ""FAILURE "";; 5432 if (ngood > 0 && nbad > 0) fCstatu = ""PROBLEMS "";; 5433 if (fISW[4] >= 0) mnprin(4, fAmin);; 5434 if (fISW[4] >= 2) mnmatu(0);; 5435 return;; 5436// new minimum found; 5437L650:; 5438 fCfrom = ""MINOS "";; 5439 fNfcnfr = nfcnmi;; 5440 fCstatu = ""NEW MINIMU"";; 5441 if (fISW[4] >= 0) mnprin(4, fAmin);; 5442 Printf("" NEW MINIMUM FOUND. GO BACK TO MINIMIZATION STEP."");; 5443 Printf("" ================================================="");; 5444 Printf("" V"");; 5445 Printf("" V"");; 5446 Printf("" V"");; 5447 Printf("" VVVVVVV"");; 5448 Printf("" VVVVV"");; 5449 Printf("" VVV"");; 5450 Printf("" V\n"");; 5451 return;; 5452L700:; 5453 Printf("" THERE ARE NO MINOS ERRORS TO CALCULATE."");; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Performs a MINOS error analysis on one parameter; 5458///; 5459/// The parameter ILAX is varied, and the minimum of the; 5460/// function with respect to the other parameters is followed; 5461/// until it crosses the value FMIN+UP.; 5462 ; 5463void TMinuit::mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi); 5464{; 5465 /* System generated locals */; 5466 Int_t i__1;; 5467 ; 5468 /* Local variables */; 5469 Double_t delu, aopt, eros;; 5470 Double_t abest, xunit, dc, ut, sigsav, du1;; 5471 Double_t fac, sig, sav;; 5472 Int_t marc, isig, mpar, ndex, imax, indx, ierr, i, j;; 5473 Int_t iercr, it, istrav, nfmxin, nlimit, isw2, isw4;; 5474 TString csig;; 5475 ; 5476// save and prepare start vals; 5477 isw2 = fISW[1];; 5478 isw4 = fISW[3];; 5479 sigsav = fEDM;; 5480 istrav = fIstrat;; 5481 dc = fDcovar;; 5482 fLnewmn = kFALSE;; 5483 fApsi = fEpsi*.5;; 5484 abest = fAmin;; 5485 mpar = fNpar;; 5486 nfmxin = fNfcnmx;; 5487 for (i = 1; i <= mpar; ++i) { fXt[i-1] = fX[i-1]; }; 5488 i__1 = mpar*(mpar + 1) / 2;; 5489 for (j = 1; j <= i__1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:178415,error,error,178415,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability," if USE_SERVER_STATS is not; 3015 * defined */; 3016 ; 3017 if ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {; 3018 mg_strlcpy(p, ptr, len + 1);; 3019 }; 3020 ; 3021 return p;; 3022}; 3023 ; 3024 ; 3025static char *; 3026mg_strdup_ctx(const char *str, struct mg_context *ctx); 3027{; 3028 return mg_strndup_ctx(str, strlen(str), ctx);; 3029}; 3030 ; 3031static char *; 3032mg_strdup(const char *str); 3033{; 3034 return mg_strndup_ctx(str, strlen(str), NULL);; 3035}; 3036 ; 3037 ; 3038static const char *; 3039mg_strcasestr(const char *big_str, const char *small_str); 3040{; 3041 size_t i, big_len = strlen(big_str), small_len = strlen(small_str);; 3042 ; 3043 if (big_len >= small_len) {; 3044 for (i = 0; i <= (big_len - small_len); i++) {; 3045 if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {; 3046 return big_str + i;; 3047 }; 3048 }; 3049 }; 3050 ; 3051 return NULL;; 3052}; 3053 ; 3054 ; 3055/* Return null terminated string of given maximum length.; 3056 * Report errors if length is exceeded. */; 3057static void; 3058mg_vsnprintf(const struct mg_connection *conn,; 3059 int *truncated,; 3060 char *buf,; 3061 size_t buflen,; 3062 const char *fmt,; 3063 va_list ap); 3064{; 3065 int n, ok;; 3066 ; 3067 if (buflen == 0) {; 3068 if (truncated) {; 3069 *truncated = 1;; 3070 }; 3071 return;; 3072 }; 3073 ; 3074#if defined(__clang__); 3075#pragma clang diagnostic push; 3076#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 3077 /* Using fmt as a non-literal is intended here, since it is mostly called; 3078 * indirectly by mg_snprintf */; 3079#endif; 3080 ; 3081 n = (int)vsnprintf_impl(buf, buflen, fmt, ap);; 3082 ok = (n >= 0) && ((size_t)n < buflen);; 3083 ; 3084#if defined(__clang__); 3085#pragma clang diagnostic pop; 3086#endif; 3087 ; 3088 if (ok) {; 3089 if (truncated) {; 3090 *truncated = 0;; 3091 }; 3092 } else {; 3093 if (truncated) {; 3094 *truncated = 1;; 3095 }; 3096 mg_cry_internal(conn,; 3097 ""truncating vsnprintf buffer: [%.*s]"",; 3098 (int)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:92366,error,errors,92366,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['errors']
Availability," if USE_SERVER_STATS is not; 3016 * defined */; 3017 ; 3018 if ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {; 3019 mg_strlcpy(p, ptr, len + 1);; 3020 }; 3021 ; 3022 return p;; 3023}; 3024 ; 3025 ; 3026static char *; 3027mg_strdup_ctx(const char *str, struct mg_context *ctx); 3028{; 3029 return mg_strndup_ctx(str, strlen(str), ctx);; 3030}; 3031 ; 3032static char *; 3033mg_strdup(const char *str); 3034{; 3035 return mg_strndup_ctx(str, strlen(str), NULL);; 3036}; 3037 ; 3038 ; 3039static const char *; 3040mg_strcasestr(const char *big_str, const char *small_str); 3041{; 3042 size_t i, big_len = strlen(big_str), small_len = strlen(small_str);; 3043 ; 3044 if (big_len >= small_len) {; 3045 for (i = 0; i <= (big_len - small_len); i++) {; 3046 if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {; 3047 return big_str + i;; 3048 }; 3049 }; 3050 }; 3051 ; 3052 return NULL;; 3053}; 3054 ; 3055 ; 3056/* Return null terminated string of given maximum length.; 3057 * Report errors if length is exceeded. */; 3058static void; 3059mg_vsnprintf(const struct mg_connection *conn,; 3060 int *truncated,; 3061 char *buf,; 3062 size_t buflen,; 3063 const char *fmt,; 3064 va_list ap); 3065{; 3066 int n, ok;; 3067 ; 3068 if (buflen == 0) {; 3069 if (truncated) {; 3070 *truncated = 1;; 3071 }; 3072 return;; 3073 }; 3074 ; 3075#if defined(__clang__); 3076#pragma clang diagnostic push; 3077#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 3078 /* Using fmt as a non-literal is intended here, since it is mostly called; 3079 * indirectly by mg_snprintf */; 3080#endif; 3081 ; 3082 n = (int)vsnprintf_impl(buf, buflen, fmt, ap);; 3083 ok = (n >= 0) && ((size_t)n < buflen);; 3084 ; 3085#if defined(__clang__); 3086#pragma clang diagnostic pop; 3087#endif; 3088 ; 3089 if (ok) {; 3090 if (truncated) {; 3091 *truncated = 0;; 3092 }; 3093 } else {; 3094 if (truncated) {; 3095 *truncated = 1;; 3096 }; 3097 mg_cry_internal(conn,; 3098 ""truncating vsnprintf buffer: [%.*s]"",; 3099 (int)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:92398,error,errors,92398,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['errors']
Availability," if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:152776,error,error,152776,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['error'],['error']
Availability," if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2918; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3215; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:152952,error,error,152952,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['error'],['error']
Availability," if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList; TBtree. Unordered collections don’t maintain the order in which the elements were added, i.e. when you iterate over an unordered collection, you are not likely to retrieve elements in the same order they were added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842987,avail,available,842987,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability," if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH1D* QuantilesX(Double_t prob = 0.5, const char* name = ""_qx"") const; Compute the X distribution of quantiles in the other variable Y; name is the name of the returned histogram; prob is the probability content for the quantile (0.5 is the default for the median); An approximate error for the quantile is computed assuming that the distribution in; the other variable is normal. TH1D* QuantilesY(Double_t prob = 0.5, const char* name = ""_qy"") const; Compute the Y distribution of quantiles in the other variable X; name is the name of the returned histogram; prob is the probability content for the quantile (0.5 is the default for the median); An approximate error for the quantile is computed assuming that the distribution in; the other variable is normal. TH1D* DoQuanti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:54469,error,error,54469,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,4,['error'],['error']
Availability," if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetShowProjectionX(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:53092,error,error,53092,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,2,['error'],['error']
Availability," if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:343433,avail,available,343433,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avail'],['available']
Availability," im4;; 2578 shape[7].x = im4; shape[7].y = im4;; 2579 shape[8].x = 0; shape[8].y = im;; 2580 shape[9].x =-im4; shape[9].y = im4;; 2581 shape[10].x= -im; shape[10].y= im4;; 2582 SetMarkerType(3,11,shape);; 2583 } else if (markerstyle == 30) {; 2584 // open star pentagone; 2585 Int_t im1 = Int_t(0.66*MarkerSizeReduced + 0.5);; 2586 Int_t im2 = Int_t(2.00*MarkerSizeReduced + 0.5);; 2587 Int_t im3 = Int_t(2.66*MarkerSizeReduced + 0.5);; 2588 Int_t im4 = Int_t(1.33*MarkerSizeReduced + 0.5);; 2589 shape[0].x = -im; shape[0].y = im4;; 2590 shape[1].x =-im2; shape[1].y =-im1;; 2591 shape[2].x =-im3; shape[2].y = -im;; 2592 shape[3].x = 0; shape[3].y =-im2;; 2593 shape[4].x = im3; shape[4].y = -im;; 2594 shape[5].x = im2; shape[5].y =-im1;; 2595 shape[6].x = im; shape[6].y = im4;; 2596 shape[7].x = im4; shape[7].y = im4;; 2597 shape[8].x = 0; shape[8].y = im;; 2598 shape[9].x =-im4; shape[9].y = im4;; 2599 shape[10].x= -im; shape[10].y= im4;; 2600 SetMarkerType(2,11,shape);; 2601 } else if (markerstyle == 32) {; 2602 // open triangle down; 2603 shape[0].x = 0; shape[0].y = im;; 2604 shape[1].x = im; shape[1].y = -im;; 2605 shape[2].x = -im; shape[2].y = -im;; 2606 shape[3].x = 0; shape[3].y = im;; 2607 SetMarkerType(2,4,shape);; 2608 } else if (markerstyle == 33) {; 2609 // full losange; 2610 Int_t imx = Int_t(2.66*MarkerSizeReduced + 0.5);; 2611 shape[0].x =-imx; shape[0].y = 0;; 2612 shape[1].x = 0; shape[1].y = -im;; 2613 shape[2].x = imx; shape[2].y = 0;; 2614 shape[3].x = 0; shape[3].y = im;; 2615 shape[4].x =-imx; shape[4].y = 0;; 2616 SetMarkerType(3,5,shape);; 2617 } else if (markerstyle == 34) {; 2618 // full cross; 2619 Int_t imx = Int_t(1.33*MarkerSizeReduced + 0.5);; 2620 shape[0].x = -im; shape[0].y =-imx;; 2621 shape[1].x =-imx; shape[1].y =-imx;; 2622 shape[2].x =-imx; shape[2].y = -im;; 2623 shape[3].x = imx; shape[3].y = -im;; 2624 shape[4].x = imx; shape[4].y =-imx;; 2625 shape[5].x = im; shape[5].y =-imx;; 2626 shape[6].x = im; shape[6].y = imx;; 2627 shap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:84752,down,down,84752,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['down'],['down']
Availability," implements covariance matrix calculation will re-implement the method. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ivar) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. bool GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; (This feature is not yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. bool Scan(unsigned int ivar, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:10750,error,error,10750,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,6,['error'],['error']
Availability," in Cling because too many side effects; 1723 Printf(""*** .reset not allowed, please use gROOT->Reset() ***"");; 1724 return 0;; 1725 ; 1726#if 0; 1727 // delete the ROOT dictionary since CINT will destroy all objects; 1728 // referenced by the dictionary classes (TClass et. al.); 1729 gROOT->GetListOfClasses()->Delete();; 1730 // fall through; 1731#endif; 1732 }; 1733 ; 1734 if (!strcmp(line, "".libraries"")) {; 1735 // List the loaded libraries; 1736 gSystem->ListLibraries();; 1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:67947,error,error,67947,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,['error'],['error']
Availability," in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/overflow.; 5296 // For this reason we use AddBinContent method; 5297 Double_t oldEntries = fEntries;; 5298 Int_t bin,binx,biny,binz;; 5299 for (bin=0; bin < hold->fNcells; ++bin) {; 5300 hold->GetBinXYZ(bin,binx,biny,binz);; 5301 Int_t ibin = GetBin(binx,biny,binz);; 5302 Double_t cu = hold->RetrieveBinContent(bin);; 5303 AddBinContent(ibin,cu);; 5304 if (errors) {; 5305 fSumw2.fArray[ibin] += hold->fSumw2.fArray[bin];; 5306 }; 5307 }; 5308 fEntries = oldEntries;; 5309 delete hold;; 5310}; 5311 ; 5312////////////////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:213486,error,errors,213486,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability," in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 3405 of file TUnixSystem.cxx. ◆ SetDisplay(). void TUnixSystem::SetDisplay ; (; ). overridevirtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented from TSystem.; Definition at line 663 of file TUnixSystem.cxx. ◆ SetDynamicPath(). void TUnixSystem::SetDynamicPath ; (; const char * ; path). overridevirtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented from TSystem.; Definition at line 4748 of file TUnixSystem.cxx. ◆ Setenv(). void TUnixSystem::Setenv ; (; const char * ; name, . const char * ; value . ). overridevirtual . Set environment variable. ; Reimplemented from TSystem.; Definition at line 2129 of file TUnixSystem.cxx. ◆ SetFPEMask(). Int_t TUnixSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). overridevirtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented from TSystem.; Definition at line 999 of file TUnixSystem.cxx. ◆ SetProgname(). void TUnixSystem::SetProgname ; (; const char * ; name). overridevirtual . Set the application name (from command line, argv[0]) and copy it in gProgName. ; Copy the application pathname in gProgPath. If name is 0 let the system set the actual executable name and path (works on MacOS X and Linux). ; Reimplemented from TSystem.; Definition at line 641 of file TUnixSystem.cxx. ◆ SetSockOpt(). int TUnixSystem::SetSockOpt ; (; int ; sock, . int ; option, . int ; val . ). overridevirtual . Set socket option. ; Reimplemented from TSystem.; Definition at line 3437 of file TUnixSystem.cxx. ◆ SigAlarmInterruptsSyscalls(). void TUnixSystem::SigAlarmInterruptsSyscalls ; (; Bool_t ; set). overridevirtual . When the argument is true the SIGALRM signal handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:67636,mask,mask,67636,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['mask'],['mask']
Availability," in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:49873,failure,failure,49873,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['failure'],['failure']
Availability," in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from externa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__BinData.html:6226,Error,ErrorType,6226,root/html532/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html,1,['Error'],['ErrorType']
Availability," in different source directory will over-write each other. . NoteThis build_dir can also be controlled via ACLiC.BuildDir in your .rootrc. ; Definition at line 4043 of file TSystem.cxx. ◆ SetDisplay(). void TSystem::SetDisplay ; (; ). virtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented in TUnixSystem.; Definition at line 235 of file TSystem.cxx. ◆ SetDynamicPath(). void TSystem::SetDynamicPath ; (; const char * ; pathname). virtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the system error string. ; This string will be used by GetError(). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno). ; Definition at line 245 of file TSystem.cxx. ◆ SetFlagsDebug(). void TSystem::SetFlagsDebug ; (; const char * ; flags). virtual . FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ; Definition at line 4056 of file TSystem.cxx. ◆ SetFlagsOpt(). void TSystem::SetFlagsOpt ; (; const char * ; flags). virtual . FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ; Definition at line 4065 of file TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:84720,error,error,84720,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['error'],['error']
Availability," in errors. int CovMatrixStatus() const; return status of covariance matrix; using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}; Minimizer who implements covariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string Variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:7422,error,error,7422,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,6,['error'],"['error', 'errors']"
Availability," in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:62203,error,error,62203,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,10,['error'],['error']
Availability," in given dataset; 1531/// projection of PDF is achieved by constructing an average over all observable values in given set.; 1532/// Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:64506,error,errors,64506,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability," in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) workers on success. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:68613,avail,available,68613,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['avail'],['available']
Availability," in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const Chebyshev &); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range. » Last changed: root/mathmore:$Id: Chebyshev.h 21503 2007-12-19 17:34:54Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Chebyshev.html:2910,error,error,2910,root/html526/ROOT__Math__Chebyshev.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Chebyshev.html,1,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& ); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()); }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Tue Jun 2 15:28:04 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooBinning.html:12244,error,error,12244,root/html604/RooBinning.html,https://root.cern,https://root.cern/root/html604/RooBinning.html,2,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& ); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()); }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Tue Jun 30 14:31:09 2015 » Last generated: 2015-06-30 14:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinning.html:12244,error,error,12244,root/html602/RooBinning.html,https://root.cern,https://root.cern/root/html602/RooBinning.html,2,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& ); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()); }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Tue Mar 10 17:14:38 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinning.html:11238,error,error,11238,root/html534/RooBinning.html,https://root.cern,https://root.cern/root/html534/RooBinning.html,2,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& b); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()) ; }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Mon Dec 7 13:46:07 2009 » Last generated: 2009-12-07 13:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinning.html:11075,error,error,11075,root/html526/RooBinning.html,https://root.cern,https://root.cern/root/html526/RooBinning.html,1,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& b); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()) ; }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Mon Jul 4 15:21:45 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBinning.html:11187,error,error,11187,root/html530/RooBinning.html,https://root.cern,https://root.cern/root/html530/RooBinning.html,1,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& b); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()) ; }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Sat Oct 9 06:58:06 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinning.html:11118,error,error,11118,root/html528/RooBinning.html,https://root.cern,https://root.cern/root/html528/RooBinning.html,1,['error'],['error']
Availability," in range [xlo,xhi]. Int_t binNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin with an upper boundary above the lower bound; of the range. Int_t rawBinNumber(Double_t x) const; Return sequential bin number that contains value x where bin; zero is the first bin that is defined, regardless if that bin; is outside the current defined range. Double_t nearestBoundary(Double_t x) const; Return the value of the nearest boundary to x. Double_t* array() const; Return array of boundary values. void setRange(Double_t xlo, Double_t xhi); Change the defined range associated with this binning.; Bins that lie outside the new range [xlo,xhi] will not be; removed, but will be 'inactive', i.e. the new 0 bin will; be the first bin with an upper boundarie > xlo. void updateBinCount(); Update the internal bin counter. Bool_t binEdges(Int_t bin, Double_t& xlo, Double_t& xhi) const; Return upper and lower bound of bin 'bin'. If the return value; is true an error occurred. Double_t binCenter(Int_t bin) const; Return the position of the center of bin 'bin'. Double_t binWidth(Int_t bin) const; Return the width of the requested bin. Double_t binLow(Int_t bin) const; Return the lower bound of the requested bin. Double_t binHigh(Int_t bin) const; Return the upper bound of the requested bin. void Streamer(TBuffer& b); Custom streamer that provides backward compatibility to read v1 data. RooAbsBinning* clone(const char* name = 0) const; { return new RooBinning(*this,name?name:GetName()) ; }. Int_t numBoundaries() const; Return the number boundaries. Double_t lowBound() const; Return the lower bound value. Double_t highBound() const; Return the upper bound value. Double_t averageBinWidth() const; Return the average bin width. » Last changed: Thu Nov 3 20:07:04 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinning.html:11187,error,error,11187,root/html532/RooBinning.html,https://root.cern,https://root.cern/root/html532/RooBinning.html,1,['error'],['error']
Availability," in root. ;  ; file  GammaFun.C;   Example showing the usage of the major special math functions (gamma, beta, erf) in ROOT To execute the macro type in: ;  ; file  goftest.C;   GoFTest tutorial macro ;  ; file  hlquantiles.C;  Demo for quantiles (with highlight mode) ;  ; file  kdTreeBinning.C;   kdTreeBinning tutorial: bin the data in cells of equal content using a kd-tree ;  ; file  Legendre.C;   Example of first few Legendre Polynomials ;  ; file  Legendre.py;   Example of first few Legendre Polynomials. ;  ; file  LegendreAssoc.C;   Example describing the usage of different kinds of Associate Legendre Polynomials To execute the macro type in: ;  ; file  limit.C;   This program demonstrates the computation of 95 % C.L. ;  ; file  mathBeta.C;   Test the TMath::BetaDist and TMath::BetaDistI functions ;  ; file  mathcoreCDF.C;   Example describing how to use the different cumulative distribution functions in ROOT. ;  ; file  mathcoreGenVector.C;   Example macro testing available methods and operation of the GenVector classes. ;  ; file  mathcoreSpecFunc.C;   Example macro describing how to use the special mathematical functions taking full advantage of the precision and speed of the C99 compliant environments. ;  ; file  mathcoreStatFunc.C;   Example macro showing some major probability density functions in ROOT. ;  ; file  mathcoreStatFunc.py;   Example macro showing some major probability density functions in ROOT. ;  ; file  mathcoreVectorCollection.C;   Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree. ;  ; file  mathcoreVectorFloatIO.C;   Macro illustrating I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CLING. ;  ; file  mathcoreVectorIO.C;   Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector. ;  ; file  mathGammaNormal.C;   Tutorial illustrating the use of TMath::GammaDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__math.html:2487,avail,available,2487,doc/master/group__tutorial__math.html,https://root.cern,https://root.cern/doc/master/group__tutorial__math.html,1,['avail'],['available']
Availability," in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value.; This method is mantained for backward compatibility and will be deprecated. std::vector<double> GetConfidenceIntervals(double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the data set used in the last fit; the confidence interval are returned as a vector of data points. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. bool ParameterBounds(unsigned int ipar, double& lower, double& upper) const; retrieve parameter bounds - return false if parameter is not bound. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(const shared_ptr<ROOT::Fit::FitResult::IModelFunction>& func); { fFitFunc = func; }. » Author: L. Moneta Wed Aug 30 11:05:34 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitResult.html:11499,error,errors,11499,root/html604/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitResult.html,2,['error'],['errors']
Availability," in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags; '--enable-fftw3',; '--wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:3674,down,download,3674,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,11,['down'],['download']
Availability," in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& b); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObject.html:16943,Error,Error,16943,root/html532/TObject.html,https://root.cern,https://root.cern/root/html532/TObject.html,1,['Error'],['Error']
Availability," in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  Return Indentation level for ls(). ;  ; static void SetMacroPath (const char *newpath);  Set or extend the macro search path. ;  ; static void ShutDown ();  Shut down ROOT. ;  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:30261,down,down,30261,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['down'],['down']
Availability," in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each to; 75 // simplify the code later. It's just a definition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:1965,error,error,1965,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['error'],['error']
Availability," in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:11879,down,download,11879,doc/master/TMVAClassificationApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html,1,['down'],['download']
Availability," in vectorDefinition Tools.cxx:765; TMVA::Tools::projNormTH1FTH1 * projNormTH1F(TTree *theTree, const TString &theVarName, const TString &name, Int_t nbins, Double_t xmin, Double_t xmax, const TString &cut)projects variable from tree into normalised histogramDefinition Tools.cxx:366; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::ReplaceRegularExpressionsTString ReplaceRegularExpressions(const TString &s, const TString &replace=""+"")replace regular expressions helper function to remove all occurrences ""$!%^&()'<>?...Definition Tools.cxx:798; TMVA::Tools::ReadTVectorDFromXMLvoid ReadTVectorDFromXML(void *node, const char *name, TVectorD *vec)Definition Tools.cxx:1267; TMVA::Tools::GetCumulativeDistTH1 * GetCumulativeDist(TH1 *h)get the cumulative distribution of a histogramDefinition Tools.cxx:1756; TMVA::Tools::ReadFloatArbitraryPrecisionvoid ReadFloatArbitraryPrecision(Float_t &val, std::istream &is)reads a float value with the available precision from a streamDefinition Tools.cxx:1073; TMVA::Tools::AddRawLineBool_t AddRawLine(void *node, const char *raw)XML helpers.Definition Tools.cxx:1190; TMVA::Tools::~Tools~Tools()destructorDefinition Tools.cxx:101; TMVA::Tools::ContainsRegularExpressionBool_t ContainsRegularExpression(const TString &s)check if regular expression helper function to search for ""$!%^&()'<>?= "" in a stringDefinition Tools.cxx:784; TMVA::Tools::UsefulSortDescendingvoid UsefulSortDescending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:564; TMVA::Tools::DestroyInstancestatic void DestroyInstance()Definition Tools.cxx:82; TMVA::Tools::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=0)Return the weighted mean of an array a with length n.Definition Tools.cxx:1687; TMVA::Tools::GetMutua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:75330,avail,available,75330,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['avail'],['available']
Availability," in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAddress().; 3173 TObjArray* branches = newtree->GetListOfBranches();; 3174 Int_t nb = branches->GetEntriesFast();; 3175 for (Int_t i = 0; i < nb; ++i) {; 3176 TBranch* br = (TBranch*) branches->UncheckedAt(i);; 3177 if (br->InheritsFrom(TBranchElement::Class())) {; 3178 ((TBranchElement*) br)->ResetDeleteObject();; 3179 }; 3180 }; 3181 ; 31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:126293,error,error,126293,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability," in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Double_t* amplitudeErrors, Double_t* amplitudeErrorsX1, Double_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Double_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Double_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Fit.html:71420,error,error,71420,root/html602/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Fit.html,8,['error'],['error']
Availability," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:128554,recover,recover,128554,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['recover'],['recover']
Availability," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:122953,recover,recover,122953,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['recover'],['recover']
Availability," inflate_buf_size *= 2;; 12664 new_mem =; 12665 (Bytef *)mg_realloc(inflated,; 12666 inflate_buf_size);; 12667 }; 12668 if (new_mem == NULL) {; 12669 mg_cry_internal(; 12670 conn,; 12671 ""Out of memory: Cannot allocate ""; 12672 ""inflate buffer of %lu bytes"",; 12673 (unsigned long)inflate_buf_size);; 12674 exit_by_callback = 1;; 12675 break;; 12676 }; 12677 inflated = new_mem;; 12678 conn->websocket_inflate_state.avail_out =; 12679 (uInt)(inflate_buf_size; 12680 - inflate_buf_size_old);; 12681 conn->websocket_inflate_state.next_out =; 12682 inflated + inflate_buf_size_old;; 12683 ret = inflate(&conn->websocket_inflate_state,; 12684 Z_SYNC_FLUSH);; 12685 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12686 || ret == Z_MEM_ERROR) {; 12687 mg_cry_internal(; 12688 conn,; 12689 ""ZLIB inflate error: %i %s"",; 12690 ret,; 12691 (conn->websocket_inflate_state.msg; 12692 ? conn->websocket_inflate_state.msg; 12693 : ""<no error message>""));; 12694 exit_by_callback = 1;; 12695 break;; 12696 }; 12697 inflate_buf_size_old = inflate_buf_size;; 12698 ; 12699 } while (conn->websocket_inflate_state.avail_out; 12700 == 0);; 12701 inflate_buf_size -=; 12702 conn->websocket_inflate_state.avail_out;; 12703 if (!ws_data_handler(conn,; 12704 mop,; 12705 (char *)inflated,; 12706 inflate_buf_size,; 12707 callback_data)) {; 12708 exit_by_callback = 1;; 12709 }; 12710 mg_free(inflated);; 12711 }; 12712 } else; 12713#endif; 12714 if (!ws_data_handler(conn,; 12715 mop,; 12716 (char *)data,; 12717 (size_t)data_len,; 12718 callback_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:368993,error,error,368993,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes"",; 12674 (unsigned long)inflate_buf_size);; 12675 exit_by_callback = 1;; 12676 break;; 12677 }; 12678 inflated = new_mem;; 12679 conn->websocket_inflate_state.avail_out =; 12680 (uInt)(inflate_buf_size; 12681 - inflate_buf_size_old);; 12682 conn->websocket_inflate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inflate_buf_size;; 12699 ; 12700 } while (conn->websocket_inflate_state.avail_out; 12701 == 0);; 12702 inflate_buf_size -=; 12703 conn->websocket_inflate_state.avail_out;; 12704 if (!ws_data_handler(conn,; 12705 mop,; 12706 (char *)inflated,; 12707 inflate_buf_size,; 12708 callback_data)) {; 12709 exit_by_callback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:369026,error,error,369026,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:76297,error,error,76297,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability," inherited from ROOT::Fit::FitResult; typedef ROOT::Math::IParamMultiFunction IModelFunction;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from ROOT::Fit::FitResult; std::shared_ptr< IModelFunction > ModelFunction ();  Return pointer non const pointer to model (fit) function with fitted parameter values. ;  ; void SetModelFunction (const std::shared_ptr< IModelFunction > &func);  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from ROOT::Fit::FitResult; std::map< unsigned int, unsigned int > fBoundParams;  list of limited parameters ;  ; double fChi2;  fit chi2 value (different than fval in case of chi2 fits) ;  ; std::vector< double > fCovMatrix;  covariance matrix (size is npar*(npar+1)/2) where npar is total parameters ;  ; int fCovStatus;  covariance matrix status code ;  ; double fEdm;  expected distance from minimum ;  ; std::vector< double > fErrors;  errors ;  ; std::shared_ptr< FitData > fFitData;  ! data set used in the fit ;  ; std::shared_ptr< IModelFunction > fFitFunc;  ! model function resulting from the fit. ;  ; std::map< unsigned int, bool > fFixedParams;  list of fixed parameters ;  ; std::vector< double > fGlobalCC;  global Correlation coefficient ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! minimizer object used for fitting ;  ; std::string fMinimType;  string indicating type of minimizer ;  ; std::map< unsigned int, std::pair< double, double > > fMinosErrors;  map contains the two Minos errors ;  ; unsigned int fNCalls;  number of function calls ;  ; unsigned int fNdf;  number of degree of freedom ;  ; unsigned int fNFree;  number of fit free parameters (total parameters are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitResult.html:20086,error,errors,20086,doc/master/classTFitResult.html,https://root.cern,https://root.cern/doc/master/classTFitResult.html,1,['error'],['errors']
Availability," initial s/b fraction in training data; Double_tfTreeEveFracfraction of events used for traing each tree; Bool_tfUseBoostuse boosted events for forest generation; Bool_tfUseRuleFitJFif true interface with J.Friedmans RuleFit module. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodRuleFit( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); RuleFit can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodRuleFit.html:21629,avail,available,21629,root/html602/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodRuleFit.html,4,['avail'],['available']
Availability," initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f]. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 moneta, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMinimizer1D.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLMinimizer1D.html:3536,toler,tolerance,3536,root/html528/ROOT__Math__GSLMinimizer1D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLMinimizer1D.html,3,"['error', 'toler']","['error', 'tolerance']"
Availability," initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f]. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 moneta, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMinimizer1D.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html:3538,toler,tolerance,3538,root/html530/ROOT__Math__GSLMinimizer1D.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html,3,"['error', 'toler']","['error', 'tolerance']"
Availability," initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f]. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 moneta, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMinimizer1D.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLMinimizer1D.html:3538,toler,tolerance,3538,root/html532/ROOT__Math__GSLMinimizer1D.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLMinimizer1D.html,6,"['error', 'toler']","['error', 'tolerance']"
Availability," initial values and limits are set.; “C”In case of linear fitting, don’t calculate the chisquare (saves time).; “F”If fitting a linear function (e.g. polN), switch to use the default minimizer (e.g. Minuit). By default, polN functions are fitted by the linear fitter. *goption:The third parameter is the graphics option that is the same as in the TH1::Draw (see the chapter Draw Options).; xxmin, xxmax:Thee fourth and fifth parameters specify the range over which to apply the fit. By default, the fitted function object is added to the histogram and is drawn in the current pad.; 5.1.2 The TGraph::Fit Method; The signature for fitting a TGraph is exactly the same as for the TH1. Only some options apply only for fitting histograms, these are the options “L”, “WL” and “I”. These options apply instead only for TGraph::Fit, the rest of options (appart from “L”, “WL” and “I” are the same). TGraph specific options. “EX0” When fitting a TGraphErrors or a TgraphAsymErrors the errors on the coordinates are not used in the fit; “ROB” in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points.; “ROB=0.x” as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. 5.2 The TF1 function class; Here we will show how to create the TF1 class that is used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:166904,error,errors,166904,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Robust', 'error']","['Robust', 'errors']"
Availability," inline . Definition at line 140 of file TSlave.h. ◆ GetUser(). const char * TSlave::GetUser ; (; ); const. inline . Definition at line 128 of file TSlave.h. ◆ GetWorkDir(). const char * TSlave::GetWorkDir ; (; ); const. inline . Definition at line 127 of file TSlave.h. ◆ Init() [1/2]. void TSlave::Init ; (; const char * ; host, . Int_t ; port, . Int_t ; stype . ). private . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Definition at line 87 of file TSlave.cxx. ◆ Init() [2/2]. void TSlave::Init ; (; TSocket * ; s, . Int_t ; stype . ). protected . Init a PROOF slave object using the connection opened via s. ; Used to avoid double opening when an attempt via TXSlave found a remote proofd. ; Definition at line 259 of file TSlave.cxx. ◆ Interrupt(). void TSlave::Interrupt ; (; Int_t ; type). protectedvirtual . Send interrupt OOB byte to master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 510 of file TSlave.cxx. ◆ IsA(). TClass * TSlave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 167 of file TSlave.h. ◆ IsSortable(). Bool_t TSlave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 122 of file TSlave.h. ◆ IsValid(). virtual Bool_t TSlave::IsValid ; (; ); const. inlinevirtual . Definition at line 150 of file TSlave.h. ◆ OldAuthSetup(). Int_t TSlave::OldAuthSetup ; (; Bool_t ; master, . TString ; wconf . ). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 403 of file TSlave.cxx. ◆ operator=(). void TSlave::operator= ; (; const TSlave & ; ). inlineprivate . Definition at line 72 of file TSlave.h. ◆ Ping(). Int_t TSlave::Ping ; (; ). protectedvirtual . Ping the remote master or slave servers. ; Returns 0 if ok, -1 in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:20110,error,error,20110,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['error'],['error']
Availability," inline . set minimizer type ; Definition at line 179 of file FitConfig.h. ◆ SetMinimizerOptions(). void ROOT::Fit::FitConfig::SetMinimizerOptions ; (; const ROOT::Math::MinimizerOptions & ; minopt). set all the minimizer options using class MinimizerOptions ; Definition at line 257 of file FitConfig.cxx. ◆ SetMinosErrors() [1/2]. void ROOT::Fit::FitConfig::SetMinosErrors ; (; bool ; on = true). inline . set Minos errors computation to be performed after fitting ; Definition at line 229 of file FitConfig.h. ◆ SetMinosErrors() [2/2]. void ROOT::Fit::FitConfig::SetMinosErrors ; (; const std::vector< unsigned int > & ; paramInd). inline . set parameter indices for running Minos this can be used for running Minos on a subset of parameters - otherwise is run on all of them if MinosErrors() is set ; Definition at line 237 of file FitConfig.h. ◆ SetNormErrors(). void ROOT::Fit::FitConfig::SetNormErrors ; (; bool ; on = true). inline . set the option to normalize the error on the result according to chi2/ndf ; Definition at line 223 of file FitConfig.h. ◆ SetParabErrors(). void ROOT::Fit::FitConfig::SetParabErrors ; (; bool ; on = true). inline . set parabolic errors ; Definition at line 226 of file FitConfig.h. ◆ SetParamsSettings() [1/2]. void ROOT::Fit::FitConfig::SetParamsSettings ; (; const std::vector< ROOT::Fit::ParameterSettings > & ; pars). inline . Definition at line 145 of file FitConfig.h. ◆ SetParamsSettings() [2/2]. void ROOT::Fit::FitConfig::SetParamsSettings ; (; unsigned int ; npar, . const double * ; params, . const double * ; vstep = nullptr . ). set the parameter settings from number of parameters and a vector of values and optionally step values. ; If there are not existing or number of parameters does not match existing one, create a new parameter setting list. ; Definition at line 135 of file FitConfig.cxx. ◆ SetUpdateAfterFit(). void ROOT::Fit::FitConfig::SetUpdateAfterFit ; (; bool ; on = true). inline . Update configuration after a fit using the Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html:10280,error,error,10280,doc/master/classROOT_1_1Fit_1_1FitConfig.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html,1,['error'],['error']
Availability," inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFile.; Definition at line 81 of file TNetFile.h. ◆ IsOpen(). Bool_t TNetFile::IsOpen ; (; ); const. overridevirtual . Retruns kTRUE if file is open, kFALSE otherwise. ; Reimplemented from TFile.; Definition at line 247 of file TNetFile.cxx. ◆ Matches(). Bool_t TNetFile::Matches ; (; const char * ; url). overridevirtual . Return kTRUE if 'url' matches the coordinates of this file. ; Check the full URL, including port and FQDN. ; Reimplemented from TFile.; Definition at line 761 of file TNetFile.cxx. ◆ operator=(). TNetFile & TNetFile::operator= ; (; const TNetFile & ; ). protected . ◆ Print(). void TNetFile::Print ; (; Option_t * ; option); const. overrideprotectedvirtual . Print some info about the net file. ; Reimplemented from TFile.; Definition at line 255 of file TNetFile.cxx. ◆ PrintError(). void TNetFile::PrintError ; (; const char * ; where, . Int_t ; err . ). protected . Print error string depending on error code. ; Definition at line 270 of file TNetFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TNetFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). overridevirtual . Read specified byte range from remote file via rootd daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 300 of file TNetFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TNetFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read specified byte range from remote file via rootd daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 373 of file TNetFile.cxx. ◆ ReadBuffers(). Bool_t TNetFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read a list of buffers given in pos[] and len[] and return it in a single buffer. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 384 of file TNetFile.cxx. ◆ Recv(). Int_t TNetFile::Recv ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:49080,error,error,49080,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,2,['error'],['error']
Availability," input socket; TStringfNameUnique name identifying this instance; Int_tfProtocolserver protocol version number; TObject*fReceivedObjectlast received object; TSeqCollection*fRootFileslist of (remote) root files; TSocket*fSocketsocket connection to server; TUrlfUrlserver's url; TRemoteObject*fWorkingDirworking (remote) directory; static Int_tfgPortAttemptsnumber of attempts to find a port; static Int_tfgPortLowerlower bound for ports; static Int_tfgPortUpperupper bound for ports. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationRemote(const char* url, Int_t debug = 0, const char* script = 0); Main constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:13874,error,error,13874,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,11,['error'],['error']
Availability," input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:9207,mask,mask,9207,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,3,['mask'],['mask']
Availability," input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*,allocator<const TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void Attach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__VariableTransformBase.html:9238,mask,mask,9238,root/html534/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html534/TMVA__VariableTransformBase.html,2,['mask'],['mask']
Availability," inputTensor = batch.GetInput();; 1548 auto outputMatrix = batch.GetOutput();; 1549 auto weights = batch.GetWeights();; 1550 // should we apply droput to the loss ??; 1551 valError += deepNet.Loss(inputTensor, outputMatrix, weights, inTraining, includeRegularization);; 1552 }; 1553 // normalize loss to number of batches and add regularization term; 1554 Double_t regTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1555 valError /= (Double_t)(nValidationSamples / settings.batchSize);; 1556 valError += regTerm;; 1557 ; 1558 //Log the loss value; 1559 fTrainHistory.AddValue(""valError"",nTrainEpochs,valError);; 1560 ; 1561 t2 = std::chrono::system_clock::now();; 1562 ; 1563 // checking for convergence; 1564 if (valError < minValError) {; 1565 convergenceCount = 0;; 1566 } else {; 1567 convergenceCount += settings.testInterval;; 1568 }; 1569 ; 1570 // copy configuration when reached a minimum error; 1571 if (valError < minValError ) {; 1572 // Copy weights from deepNet to fNet; 1573 Log() << std::setw(10) << nTrainEpochs; 1574 << "" Minimum Test error found - save the configuration "" << Endl;; 1575 for (size_t i = 0; i < deepNet.GetDepth(); ++i) {; 1576 fNet->GetLayerAt(i)->CopyParameters(*deepNet.GetLayerAt(i));; 1577 // if (i == 0 && deepNet.GetLayerAt(0)->GetWeights().size() > 1) {; 1578 // Architecture_t::PrintTensor(deepNet.GetLayerAt(0)->GetWeightsAt(0), "" input weights"");; 1579 // Architecture_t::PrintTensor(deepNet.GetLayerAt(0)->GetWeightsAt(1), "" state weights"");; 1580 // }; 1581 }; 1582 // Architecture_t::PrintTensor(deepNet.GetLayerAt(1)->GetWeightsAt(0), "" cudnn weights"");; 1583 // ArchitectureImpl_t::PrintTensor(fNet->GetLayerAt(1)->GetWeightsAt(0), "" cpu weights"");; 1584 ; 1585 minValError = valError;; 1586 }; 1587 else if ( minValError <= 0. ); 1588 minValError = valError;; 1589 ; 1590 if (!computeLossInTraining) {; 1591 trainingError = 0.0;; 1592 // Compute training error.; 1593 for (auto batch : trainingData) {; 1594 auto inputTensor =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:62242,error,error,62242,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['error'],['error']
Availability," instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:9369,down,down,9369,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['down'],['down']
Availability," instances of the corresponding MVA method are stored ; Definition at line 2020 of file MethodBase.cxx. ◆ NoErrorCalc(). void TMVA::MethodBase::NoErrorCalc ; (; Double_t *const ; err, . Double_t *const ; errUpper . ). protected . Definition at line 837 of file MethodBase.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodBase::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). virtual . call the Optimizer with the set of parameters and ranges that are meant to be tuned. ; Reimplemented in TMVA::MethodBDT, and TMVA::MethodSVM.; Definition at line 623 of file MethodBase.cxx. ◆ PrintHelpMessage(). void TMVA::MethodBase::PrintHelpMessage ; (; ); const. virtual . prints out method-specific help method ; Implements TMVA::IMethod.; Definition at line 3264 of file MethodBase.cxx. ◆ ProcessBaseOptions(). void TMVA::MethodBase::ProcessBaseOptions ; (; ). private . the option string is decoded, for available options see ""DeclareOptions"" ; Definition at line 540 of file MethodBase.cxx. ◆ ProcessOptions(). virtual void TMVA::MethodBase::ProcessOptions ; (; ). pure virtual . Implements TMVA::IMethod.; Implemented in TMVA::MethodPyAdaBoost, TMVA::MethodPyGTB, TMVA::MethodPyKeras, TMVA::MethodPyRandomForest, TMVA::MethodPyTorch, TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, TMVA::MethodRXGB, TMVA::MethodANNBase, TMVA::MethodBayesClassifier, TMVA::MethodBDT, TMVA::MethodBoost, TMVA::MethodCategory, TMVA::MethodCFMlpANN, TMVA::MethodCrossValidation, TMVA::MethodCuts, TMVA::MethodDL, TMVA::MethodDNN, TMVA::MethodDT, TMVA::MethodFDA, TMVA::MethodFisher, TMVA::MethodHMatrix, TMVA::MethodKNN, TMVA::MethodLD, TMVA::MethodLikelihood, TMVA::MethodMLP, TMVA::MethodPDEFoam, TMVA::MethodPDERS, TMVA::MethodRuleFit, TMVA::MethodSVM, TMVA::MethodTMlpANN, TMVA::PyMethodBase, TMVA::RMethodBase, and TMVA::MethodCompositeBase. ◆ ProcessSetup(). void TMVA::MethodBase::ProcessSetup ; (; ). process all options the ""CheckF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:64905,avail,available,64905,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['avail'],['available']
Availability," instead of using the function value evaluated at the bin center, when doing the fit and to use a range beween the ‘xmin’ and ‘xmax’ values.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:193848,error,errors,193848,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],['errors']
Availability," instead.; [legend]; Member Typedef Documentation. ◆ GSLFuncPointer. typedef double(* ROOT::Math::GSLRootFinder::GSLFuncPointer) (double, void *). Definition at line 94 of file GSLRootFinder.h. Constructor & Destructor Documentation. ◆ GSLRootFinder() [1/3]. ROOT::Math::GSLRootFinder::GSLRootFinder ; (; ). Definition at line 49 of file GSLRootFinder.cxx. ◆ ~GSLRootFinder(). ROOT::Math::GSLRootFinder::~GSLRootFinder ; (; ). override . Definition at line 59 of file GSLRootFinder.cxx. ◆ GSLRootFinder() [2/3]. ROOT::Math::GSLRootFinder::GSLRootFinder ; (; const GSLRootFinder & ; ). delete . ◆ GSLRootFinder() [3/3]. ROOT::Math::GSLRootFinder::GSLRootFinder ; (; GSLRootFinder && ; ). delete . Member Function Documentation. ◆ FreeSolver(). void ROOT::Math::GSLRootFinder::FreeSolver ; (; ). protected . Definition at line 101 of file GSLRootFinder.cxx. ◆ Iterate(). int ROOT::Math::GSLRootFinder::Iterate ; (; ). overridevirtual . This method is implemented only by the GSLRootFinder and GSLRootFinderDeriv classes and will return an error if it's not one of them. ; Reimplemented from ROOT::Math::IRootFinderMethod.; Definition at line 106 of file GSLRootFinder.cxx. ◆ Iterations(). int ROOT::Math::GSLRootFinder::Iterations ; (; ); const. inlineoverridevirtual . Return number of iterations. ; Reimplemented from ROOT::Math::IRootFinderMethod.; Definition at line 112 of file GSLRootFinder.h. ◆ Name(). const char * ROOT::Math::GSLRootFinder::Name ; (; ); const. overridevirtual . double GSLRootFinder::XLower() const { return fXlow; } ; double GSLRootFinder::XUpper() const { return fXup; } ; Implements ROOT::Math::IRootFinderMethod.; Definition at line 147 of file GSLRootFinder.cxx. ◆ operator=() [1/2]. GSLRootFinder & ROOT::Math::GSLRootFinder::operator= ; (; const GSLRootFinder & ; ). delete . ◆ operator=() [2/2]. GSLRootFinder & ROOT::Math::GSLRootFinder::operator= ; (; GSLRootFinder && ; ). delete . ◆ Root(). double ROOT::Math::GSLRootFinder::Root ; (; ); const. overridevirtual . R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRootFinder.html:4225,error,error,4225,doc/master/classROOT_1_1Math_1_1GSLRootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRootFinder.html,1,['error'],['error']
Availability," int > & ROOT::RGeomDescription::GetSelectedStack ; (; ); const. inline . Get top node path. ; Definition at line 364 of file RGeomData.hxx. ◆ GetTopVisible(). bool ROOT::RGeomDescription::GetTopVisible ; (; ); const. inline . Returns draw options, used for JSROOT TGeoPainter. ; Definition at line 334 of file RGeomData.hxx. ◆ GetUsedNSegments(). int RGeomDescription::GetUsedNSegments ; (; int ; min = 20). private . Returns really used number of cylindrical segments. ; Definition at line 922 of file RGeomData.cxx. ◆ GetVisLevel(). int ROOT::RGeomDescription::GetVisLevel ; (; ); const. inline . Returns maximal visible level. ; Definition at line 329 of file RGeomData.hxx. ◆ GetVolume(). TGeoVolume * RGeomDescription::GetVolume ; (; int ; nodeid). private . Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0. ; Definition at line 583 of file RGeomData.cxx. ◆ HasDrawData(). bool RGeomDescription::HasDrawData ; (; ); const. Check if there is draw data available. ; Definition at line 1331 of file RGeomData.cxx. ◆ IsBuild(). bool ROOT::RGeomDescription::IsBuild ; (; ); const. inline . Definition at line 373 of file RGeomData.hxx. ◆ IsBuildShapes(). int ROOT::RGeomDescription::IsBuildShapes ; (; ); const. inline . Returns true if binary 3D model build already by C++ server (default) ; Definition at line 339 of file RGeomData.hxx. ◆ IsPhysNodeVisible(). int RGeomDescription::IsPhysNodeVisible ; (; const std::vector< int > & ; stack). private . Check if there special settings for specified physical node returns -1 if nothing is found. ; Definition at line 2043 of file RGeomData.cxx. ◆ IsPreferredOffline(). bool ROOT::RGeomDescription::IsPreferredOffline ; (; ); const. inline . Is offline operations preferred. ; After get full description, client can do most operations without extra requests ; Definition at line 361 of file RGeomData.hxx. ◆ IsPrincipalEndNode(). bool RGeomDescription::IsPrincipalEndNode ; (; int ; nodeid). return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RGeomDescription.html:17794,avail,available,17794,doc/master/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RGeomDescription.html,1,['avail'],['available']
Availability," int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y ). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double *x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double *x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double *x, double val, const double * ex, double eval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:8959,error,errors,8959,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['error'],['errors']
Availability," int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructor. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:6723,error,errors,6723,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,2,['error'],['errors']
Availability," int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__BinData.html:6725,error,errors,6725,root/html532/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html,8,['error'],['errors']
Availability," int TGHtml::NameToType ; (; char * ; zType). protected . Convert a markup name into a type integer. ; Definition at line 1302 of file TGHtmlParse.cxx. ◆ NextMarkupType(). int TGHtml::NextMarkupType ; (; TGHtmlElement * ; p). protected . Return the next markup type [TGHtmlElement::NextMarkupType]. ; Definition at line 812 of file TGHtmlLayout.cxx. ◆ ParseText(). int TGHtml::ParseText ; (; char * ; text, . const char * ; index = nullptr . ). Appends (or insert at the specified position) the given HTML text to the end of any HTML text that may have been inserted by prior calls to this command. ; Then it runs the tokenizer, parser and layout engine as far as possible with the text that is available. The display is updated appropriately. ; Definition at line 325 of file TGHtml.cxx. ◆ PopStyleStack(). SHtmlStyle_t TGHtml::PopStyleStack ; (; int ; tag). protected . Pop a rendering style off of the stack. ; The top-most style on the stack should have a tag equal to ""tag"". If not, then we have an HTML coding error. Perhaps something like this: ""Some text <em>Enphasized</i> more text"". It is an interesting problem to figure out how to respond sanely to this kind of error. Our solution is to keep popping the stack until we find the correct tag, or until the stack is empty. ; Definition at line 87 of file TGHtmlSizer.cxx. ◆ PrintList(). void TGHtml::PrintList ; (; TGHtmlElement * ; first, . TGHtmlElement * ; last . ). Print a list of tokens. ; Definition at line 1509 of file TGHtmlParse.cxx. ◆ ProcessApplet(). virtual TGFrame * TGHtml::ProcessApplet ; (; TGHtmlInput * ; ). inlinevirtual . Definition at line 942 of file TGHtml.h. ◆ ProcessFrame(). virtual int TGHtml::ProcessFrame ; (; ). inlinevirtual . Definition at line 938 of file TGHtml.h. ◆ ProcessMessage(). Bool_t TGHtml::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; p1, . Longptr_t ; p2 . ). overridevirtual . Process messages (GUI events) in the html widget. ; Reimplemented from TGCompositeFrame.; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:80446,error,error,80446,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['error'],['error']
Availability," int j) const;  retrieve covariance matrix element ;  ; int CovMatrixStatus () const;  covariance matrix status code using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate ;  ; double Edm () const;  Expected distance from minimum. ;  ; double Error (unsigned int i) const;  parameter error by index ;  ; const std::vector< double > & Errors () const;  parameter errors (return st::vector) ;  ; void FillResult (const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0);  Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the configuration. ;  ; const BinData * FittedBinData () const;  return BinData used in the fit (return a nullptr in case a different fit is done or the data are not available Pointer is managed internally, it must not be deleted ;  ; const IModelFunction * FittedFunction () const;  fitting quantities ;  ; void GetConfidenceIntervals (const BinData &data, double *ci, double cl=0.95, bool norm=false) const;  evaluate confidence interval for the point specified in the passed data sets the confidence interval are returned in the array ci cl is the desired confidence interval value. ;  ; std::vector< double > GetConfidenceIntervals (double cl=0.95, bool norm=false) const;  evaluate confidence interval for the data set used in the last fit the confidence interval are returned as a vector of data points ;  ; void GetConfidenceIntervals (unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) const;  get confidence intervals for an array of n points x. ;  ; template<class Matrix > ; void GetCorrelationMatrix (Matrix &mat) const;  fill a correlation matrix elements using a generic symmetric matrix class implementing operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:2745,avail,available,2745,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,2,['avail'],['available']
Availability," int l, int m = 0); RooLegendre(const char* name, const char* title, RooAbsReal& ctheta, int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:23962,Error,ErrorLoggingMode,23962,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,2,['Error'],['ErrorLoggingMode']
Availability," intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLinearMinimizer.html:6517,error,error,6517,root/html534/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html,2,['error'],['error']
Availability," int_numBadNLL; int_printEvalErrors; bool_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMinimizerFcn(RooAbsReal* funct, RooMinimizer* context, bool verbose = false); Reset the *largest* negative log-likelihood value we have seen so far. RooMinimizerFcn(const RooMinimizerFcn& other). ~RooMinimizerFcn(). ROOT::Math::IBaseFunctionMultiDim* Clone() const. Bool_t Synchronize(vector<ROOT::Fit::ParameterSettings>& parameters, Bool_t optConst, Bool_t verbose). Double_t GetPdfParamVal(Int_t index); Access PDF parameter value by ordinal index (needed by MINUIT). Double_t GetPdfParamErr(Int_t index); Access PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t value); Modify PDF parameter error by ordinal index (needed by MINUIT). void ClearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void BackProp(const ROOT::Fit::FitResult& results); Transfer MINUIT fit results back into RooFit objects. Bool_t SetLogFile(const char* inLogfile); Change the file name for logging of a RooMinimizer of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. void ApplyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const; RooRealVar* par = (RooRealVar*)_floatParamList->at(index);. void updateFloatVec(). double DoEval(const double* x) const. unsigned int NDim() const; { return _nDim; }. RooArgList* GetFloatParamList(); { return _floatParamList; }. RooArgList* GetConstParamList(); { return _constParamList; }. RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizerFcn.html:3369,error,error,3369,root/html602/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html602/RooMinimizerFcn.html,4,['error'],['error']
Availability," integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). EvalErrorIter evalErrorIter(). Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kFALSE ; }. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; { return 0 ; }. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooAbsMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooAbsMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooAbsMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooAbsMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t setData(RooAbsData& , Bool_t = kTRUE); { return kTRUE ; }. void enableOffsetting(Bool_t ); {}. Bool_t isOffsettin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:83218,error,error,83218,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,6,['error'],['error']
Availability," integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction2Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 13:07:13 2015 » Last generated: 2015-06-02 13:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html:38450,ERROR,ERROR,38450,root/html602/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html,1,['ERROR'],['ERROR']
Availability," integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction2Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 15:28:25 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction2Binding_double_double_int_.html:38450,ERROR,ERROR,38450,root/html604/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html604/RooCFunction2Binding_double_double_int_.html,1,['ERROR'],['ERROR']
Availability," integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction2Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 13:07:15 2015 » Last generated: 2015-06-02 13:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html:38450,ERROR,ERROR,38450,root/html602/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html,1,['ERROR'],['ERROR']
Availability," integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction2Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 15:28:27 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction2Binding_double_int_double_.html:38450,ERROR,ERROR,38450,root/html604/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html604/RooCFunction2Binding_double_int_double_.html,1,['ERROR'],['ERROR']
Availability," internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualViewer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:11158,avail,available,11158,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,10,['avail'],['available']
Availability," interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html:11030,Error,Error,11030,root/html602/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html,1,['Error'],['Error']
Availability," interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:11051,Error,Error,11051,root/html534/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html,1,['Error'],['Error']
Availability," interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html:11022,Error,Error,11022,root/html604/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html,1,['Error'],['Error']
Availability," interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:11051,Error,Error,11051,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,1,['Error'],['Error']
Availability," intfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; float*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); float*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_float_.html:17933,failure,failure,17933,root/html528/TKDTree_int_float_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_float_.html,10,['failure'],['failure']
Availability," int ; option, . int * ; val . ). overridevirtual . Get socket option. ; Reimplemented from TSystem.; Definition at line 3507 of file TUnixSystem.cxx. ◆ GetSysInfo(). int TUnixSystem::GetSysInfo ; (; SysInfo_t * ; info); const. overridevirtual . Returns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t structure. ; Returns -1 in case of error, 0 otherwise. ; Reimplemented from TSystem.; Definition at line 5318 of file TUnixSystem.cxx. ◆ GetUid(). Int_t TUnixSystem::GetUid ; (; const char * ; user = nullptr). overridevirtual . Returns the user's id. If user = 0, returns current user's id. ; Reimplemented from TSystem.; Definition at line 2005 of file TUnixSystem.cxx. ◆ GetUserInfo() [1/2]. UserGroup_t * TUnixSystem::GetUserInfo ; (; const char * ; user = nullptr). overridevirtual . Returns all user info in the UserGroup_t structure. ; If user = 0, returns current user's id info. The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented from TSystem.; Definition at line 2087 of file TUnixSystem.cxx. ◆ GetUserInfo() [2/2]. UserGroup_t * TUnixSystem::GetUserInfo ; (; Int_t ; uid). overridevirtual . Returns all user info in the UserGroup_t structure. ; The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented from TSystem.; Definition at line 2054 of file TUnixSystem.cxx. ◆ GetWorkingDirectory(). std::string TUnixSystem::GetWorkingDirectory ; (; ); const. overridevirtual . Return working directory. ; Reimplemented from TSystem.; Definition at line 1463 of file TUnixSystem.cxx. ◆ HomeDirectory(). const char * TUnixSystem::HomeDirectory ; (; const char * ; userName = nullptr). overridevirtual . Return the user's home directory. ; Reimplemented from TSystem.; Definition at line 1483 of file TUnixSystem.cxx. ◆ HostName(). const char * TUnixSystem::HostName ; (; ). overridevirtual . Return the system's host name. ; Reimplemented from TSystem.; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:55975,error,error,55975,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability," int ; sock, . const void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 5010 of file TWinNTSystem.cxx. ◆ SetDynamicPath(). void TWinNTSystem::SetDynamicPath ; (; const char * ; path). overridevirtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented from TSystem.; Definition at line 4100 of file TWinNTSystem.cxx. ◆ Setenv(). void TWinNTSystem::Setenv ; (; const char * ; name, . const char * ; value . ). overridevirtual . Set environment variable. ; Reimplemented from TSystem.; Definition at line 3847 of file TWinNTSystem.cxx. ◆ SetFPEMask(). Int_t TWinNTSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). overridevirtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented from TSystem.; Definition at line 1591 of file TWinNTSystem.cxx. ◆ SetGUIThreadMsgHandler(). void TWinNTSystem::SetGUIThreadMsgHandler ; (; ThreadMsgFunc_t ; func). Set the (static part of) the event handler func for GUI messages. ; Definition at line 1314 of file TWinNTSystem.cxx. ◆ SetNonBlock(). int TWinNTSystem::SetNonBlock ; (; int ; fd). Make descriptor fd non-blocking. ; Definition at line 2921 of file TWinNTSystem.cxx. ◆ SetProgname(). void TWinNTSystem::SetProgname ; (; const char * ; name). overridevirtual . Set the application name (from command line, argv[0]) and copy it in gProgName. ; Copy the application pathname in gProgPath. ; Reimplemented from TSystem.; Definition at line 1192 of file TWinNTSystem.cxx. ◆ SetSockOpt(). int TWinNTSystem::SetSockOpt ; (; int ; sock, . int ; opt, . int ; val . ). overridevir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:70171,mask,mask,70171,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['mask'],['mask']
Availability," inverseCorr=false);  Return the sum of the weights of a multi-dimensional slice of the histogram by summing only over the dimensions specified in sumSet. ;  ; double sumEntries () const override;  Sum the weights of all bins. ;  ; double sumEntries (const char *cutSpec, const char *cutRange=nullptr) const override;  Return the sum of weights in all entries matching cutSpec (if specified) and in named range cutRange (if specified) Return the. ;  ; double const * sumW2Array () const;  ; double weight (const RooArgSet &bin, Int_t intOrder=1, bool correctForBinSize=false, bool cdfBoundaries=false, bool oneSafe=false);  Return the weight at given coordinates with optional interpolation. ;  ; double weight (std::size_t i) const;  Return weight of i-th bin. ;  ; double const * weightArray () const;  ; void weightError (double &lo, double &hi, ErrorType etype=Poisson) const override;  Return the asymmetric errors on the current weight. ;  ; double weightError (ErrorType etype=Poisson) const override;  Return the symmetric error on the current weight. ;  ; double weightFast (const RooArgSet &bin, int intOrder, bool correctForBinSize, bool cdfBoundaries);  A faster version of RooDataHist::weight that assumes the passed arguments are aligned with the histogram variables. ;  ; void weights (double *output, std::span< double const > xVals, int intOrder, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of RooDataHist::weight() for one dimensional histograms with up to one dimensional interpolation. ;  ; double weightSquared (std::size_t i) const;  Return squared weight sum of i-th bin. ;  ; double const * wgtErrHiArray () const;  ; double const * wgtErrLoArray () const;  ; Deprecated functions; These functions rely on the fact that an event has been loaded before they are called.; It is advised to switch to their counterparts that take bin numbers as arguments. In this way, code like, const RooArgSet* coordinates = dataHist.get(i); // Need this to achieve side e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:10627,error,error,10627,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['error'],['error']
Availability," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:23224,error,error,23224,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,10,['error'],['error']
Availability," is : "" << formula << std::endl;; 1615 } else {; 1616 Warning(""HandleFunctionArguments"", ""Unable to make replacement. Number of parameters doesn't work : ""; 1617 ""%d arguments, %d dimensions, %d parameters"",; 1618 nArguments, ndim, npar);; 1619 i = j;; 1620 }; 1621 ; 1622 } else {; 1623 i = j; // skip to end of candidate ""name""; 1624 }; 1625 }; 1626 }; 1627 ; 1628}; 1629 ; 1630////////////////////////////////////////////////////////////////////////////////; 1631/// Handling exponentiation; 1632/// Can handle multiple carets, eg.; 1633/// 2^3^4 will be treated like 2^(3^4); 1634 ; 1635void TFormula::HandleExponentiation(TString &formula); 1636{; 1637 Int_t caretPos = formula.Last('^');; 1638 while (caretPos != kNPOS && !IsAParameterName(formula, caretPos)) {; 1639 ; 1640 TString right, left;; 1641 Int_t temp = caretPos;; 1642 temp--;; 1643 // get the expression in ( ) which has the operator^ applied; 1644 if (formula[temp] == ')') {; 1645 Int_t depth = 1;; 1646 temp--;; 1647 while (depth != 0 && temp > 0) {; 1648 if (formula[temp] == ')'); 1649 depth++;; 1650 if (formula[temp] == '('); 1651 depth--;; 1652 temp--;; 1653 }; 1654 if (depth == 0); 1655 temp++;; 1656 }; 1657 // this in case of someting like sin(x+2)^2; 1658 do {; 1659 temp--; // go down one; 1660 // handle scientific notation cases (1.e-2 ^ 3 ); 1661 if (temp >= 2 && IsScientificNotation(formula, temp - 1)); 1662 temp -= 3;; 1663 } while (temp >= 0 && !IsOperator(formula[temp]) && !IsBracket(formula[temp]));; 1664 ; 1665 assert(temp + 1 >= 0);; 1666 Int_t leftPos = temp + 1;; 1667 left = formula(leftPos, caretPos - leftPos);; 1668 // std::cout << ""left to replace is "" << left << std::endl;; 1669 ; 1670 // look now at the expression after the ^ operator; 1671 temp = caretPos;; 1672 temp++;; 1673 if (temp >= formula.Length()) {; 1674 Error(""HandleExponentiation"", ""Invalid position of operator ^"");; 1675 return;; 1676 }; 1677 if (formula[temp] == '(') {; 1678 Int_t depth = 1;; 1679 temp++;; 1680 while (depth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:62781,down,down,62781,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['down'],['down']
Availability," is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:47622,error,error,47622,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,8,"['error', 'reliab']","['error', 'reliable']"
Availability," is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void CreateApplication ();  Static function used to create a default application environment. ;  ; static const char * DeclFileName ();  ; static Longptr_t ExecuteFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Execute a file containing a C++ macro (static method). ;  ; static TList * GetApplications ();  Static method returning the list of available applications. ;  ; static void NeedGraphicsLibs ();  Static method. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TQObject; static Bool_t AreAllSignalsBlocked ();  Returns true if all signals are blocked. ;  ; static Bool_t BlockAllSignals (Bool_t b);  Block or unblock all signals. Returns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:15788,avail,available,15788,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['avail'],['available']
Availability," is copied and the linked dataset must be remain live for the duration of this dataset. Note that link is active for both reading and writing, so modifications to the aggregate dataset will also modify its components. Link() and Import() are mutually exclusive. . OwnLinked() Take ownership of all linked datasets . Import(std::map<string,RooAbsData*>&) As above, but allows specification of many imports in a single operation . Link(std::map<string,RooDataSet*>&) As above, but allows specification of many links in a single operation . Cut(const char*) ; Cut(RooFormulaVar&) Apply the given cut specification when importing data . CutRange(const char*) Only accept events in the observable range with the given name . WeightVar(const char*) ; WeightVar(const RooAbsArg&) Interpret the given variable as event weight rather than as observable . StoreError(const RooArgSet&) Store symmetric error along with value for given subset of observables . StoreAsymError(const RooArgSet&) Store asymmetric error along with value for given subset of observables . GlobalObservables(const RooArgSet&) Define the set of global observables to be stored in this RooDataSet. A snapshot of the passed RooArgSet is stored, meaning the values wont't change unexpectedly. . Definition at line 277 of file RooDataSet.cxx. ◆ RooDataSet() [3/5]. RooDataSet::RooDataSet ; (; RooStringView ; name, . RooStringView ; title, . RooDataSet * ; dset, . const RooArgSet & ; vars, . const char * ; cuts = nullptr, . const char * ; wgtVarName = nullptr . ). Constructor of a data set from (part of) an existing data set. ; The dimensions of the data set are defined by the 'vars' RooArgSet, which can be identical to 'dset' dimensions, or a subset thereof. The 'cuts' string is an optional RooFormula expression and can be used to select the subset of the data points in 'dset' to be copied. The cut expression can refer to any variable in the source dataset. For cuts involving variables other than those contained in the source da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:39670,error,error,39670,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['error'],['error']
Availability," is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH2D using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option ""W"") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable (TProfile2D::fSumw2[bin] ) . Definition at line 1287 of file TProfile2D.cxx. ◆ PutStats(). void TProfile2D::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimplemented from TH2.; Definition at line 1474 of file TProfile2D.cxx. ◆ Rebin2D(). TProfile2D * TProfile2D::Rebin2D ; (; Int_t ; nxgroup = 2, . Int_t ; nygroup = 2, . const char * ; newname = """" . ). overridevirtual . Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together. ; if newname is not blank a new profile hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to be merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.; examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins hpxpy->Rebin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:97360,error,error,97360,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['error'],['error']
Availability," is drawn on the right side of the plot. . ""MIN0"" Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). . Options supported for 1D histograms. Option Description . "" "" Default. . ""AH"" Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis. . ""]["" When this option is selected the first and last vertical lines of the histogram are not drawn. . ""B"" Bar chart option. . ""BAR"" Like option ""B"", but bars can be drawn with a 3D effect. . ""HBAR"" Like option ""BAR"", but bars are drawn horizontally. . ""C"" Draw a smooth Curve through the histogram bins. . ""E0"" Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping . ""E1"" Draw error bars with perpendicular lines at the edges. . ""E2"" Draw error bars with rectangles. . ""E3"" Draw a fill area through the end points of the vertical error bars. . ""E4"" Draw a smoothed filled area through the end points of the error bars. . ""E5"" Like E3 but ignore the bins with 0 contents. . ""E6"" Like E4 but ignore the bins with 0 contents. . ""X0"" When used with one of the ""E"" option, it suppress the error bar along X as gStyle->SetErrorX(0) would do. . ""L"" Draw a line through the bin contents. . ""P"" Draw current marker at each bin except empty bins. . ""P*"" Draw a star marker at each bin except empty bins. . ""P0"" Draw current marker at each bin including empty bins. . ""PIE"" Draw histogram as a Pie Chart. . ""*H"" Draw histogram with a * at each bin. . ""LF2"" Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour. . Options supported for 2D histograms. Option Description . "" "" Default (color plot). . ""ARR"" Arrow mode. Shows gradient between adjacent cells. . ""BOX"" A box is drawn for each cell with surface proportional to the content's absolute value. A negative co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:7763,error,error,7763,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['error'],['error']
Availability," is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGClient.html:14314,error,error,14314,root/html528/TGClient.html,https://root.cern,https://root.cern/root/html528/TGClient.html,4,['error'],['error']
Availability," is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGClient.html:14676,error,error,14676,root/html534/TGClient.html,https://root.cern,https://root.cern/root/html534/TGClient.html,6,['error'],['error']
Availability," is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independently of the labels.; For adding histogram with labels one should use TH1::Merge. SPECIAL CASE (Average/Efficiency histograms); For histograms representing averages or efficiencies, one should compute the average; of the two histograms and not the sum. One can mark a histogram to be an average; histogram by setting its bit kIsAverage with; myhist.SetBit(TH1::kIsAverage);; Note that the two histograms must have their kIsAverage bit set. IMPORTANT NOTE1: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; is used , ie this = this + c1*factor*h1; Use the other TH1::Add function if you do not want this feature. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*-*Replace contents of this histogram by the addition of h1 and h2*-*-*. this = c1*h1 + c2*h2; if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independently of the labels.; For adding histogram ith labels one should use TH1::Merge. SPECIAL CASE (Average/Efficiency histograms); For histograms representing avera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:42652,error,errors,42652,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['error'],['errors']
Availability," is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independently of the labels.; For adding histogram with labels one should use TH1::Merge. SPECIAL CASE (Average/Efficiency histograms); For histograms representing averages or efficiencies, one should compute the average; of the two histograms and not the sum. One can mark a histogram to be an average; histogram by setting its bit kIsAverage with; myhist.SetBit(TH1::kIsAverage);; Note that the two histograms must have their kIsAverage bit set. IMPORTANT NOTE1: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; is used , ie this = this + c1*factor*h1; Use the other TH1::Add function if you do not want this feature. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. this = c1*h1 + c2*h2; if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independently of the labels.; For adding histogram ith labels one should use TH1::Merge. SPECIAL CASE (Average/Efficiency histograms); For histograms representing averages or effi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:43599,error,errors,43599,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability," is produced and returned, off by default; 4223/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4224///; 4225/// <tr><th><th> Options to control informational output; 4226/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4227/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4228/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4229/// messages are suppressed as well; 4230/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4231/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4232/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4233/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4234/// </table>; 4235 ; 4236RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4237 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4238 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4239{; 4240 RooLinkedList l ;; 4241 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4242 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4243 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4244 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4245 return chi2FitTo(xydata,l) ;; 4246}; 4247 ; 4248 ; 4249 ; 4250 ; 4251////////////////////////////////////////////////////////////////////////////////; 4252/// \copydoc RooAbsReal::chi2FitTo(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4253 ; 4254RooFit::OwningPtr<RooF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:186874,error,error,186874,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability," is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; TH1 *hist2_prob = mcs2->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist2_chi2->SetLineColor(kRed);; hist2_prob->SetLineColor(kRed);; ; TLegend leg;; leg.AddEntry(hist_chi2, ""Optimal fit"", ""L"");; leg.AddEntry(hist2_chi2, ""Biased fit"", ""L"");; leg.SetBorderSize(0);; leg.SetFillStyle(0);; ; TCanvas *c = new TCanvas(""rf802_mcstudy_addons"", ""rf802_mcstudy_addons"", 800, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; hist_chi2->GetYaxis()->SetTitleOffset(1.4);; hist_chi2->Draw();; hist2_chi2->Draw(""esame"");; leg.DrawClone();; c->cd(2);; gPad->SetLeftMargin(0.15);; hist_prob->GetYaxis()->SetTitleOffset(1.4);; hist_prob->Draw();; hist2_prob->Draw(""esame"");; c->cd(3);; pullMeanFrame->Draw();; ; ; // Make RooMCStudy object available on command line after; // macro finishes; gDirectory->Add(mcs);; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooChebychev.h; RooChi2MCSModule.h; RooDataSet.h; RooGaussian.h; RooMCStudy.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TH1.h; TLegend.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::createHistogramTH1 * createHistogram(const char *name, const RooAbsRealLValue &xvar, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCalls createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooLinkedList& argList) c...Definition RooAbsData.cxx:561; RooChi2MCSModuleRooChi2MCSModule is an add-on module to RooMCStudy that calculates the chi-squared of fitted p....Definition R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html:4313,avail,available,4313,doc/master/rf802__mcstudy__addons_8C.html,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html,1,['avail'],['available']
Availability," is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Picture; Source. {; TCanvas *c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; return c42;; }; The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Picture; Source. {; TCanvas *c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double y1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; TGraphErrors *graph1 = new TGraphErrors(5, x, y1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph1_sys = new TGraphErrors(5, x, y1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; TGraphErrors *graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph2_sys = new TGraphErrors(5, x, y2, zero, e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:9511,error,errors,9511,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,2,['error'],['errors']
Availability," is slower. Changing the fitting objective function. By default a chi square function is used for fitting. When option ""L"" (or ""LL"") is used; a Poisson likelihood function (see note below) is used.; The functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; the file math/mathcore/src/FitUtil.cxx.; To specify a User defined fitting function, specify option ""U"" and; call the following functions:; TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Likelihood Fits. When using option ""L"" a likelihood fit is used instead of the default chi2 square fit.; The likelihood is built assuming a Poisson probability density function for each bin.; This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).; The likelihood method has the advantage of treating correctly the empty bins and use them in the; fit procedure.; In the chi2 method the empty bins are skipped and not considered in the fit.; The likelihood method, although a bit slower, it is the recommended method in case of low; bin statistics, where the chi2 method may give incorrect results. Fitting a histogram of dimension N with a function of dimension N-1. It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; In this case the option ""Integral"" is not allowed and each cell has; equal weight. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:75794,error,errors,75794,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['error'],['errors']
Availability," is specified, ""A"" is; ignored.; ""F"" show all details available about queries; ""H"" print help menu; Default """". Bool_t IsDataReady(Long64_t& totalbytes, Long64_t& bytesready); See if the data is ready to be analyzed. void Interrupt(TProof::EUrgent type, TProof::ESlaves list = kActive); Send interrupt to master or slave servers. Int_t GetParallel() const; Returns number of slaves active in parallel mode. Returns 0 in case; there are no active slaves. Returns -1 in case of error. TList * GetListOfSlaveInfos(); Returns list of TSlaveInfo's. In case of error return 0. void Activate(TList* slaves = 0); Activate slave server list. void SetMonitor(TMonitor* mon = 0, Bool_t on = kTRUE); Activate (on == TRUE) or deactivate (on == FALSE) all sockets; monitored by 'mon'. Int_t BroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. Int_t BroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. void ResetMergePrg(); Reset the merge progress notificator. Int_t Broadcast(const TMessage& mess, TList* slaves); Broadcast a message to all slaves in the specified list. Returns; the number of slaves the message was successfully sent to.; Returns -1 in case of error. Int_t Broadcast(const TMessage& mess, TProof::ESlaves list = kActive); Broadcast a message to all slaves in the specified list (either; all slaves or only the active slaves). Returns the number of slaves; the message was successfully sent to. Returns -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind, TList* slaves); Broadcast a character string buffer to all slaves in the specified; list. Use kind to set the TMessage what field. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:38565,error,error,38565,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['error'],['error']
Availability," is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. Bool_t Multiply(const TH1* h1); Multiply this profile2D by h1*-; *-* =============================. this = this*h1. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile2D by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH3D * ProjectionXYZ(const char* name = ""_pxyz"", Option_t* option = ""e"") const; Project this profile3D into a 3-D histogram along X,Y,Z*-*-; *-* =====================================================. The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:39488,error,errors,39488,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,6,['error'],['errors']
Availability," is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented from TH1.; Definition at line 73 of file TProfile2D.h. ◆ SetBins() [6/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). inlineoverrideprivatevirtual . Redefine x axis parameters. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 67 of file TProfile2D.h. ◆ SetBins() [7/7]. void TProfile2D::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax, . Int_t ; nz, . Double_t ; zmin, . Double_t ; zmax . ). inlineoverrideprivatevirtual . Redefine x, y and z axis parameters. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 71 of file TProfile2D.h. ◆ SetBinsLength(). void TProfile2D::SetBinsLength ; (; Int_t ; n = -1). overridevirtual . Set total number of bins including under/overflow. ; Reallocate bin contents array ; Reimplemented from TH2D.; Definition at line 1947 of file TProfile2D.cxx. ◆ SetBuffer(). void TProfile2D::SetBuffer ; (; Int_t ; buffersize, . Option_t * ; option = """" . ). overridevirtual . Set the buffer size in units of 8 bytes (double). ; Reimplemented from TH1.; Definition at line 1956 of file TProfile2D.cxx. ◆ SetErrorOption(). void TProfile2D::SetErrorOption ; (; Option_t * ; option = """"). virtual . Set option to compute profile2D errors. ; The computation of the bin errors is based on the parameter option:; ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z), i.e. the standard error of the bin contents. Note that if TProfile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:104048,error,errors,104048,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,2,['error'],['errors']
Availability, is taken in the RooMinuit constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. s - Run Hesse first to estimate initial step size; m - Run Migrad only; h - Run Hesse to estimate errors; v - Verbose mode; l - Log parameters after each Minuit steps to file; t - Activate profile timer; r - Save fit result; 0 - Run Migrad with strategy 0. Int_t migrad(); Execute MIGRAD. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t hesse(); Execute HESSE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(); Execute MINOS. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:10134,error,errors,10134,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,5,['error'],['errors']
Availability," is the file is equal or different. Returns 0 in case of success and -1 in case of error. ; Definition at line 8334 of file TProof.cxx. ◆ DrawSelect() [1/2]. Long64_t TProof::DrawSelect ; (; const char * ; dsetname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0, . TObject * ; enl = 0 . ). Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ; The syntax for dsetname is name[#[dir/]objname], e.g. ""mydset"" analysis of the first tree in the top dir of the dataset named ""mydset"" ""mydset#T"" analysis tree ""T"" in the top dir of the dataset named ""mydset"" ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset named ""mydset"" ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the dataset named ""mydset"" The last argument 'enl' specifies an entry- or event-list to be used as event selection. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Definition at line 6182 of file TProof.cxx. ◆ DrawSelect() [2/2]. Long64_t TProof::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). virtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data set object using TDSet::SetEntryList. Returns -1 in case of error or number of selected events otherwise. ; Reimplemented in TProofLite.; Definition at line 6146 of file TProof.cxx. ◆ Echo() [1/2]. Int_t TProof::Echo ; (; const char * ; str). virtual . Sends a string to master and workers and expect them to echo it back to the client via a message. ; It is a special case of the generic Echo() that works with TObjects. Returns -1 on error, the number of workers that received the message on success. ; Definition at line 7042 of file TProof.cxx. ◆ Echo() [2/2]. Int_t TPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:84452,error,error,84452,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability," is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Histogram chapter.; 13.11 ROOT Finder Algorithms; The function must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. Some of the algorithm requires the derivatives of the function. In that c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:716892,avail,available,716892,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability," is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:17549,error,errors,17549,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,4,['error'],['errors']
Availability," is used if none is provided.; 1163 ///; 1164 /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; 1165 /// is avoided.; 1166 ///; 1167 /// \sa This Vary() overload for more information.; 1168 RInterface<Proxied, DS_t> Vary(std::initializer_list<std::string> colNames, std::string_view expression,; 1169 std::size_t nVariations, std::string_view variationName); 1170 {; 1171 return Vary(std::vector<std::string>(colNames), expression, nVariations, variationName);; 1172 }; 1173 ; 1174 /// \brief Register systematic variations for multiple existing columns using custom variation tags.; 1175 /// \param[in] colNames set of names of the columns for which varied values are provided.; 1176 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; 1177 /// values for the specified columns.; 1178 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1179 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1180 ///; 1181 /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; 1182 /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; 1183 /// `{""down"", ""up""}`.; 1184 /// ~~~{.cpp}; 1185 /// auto nominal_hx =; 1186 /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); 1187 /// .Histo1D(""x"", ""y"");; 1188 ///; 1189 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1190 /// hx[""nominal""].Draw();; 1191 /// hx[""xy:down""].Draw(""SAME"");; 1192 /// hx[""xy:up""].Draw(""SAME"");; 1193 /// ~~~; 1194 ///; 1195 /// \sa This Vary() overload for more information.; 1196 RInterface<Proxied, DS_t> Vary(const std::vector<std::string> &colNames, std::string_view expression,; 1197 const std::vector<std::string> &va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:64590,down,down,64590,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability," it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:20113,Error,Error,20113,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['Error'],['Error']
Availability," it. ;  ; void Build ();  Build the kd-tree. ;  ; Double_t Distance (const Value *point, Index ind, Int_t type=2) const;  Find the distance between point of the first argument and the point at index value ind Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. ;  ; void DistanceToNode (const Value *point, Index inode, Value &min, Value &max, Int_t type=2);  Find the minimal and maximal distance from a given point to a given node. ;  ; void FindBNodeA (Value *point, Value *delta, Int_t &inode);  find the smallest node covering the full range - start ;  ; void FindInRange (Value *point, Value range, std::vector< Index > &res);  Find all points in the sphere of a given radius ""range"" around the given point 1st argument - the point 2nd argument - radius of the shere 3rd argument - a vector, in which the results will be returned. ;  ; void FindNearestNeighbors (const Value *point, Int_t k, Index *ind, Value *dist);  Find kNN nearest neighbors to the point in the first argument Returns 1 on success, 0 on failure Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. ;  ; Index FindNode (const Value *point) const;  returns the index of the terminal node to which point belongs (index in the fAxis, fValue, etc arrays) returns -1 in case of failure ;  ; void FindPoint (Value *point, Index &index, Int_t &iter);  find the index of point works only if we keep fData pointers ;  ; Value * GetBoundaries ();  Get the boundaries. ;  ; Value * GetBoundariesExact ();  Get the boundaries. ;  ; Value * GetBoundary (const Int_t node);  Get a boundary. ;  ; Value * GetBoundaryExact (const Int_t node);  Get a boundary. ;  ; Index GetBucketSize ();  ; Int_t GetCrossNode ();  smallest terminal row ;  ; Index * GetIndPoints ();  offset in fIndPoints ;  ; Int_t GetLeft (Int_t inode) const;  ; Index GetNDim ();  ; Int_t GetNNodes () const;  ; UChar_t GetNodeAxis (Int_t id) const;  ; void GetNodePointsIndexes (Int_t node, Int_t &firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:13691,failure,failure,13691,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['failure'],['failure']
Availability," it. void MarkBad(TSocket* s, const char* reason = 0); Add slave with socket s to the bad slave list and remove if from; the active list and from the two monitor objects. void TerminateWorker(TSlave* wrk); Ask an active worker 'wrk' to terminate, i.e. to shutdown. void TerminateWorker(const char* ord); Ask an active worker 'ord' to terminate, i.e. to shutdown. Int_t Ping(); Ping PROOF. Returns 1 if master server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C) file.; The default tree is analyzed (i.e. the first one found). To specify another; tree, the default tree can be changed using TFileCollection::SetDefaultMetaData .; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* dsetname, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Process a dataset which is stored on the master with name 'dsetname'.; The syntax for dsetname is name[#[dir/]objname], e.g.; ""mydset"" analysis of the first tree in the top dir of the dataset; named ""mydset""; ""mydset#T"" analysis tree ""T"" in the top dir of the dataset; named ""mydset""; ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:45492,error,error,45492,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability," its limits, then the existence of limits has probably not prevented MINUIT from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimizer has become `‘blocked’' at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{\pi}{2}\) that MINUIT prints a warning to this effect when it prints the parameter values.; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is. \[; \frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; \]. Getting the right parameter errors with limits.; In the best case, where the minimum is far from any limits, MINUIT will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn't need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. Interpretation of Parameter Errors:; There are two kinds of problems that can arise: the reliability of MINUIT's error estimates, and their statistical interpretation, assuming they are accurate. Statistical interpretation:; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see:. F.Jame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:6490,error,errors,6490,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['errors']
Availability," its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:19423,error,errors,19423,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,4,['error'],['errors']
Availability," its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TTabCom.h 30215 2009-09-17 10:25:41Z rdm $ » Last generated: 2010-09-27 12:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:12164,error,error,12164,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,2,['error'],['error']
Availability," i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. The class stores coef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__VavilovFast.html:1506,Avail,Available,1506,root/html532/ROOT__Math__VavilovFast.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__VavilovFast.html,4,['Avail'],['Available']
Availability," kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQtClientWidget.html:2578,mask,mask,2578,root/html534/TQtClientWidget.html,https://root.cern,https://root.cern/root/html534/TQtClientWidget.html,8,['mask'],['mask']
Availability," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:7777,error,error,7777,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,6,['error'],['error']
Availability," kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGCheckButton*fAutoLighting; Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TEveGValuator*fExtrude; TGFrameElement*TGFrame::fFEpointer to frame element; TGComboBox*fFile; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGCheckButton*fLighting; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveText*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGComboBox*fMode; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTextEditor.html:17446,mask,mask,17446,root/html528/TEveTextEditor.html,https://root.cern,https://root.cern/root/html528/TEveTextEditor.html,6,['mask'],['mask']
Availability," kFALSE in case file is already on remote node. . Definition at line 674 of file TApplicationRemote.cxx. ◆ Class(). static TClass * TApplicationRemote::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationRemote::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationRemote::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 117 of file TApplicationRemote.h. ◆ Collect(). Int_t TApplicationRemote::Collect ; (; Long_t ; timeout = -1). private . Collect responses from the remote server. ; Returns the number of messages received. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). ; Definition at line 326 of file TApplicationRemote.cxx. ◆ CollectInput(). Int_t TApplicationRemote::CollectInput ; (; ). private . Collect and analyze available input from the socket. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 394 of file TApplicationRemote.cxx. ◆ DeclFileName(). static const char * TApplicationRemote::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 117 of file TApplicationRemote.h. ◆ Interrupt(). void TApplicationRemote::Interrupt ; (; Int_t ; type = kRRI_Hard). Send interrupt OOB byte to server. ; Returns 0 if ok, -1 in case of error ; Definition at line 937 of file TApplicationRemote.cxx. ◆ IsA(). TClass * TApplicationRemote::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TApplication.; Definition at line 117 of file TApplicationRemote.h. ◆ IsFolder(). Bool_t TApplicationRemote::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 100 of file TApplicationRemote.h. ◆ IsValid(). B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:27514,failure,failure,27514,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['failure'],['failure']
Availability," kFALSE); RooArgProxy(const char* name, const char* desc, RooAbsArg* owner, RooAbsArg& arg, Bool_t valueServer, Bool_t shapeServer, Bool_t proxyOwnsArg = kFALSE); virtual~RooArgProxy(); RooAbsArg*absArg() const; voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgProxy.html:2097,Error,Error,2097,root/html534/RooArgProxy.html,https://root.cern,https://root.cern/root/html534/RooArgProxy.html,1,['Error'],['Error']
Availability," kFALSE, . Int_t * ; error = nullptr . ). overridevirtual . Parse a single command line and forward the request to the remote server where it will be processed. ; The line is either a C++ statement or an interpreter command starting with a ""."". Return the return value of the command casted to a long. ; Reimplemented from TApplication.; Definition at line 886 of file TApplicationRemote.cxx. ◆ RecvLogFile(). void TApplicationRemote::RecvLogFile ; (; Int_t ; size). private . Receive the log file from the server. ; Definition at line 602 of file TApplicationRemote.cxx. ◆ SendFile(). Int_t TApplicationRemote::SendFile ; (; const char * ; file, . Int_t ; opt = kAscii, . const char * ; rfile = nullptr . ). Send a file to the server. ; Return 0 on success, -1 in case of error. If defined, the full path of the remote path will be rfile. The mask 'opt' is an or of ESendFileOpt: kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). Definition at line 762 of file TApplicationRemote.cxx. ◆ SendObject(). Int_t TApplicationRemote::SendObject ; (; const TObject * ; obj). Send object to server. ; Return 0 on success, -1 in case of error. ; Definition at line 652 of file TApplicationRemote.cxx. ◆ SetPortParam(). void TApplicationRemote::SetPortParam ; (; Int_t ; lower = -1, . Int_t ; upper = -1, . Int_t ; attempts = -1 . ). static . Set port parameters for tunnelling. A value of -1 means unchanged. ; Definition at line 867 of file TApplicationRemote.cxx. ◆ Streamer(). void TApplicationRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication. ◆ StreamerNVirtual(). void TApplicationRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 117 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:29778,mask,mask,29778,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,2,"['down', 'mask']","['downloaded', 'mask']"
Availability," kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual void AddBinContent (Int_t bin);  Increment bin content by 1. ;  ; virtual void AddBinContent (Int_t bin, Double_t w);  Increment bin content by a weight w. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:24902,error,errors,24902,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability," kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TRatioPlot.h>. Inheritance diagram for TRatioPlot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ CalculationMode. enum TRatioPlot::CalculationMode. private . EnumeratorkDivideHist Use TH1::Divide to create the ratio. . kDivideGraph Use TGraphAsymmErrors::Divide to create the ratio. . kDifference Calculate the difference between the histograms. . kFitResidual Calculate the fit residual between the histogram and a fit stored within it. . kDifferenceSign Calculate the difference divided by the error. . Definition at line 49 of file TRatioPlot.h. ◆ ErrorMode. enum TRatioPlot::ErrorMode. private . EnumeratorkErrorSymmetric Use the regular TH1::GetBinError as the error. . kErrorAsymmetric Use TH1::GetBinErrorUp and TH1::GetBinErrorLow for the error, depending on y values. . kErrorFunc Use the square root of the function value as the error. . Definition at line 57 of file TRatioPlot.h. ◆ HideLabelMode. enum TRatioPlot::HideLabelMode. private . EnumeratorkHideUp Hide the first label of the upper y axis when there is low space. . kHideLow Hide the last label of the lower y axis when there is low space. . kNoHide Do not hide labels when there is low space. . kForceHideUp Always hide the first label of the upper y axis. . kForceHideLow Always hide the last label of the lower y axis. . Definition at line 63 of file TRatioPlot.h. Constructor & Destructor Documentation. ◆ TRatioPlot() [1/6]. TRatioPlot::TRatioPlot ; (; const TRatioPlot & ; ). privatedelete . ◆ TRatioPlot() [2/6]. TRatioPlot::TRatioPlot ; (; ). TRatioPlot default constructor. ; Definition at line 104 of file TRatioPlot.cxx. ◆ ~TRatioPlot(). TRatioPlot::~TRa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:26730,error,error,26730,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['error'],['error']
Availability," kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:31059,error,error,31059,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['error'],['error']
Availability," kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TDirectory*TGraph2D::fDirectory!Pointer to directory holding this 2D graph; Double_t*fEX[fNpoints] array of X errors; Double_t*fEY[fNpoints] array of Y errors; Double_t*fEZ[fNpoints] array of Z errors; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*TGraph2D::fFunctionsPointer to list of functions (fits and user); TH2D*TGraph2D::fHistogram!2D histogram of z values linearly interpolated; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Double_tTGraph2D::fMarginExtra space (in %) around interpolated area for fHistogram; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTGraph2D::fMaxIterMaximum number of iterations to find Delaunay t>; Double_tTGraph2D::fMaximumMaximum value for plotting along z; Double_tTGraph2D::fMinimumMinimum value for plotting along z; TStringTNamed::fNameobject identifier; Int_tTGraph2D::fNpointsNumber of points in the data set; Int_tTGraph2D::fNpxNumber of bins along X in fHistogram; Int_tTGraph2D::fNpyNumber of bins along Y in fHistogram; TVirtualHistPainter*TGraph2D::fPainter!pointer to histogram painter; Int_tTGraph2D::fSize!Real size of fX, fY and fZ; TStringTNamed::fTitleobject title; Double_t*TGraph2D::fX[fNpoints]; Double_t*TGraph2D::fY[fNpoints] Data set to be plotted; Double_t*TGraph2D::fZ[fNpoints]; Double_tTGraph2D::fZoutfHistogram bin height for points lying outside the interpolated area. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2DErrors(); TGraph2DErrors default constructor. TGraph2DErrors(Int_t n); TGraph2DErrors normal constructor; the arrays are pres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraph2DErrors.html:10833,error,errors,10833,root/html530/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html530/TGraph2DErrors.html,9,['error'],['errors']
Availability," kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TDirectory*TGraph2D::fDirectory!Pointer to directory holding this 2D graph; Double_t*fEX[fNpoints] array of X errors; Double_t*fEY[fNpoints] array of Y errors; Double_t*fEZ[fNpoints] array of Z errors; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*TGraph2D::fFunctionsPointer to list of functions (fits and user); TH2D*TGraph2D::fHistogram!2D histogram of z values linearly interpolated; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Double_tTGraph2D::fMarginExtra space (in %) around interpolated area for fHistogram; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTGraph2D::fMaxIterMaximum number of iterations to find Delaunay t>; Double_tTGraph2D::fMaximumMaximum value for plotting along z; Double_tTGraph2D::fMinimumMinimum value for plotting along z; TStringTNamed::fNameobject identifier; Int_tTGraph2D::fNpointsNumber of points in the data set; Int_tTGraph2D::fNpxNumber of bins along X in fHistogram; Int_tTGraph2D::fNpyNumber of bins along Y in fHistogram; TVirtualHistPainter*TGraph2D::fPainter!pointer to histogram painter; Int_tTGraph2D::fSize!Real size of fX, fY and fZ; TStringTNamed::fTitleobject title; Double_t*TGraph2D::fX[fNpoints]; Double_t*TGraph2D::fY[fNpoints] Data set to be plotted; Double_t*TGraph2D::fZ[fNpoints]; Double_tTGraph2D::fZoutfHistogram bin height for points lying outside the interpolated area. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2DErrors(const TGraph2DErrors& ). TGraph2DErrors& operator=(const TGraph2DErrors& ). TGraph2DErrors(). TGraph2DErrors(Int_t n).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph2DErrors.html:9545,error,errors,9545,root/html528/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html528/TGraph2DErrors.html,3,['error'],['errors']
Availability," kOpaqueDefinition TVirtualX.h:51; TVirtualX::kClear@ kClearDefinition TVirtualX.h:51; TVirtualX::fDrawModeEDrawMode fDrawModeDefinition TVirtualX.h:55; TVirtualX::EBoxModeEBoxModeDefinition TVirtualX.h:50; TVirtualX::kFilled@ kFilledDefinition TVirtualX.h:50; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; TVirtualX::ETextSetModeETextSetModeDefinition TVirtualX.h:52; TVirtualX::kLoad@ kLoadDefinition TVirtualX.h:52; Visual; XColor; XGCValues; XImage; XSetWindowAttributes; XVisualInfo; bool; int; unsigned int; ptTPaveText * ptDefinition entrylist_figure1.C:7; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; G#define G(x, y, z); TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; RVisualDefinition GX11Gui.cxx:141; RXColorDefinition GX11Gui.cxx:138; RXGCValuesDefinition GX11Gui.cxx:137; RXImageDefinition TGX11.cxx:163; RXPointDefinition TGX11.cxx:164; RXVisualInfoDefinition TGX11.cxx:165; XColor_tDescription of a X11 color.Definition TGWin32.h:56; XColor_t::fDefinedBool_t fDefinedtrue if pixel value is definedDefinition TGWin32.h:58; XColor_t::fBlueUShort_t fBlueblue valueDefinition TGX11.h:72; XColor_t::fRedUShort_t fRedred value in range [0,kBIGGEST_RGB_VALUE]Definition TGX11.h:70; XColor_t::fGreenUShort_t fGreengreen value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:161037,down,downward,161037,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['down'],['downward']
Availability," kReleaseCache); TPBHandleDSType(const TPBHandleDSType&); virtual~TPBHandleDSType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TPBHandleDSType::EHandleDSTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPBHandleDSType.html:1447,error,error,1447,root/html530/TPBHandleDSType.html,https://root.cern,https://root.cern/root/html530/TPBHandleDSType.html,5,['error'],['error']
Availability," kSingleKey, kOverwrite or kWriteDelete; Using the kOverwrite option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the kWriteDelete option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The kSingleKey option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TObject.html:16542,Error,ErrorHandler,16542,root/html534/TObject.html,https://root.cern,https://root.cern/root/html534/TObject.html,3,['Error'],['ErrorHandler']
Availability," kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const RooChi2Var& other, const char* name = 0); Copy constructor. ~RooChi2Var(); Destructor. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. TObject* clone(const char* newname) const; { return new RooChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. » Last changed: Thu Sep 23 19:59:16 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:42148,error,error,42148,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,2,['error'],['error']
Availability," kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TProofServLite.h 33637 2010-05-28 13:13:05Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServLite.html:17286,error,error,17286,root/html530/TProofServLite.html,https://root.cern,https://root.cern/root/html530/TProofServLite.html,5,"['alive', 'error']","['alive', 'error']"
Availability," kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TProofServLite.h 33637 2010-05-28 13:13:05Z rdm $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServLite.html:17286,error,error,17286,root/html532/TProofServLite.html,https://root.cern,https://root.cern/root/html532/TProofServLite.html,10,"['alive', 'error']","['alive', 'error']"
Availability," key and value objects are deleted if map is the owner of keys and values respectively. ; Definition at line 190 of file TMap.cxx. ◆ DeleteKeys(). void TMap::DeleteKeys ; (; ). inline . Definition at line 68 of file TMap.h. ◆ DeleteValues(). void TMap::DeleteValues ; (; ). Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ; Definition at line 151 of file TMap.cxx. ◆ FindObject() [1/2]. TObject * TMap::FindObject ; (; const char * ; keyname); const. overridevirtual . Check if a (key,value) pair exists with keyname as name of the key. ; Returns a TPair* (need to downcast from TObject). Use Key() and Value() to get the pointers to the key and value, respectively. Returns 0 if not found. ; Reimplemented from TCollection.; Definition at line 215 of file TMap.cxx. ◆ FindObject() [2/2]. TObject * TMap::FindObject ; (; const TObject * ; key); const. overridevirtual . Check if a (key,value) pair exists with key as key. ; Returns a TPair* (need to downcast from TObject). Use Key() and Value() to get the pointers to the key and value, respectively. Returns 0 if not found. ; Reimplemented from TCollection.; Definition at line 226 of file TMap.cxx. ◆ GetObjectRef(). TObject ** TMap::GetObjectRef ; (; const TObject * ; obj); const. inlineoverridevirtual . Implements TCollection.; Definition at line 74 of file TMap.h. ◆ GetTable(). const THashTable * TMap::GetTable ; (; ); const. inline . Definition at line 75 of file TMap.h. ◆ GetValue() [1/2]. TObject * TMap::GetValue ; (; const char * ; keyname); const. Returns a pointer to the value associated with keyname as name of the key. ; Definition at line 236 of file TMap.cxx. ◆ GetValue() [2/2]. TObject * TMap::GetValue ; (; const TObject * ; key); const. Returns a pointer to the value associated with key. ; Definition at line 246 of file TMap.cxx. ◆ IsA(). TClass * TMap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TCollectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:21443,down,downcast,21443,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['down'],['downcast']
Availability," key is the attribute's name and value is the attribute's value. ; Definition at line 126 of file TSAXParser.cxx. ◆ OnWarning(). void TSAXParser::OnWarning ; (; const char * ; text). virtual . Emit a signal for OnWarning, where text is the warning. ; Definition at line 163 of file TSAXParser.cxx. ◆ operator=(). TSAXParser & TSAXParser::operator= ; (; const TSAXParser & ; ). privatedelete . ◆ Parse(). Int_t TSAXParser::Parse ; (; ). privatevirtual . This function parses the xml file, by initializing the parser and checks whether the parse context is created or not, it will check as well whether the document is well formated. ; It returns the parse error code, see TXMLParser. ; Definition at line 212 of file TSAXParser.cxx. ◆ ParseBuffer(). Int_t TSAXParser::ParseBuffer ; (; const char * ; contents, . Int_t ; len . ). overridevirtual . It parse the contents, instead of a file. ; It will return error if is attempted to parse a second file while a parse is in progres. It returns parse code error, see TXMLParser. ; Implements TXMLParser.; Definition at line 259 of file TSAXParser.cxx. ◆ ParseFile(). Int_t TSAXParser::ParseFile ; (; const char * ; filename). overridevirtual . It creates the parse context of the xml file, where the xml file name is filename. ; If context is created sucessfully, it will call Parse() It returns parse error code, see TXMLParser. ; Implements TXMLParser.; Definition at line 242 of file TSAXParser.cxx. ◆ Streamer(). void TSAXParser::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TSAXParser::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file TSAXParser.h. Friends And Related Symbol Documentation. ◆ TSAXParserCallback. friend class TSAXParserCallback. friend . Definition at line 25 of file TSAXParser.h. Member Data Documentation. ◆ fSAXHandler. _xmlSAXHandler* TSAXParser::fSAXHandler. private . libxml2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSAXParser.html:23858,error,error,23858,doc/master/classTSAXParser.html,https://root.cern,https://root.cern/doc/master/classTSAXParser.html,1,['error'],['error']
Availability," known to the server. The list of all known; 10573 * HTTP methods can be found here at; 10574 * http://www.iana.org/assignments/http-methods/http-methods.xhtml; 10575 */; 10576 const struct mg_http_method_info *m = http_methods;; 10577 ; 10578 while (m->name) {; 10579 if (!strcmp(m->name, method)) {; 10580 return m;; 10581 }; 10582 m++;; 10583 }; 10584 return NULL;; 10585}; 10586 ; 10587 ; 10588static int; 10589is_valid_http_method(const char *method); 10590{; 10591 return (get_http_method_info(method) != NULL);; 10592}; 10593 ; 10594 ; 10595/* Parse HTTP request, fill in mg_request_info structure.; 10596 * This function modifies the buffer by NUL-terminating; 10597 * HTTP request components, header names and header values.; 10598 * Parameters:; 10599 * buf (in/out): pointer to the HTTP header to parse and split; 10600 * len (in): length of HTTP header buffer; 10601 * re (out): parsed header as mg_request_info; 10602 * buf and ri must be valid pointers (not NULL), len>0.; 10603 * Returns <0 on error. */; 10604static int; 10605parse_http_request(char *buf, int len, struct mg_request_info *ri); 10606{; 10607 int request_length;; 10608 int init_skip = 0;; 10609 ; 10610 /* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,; 10611 * remote_port */; 10612 ri->remote_user = ri->request_method = ri->request_uri = ri->http_version =; 10613 NULL;; 10614 ri->num_headers = 0;; 10615 ; 10616 /* RFC says that all initial whitespaces should be ignored */; 10617 /* This included all leading \r and \n (isspace) */; 10618 /* See table: http://www.cplusplus.com/reference/cctype/ */; 10619 while ((len > 0) && isspace((unsigned char)*buf)) {; 10620 buf++;; 10621 len--;; 10622 init_skip++;; 10623 }; 10624 ; 10625 if (len == 0) {; 10626 /* Incomplete request */; 10627 return 0;; 10628 }; 10629 ; 10630 /* Control characters are not allowed, including zero */; 10631 if (iscntrl((unsigned char)*buf)) {; 10632 return -1;; 10633 }; 10634 ; 10635 /* Find end of HTTP header */; 10636 request_le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:305088,error,error,305088,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability," known to the server. The list of all known; 10574 * HTTP methods can be found here at; 10575 * http://www.iana.org/assignments/http-methods/http-methods.xhtml; 10576 */; 10577 const struct mg_http_method_info *m = http_methods;; 10578 ; 10579 while (m->name) {; 10580 if (!strcmp(m->name, method)) {; 10581 return m;; 10582 }; 10583 m++;; 10584 }; 10585 return NULL;; 10586}; 10587 ; 10588 ; 10589static int; 10590is_valid_http_method(const char *method); 10591{; 10592 return (get_http_method_info(method) != NULL);; 10593}; 10594 ; 10595 ; 10596/* Parse HTTP request, fill in mg_request_info structure.; 10597 * This function modifies the buffer by NUL-terminating; 10598 * HTTP request components, header names and header values.; 10599 * Parameters:; 10600 * buf (in/out): pointer to the HTTP header to parse and split; 10601 * len (in): length of HTTP header buffer; 10602 * re (out): parsed header as mg_request_info; 10603 * buf and ri must be valid pointers (not NULL), len>0.; 10604 * Returns <0 on error. */; 10605static int; 10606parse_http_request(char *buf, int len, struct mg_request_info *ri); 10607{; 10608 int request_length;; 10609 int init_skip = 0;; 10610 ; 10611 /* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,; 10612 * remote_port */; 10613 ri->remote_user = ri->request_method = ri->request_uri = ri->http_version =; 10614 NULL;; 10615 ri->num_headers = 0;; 10616 ; 10617 /* RFC says that all initial whitespaces should be ignored */; 10618 /* This included all leading \r and \n (isspace) */; 10619 /* See table: http://www.cplusplus.com/reference/cctype/ */; 10620 while ((len > 0) && isspace((unsigned char)*buf)) {; 10621 buf++;; 10622 len--;; 10623 init_skip++;; 10624 }; 10625 ; 10626 if (len == 0) {; 10627 /* Incomplete request */; 10628 return 0;; 10629 }; 10630 ; 10631 /* Control characters are not allowed, including zero */; 10632 if (iscntrl((unsigned char)*buf)) {; 10633 return -1;; 10634 }; 10635 ; 10636 /* Find end of HTTP header */; 10637 request_le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:305121,error,error,305121,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability," l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:15195,down,downharpoonright,15195,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,4,['down'],['downharpoonright']
Availability," l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMathText.html:15199,down,downharpoonright,15199,root/html534/TMathText.html,https://root.cern,https://root.cern/root/html534/TMathText.html,2,['down'],['downharpoonright']
Availability," label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the error of R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:40862,error,error,40862,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,4,['error'],['error']
