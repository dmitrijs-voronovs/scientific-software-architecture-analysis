quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,// AvailableOut minus AvailableIn.; // All elements are Instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:3,Avail,AvailableOut,3,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['Avail'],"['AvailableIn', 'AvailableOut']"
Availability,// AvailableOut will change only when Contribution changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:3,Avail,AvailableOut,3,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableOut']
Availability,"// Avoid ""Address already in use"" errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:34,error,errors,34,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,1,['error'],['errors']
Availability,// Avoid MSVC's Compiler Error C2276:; // http://msdn.microsoft.com/en-us/library/850cstw1(v=VS.80).aspx,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:25,Error,Error,25,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,1,['Error'],['Error']
Availability,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:768,avail,available,768,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['avail'],['available']
Availability,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:53,failure,failures,53,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,1,['failure'],['failures']
Availability,"// Avoid crashing on undefined behavior with an illegal call to a; // kernel. If a callsite's calling convention doesn't match the; // function's, it's undefined behavior. If the callsite calling; // convention does match, that would have errored earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp:239,error,errored,239,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp,1,['error'],['errored']
Availability,// Avoid emitting extra errors if we already errored on the scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:24,error,errors,24,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,['error'],"['errored', 'errors']"
Availability,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,3,['error'],['error']
Availability,"// Avoid error: invalid application of ‘sizeof’ to incomplete type in RJittedAction::GetMergeableValue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx:9,error,error,9,tree/dataframe/src/RJittedAction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx,1,['error'],['error']
Availability,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:596,mask,mask,596,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['mask'],['mask']
Availability,"// Avoid introducing shuffles with illegal mask.; // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, B, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, C, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, C, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, A, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, A, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, B, M2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Avoid producing TBL instruction if we don't know SVE register minimal size,; // unless NEON is not available and we can assume minimal SVE register size is; // 128-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:102,avail,available,102,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// Avoid query of available multi-sample modes when not required.; // Over ssh, SLC5 lies about supporting the GLX_SAMPLES_ARB; // extension and then dies horribly when the query is made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLFormat.cxx:18,avail,available,18,graf3d/gl/src/TGLFormat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLFormat.cxx,1,['avail'],['available']
Availability,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:109,error,error,109,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['error'],['error']
Availability,"// Avoid redundant warning, only warn at the first unmatched sample.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:9,redundant,redundant,9,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['redundant'],['redundant']
Availability,"// Avoid sending (error) messages at next action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:18,error,error,18,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['error'],['error']
Availability,"// Avoid spurrious/redundant error messages in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/testHashRecursiveRemove.cxx:19,redundant,redundant,19,core/meta/test/testHashRecursiveRemove.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/testHashRecursiveRemove.cxx,3,"['error', 'failure', 'redundant']","['error', 'failure', 'redundant']"
Availability,// Avoid ternary due to failure to convert the ubig32_t value to a unit64_t; // with MSVC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:24,failure,failure,24,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,2,['failure'],['failure']
Availability,"// Avoid the String.fromCharCode.apply(null, array) shortcut, which; // throws a ""maximum call stack size exceeded"" error for large arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:116,error,error,116,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['error'],['error']
Availability,// Avoid triggering a fatal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:28,error,error,28,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,"// B is a base of D. But is it an allowed base? If not, it's a hard error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:68,error,error,68,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['error'],['error']
Availability,"// B is available in all versions of the Arm ISA, so the only question is; // whether that ISA is available at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:8,avail,available,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['avail'],['available']
Availability,"// B.W is available in any Thumb2-supporting target, and also in every; // version of Armv8-M, even Baseline which does not include the rest of; // Thumb2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['avail'],['available']
Availability,"// BFI encompasses sufficiently many nodes that it's worth inserting an extra; // LSL/LSR if the mask in NonZeroBits doesn't quite match up with the ISD::SHL; // amount. BiggerPattern is true when this pattern is being matched for BFI,; // BiggerPattern is false when this pattern is being matched for UBFIZ, in; // which case it is not profitable to insert an extra shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:97,mask,mask,97,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// BFI is only available on V6T2+,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,avail,available,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,// BFI is only available on V6T2+.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,avail,available,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// BITREVERSE: Push the concat down, swapping the lower/upper sources.; // concat(bitreverse(x),bitreverse(y)) -> bitreverse(concat(x,y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:31,down,down,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['down'],['down']
Availability,"// BRKN uses an all active implicit mask to set flags unlike the other; // flag-setting instructions.; // PTEST(PTRUE_B(31), BRKN(PG, A, B)) -> BRKNS(PG, A, B).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['mask'],['mask']
Availability,"// BSWAP: Push the concat down, swapping the lower/upper sources.; // concat(bswap(x),bswap(y)) -> bswap(concat(x,y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:26,down,down,26,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['down'],['down']
Availability,// BT{S|R|C} on memory operand don't modulo bit position so we need to; // mask it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:75,mask,mask,75,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// BZHI, if available, is always fast, unlike BEXTR. But even if we decide; // that we can't use BEXTR, it is only worthwhile using BZHI if the mask; // does not fit into 32 bits. Load folding is not a sufficient reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:12,avail,available,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// Backport if not_fn is not available.; // libc++ does not define __cpp_lib_not_fn.; // Assume we have not_fn if libc++ is compiled with C++14 and up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RNotFn.hxx:29,avail,available,29,core/foundation/inc/ROOT/RNotFn.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RNotFn.hxx,1,['avail'],['available']
Availability,"// Backpropagate the error in i'th layer of each deep net",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h:21,error,error,21,tmva/tmva/inc/TMVA/DNN/DeepNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h,3,['error'],['error']
Availability,"// Bad token, return it as an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,2,['error'],['error']
Availability,// Bail if the mask is not a constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['mask'],['mask']
Availability,// Bail if the shuffle mask doesn't cross 128-bit lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Bail if we already have a repeated lane shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Bail if we failed to find a matching repeated sub-lane mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,2,['avail'],['available']
Availability,// Bail off if there is a parsing error in the parsing of the parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:34,error,error,34,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['error'],['error']
Availability,// Bail off if there is a syntax error in the align token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:33,error,error,33,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['error'],['error']
Availability,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:85,mask,mask,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,// Bail out early if there's already an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:40,error,error,40,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,1,['error'],['error']
Availability,// Bail out if any mask value is undefined. That kind of shuffle may be; // simplified further based on demanded bits or other folds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// Bail out if the mask constant is already negative. It's can't shrink more.; // If the upper 32 bits of a 64 bit mask are all zeros, we have special isel; // patterns to use a 32-bit and instead of a 64-bit and by relying on the; // implicit zeroing of 32 bit ops. So we should check if the lower 32 bits; // are negative too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,// Bail out if the mask is not a constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,// Bail out if there is an argument that has no available types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:48,avail,available,48,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avail'],['available']
Availability,"// Bail out if we've hit any errors, even if we managed to build the; // call. We don't want to produce more than one error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,error,errors,29,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['error'],"['error', 'errors']"
Availability,// Bail out when the SRL has more than one use. This is done for historical; // (undocumented) reasons. Maybe intent was to guard the AND-masking below; // check below? And maybe it could be non-profitable to do the transform in; // case the SRL has multiple uses and we get here with Opc!=ISD::SRL?; // FIXME: Can't we just skip this check for the Opc==ISD::SRL case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,mask,masking,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,"// Bail out when value type is not one of {i32, i64}, since AArch64 ADD with; // shifted register is only available for i32 and i64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:106,avail,available,106,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,"// Base types with sizes that aren't a power of two don't work; // with the layout rules for MS structs. This isn't an issue in; // MSVC itself since there are no such base data types there.; // On e.g. x86_32 mingw and linux, long double is 12 bytes though.; // Any structs involving that data type obviously can't be ABI; // compatible with MSVC regardless of how it is laid out.; // Since ms_struct can be mass enabled (via a pragma or via the; // -mms-bitfields command line parameter), this can trigger for; // structs that don't actually need MSVC compatibility, so we; // need to be able to sidestep the ms_struct layout for these types.; // Since the combination of -mms-bitfields together with structs; // like max_align_t (which contains a long double) for mingw is; // quite common (and GCC handles it silently), just handle it; // silently there. For other targets that have ms_struct enabled; // (most probably via a pragma or attribute), trigger a diagnostic; // that defaults to an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:997,error,error,997,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['error'],['error']
Availability,// Based on ITEM 23 in AIM-239: http://dspace.mit.edu/handle/1721.1/6086; // (a & b) + (a | b) = a + b = (a ^ b) + 2 * (a & b) =>; // (a + b) / 2 = ((a ^ b) >> 1) + (a & b); // To operate on multiple sub-elements we need to make sure to mask out bits; // that crossed over into adjacent elements during the shift.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:237,mask,mask,237,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,1,['mask'],['mask']
Availability,"// BasicAA is always available for function analyses. Also, we add it first; // so that it can trump TBAA results when it proves MustAlias.; // FIXME: TBAA should have an explicit mode to support this and then we; // should reconsider the ordering here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['avail'],['available']
Availability,"// Be a little bit makefile friendly and remove the dictionary in case of error.; // We could add an option -k to keep the file even in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:74,error,error,74,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,2,['error'],['error']
Availability,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:436,alive,alive,436,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,3,['alive'],['alive']
Availability,"// Be robust against unsimplified IR for the form ""op i1 X, NeutralElement""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,robust,robust,6,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['robust'],['robust']
Availability,"// Because -save-temps is a debugging feature, we report the error; // directly and exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:61,error,error,61,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,2,['error'],['error']
Availability,"// Because ClassDefInline does not yet support class template on all platforms,; // we have no ClassDef and thus can not get a good message from TObject::Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:154,Error,Error,154,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,1,['Error'],['Error']
Availability,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:379,down,down,379,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['down'],['down']
Availability,// Because getNegatedExpression can delete nodes we need a handle to keep; // temporary nodes alive in case the recursion manages to create an identical; // node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:94,alive,alive,94,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['alive'],['alive']
Availability,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,redundant,redundant,76,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['redundant'],['redundant']
Availability,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:23,error,errors,23,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,3,['error'],"['error', 'errors']"
Availability,"// Because of simplify-demanded-bits in DAGCombine, involved masks may not; // have the expected shape. Try to undo that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:61,mask,masks,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,"// Because of simplify-demanded-bits in DAGCombine, the mask may have been; // simplified. Try to undo that",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Because of the situation described above, we may have some proxies; // already created and some not, if their branch was not available so far.; // Make sure we do not recreate the proxy unnecessarily, unless the; // data member was set outside of this function (e.g. in Restart).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:128,avail,available,128,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['avail'],['available']
Availability,"// Because the Enable and Disable calls are static, it means that; // there may not actually be an Impl available, or even a current; // CrashRecoveryContext at all. So we make use of a thread-local; // exception table. The handles contained in here will either be; // non-NULL, valid VEH handles, or NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:104,avail,available,104,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['avail'],['available']
Availability,"// Because the lowering happens after all combining takes place, we need to; // manually combine these blend masks as much as possible so that we create; // a minimal number of high-level vector shuffle nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:109,mask,masks,109,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// Because the value may be negative, we must mask out the sign bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,2,['mask'],['mask']
Availability,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:122,error,error,122,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Because we are going top-down through the block, all value numbers; // will be available in the predecessor by the time we need them. Any; // that weren't originally present will have been instantiated earlier; // in this loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:28,down,down,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// Because we try the reference downcast before this function, from now on; // this is the only cast possibility, so we issue an error if we fail now.; // FIXME: Should allow casting away constness if CStyle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:32,down,downcast,32,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,2,"['down', 'error']","['downcast', 'error']"
Availability,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['mask'],['mask']
Availability,"// Because we'll be zero-extending the output anyway if don't have a specific; // value for each input byte (via the Mask), we can 'anyext' the inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,Mask,Mask,117,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,redundant,redundant,917,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redundant'],['redundant']
Availability,// Before doing anything complicated check if the mapping is not; // directly available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:78,avail,available,78,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['avail'],['available']
Availability,"// Before kernel 4.17, Linux did not support MAP_FIXED_NOREPLACE, so if it is; // not available, simplfy define it as MAP_FIXED which performs the same; // function but does not guarantee existing mappings won't get clobbered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h:86,avail,available,86,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,1,['avail'],['available']
Availability,"// Before returning, rename the files if no errors occurred; // otherwise clean them to avoid remnants (see ROOT-10015)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:44,error,errors,44,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['errors']
Availability,"// Before using SVE's features, check first if it's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:487,avail,available,487,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avail'],['available']
Availability,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,recover,recover,134,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Availability,"// Begin by bitcasting the input to byte vector, then split those bytes; // into lo/hi nibbles and use the PSHUFB LUT to perform CLTZ on each of them.; // If the hi input nibble is zero then we add both results together, otherwise; // we just take the hi result (by masking the lo result to zero before the; // add).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:266,mask,masking,266,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masking']
Availability,// Behavior is independent of mask policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['mask'],['mask']
Availability,"// Below are virtual fonts for bookkeeping and do not; // have to correspond to a physical font available in; // surface_t.; //; // TeX combined styles",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/inc/mathtext.h:96,avail,available,96,graf2d/mathtext/inc/mathtext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/inc/mathtext.h,1,['avail'],['available']
Availability,"// Below is based on the following information:; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | Processor Name | Cache Line Size (Bytes) | Source |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:927,down,download,927,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,1,['down'],['download']
Availability,"// Below, let H and L be arbitrary elements of the shuffle mask; // where H is in the range [4,7] and L is in the range [0,3].; // H, 1, 2, 3 or L, 5, 6, 7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Besides the SSE4A subtarget exception above, only aligned stores are; // available nontemporaly on any other subtarget. And only stores with a size; // of 4..32 bytes (powers of 2, only) are permitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['avail'],['available']
Availability,"// Beyond ~19, the VDT polynomials break down when c1 is very negative",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testExponential.cxx:41,down,down,41,roofit/roofit/test/vectorisedPDFs/testExponential.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testExponential.cxx,1,['down'],['down']
Availability,"// Bifurcate the state into failed and non-failed.; // Return zero on success, nonzero on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// Bin contents and bin errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx:24,error,errors,24,hist/hist/test/test_TH1_SaveAs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx,1,['error'],['errors']
Availability,// Bit mask for extra allowed value types other than integers for atomic; // arithmetic operations. Add/sub allow pointer and floating point. Min/max; // allow floating point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:7,mask,mask,7,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['mask'],['mask']
Availability,// Bit mask of lanes that cover their registers. A sub-register index whose; // LaneMask is contained in CoveringLanes will be completely covered by; // another sub-register with the same or larger lane mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:7,mask,mask,7,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,2,['mask'],['mask']
Availability,"// Bit mask of live FP registers. Bit 0 = FP0, bit 1 = FP1, &c.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['mask'],['mask']
Availability,"// Bit mask of sub-classes including this, indexed by their EnumValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:7,mask,mask,7,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['mask'],['mask']
Availability,// Bit mask selecting rounding mode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,3,['mask'],['mask']
Availability,// Bitcast the operands to be the same type as the mask.; // This is needed when we select between FP types because; // the mask is a vector of integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,4,['mask'],['mask']
Availability,"// Bitcast to vXi1 type and then back to integer. This gets the mask; // register type into the IR, but might be optimized out depending on; // what's around it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:64,mask,mask,64,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:53,Mask,Mask,53,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,2,['Mask'],['Mask']
Availability,// Bitmask of available domains for this instruction after taking collapsed; // operands into account.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,1,['avail'],['available']
Availability,// Bitmask of domains that dv and available have in common.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,1,['avail'],['available']
Availability,"// Bits [7:6] of the constant are the source select. This will always be; // zero here. The DAG Combiner may combine an extract_elt index into; // these bits. For example (insert (extract, 3), 2) could be matched by; // putting the '3' into bits [7:6] of X86ISD::INSERTPS.; // Bits [5:4] of the constant are the destination select. This is the; // value of the incoming immediate.; // Bits [3:0] of the constant are the zero mask. The DAG Combiner may; // combine either bitwise AND or insert of float 0.0 to set these bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:425,mask,mask,425,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Bits of each operand that are used to compute alive bits of the; // output are alive, all others are dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:49,alive,alive,49,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,"// Bitwise-not (xor X, -1) is a special case: we don't usually shrink its; // constant, but if this 'and' is only clearing bits that were just set by; // the xor, then this 'and' can be eliminated by shrinking the mask of; // the xor. For example, for a 32-bit X:; // and (xor (srl X, 31), -1), 1 --> xor (srl X, 31), 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:214,mask,mask,214,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,"// Blend in all instances of this value using a VSELECT, using a; // mask where each bit signals whether that element is the one; // we're after.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:69,mask,mask,69,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// Block in mask is all-one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['mask'],['mask']
Availability,// Block intended to contains information on the bitcode versioning.; // Can be used to provide better error messages when we fail to parse a; // bitcode file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:103,error,error,103,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,1,['error'],['error']
Availability,// Block that defines the available value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:26,avail,available,26,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['avail'],['available']
Availability,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,redundant,redundant,79,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['redundant'],['redundant']
Availability,// Boils down to isupper() or islower() or isdigit().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['down'],['down']
Availability,"// Boolean ext_vector_type(N) are special because their real element type; // (bits of bit size) is not their Clang element type (_Bool of size byte).; // For now, we pretend the boolean vector were actually a vector of bytes; // (where each byte represents 8 bits of the actual vector).; // FIXME Debug info should actually represent this proper as a vector mask; // type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:359,mask,mask,359,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['mask'],['mask']
Availability,// Both LHS and RHS must be available at loop entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avail'],['available']
Availability,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:22,Mask,Mask,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,2,"['Mask', 'mask']","['Mask', 'masked']"
Availability,"// Both assignments, i.e. Red->Up and Red->Down are valid, but they will; // result in different controls. Let's pick the one where the first; // control will be ""Pass"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:43,Down,Down,43,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Down'],['Down']
Availability,"// Both invalid, or one is invalid and other is non-present: return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:68,error,error,68,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['error'],['error']
Availability,"// Both llvm and ThreadSanitizer atomic operations are based on C++11/C1x; // standards. For background see C++11 standard. A slightly older, publicly; // available draft of the standard (not entirely up-to-date, but close enough; // for casual browsing) is available here:; // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf; // The following page contains more background information:; // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:155,avail,available,155,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,2,['avail'],['available']
Availability,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,redundant,redundant,258,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['redundant'],['redundant']
Availability,"// Branch on the LHS first. If it is false, go to the failure (cont) block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:54,failure,failure,54,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['failure'],['failure']
Availability,"// Branches if a condition is true. Operand 0 is the chain operand;; // operand 1 is the 4-bit condition-code mask, with bit N in; // big-endian order meaning ""branch if CC=N""; operand 2 is the; // target block and operand 3 is the flag operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:110,mask,mask,110,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,// Break down -march into individual extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['down'],['down']
Availability,// Break down insert_subvector into simpler parts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['down'],['down']
Availability,// Break down the annotation byte code and calculate code and line offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h:9,down,down,9,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h,1,['down'],['down']
Availability,// Break down the annotation byte code and calculate code and line offsets.; // FIXME: It would be helpful if we could look up the initial file and inlinee; // lines offset using the inlinee index above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/MinimalSymbolDumper.cpp:9,down,down,9,interpreter/llvm-project/llvm/tools/llvm-pdbutil/MinimalSymbolDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/MinimalSymbolDumper.cpp,1,['down'],['down']
Availability,// Break down the array into individual dimensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['down'],['down']
Availability,// Break down the big constant in smaller ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['down'],['down']
Availability,"// Break down the compound of a fully qualified type name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TypeManip.cxx:9,down,down,9,bindings/pyroot/cppyy/CPyCppyy/src/TypeManip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TypeManip.cxx,1,['down'],['down']
Availability,// Break down the source location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,7,['down'],['down']
Availability,// Break down the source locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['down'],['down']
Availability,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:467,down,down,467,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['down'],['down']
Availability,// Bring vecSize down to something no larger than numElts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:17,down,down,17,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['down'],['down']
Availability,// Broadcast mask to vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['mask']
Availability,// Broadcast the mask so that the entire vector is all one or all zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// Bubble up any error (e.g. undefined variables) in the recursive; // evaluation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"// Bugzilla ID: 46767; // TODO: Check if fixing up the stack more than once is safe so we can; // outline these.; //; // An outline resulting in a caller that requires stack fixups at the; // callsite to a callee that also requires stack fixups can happen when; // there are no available registers at the candidate callsite for a; // candidate that itself also has calls.; //; // In other words if function_containing_sequence in the following pseudo; // assembly requires that we save LR at the point of the call, but there; // are no available registers: in this case we save using SP and as a; // result the SP offsets requires stack fixups by multiples of 16.; //; // function_containing_sequence:; // ...; // save LR to SP <- Requires stack instr fixups in OUTLINED_FUNCTION_N; // call OUTLINED_FUNCTION_N; // restore LR from SP; // ...; //; // OUTLINED_FUNCTION_N:; // save LR to SP <- Requires stack instr fixups in OUTLINED_FUNCTION_N; // ...; // bl foo; // restore LR from SP; // ret; //; // Because the code to handle more than one stack fixup does not; // currently have the proper checks for legality, these cases will assert; // in the AArch64 MachineOutliner. This is because the code to do this; // needs more hardening, testing, better checks that generated code is; // legal, etc and because it is only verified to handle a single pass of; // stack fixup.; //; // The assert happens in AArch64InstrInfo::buildOutlinedFrame to catch; // these cases until they are known to be handled. Bugzilla 46767 is; // referenced in comments at the assert site.; //; // To avoid asserting (or generating non-legal code on noassert builds); // we remove all candidates which would need more than one stack fixup by; // pruning the cases where the candidate has calls while also having no; // available LR and having no available general purpose registers to copy; // LR to (ie one extra stack save/restore).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:278,avail,available,278,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,4,['avail'],['available']
Availability,"// Build 1 << (-CTLZ & (BitWidth-1)). The negation likely corresponds to a; // single hardware instruction as opposed to BitWidth - CTLZ, where BitWidth; // is an integer constant. Masking with BitWidth-1 comes free on some; // hardware as part of the shift instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:181,Mask,Masking,181,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['Mask'],['Masking']
Availability,// Build TopLevelProbeFrameMap to track size for optimized inlinees when probe; // is available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:86,avail,available,86,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['avail'],['available']
Availability,// Build a base mask of undef shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Recover,Recover,111,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['Recover', 'error']","['Recover', 'errors']"
Availability,"// Build a gaussian resolution model scaled by the per-event error = gauss(dt,bias,sigma*dterr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:61,error,error,61,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],['error']
Availability,// Build a mask by testing the condition against zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Build a mask out of the reorder indices and reorder scalars per this; // mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,// Build a shuffle mask for better cost estimation and vector emission.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Build a shuffle mask for the output, discovering on the fly which; // input vectors to use as shuffle operands (recorded in InputUsed).; // If building a suitable shuffle vector proves too hard, then bail; // out with useBuildVector set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['mask']
Availability,"// Build a shuffle mask for the output, discovering on the fly which; // input vectors to use as shuffle operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,// Build a shuffle mask that takes each input element and places it in the; // MSBs of the new element size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Build a status that is common to all the predecessors by intersecting; // all the predecessor exit status values.; // Mask bits (which represent the Mode bits with a known value) can only be; // added by explicit SETREG instructions or the initial default value -; // the intersection process may remove Mask bits.; // If we find a predecessor that has not yet had an exit value determined; // (this can happen for example if a block is its own predecessor) we defer; // use of that value as the Mask will be all zero, and we will revisit this; // block again later (unless the only predecessor without an exit value is; // this block).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp:121,Mask,Mask,121,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,3,['Mask'],['Mask']
Availability,// Build a string naming the redundant qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:29,redundant,redundant,29,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redundant'],['redundant']
Availability,// Build a vector of constants.; // Use an UNDEF node if MaskElt == -1.; // Split 64-bit constants in the 32-bit mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:57,Mask,MaskElt,57,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['MaskElt']
Availability,// Build mask for VECTOR_SHUFLLE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Build shuffle mask to perform the splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['mask'],['mask']
Availability,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:102,mask,masked,102,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['mask'],['masked']
Availability,"// Build the final mask, check for the identity shuffle, if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:33,repair,repair,33,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repair']
Availability,"// Build the list of available styles and select gStyle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:21,avail,available,21,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avail'],['available']
Availability,// Build the mask for the vectorized insertelement instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,// Build worklist and check for any symbols in the error state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:51,error,error,51,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// BuildBinOp already emitted error, this one is to point user to upper; // and lower bound, and to tell what is passed to 'operator-'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:30,error,error,30,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['error'],['error']
Availability,// Built a set of available delta passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/DeltaManager.cpp:18,avail,available,18,interpreter/llvm-project/llvm/tools/llvm-reduce/DeltaManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/DeltaManager.cpp,1,['avail'],['available']
Availability,// Bump CurCycle to account for latency. We assume the latency of other; // available instructions may be hidden by the stall (not a full pipe stall).; // This updates the hazard recognizer's cycle before reserving resources for; // this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,// Butterfly shuffles.; //; // V6_vdelta; // V6_vrdelta; // V6_vror; // The assumption here is that all elements picked by Mask are in the; // first operand to the vector_shuffle. This assumption is enforced; // by the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:123,Mask,Mask,123,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Mask'],['Mask']
Availability,"// Button DOWN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx:10,DOWN,DOWN,10,graf3d/gl/src/TGLEventHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx,1,['DOWN'],['DOWN']
Availability,// By default we assume we will have to repair something.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,repair,repair,40,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repair']
Availability,"// By default we preserve the original operand order, and use a mask to; // select LHS as true and RHS as false. However, since RVV vector selects may; // feature splats but only on the LHS, we may choose to invert our mask and; // instead select between RHS and LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// By default, X-Form is always available to be selected.; // When a frame index is not aligned, we also match by XForm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:51,avail,available,51,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['avail'],['available']
Availability,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:52,avail,available,52,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['avail'],['available']
Availability,"// By default, if Clang doesn't know how to generate useful OpenMP code; // for a specific runtime library, we just don't pass the '-fopenmp' flag; // down to the actual compilation.; // FIXME: It would be better to have a mode which *only* omits IR; // generation based on the OpenMP support so that we get consistent; // semantic analysis, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:151,down,down,151,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['down'],['down']
Availability,"// By here, packing by segment (half-vector) shuffling, and vector alignment; // failed. Try vmux.; // Note: since this is using the original mask, Va and Vb must not have been; // modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:142,mask,mask,142,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:139,redundant,redundant,139,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['redundant'],['redundant']
Availability,// By this point we've effectively got; // zero_inactive_lanes_and_trunc_i1(sext_i1(A)). If we can prove A's inactive; // lanes are already zero then the trunc(sext()) sequence is redundant and we; // can operate on A directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:180,redundant,redundant,180,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redundant'],['redundant']
Availability,// Byte blends are only available in AVX2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// ByteVec is the target vector VecV rotated in such a way that the; // subvector should be inserted at index 0. Generate a predicate mask; // and use vmux to do the insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:134,mask,mask,134,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['mask'],['mask']
Availability,"// C now contains V C^-1 V; // Propagate corrected errors to parameters objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:51,error,errors,51,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['error'],['errors']
Availability,"// C o m p a r e f i t r e s u l t s o f c h i 2 , M L f i t s t o ( u n ) w e i g h t e d d a t a; // ---------------------------------------------------------------------------------------------------------------; // Note that ML fit on 1Kevt of weighted data is closer to result of ML fit on 43Kevt of unweighted data; // than to 1Kevt of unweighted data, whereas the reference chi^2 fit with SumW2 error gives a result closer to; // that of an unbinned ML fit to 1Kevt of unweighted data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:402,error,error,402,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['error']
Availability,"// C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:176,error,errors,176,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,4,['error'],"['error', 'errors']"
Availability,"// C r e a t e m a n a g e r; // ---------------------------; // Instantiate RooMCStudy manager on model with x as observable and given choice of fit options; //; // The Silence() option kills all messages below the PROGRESS level, leaving only a single message; // per sample executed, and any error message that occur during fitting; //; // The Extended() option has two effects:; // 1) The extended ML term is included in the likelihood and; // 2) A poisson fluctuation is introduced on the number of generated events; //; // The FitOptions() given here are passed to the fitting stage of each toy experiment.; // If Save() is specified, the fit result of each experiment is saved by the manager; //; // A Binned() option is added in this example to bin the data between generation and fitting; // to speed up the study at the expemse of some precision",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:295,error,error,295,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['error']
Availability,"// C'99 standard, §7.19.8.1.3, the return value of fread:; // The fread function returns the number of elements successfully read, which; // may be less than nmemb if a read error or end-of-file is encountered. If; // size or nmemb is zero, fread returns zero and the contents of the array and; // the state of the stream remain unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:174,error,error,174,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// C++ 5.2.9p5, reference downcast.; // See the function for details.; // DR 427 specifies that this is to be applied before paragraph 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:26,down,downcast,26,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['down'],['downcast']
Availability,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,redundant,redundant,254,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['redundant'],['redundant']
Availability,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:895,avail,available,895,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['avail'],['available']
Availability,"// C++ [basic.scope.pdecl]p5:; // -- for an elaborated-type-specifier of the form; //; // class-key identifier; //; // if the elaborated-type-specifier is used in the; // decl-specifier-seq or parameter-declaration-clause of a; // function defined in namespace scope, the identifier is; // declared as a class-name in the namespace that contains; // the declaration; otherwise, except as a friend; // declaration, the identifier is declared in the smallest; // non-class, non-function-prototype scope that contains the; // declaration.; //; // C99 6.7.2.3p8 has a similar (but not identical!) provision for; // C structs and unions.; //; // It is an error in C++ to declare (rather than define) an enum; // type, including via an elaborated type specifier. We'll; // diagnose that later; for now, declare the enum in the same; // scope as we would have picked for any other tag type.; //; // GNU C also supports this behavior as part of its incomplete; // enum types extension, while GNU C++ does not.; //; // Find the context where we'll be declaring the tag.; // FIXME: We would like to maintain the current DeclContext as the; // lexical context,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:650,error,error,650,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// C++ [class.member.lookup]p8:; // [...] Ambiguities can often be resolved by qualifying a name with its; // class name.; //; // If the member was a qualified name and the qualified referred to a; // specific base subobject type, we'll cast to that intermediate type; // first and then to the object in which the member is declared. That allows; // one to resolve ambiguities in, e.g., a diamond-shaped hierarchy such as:; //; // class Base { public: int x; };; // class Derived1 : public Base { };; // class Derived2 : public Base { };; // class VeryDerived : public Derived1, public Derived2 { void f(); };; //; // void VeryDerived::f() {; // x = 17; // error: ambiguous base subobjects; // Derived1::x = 17; // okay, pick the Base subobject of Derived1; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:657,error,error,657,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// C++ [conv.ptr]p3:; //; // An rvalue of type ""pointer to cv D,"" where D is a class type,; // can be converted to an rvalue of type ""pointer to cv B,"" where; // B is a base class (clause 10) of D. If B is an inaccessible; // (clause 11) or ambiguous (10.2) base class of D, a program that; // necessitates this conversion is ill-formed. The result of the; // conversion is a pointer to the base class sub-object of the; // derived class object. The null pointer value is converted to; // the null pointer value of the destination type.; //; // Note that we do not check for ambiguity or inaccessibility; // here. That is handled by CheckPointerConversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:633,CheckPoint,CheckPointerConversion,633,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['CheckPoint'],['CheckPointerConversion']
Availability,"// C++ [dcl.dcl]p3:; // [If there are no declarators], and except for the declaration of an; // unnamed bit-field, the decl-specifier-seq shall introduce one or more; // names into the program; // C++ [class.mem]p2:; // each such member-declaration shall either declare at least one member; // name of the class or declare at least one unnamed bit-field; //; // For C this is an error even for a named struct, and is diagnosed elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:379,error,error,379,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// C++ [except.spec]p17:; // An exception-specification is considered to be needed when:; // - in an expression, the function is the unique lookup result or; // the selected member of a set of overloaded functions.; //; // We delay doing this until after we've built the function reference and; // marked it as used so that:; // a) if the function is defaulted, we get errors from defining it before /; // instead of errors from computing its exception specification, and; // b) if the function is a defaulted comparison, we can use the body we; // build when defining it as input to the exception specification; // computation rather than computing a new body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:369,error,errors,369,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['errors']
Availability,"// C++ [over.over]p1:; // [...] [Note: any redundant set of parentheses surrounding the; // overloaded function name is ignored (5.1). ]; // C++ [over.over]p1:; // [...] The overloaded function name can be preceded by the &; // operator.; // If we didn't actually find any template-ids, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,redundant,redundant,43,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['redundant'],['redundant']
Availability,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:218,redundant,redundant,218,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['recover', 'redundant']","['recovery', 'redundant']"
Availability,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,recover,recover,378,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Availability,// C++ [temp.param]p10:; // The set of default template-arguments available for use with a; // template declaration or definition is obtained by merging the; // default arguments from the definition (if in scope) and all; // declarations in scope in the same way default function; // arguments are (8.3.6).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:66,avail,available,66,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avail'],['available']
Availability,"// C++ maintains the hardref, keeping the PyObject alive w/o outstanding ref",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx:51,alive,alive,51,bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx,1,['alive'],['alive']
Availability,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,redundant,redundant,485,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['redundant'],['redundant']
Availability,"// C++11 [basic.start.main]p3:; // A program that [...] declares main to be inline, static or; // constexpr is ill-formed.; // C11 6.7.4p4: In a hosted environment, no function specifier(s) shall; // appear in a declaration of main.; // static main is not an error under C99, but we should warn about it.; // We accept _Noreturn main as an extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:259,error,error,259,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:273,failure,failure,273,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['failure'],['failure']
Availability,"// C++11 [except.spec]p2:; // A type denoted in an exception-specification shall not denote an; // incomplete type other than a class currently being defined [...].; // A type denoted in an exception-specification shall not denote a; // pointer or reference to an incomplete type, other than (cv) void* or a; // pointer or reference to a class currently being defined.; // In Microsoft mode, downgrade this to a warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:392,down,downgrade,392,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['down'],['downgrade']
Availability,// C++11 [expr.static.cast]p11: Behavior is undefined if a downcast is; // performed and the object is not of the derived type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:59,down,downcast,59,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['down'],['downcast']
Availability,// C++11 [expr.static.cast]p2: Behavior is undefined if a downcast is; // performed and the object is not of the derived type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:58,down,downcast,58,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['down'],['downcast']
Availability,"// C++11 [temp.deduct.partial]p9:; // If, for a given type, deduction succeeds in both directions (i.e.,; // the types are identical after the transformations above) and both; // P and A were reference types [...]:; // - if [one type] was an lvalue reference and [the other type] was; // not, [the other type] is not considered to be at least as; // specialized as [the first type]; // - if [one type] is more cv-qualified than [the other type],; // [the other type] is not considered to be at least as specialized; // as [the first type]; // Objective-C ARC adds:; // - [one type] has non-trivial lifetime, [the other type] has; // __unsafe_unretained lifetime, and the types are otherwise; // identical; //; // A is ""considered to be at least as specialized"" as P iff deduction; // succeeds, so we model this as a deduction failure. Note that; // [the first type] is P and [the other type] is A here; the standard; // gets this backwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:826,failure,failure,826,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['failure'],['failure']
Availability,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:372,recover,recover,372,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,redundant,redundant,234,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['redundant'],['redundant']
Availability,"// C++2a [basic.stc.dynamic.allocation]p4:; // An allocation function that has a non-throwing exception specification; // indicates failure by returning a null pointer value. Any other allocation; // function never returns a null pointer value and indicates failure only by; // throwing an exception [...]; //; // However, -fcheck-new invalidates this possible assumption, so don't add; // NonNull when that is enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:132,failure,failure,132,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['failure'],['failure']
Availability,"// C++2a [over.built]p14:; //; // For every integral type T there exists a candidate operator function; // of the form; //; // std::strong_ordering operator<=>(T, T); //; // C++2a [over.built]p15:; //; // For every pair of floating-point types L and R, there exists a candidate; // operator function of the form; //; // std::partial_ordering operator<=>(L, R);; //; // FIXME: The current specification for integral types doesn't play nice with; // the direction of p0946r0, which allows mixed integral and unscoped-enum; // comparisons. Under the current spec this can lead to ambiguity during; // overload resolution. For example:; //; // enum A : int {a};; // auto x = (a <=> (long)42);; //; // error: call is ambiguous for arguments 'A' and 'long'.; // note: candidate operator<=>(int, int); // note: candidate operator<=>(long, long); //; // To avoid this error, this function deviates from the specification and adds; // the mixed overloads `operator<=>(L, R)` where L and R are promoted; // arithmetic types (the same as the generic relational overloads).; //; // For now this function acts as a placeholder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:697,error,error,697,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['error'],['error']
Availability,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:263,error,error,263,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,// C99 6.10.5 - Error Directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:16,Error,Error,16,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['Error'],['Error']
Availability,"// C99 6.7.5.3p1: The return type may not be a function or array type.; // For conversion functions, we'll diagnose this particular error later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:132,error,error,132,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"// C99 6.8.6.4p3(136): The return statement is not an assignment. The; // overlap restriction of subclause 6.5.16.1 does not apply to the case of; // function return.; // In C++ the return statement is handled via a copy initialization,; // the C version of which boils down to CheckSingleAssignmentConstraints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:270,down,down,270,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['down'],['down']
Availability,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:346,error,error,346,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// C99 7.17p3:; // (If the specified member is a bit-field, the behavior is undefined.); //; // We diagnose this as an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,error,error,119,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:124,mask,mask,124,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['mask'],['mask']
Availability,"// CEF applications have multiple sub-processes (render, plugin, GPU, etc); // that share the same executable. This function checks the command-line and,; // if this is a sub-process, executes the appropriate logic.; /* int exit_code = CefExecuteProcess(main_args, nullptr, nullptr);; if (exit_code >= 0) {; // The sub-process has completed so return here.; return exit_code;; }; */; // Install xlib error handlers so that the application won't be terminated; // on non-fatal errors.; // XSetErrorHandler(XErrorHandlerImpl);; // XSetIOErrorHandler(XIOErrorHandlerImpl);; // Specify CEF global settings here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx:400,error,error,400,gui/cefdisplay/src/RCefWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx,2,['error'],"['error', 'errors']"
Availability,// CF == 1; // Set up an addend that when one is added will need a carry due to not; // having a higher bit available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:108,avail,available,108,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,1,['avail'],['available']
Availability,// CM is the shifted-left mask. Shift it back right to remove the zero; // bits on least-significant positions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,1,['mask'],['mask']
Availability,"// CUDA E.2.4.1 ""__shared__ variables cannot have an initialization; // as part of their declaration."" Sema has already checked for; // error cases, so we just need to set Init to UndefValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:136,error,error,136,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['error'],['error']
Availability,// CUDA architectures for which we have raised an error in; // CheckCudaVersionSupportsArch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:50,error,error,50,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['error'],['error']
Availability,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:142,error,error,142,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,2,['error'],['error']
Availability,// CUDA/HIP can have the same input source code compiled multiple times so do; // not compiled again if there are already failures. It is OK to abort the; // CUDA pipeline on errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:122,failure,failures,122,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,2,"['error', 'failure']","['errors', 'failures']"
Availability,"// Cache for the ""fake"" buffer used for error-recovery purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:40,error,error-recovery,40,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error-recovery']
Availability,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,redundant,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,2,"['avail', 'redundant']","['available', 'redundant']"
Availability,"// Cache the redirection in the previously-inserted entry, still available; // in the tentative return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:65,avail,available,65,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['avail'],['available']
Availability,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:42,error,error,42,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['error'],['error']
Availability,// Cached register mask interference info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:19,mask,mask,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,1,['mask'],['mask']
Availability,// Cached results from CallerCalleePair to the number of available call paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h:57,avail,available,57,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,1,['avail'],['available']
Availability,// Calculate a possible zero extend mask for this constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Calculate enabled checkers with the correct registration order. As this is; // done recursively, its arguably cheaper, but for sure less error prone to; // recalculate from scratch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:140,error,error,140,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['error'],['error']
Availability,"// Calculate error in linear approximation from variations and correlation coefficient",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:13,error,error,13,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,4,['error'],['error']
Availability,"// Calculate external error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:22,error,error,22,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,1,['error'],['error']
Availability,// Calculate how to scale down to 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:26,down,down,26,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,2,['down'],['down']
Availability,"// Calculate mask and reference plot bins for non-iterating variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:13,mask,mask,13,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['mask'],['mask']
Availability,"// Calculate mask and reference plot bins for non-iterating variables,; // and get ranges for iterating variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:13,mask,mask,13,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['mask'],['mask']
Availability,// Calculate mask for extended hash bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:13,mask,mask,13,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['mask'],['mask']
Availability,// Calculate masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:13,mask,masks,13,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['mask'],['masks']
Availability,// Calculate new mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['mask']
Availability,"// Calculate poisson errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:21,error,errors,21,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['error'],['errors']
Availability,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:22,down,down,22,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,3,['down'],['down']
Availability,// Calculate the mask corresponding to the visited def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,1,['mask'],['mask']
Availability,"// Calculate the masks needed for the new input shuffles, which get padded; // with undef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:17,mask,masks,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['masks']
Availability,"// Calculate the reconstruction mask for this shuffle, as the mask needed to; // take the packed values from Op0/Op1 and reconstructing to the original; // order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['mask'],['mask']
Availability,"// Calculated corrected errors for weighted likelihood fits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:24,error,errors,24,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,2,['error'],['errors']
Availability,"// Call ::dup2 and report errMsg on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:36,failure,failure,36,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,1,['failure'],['failure']
Availability,"// Call CINT to perform constructor call. Catch any error thrown by argument conversion method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:52,error,error,52,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['error'],['error']
Availability,"// Call HandlePhysRegKill() for all live registers clobbered by Mask.; // Clobbered registers are always dead, sp there is no need to use; // HandlePhysRegDef().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:64,Mask,Mask,64,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['Mask'],['Mask']
Availability,"// Call ShowMember() on obj.; // This could be faster if we implemented this either as a templated; // function or by rootcint-generated code using the typeid (i.e. the; // difference is a lookup in a TList instead of in a map).; // To avoid a spurious error message in case the data member is; // transient and does not have a dictionary we check first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx:253,error,error,253,core/base/src/TMemberInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx,1,['error'],['error']
Availability,// Call error() if we have an error and it will exit with a status of 1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:8,error,error,8,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,2,['error'],['error']
Availability,"// Call getAArch64ArchFeaturesFromMarch only if ""-Wa,-march="" or; // ""-Xassembler -march"" is detected. Otherwise it may return false; // and causes Clang to error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp:157,error,error,157,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,1,['error'],['error']
Availability,// Call reset to make sure we don't mix errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp:40,error,errors,40,interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,1,['error'],['errors']
Availability,"// Call site count is more reliable, so we look up the corresponding call; // target profile in caller's context profile to retrieve call site count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp:27,reliab,reliable,27,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,1,['reliab'],['reliable']
Availability,"// Call site-related attributes are available in DWARF v5. Some debuggers,; // while not fully DWARF v5-compliant, may accept these attributes as if they; // were part of DWARF v4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:36,avail,available,36,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avail'],['available']
Availability,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,repair,repair,15,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['repair'],['repair']
Availability,// Callback to repair the associated function. A new alloca is placed at the; // beginning and initialized with the values passed through arguments. The; // new alloca replaces the use of the old pointer argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,repair,repair,15,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['repair'],['repair']
Availability,// Called by signal handlers so do not lock here; // Is the PrintCrashIRInstrumentation still alive?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:94,alive,alive,94,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['alive'],['alive']
Availability,// Called when decoding an IT instruction. Sets the IT state for; // the following instructions that for the IT block. Firstcond; // corresponds to the field in the IT instruction encoding; Mask; // is in the MCOperand format in which 1 means 'else' and 0 'then'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:190,Mask,Mask,190,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['Mask'],['Mask']
Availability,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:221,redundant,redundant,221,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['redundant'],['redundant']
Availability,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:592,avail,available,592,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avail'],['available']
Availability,"// Calling the overload for instr_iterator is always correct. However, the; // definition is not available in headers, so inline the check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:97,avail,available,97,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,2,['avail'],['available']
Availability,"// Calling this an 'error' is unintuitive, but it does the right thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:20,error,error,20,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"// Calls involved in thread-local variable lookup save more registers than; // normal calls, so they need a different mask to represent this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h:118,mask,mask,118,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h,2,['mask'],['mask']
Availability,"// Can a (CMP op1, (sub 0, op2) be turned into a CMN instruction on; // the grounds that ""op1 - (-op2) == op1 + op2"" ? Not always, the C and V flags; // can be set differently by this operation. It comes down to whether; // ""SInt(~op2)+1 == SInt(~op2+1)"" (and the same for UInt). If they are then; // everything is fine. If not then the optimization is wrong. Thus general; // comparisons are only valid if op2 != 0.; //; // So, finally, the only LLVM-native comparisons that don't mention C and V; // are SETEQ and SETNE. They're the only ones we can safely use CMN for in; // the absence of information about op2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:204,down,down,204,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['down'],['down']
Availability,"// Can it be decomposed into icmp eq (X & Mask), 0 ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:42,Mask,Mask,42,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Mask'],['Mask']
Availability,// Can only let one input through the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Can this instruction generate a non-zero result when given only zeroed; // operands? This allows us to know that, given operands with false bytes; // zeroed by masked loads, that the result will also contain zeros in those; // bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:163,mask,masked,163,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['mask'],['masked']
Availability,// Can we find an appropriate register that is available throughout the life; // of the chain? Simulate liveness backwards until the end of the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['avail'],['available']
Availability,// Can we model the truncate and extension with an and mask?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Can we simplify (MaskShAmt+ShiftShAmt) ?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:20,Mask,MaskShAmt,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['Mask'],['MaskShAmt']
Availability,// Can we simplify (ShiftShAmt-MaskShAmt) ?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:31,Mask,MaskShAmt,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['Mask'],['MaskShAmt']
Availability,"// Can't determine a more specific message, so display the generic error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:67,error,error,67,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,// Can't tell us anything about T.; // Now Req cannot a substitution-error: those aren't dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:69,error,error,69,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['error'],['error']
Availability,// Can't translate locations if a SourceManager isn't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:54,avail,available,54,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,1,['avail'],['available']
Availability,"// Cannot determine error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:20,error,error,20,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,2,['error'],['error']
Availability,"// Cannot modify the predecessors inside the above loop as it will cause; // the iterators to be nullptrs, causing memory errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:122,error,errors,122,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['error'],['errors']
Availability,"// Canonicalise concat_vectors to replace concatenations of truncated nots; // with nots of concatenated truncates. This in some cases allows for multiple; // redundant negations to be eliminated.; // (concat_vectors (v4i16 (truncate (not (v4i32)))),; // (v4i16 (truncate (not (v4i32))))); // ->; // (not (concat_vectors (v4i16 (truncate (v4i32))),; // (v4i16 (truncate (v4i32)))))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:159,redundant,redundant,159,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redundant'],['redundant']
Availability,// Canonicalization of binary shuffle masks to improve pattern matching by; // commuting the inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,masks,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['masks']
Availability,"// Canonicalization: If mask does not select elements from an input vector,; // replace that input vector with poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:139,mask,mask,139,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// Canonicalize a unary shuffle after the cast if neither operation changes; // the size or element size of the input vector.; // TODO: We could allow size-changing ops if that doesn't harm codegen.; // cast (shuffle X, Mask) --> shuffle (cast X), Mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:220,Mask,Mask,220,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,2,['Mask'],['Mask']
Availability,"// Canonicalize shuffle undef, v -> v, undef. Commute the shuffle mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Canonicalize the AND to have the mask on the RHS,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Canonicalize the combined shuffle mask chain with horizontal ops.; // NOTE: This may update the Ops and Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Canonicalize the combined shuffle mask chain with horizontal ops.; // NOTE: This will update the Ops and Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Canonicalize the expression in an attempt to have fewer unique masks; // and therefore fewer registers used to hold the masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:66,mask,masks,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,4,['mask'],['masks']
Availability,"// Canonicalize the operands; // We want 'and %val, %mask'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Canonicalize the shuffle with any horizontal ops inputs.; // NOTE: This may update Ops and Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,Mask,Mask,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Canonicalize to a mask and wider compare if the wide type is suitable:; // (trunc X to i8) == C --> (X & 0xff) == (zext C),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// Cap of # errors emitted, 0 -> no limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:12,error,errors,12,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"// Cap the length of the string at however many bytes we have available,; // plus one for the required null terminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:62,avail,available,62,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,1,['avail'],['available']
Availability,"// Cap the size growth from profile guided inlining. This is needed even; // though cost of each inline candidate already accounts for callee size,; // because with top-down inlining, we can grow inliner size significantly; // with large number of smaller inlinees each pass the cost check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:169,down,down,169,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['down'],['down']
Availability,"// Capture the context of CB before inlining, as a successful inlining may; // change that context, and we want to report success or failure in the; // original context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:133,failure,failure,133,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,1,['failure'],['failure']
Availability,// Capture the emitted diagnostics and report them to the client; // in the case of a failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:86,failure,failure,86,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['failure'],['failure']
Availability,"// Captures diagnostics into a vector, optionally reporting errors to gtest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:60,error,errors,60,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,1,['error'],['errors']
Availability,"// Careful: if the neg can be folded up, don't try to pull it back down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:67,down,down,67,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['down'],['down']
Availability,"// Case (1): or (and A, mask), val => ARMbfi A, val, mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],['mask']
Availability,"// Case (3): or (and (shl A, #shamt), mask), B => ARMbfi B, A, ~mask; // where lsb(mask) == #shamt and masked bits of B are known zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,4,['mask'],"['mask', 'masked']"
Availability,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,mask,masked,83,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masked']
Availability,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:323,mask,masked-store,323,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['masked-store']
Availability,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:181,avail,available,181,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,3,"['avail', 'down']","['available', 'down']"
Availability,// Cast combination can't happen (error in input). This is for all cases; // where the MidTy is not the same for the two cast instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:34,error,error,34,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['error'],['error']
Availability,// Cast mask to an integer type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Cast the mask to an i1 vector and then extract the lowest element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,"// Cast to other types through float, using either the intrinsic or FPExt,; // depending on whether the half type itself is supported; // (as opposed to operations on half, available with NativeHalfType).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:173,avail,available,173,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['avail'],['available']
Availability,"// Catch error condition: data present where zero events are predicted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx:9,error,error,9,roofit/roofitcore/src/RooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx,3,['error'],['error']
Availability,"// Catch this common potential error here; // We have to set kRawSize (unless already done) to allocate buffer space; // before kRaw can be filled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:31,error,error,31,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['error'],['error']
Availability,// Causes crash on allocation failure. It is called prior to the handler set by; // 'install_bad_alloc_error_handler'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:30,failure,failure,30,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['failure'],['failure']
Availability,// Change the predicate and update the mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,1,['mask'],['mask']
Availability,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:89,failure,failure,89,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:27,failure,failure,27,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,redundant,redundant,258,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,1,['redundant'],['redundant']
Availability,// Check PHI nodes in successors that expect a value to be available from this; // block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avail'],['available']
Availability,// Check all elements are used once in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:300,avail,available,300,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['avail'],['available']
Availability,"// Check an assertion: Obtain the condition value and be sure it is true.; // If not, print a nonfatal error along with the message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp:103,error,error,103,interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,1,['error'],['error']
Availability,// Check and apply the optional mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['mask'],['mask']
Availability,// Check and update the optional mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['mask'],['mask']
Availability,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:9,avail,availability,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,2,['avail'],"['availability', 'available']"
Availability,// Check availability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:9,avail,availability,9,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avail'],['availability']
Availability,// Check both offsets (or masks for MIMG) can be combined and fit in the; // reduced range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:26,mask,masks,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['mask'],['masks']
Availability,// Check code object version options. Emit warnings for legacy options; // and errors for the last invalid code object version options.; // It is done here to avoid repeated warning or error messages for; // each tool invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:79,error,errors,79,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,2,['error'],"['error', 'errors']"
Availability,// Check consitency of records. Return true if an error has been detected.; // Return false if the records are valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp:50,error,error,50,interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,1,['error'],['error']
Availability,"// Check current mappings for new -Werror mappings, and the stored mappings; // for cases that were explicitly mapped to *not* be errors that are now; // errors because of options like -Werror.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:130,error,errors,130,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,['error'],['errors']
Availability,// Check each AvailabilityAttr to find the one for this platform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:14,Avail,AvailabilityAttr,14,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['Avail'],['AvailabilityAttr']
Availability,"// Check each possible rename register for SuperReg in round-robin; // order. If that register is available, and the corresponding; // registers are available for the other group subregisters, then we; // can use those registers to rename.; // FIXME: Using getMinimalPhysRegClass is very conservative. We should; // check every use of the register and find the largest register class; // that can be used in all of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:98,avail,available,98,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,2,['avail'],['available']
Availability,// Check each user of GEPIOp to check if unmerging would make GEPIOp not alive; // on IndirectBr edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:73,alive,alive,73,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['alive'],['alive']
Availability,"// Check error rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:9,error,error,9,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['error'],['error']
Availability,"// Check error reporting and handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx:9,error,error,9,core/metacling/test/TClingTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx,1,['error'],['error']
Availability,"// Check every two hours if client is still alive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:44,alive,alive,44,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['alive'],['alive']
Availability,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:85,error,error,85,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// Check for -stdlib= flags. We only support libc++ but this consumes the arg; // if the value is libc++, and emits an error for other values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:119,error,error,119,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,1,['error'],['error']
Availability,// Check for Dyld error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:18,error,error,18,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,1,['error'],['error']
Availability,"// Check for EOF or stream failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/Stringio.cxx:27,failure,failure,27,core/base/src/Stringio.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/Stringio.cxx,1,['failure'],['failure']
Availability,"// Check for Neon shuffles that modify both input vectors in place.; // If both results are used, i.e., if there are two shuffles with the same; // source operands and with masks corresponding to both results of one of; // these operations, DAG memoization will ensure that a single node is; // used for both shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:173,mask,masks,173,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['masks']
Availability,"// Check for SSSE3 which lets us lower all v16i8 shuffles much more directly; // with PSHUFB. It is important to do this before we attempt to generate any; // blends but after all of the single-input lowerings. If the single input; // lowerings can find an instruction sequence that is faster than a PSHUFB, we; // want to preserve that and we can DAG combine any longer sequences into; // a PSHUFB in the end. But once we start blending from multiple inputs,; // the complexity of DAG combining bad patterns back into PSHUFB is too high,; // and there are *very* few patterns that would actually be faster than the; // PSHUFB approach because of its ability to zero lanes.; //; // If the mask is a binary compaction, we can more efficiently perform this; // as a PACKUS(AND(),AND()) - which is quicker than UNPACK(PSHUFB(),PSHUFB()).; //; // FIXME: The only exceptions to the above are blends which are exact; // interleavings with direct instructions supporting them. We currently don't; // handle those well here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:689,mask,mask,689,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,recover,recover,39,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,4,['recover'],['recover']
Availability,// Check for a plain register or register mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,1,['mask'],['mask']
Availability,// Check for an available register in this class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['avail'],['available']
Availability,"// Check for an undef mask and a mask value properly aligned to fit with; // a pair of values. If we find such a case, use the non-undef mask's value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],['mask']
Availability,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,Mask,Mask,151,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,7,['Mask'],['Mask']
Availability,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:310,error,errors,310,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['errors']
Availability,// Check for conversion failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,failure,failure,24,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['failure'],['failure']
Availability,// Check for correct shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check for equality comparisons with the mask, or the equivalent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Check for error condition which is already reported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,// Check for error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,3,['error'],['error']
Availability,"// Check for errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:13,error,errors,13,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,3,['error'],['errors']
Availability,"// Check for errors if available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13,error,errors,13,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,"['avail', 'error']","['available', 'errors']"
Availability,"// Check for errors in Nexpected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:13,error,errors,13,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['error'],['errors']
Availability,"// Check for errors in module generation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:13,error,errors,13,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['errors']
Availability,"// Check for errors...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:13,error,errors,13,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['error'],['errors']
Availability,// Check for illegal shuffle mask element index values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check for missing argument error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:30,error,error,30,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,4,['error'],['error']
Availability,// Check for non-undef masks pointing at an undef vector and make the masks; // undef as well. This makes it easier to match the shuffle based solely on; // the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,masks,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],"['mask', 'masks']"
Availability,// Check for out-of-range target shuffle mask indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check for redundant/conflicting ownership qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:13,redundant,redundant,13,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redundant'],['redundant']
Availability,// Check for soft failure of the match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:18,failure,failure,18,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['failure'],['failure']
Availability,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,redundant,redundant,204,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,redundant,redundant,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redundant'],['redundant']
Availability,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,error,errors,33,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,3,"['error', 'failure']","['errors', 'failure']"
Availability,// Check for viability and report error if casting an rvalue to a; // life-time qualifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,error,error,34,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['error'],['error']
Availability,// Check if AvailableAnalysis map has one entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:12,Avail,AvailableAnalysis,12,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['Avail'],['AvailableAnalysis']
Availability,"// Check if EFLAGS are alive by seeing if there is a def of them or they; // live-in, and then seeing if that def is in turn used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:23,alive,alive,23,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['alive'],['alive']
Availability,// Check if GNU-style InlineAsm is disabled.; // Error on anything other than empty string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:49,Error,Error,49,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['Error'],['Error']
Availability,// Check if LLT sizes match sizes of available register banks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,1,['avail'],['available']
Availability,"// Check if LR is available through all of the MBB. If it's not, then set; // a flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['avail'],['available']
Availability,"// Check if M starts with a contiguous sequence of W times 1 bits. Get; // the low U bits of M (which eliminates the 0 bits shifted in on the; // left), and check if the result is APInt's ""mask"":",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:189,mask,mask,189,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,1,['mask'],['mask']
Availability,// Check if OpenCL C version is contained in a given encoded OpenCL C version; // mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h:82,mask,mask,82,interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,1,['mask'],['mask']
Availability,"// Check if \p Ty is a valid type for the elementwise math builtins. If it is; // not a valid type, emit an error message and return true. Otherwise return; // false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:108,error,error,108,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// Check if a node selects whole bytes from its operand 0 starting at a byte; // boundary while masking the rest. Returns select mask as in the v_perm_b32; // or -1 if not succeeded.; // Note byte select encoding:; // value 0-3 selects corresponding source byte;; // value 0xc selects zero;; // value 0xff selects 0xff.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:96,mask,masking,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// Check if a vector is built from one vector via extracted elements of; // another together with an AND mask, ensuring that all elements fit; // within range. This can be reconstructed using AND and NEON's TBL1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:105,mask,mask,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check if all indices in Mask are Undef. In case, propagate Undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Mask,Mask,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,// Check if all the records were read or if an error occurred while reading; // the next record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:47,error,error,47,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['error'],['error']
Availability,// Check if an EXT instruction can handle the shuffle mask when the vector; // sources of the shuffle are the same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,"// Check if an epilog exists as a subset of the end of a prolog (backwards).; // An epilog may end with one out of three different end opcodes; if this; // is the first epilog that shares opcodes with the prolog, we can tolerate; // that this opcode differs (and the caller will update the prolog to use; // the same end opcode as the epilog). If another epilog already shares; // opcodes with the prolog, the ending opcode must be a strict match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:220,toler,tolerate,220,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['toler'],['tolerate']
Availability,"// Check if any of the odd lanes in the v16i8 are used. If not, we can mask; // them out and avoid using UNPCK{L,H} to extract the elements of V as; // i16s.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if each of the unsafe registers are available...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:45,avail,available,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['avail'],['available']
Availability,// Check if every byte has common bits in Bytes and Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,Mask,Mask,52,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Mask'],['Mask']
Availability,// Check if extension is supported by target and is available in this; // OpenCL version,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:52,avail,available,52,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['avail'],['available']
Availability,"// Check if file is still available, if touch is set actually read from the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:26,avail,available,26,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['avail'],['available']
Availability,// Check if frame index is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avail'],['available']
Availability,// Check if input operands are already available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,1,['avail'],['available']
Availability,"// Check if it's a shifted byte, by shifting it down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:48,down,down,48,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['down'],['down']
Availability,// Check if iteration is over or there is an error during iteration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp:45,error,error,45,interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,1,['error'],['error']
Availability,// Check if maskedFlags is non-zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,mask,maskedFlags,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,2,['mask'],['maskedFlags']
Availability,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:12,mask,masking,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,['mask'],['masking']
Availability,"// Check if numerical result is within tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testBinnedFitExecPolicy.cxx:39,toler,tolerance,39,math/mathcore/test/fit/testBinnedFitExecPolicy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testBinnedFitExecPolicy.cxx,1,['toler'],['tolerance']
Availability,// Check if our mask can be done as a 1-to-1 mapping from source; // to destination registers in the group without needing to; // write each destination more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check if replacement decision is already available in the cached table.; // if so, return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['avail'],['available']
Availability,"// Check if reuse shuffle indices can be improved by reordering.; // For this, check that reuse mask is ""clustered"", i.e. each scalar values; // is used once in each submask of size <number_of_scalars>.; // Example: 4 scalar values.; // ReuseShuffleIndices mask: 0, 1, 2, 3, 3, 2, 0, 1 - clustered.; // 0, 1, 2, 3, 3, 3, 1, 0 - not clustered, because; // element 3 is used twice in the second submask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,// Check if shuffle mask can be simplified to undef/zero/identity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if the .res file contains no entries. In this case we don't have; // to throw an error but can rather just return without parsing anything.; // This applies for files which have a valid PE header magic and the; // mandatory empty null resource entry. Files which do not fit this; // criteria would have already been filtered out by; // WindowsResource::createWindowsResource().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp:90,error,error,90,interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,1,['error'],['error']
Availability,// Check if the AND mask is an immediate of the form: 000.....1111111100,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Check if the LHS feeding the AND is impacted by the high bits that we're; // masking out.; //; // e.g. for 64-bit x, y:; //; // add_64(x, y) & 65535 == zext(add_16(trunc(x), trunc(y))) & 65535",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:80,mask,masking,80,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['masking']
Availability,// Check if the Mask's nonzero elements are in increasing order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Mask,Mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Check if the current operand has a custom associated parser, if so, try to; // custom parse the operand, or fallback to the general approach. Force all; // features to be available during the operand check, or else we will fail to; // find the custom parser, and then we will later get an InvalidOperand error; // instead of a MissingFeature errror.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:174,avail,available,174,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,"// Check if the extra components of the expressions in the enclosing; // data environment are redundant for the current base declaration.; // If they are, the maps completely overlap, which is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:94,redundant,redundant,94,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['redundant'],['redundant']
Availability,"// Check if the extracted bits are contained within the mask that it is; // and-ed with. The extract operation will copy these bits, and so the; // mask cannot any holes in it that would clear any of the bits of the; // extracted field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,2,['mask'],['mask']
Availability,// Check if the first input is tied. If there isn't one then we only; // need to skip the mask operand which we did above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:90,mask,mask,90,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,// Check if the first operand is all zeros and Cond type is vXi1.; // If this an avx512 target we can improve the use of zero masking by; // swapping the operands and inverting the condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,mask,masking,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masking']
Availability,// Check if the flag's bitmask has the bits of the current mask set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,1,['mask'],['mask']
Availability,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:522,robust,robust,522,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['robust'],['robust']
Availability,"// Check if the graph errors are sorted based on the sorted values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx:22,error,errors,22,hist/hist/test/test_TGraph_sorting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx,4,['error'],['errors']
Availability,"// Check if the indices of different trees are in order. If not then return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx:79,error,error,79,tree/treeplayer/src/TChainIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx,2,['error'],['error']
Availability,// Check if the instruction is alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:31,alive,alive,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,2,['alive'],['alive']
Availability,"// Check if the mask can be mapped to a TRUNCATE or VTRUNC, truncating the; // source into the lower elements and zeroing the upper elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check if the mask is -1. In that case, this is an unnecessary instruction; // that escaped earlier analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Check if the mask is known to be all ones,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,// Check if the mask matches a DUP for a wider element,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,redundant,redundant,35,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,// Check if the resources occupied by a MCInstrDesc are available in the; // current state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:56,avail,available,56,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,1,['avail'],['available']
Availability,// Check if the resources occupied by a MCInstrDesc are available in; // the current state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['avail'],['available']
Availability,// Check if the resources occupied by a machine instruction are available; // in the current state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:64,avail,available,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,2,['avail'],['available']
Availability,// Check if the runtime trip count is too small when profile is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:64,avail,available,64,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['avail'],['available']
Availability,"// Check if the scalar load can be widened into a vector load. And if; // the address is ""base + cst"" see if the cst can be ""absorbed"" into; // the shuffle mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:156,mask,mask,156,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:64,avail,available,64,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['avail'],['available']
Availability,// Check if the scope of this variable location is alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:51,alive,alive,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,2,['alive'],['alive']
Availability,// Check if the second half of the mask is all-undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,// Check if the shuffle mask accesses only the low half of each input vector; // (half-index output is 0 or 2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if the shuffle mask is suitable for the AVX vpunpcklwd or vpunpckhwd; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check if the sign bits of source go down as far as the truncated value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:39,down,down,39,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,3,['down'],['down']
Availability,"// Check if the symbol is available without loading the library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:26,avail,available,26,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['avail'],['available']
Availability,// Check if the target register is available here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['avail'],['available']
Availability,// Check if there are already splitted versions of the vector available and; // use those instead of splitting the mask operand again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp:62,avail,available,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// Check if there are errors inside the chain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:22,error,errors,22,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['error'],['errors']
Availability,// Check if there is an available GPR before hitting the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avail'],['available']
Availability,// Check if there is an available register across the sequence that we can; // use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,['avail'],['available']
Availability,// Check if there is an expected trip count available from profile data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avail'],['available']
Availability,// Check if there was an syntax or semantic error during parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:44,error,error,44,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"// Check if this actually represents a binned dataset, and then import it; // like a RooDataHist. This happens frequently when people create combined; // RooDataSets from binned data to fit HistFactory models. In this case, it; // doesn't make sense to export them like an unbinned dataset, because the; // coordinates are redundant information with the binning. We only do this; // for 1D data for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:323,redundant,redundant,323,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['redundant'],['redundant']
Availability,"// Check if this instruction is supported. Otherwise, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:64,error,error,64,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['error'],['error']
Availability,// Check if this is an error that is accidentally in a warning; // group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp:23,error,error,23,interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,1,['error'],['error']
Availability,"// Check if this pass is suitable for the current LPPassManager, if; // available. This pass P is not suitable for a LPPassManager if P; // is not preserving higher level analysis info used by other; // LPPassManager passes. In such case, pop LPPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:72,avail,available,72,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,2,['avail'],['available']
Availability,"// Check if this register operand is independent according to `Mask`.; // Note that Mask may not have enough bits to describe all explicit and; // implicit input operands. If this register operand doesn't have a; // corresponding bit in Mask, then conservatively assume that it is; // dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:63,Mask,Mask,63,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,3,['Mask'],['Mask']
Availability,"// Check if variable is at least a range or constant else throw error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIOUtils.cxx:64,error,error,64,roofit/hs3/src/JSONIOUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIOUtils.cxx,1,['error'],['error']
Availability,// Check if we are at the end of the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['mask'],['mask']
Availability,"// Check if we are here because client is closed. Try to ping client,; // if that works it we are here because some slave died",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:57,ping,ping,57,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['ping'],['ping']
Availability,// Check if we are working with mask vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check if we can find a physical register for renaming \p Reg. This register; // must:; // * not be defined already in \p DefinedInBB; DefinedInBB must contain all; // defined registers up to the point where the renamed register will be used,; // * not used in \p UsedInBetween; UsedInBetween must contain all accessed; // registers in the range the rename register will be used,; // * is available in all used register classes (checked using RequiredClasses).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:391,avail,available,391,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['avail'],['available']
Availability,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:60,down,down,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['down'],['down']
Availability,"// Check if we can replace AND+IMM{32,64} with a shift. This is possible; // for masks like 0xFF000000 or 0x00FFFFFF and if we care only about the; // zero flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:81,mask,masks,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// Check if we encountered an error for one the string insturctions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['error']
Availability,// Check if we have a Subtarget feature mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp,1,['mask'],['mask']
Availability,"// Check if we have a cached safety value from parallel world, and if this can still be used.; // Return negative value if no cache available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:132,avail,available,132,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['avail'],['available']
Availability,"// Check if we need to download: get the remote checksum; // Retrieve the checksum of the file, if available; // Dowload checksum file, if available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:23,down,download,23,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,3,"['avail', 'down']","['available', 'download']"
Availability,"// Check if we passed LTO options but they were suppressed because this is a; // device offloading action, or we passed device offload LTO options which; // were suppressed because this is not the device offload action.; // Check if we are using PS4 in regular LTO mode.; // Otherwise, issue an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:295,error,error,295,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"// Check if we should prefer a vector store that will become a .new version.; // The .new store uses different resources than a normal store, and the; // packetizer will not generate the .new if the regular store does not have; // resources available (even if the .new version does). To help, the schedule; // attempts to schedule the .new as soon as possible in the packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:241,avail,available,241,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['avail'],['available']
Availability,// Check if we're getting a shuffle mask with zero'd elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check intrinsics that are available in [sve2p1 or sme/sme2].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,avail,available,29,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['avail'],['available']
Availability,"// Check non-power-of-2 loads/stores for legal vector element types with; // NEON. Non-power-of-2 memory ops will get broken down to a set of; // operations on smaller power-of-2 ops, including ld1/st1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:125,down,down,125,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['down'],['down']
Availability,// Check parameter attributes against a function type.; // The value V is printed in error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:85,error,error,85,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,// Check successor nodes' PHI nodes that expect a constant to be available; // from this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:65,avail,available,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['avail'],['available']
Availability,// Check that D is not yet in DiagnosedConflictingDefinitions is required; // to make sure that we issue an error only once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:108,error,error,108,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['error'],['error']
Availability,// Check that GD is not yet in DiagnosedConflictingDefinitions is required; // to make sure that we issue an error only once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['error'],['error']
Availability,"// Check that GEP is used outside the block, meaning it's alive on the; // IndirectBr edge(s).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:58,alive,alive,58,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['alive'],['alive']
Availability,"// Check that InternedResult matches up with MR->getSymbols(), overriding; // flags if requested.; // This guards against faulty transformations / compilers / object caches.; // First check that there aren't any missing symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:122,fault,faulty,122,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['fault'],['faulty']
Availability,"// Check that LEA def register can be used as MI address base. Some; // instructions can use a limited set of registers as address base, for; // example MOV8mr_NOREX. We could constrain the register class of the LEA; // def to suit MI, however since this case is very rare and hard to; // reproduce in a test it's just more reliable to skip the LEA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:324,reliab,reliable,324,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['reliab'],['reliable']
Availability,// Check that RHS is available in this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avail'],['available']
Availability,// Check that SVE types are only used in functions with SVE available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,avail,available,60,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,// Check that TrueVal is a constant instead of matching it with m_Zero(); // to handle the case when it is a scalar undef value or a vector containing; // non-zero elements that are masked by undef elements in the compare; // constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:182,mask,masked,182,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['masked']
Availability,"// Check that a call to a target specific builtin has the correct target; // features.; // This is down here to avoid non-target specific builtins, however, if; // generic builtins start to require generic target features then we; // can move this up to the beginning of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:99,down,down,99,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['down'],['down']
Availability,"// Check that all input files have the same machine type.; // Mixing normal objects and LTO bitcode files is fine as long as they; // have the same machine type.; // Doing this here duplicates the header parsing work that writeArchive(); // below does, but it's not a lot of work and it's a bit awkward to do; // in writeArchive() which needs to support many tools, can't assume the; // input is COFF, and doesn't have a good way to report errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-lib/LibDriver.cpp:440,error,errors,440,interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-lib/LibDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-lib/LibDriver.cpp,1,['error'],['errors']
Availability,"// Check that all the sources are coming from the same lane and see if we; // can form a repeating shuffle mask (local to each sub-lane). At the same; // time, determine the source sub-lane for each destination sub-lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:107,mask,mask,107,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check that all uses of the instruction, if they are instructions; // themselves, actually have parent basic blocks. If the use is not an; // instruction, it is an error!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:166,error,error,166,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,// Check that any values available outside of the loop will be the same; // after tail predication conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:25,avail,available,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['avail'],['available']
Availability,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masks']"
Availability,// Check that each group of lanes in the mask are either undef or make a valid; // mask for the wider lane type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Check that mask and shift compliment eachother,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Check that non-undef values are the same as in the mask. If they; // aren't then give up,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['mask'],['mask']
Availability,// Check that our new mask is a subset of the demanded mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:251,down,down,251,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['down'],['down']
Availability,// Check that the FileEntry is not null because it was not resolved and; // we create a PCH even with compiler errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:111,error,errors,111,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['error'],['errors']
Availability,// Check that the and mask is correct for the shift,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Check that the and mask is the same as the one we decided to put on the; // new and.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['mask'],['mask']
Availability,// Check that the available copy isn't clobbered by any regmasks between; // itself and the destination.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,"// Check that the column ranges for model-extended subfields are properly constructed by iterating over their view.; // For improper column ranges, the global field range would go until the value of kInvalidClusterIndex and result in; // an out-of-bounds error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:255,error,error,255,tree/ntuple/v7/test/ntuple_modelext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx,1,['error'],['error']
Availability,// Check that the constant bitmask masks whole bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,mask,masks,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// Check that the contained objects class name is part of the element title.; // This name is mandatory when reading the tree later on and; // the parent class with the pointer to the STL container is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:205,avail,available,205,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['avail'],['available']
Availability,// Check that the extension bits are don't-care (i.e. are masked out; // by the final mask).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,mask,masked,58,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// Check that the indices are consecutive, in the case of a multi-byte element; // splatted with a v16i8 mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,mask,mask,105,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check that the mask allows a multiple of 8 bits for a bswap, for an; // early exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['mask'],['mask']
Availability,// Check that the mask is a broadcast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check that the materialization of the repairing is possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:41,repair,repairing,41,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// Check that the operation in question is available (most are plain SSE2,; // but PCMPGTQ and PCMPEQQ have different requirements).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Check that the required non-target libraries are all available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:56,avail,available,56,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['avail'],['available']
Availability,// Check that the shuffle mask can be broken evenly between the; // different sources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,"// Check that the shuffle mask matches the semantics of XXSPLTI32DX.; // The instruction splats a constant C into two words of the source vector; // producing { C, Unchanged, C, Unchanged } or { Unchanged, C, Unchanged, C }.; // Thus we check that the shuffle mask is the equivalent of; // <0, [4-7], 2, [4-7]> or <[4-7], 1, [4-7], 3> respectively.; // Note: the check above of isNByteElemShuffleMask() ensures that the bytes; // within each word are consecutive, so we only need to check the first byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,// Check that the source of the element keeps flipping; // (i.e. Mask[i] < NumElts -> Mask[i+i] >= NumElts).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:65,Mask,Mask,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['Mask'],['Mask']
Availability,"// Check that the start value is a multiple of the VectorWidth.; // TODO: This could do with a method to check if the scev is a multiple of; // VectorWidth. For the moment we just check for constants, muls and unknowns; // (which use MaskedValueIsZero and seems to be the most common).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:234,Mask,MaskedValueIsZero,234,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['Mask'],['MaskedValueIsZero']
Availability,// Check that the stored value is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avail'],['available']
Availability,"// Check that ubfx can do the extraction, with no holes in the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,"// Check that we successfully analyzed the mask, and normalize the results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,// Check that we're defining V0 as a mask register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Check that we're using V0 as a mask register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Mask,Mask,18,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,3,['Mask'],['Mask']
Availability,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Mask,Mask,18,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,3,['Mask'],['Mask']
Availability,"// Check the 'this' pointer once per function, if it's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:55,avail,available,55,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['avail'],['available']
Availability,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:565,down,down,565,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['down'],['down']
Availability,// Check the bundle for errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:24,error,errors,24,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,3,['error'],['errors']
Availability,// Check the constant mask. Invert it so that the bits being masked out are; // 0 and the bits being kept are 1. Use getSExtValue so that leading bits; // follow the sign bit for uniformity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// Check the header for errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:24,error,errors,24,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['error'],['errors']
Availability,// Check the immediate mask and replace unused sources with undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check the mask and VL are the same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,// Check the mask and VL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// Check the mask extracts either the lower or upper half of vector; // elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Check the mask is 1,0,3,2,5,4,...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check the opcode pattern. We apply the mask on the opcode arguments and; // then check if it is what we expect.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Check the operands are the same as the original, or reversed (in which; // case we need to commute the mask).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:106,mask,mask,106,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,// Check the operands of the MDNode before accessing the operands.; // The verifier will actually catch these failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:110,failure,failures,110,interpreter/llvm-project/llvm/lib/IR/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp,1,['failure'],['failures']
Availability,"// Check the parsed register group ""Reg.Group"" with the expected ""Group""; // Have to error out if user specified wrong prefix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:85,error,error,85,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['error'],['error']
Availability,// Check the second operand: the supposed mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Check the target size with a 5% tolerance to account for small fluctuations across different platforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx:35,toler,tolerance,35,tree/ntupleutil/v7/test/ntuple_inspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx,2,['toler'],['tolerance']
Availability,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,avail,available,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// Check to see if IVal is all zeros in the part being masked in by the 'or'; // that uses this. If not, this is not a replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,mask,masked,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,// Check to see if Mask is valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,Mask,Mask,19,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['Mask'],['Mask']
Availability,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,avail,available,98,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,['avail'],['available']
Availability,// Check to see if our mask is the same. If not the resulting flag bits; // may be different and we can't remove the ptest.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['mask'],['mask']
Availability,// Check to see if the mask appeared in both the AND and ANDNP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Check to see if these are inside the absolute tolerance,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:49,toler,tolerance,49,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['toler'],['tolerance']
Availability,"// Check to see if we got the pointer another way. This can happen when; // enumerating recursive types that hit the base case deeper than they start.; //; // If this is actually a struct that we are treating as forward ref'able,; // then emit the definition now that all of its contents are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:292,avail,available,292,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['avail'],['available']
Availability,"// Check to see if we have a call with 2 vector arguments, the unary shuffle; // with mask. If so, verify that RHS is an integer vector type with the; // same number of elts as lhs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,mask,mask,86,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['mask'],['mask']
Availability,"// Check to see if we have already visited this pred block with another; // pointer. If so, we can't do this lookup. This failure can occur; // with PHI translation when a critical edge exists and the PHI node in; // the successor translates to a pointer value different than the; // pointer the block was first analyzed with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,failure,failure,122,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['failure'],['failure']
Availability,"// Check to see whether Res is a function designator only. If it is and we; // are compiling for OpenCL, we need to return an error as this implies; // that the address of the function is being taken, which is illegal in CL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:126,error,error,126,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,"// Check to see whether we could do some optimization; // to attach relocation to downstream dependent instructions.; // Two kinds of patterns are recognized below:; // Pattern 1:; // %1 = LD_imm64 @""llvm.b:0:4$0:1"" <== patch_imm = 4; // %2 = LDD %1, 0 <== this insn will be removed; // %3 = ADD_rr %0, %2; // %4 = LDW[32] %3, 0 OR STW[32] %4, %3, 0; // The `%4 = ...` will be transformed to; // CORE_[ALU32_]MEM(%4, mem_opcode, %0, @""llvm.b:0:4$0:1""); // and later on, BTF emit phase will translate to; // %4 = LDW[32] %0, 4 STW[32] %4, %0, 4; // and attach a relocation to it.; // Pattern 2:; // %15 = LD_imm64 @""llvm.t:5:63$0:2"" <== relocation type 5; // %16 = LDD %15, 0 <== this insn will be removed; // %17 = SRA_rr %14, %16; // The `%17 = ...` will be transformed to; // %17 = CORE_SHIFT(SRA_ri, %14, @""llvm.t:5:63$0:2""); // and later on, BTF emit phase will translate to; // %r4 = SRA_ri %r4, 63",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:82,down,downstream,82,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,1,['down'],['downstream']
Availability,"// Check uses of this function for other than direct calls or invokes to it.; // Inline virtual functions have linkeOnceODR linkage. When a key method; // exists, the vtable will only be emitted in the TU where the key method; // is defined. In a TU where vtable is not available, the function won't; // be 'addresstaken'. If its address is not recorded here, the profile data; // with missing address may be picked by the linker leading to missing; // indirect call target info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:270,avail,available,270,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avail'],['available']
Availability,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:38,redundant,redundant,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,3,['redundant'],['redundant']
Availability,"// Check whether FADD is available, as a proxy for floating-point in; // general.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:25,avail,available,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['avail'],['available']
Availability,// Check whether a value was added to either CurInfo or; // StructBaseCurInfo and error if no value was added to either of; // them:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:82,error,error,82,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['error'],['error']
Availability,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Mask,Mask,29,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,4,"['MASK', 'Mask', 'mask']","['MASK', 'Mask', 'mask']"
Availability,// Check whether every element of Mask is the same constant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Mask,Mask,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Mask'],['Mask']
Availability,// Check whether next instruction kills the spilled register.; // FIXME: Current solution does not cover search for killed register in; // bundles and instructions further down the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:172,down,down,172,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['down'],['down']
Availability,"// Check whether the class is available for auto-loading first:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:30,avail,available,30,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avail'],['available']
Availability,"// Check whether the combination of mask, comparison value and comparison; // type are suitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Check whether the high part is an AND that doesn't change the; // high 32 bits and just masks out low bits. We can skip it if so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,mask,masks,91,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['masks']
Availability,"// Check whether the mask is suitable for TMHH, TMHL, TMLH or TMLL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Check whether the nonconstant input is an AND with a constant mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Check whether the operand is already available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avail'],['available']
Availability,"// Check whether the original node or the incoming node has the higher; // priority namespace. Depending on which one is dominant, we will have; // to recursively apply namespace changes down to children of the original; // node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:187,down,down,187,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,1,['down'],['down']
Availability,"// Check whether the user wants to suppress errors for this specific branch; // if it is missing. This information is used here to act in the situation; // where the first tree of the chain does not contain that branch. In such; // case, we need to postpone the creation of the corresponding proxy until; // we find the branch in a following tree of the chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:44,error,errors,44,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['error'],['errors']
Availability,"// Check whether the user wants to suppress errors for this specific branch; // if it is missing. We have to use this information differently in two; // different situations:; // - If the branch was present in the first tree of the chain, but missing; // when switching to a new tree; // - If the branch is missing from the first tree already. In this case we; // also need to postpone the creation of the branch proxy until at least; // one tree in the chain has that branch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:44,error,errors,44,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['error'],['errors']
Availability,// Check whether there was a previous failed import.; // If yes return the existing error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:84,error,error,84,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,// Check whether this instance is a subclass of ErrorInfoT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:48,Error,ErrorInfoT,48,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorInfoT']
Availability,// Check whether this module is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:32,avail,available,32,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['avail'],['available']
Availability,"// Check whether we have at least one masked vector version of a scalar; // function. If no VF is specified then we check for any masked variant,; // otherwise we look for one that matches the supplied VF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:38,mask,masked,38,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['mask'],['masked']
Availability,// Check whether we have equal-size ranges that only differ by one bit.; // In that case we can apply a mask to map one range onto the other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:404,avail,available,404,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avail'],['available']
Availability,"// Check whether we're masking/truncating an OR-reduction result, in which; // case track the masked bits.; // TODO: Add CmpAllOnes support.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,masking,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['masked', 'masking']"
Availability,// Check which register units are alive throughout the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:34,alive,alive,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['alive'],['alive']
Availability,"// CheckNonTypeTemplateParameterType will produce a diagnostic if there's; // an error. The error message normally references the parameter; // declaration, but here we'll pass the argument location because that's; // where the parameter type is deduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,error,error,81,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['error'],['error']
Availability,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,error,error,77,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['error'],"['error', 'errors']"
Availability,// Checks hardware and software support for current benchmark mode.; // Returns an error if the target host does not have support to run the; // benchmark.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:83,error,error,83,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['error'],['error']
Availability,"// Checks if the -faltivec-src-compat=gcc option is specified.; // If so, AltiVecVector, AltiVecBool and AltiVecPixel types are; // treated the same way as they are when trying to initialize; // these vectors on gcc (an error is emitted).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:220,error,error,220,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,// Checks if the mask's zeros elements are built from only zeros.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Checks if there are enough physical registers in the register files.; // Returns a ""response mask"" where each bit represents the response from a; // different register file. A mask of all zeroes means that all register; // files are available. Otherwise, the mask can be used to identify which; // register file was busy. This sematic allows us to classify dispatch; // stalls caused by the lack of register file resources.; //; // Current implementation can simulate up to 32 register files (including the; // special register file at index #0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:96,mask,mask,96,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,4,"['avail', 'mask']","['available', 'mask']"
Availability,// Checks if we should emit the availability diagnostic in the context of C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:32,avail,availability,32,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:220,error,error,220,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"// Checks whether the shuffle mask represents a vector transpose (VTRN) by; // checking that pairs of elements in the shuffle mask represent the same index; // in each vector, incrementing the expected index by 2 at each step.; // e.g. For v1,v2 of type v4i32 a valid shuffle mask is: [0, 4, 2, 6]; // v1={a,b,c,d} => x=shufflevector v1, v2 shufflemask => x={a,e,c,g}; // v2={e,f,g,h}; // WhichResult gives the offset for each element in the mask based on which; // of the two results it belongs to.; //; // The transpose can be represented either as:; // result1 = shufflevector v1, v2, result1_shuffle_mask; // result2 = shufflevector v1, v2, result2_shuffle_mask; // where v1/v2 and the shuffle masks have the same number of elements; // (here WhichResult (see below) indicates which result is being checked); //; // or as:; // results = shufflevector v1, v2, shuffle_mask; // where both results are returned in one vector and the shuffle mask has twice; // as many elements as v1/v2 (here WhichResult will always be 0 if true) here we; // want to check the low half and high half of the shuffle mask as if it were; // the other case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,7,['mask'],"['mask', 'masks']"
Availability,"// Checks whether the shuffle mask represents a vector unzip (VUZP) by checking; // that the mask elements are either all even and in steps of size 2 or all odd; // and in steps of size 2.; // e.g. For v1,v2 of type v4i32 a valid shuffle mask is: [0, 2, 4, 6]; // v1={a,b,c,d} => x=shufflevector v1, v2 shufflemask => x={a,c,e,g}; // v2={e,f,g,h}; // Requires similar checks to that of isVTRNMask with; // respect the how results are returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['mask'],['mask']
Availability,"// Checks whether the shuffle mask represents a vector zip (VZIP) by checking; // that pairs of elements of the shufflemask represent the same index in each; // vector incrementing sequentially through the vectors.; // e.g. For v1,v2 of type v4i32 a valid shuffle mask is: [0, 4, 1, 5]; // v1={a,b,c,d} => x=shufflevector v1, v2 shufflemask => x={a,e,b,f}; // v2={e,f,g,h}; // Requires similar checks to that of isVTRNMask with respect the how results; // are returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],['mask']
Availability,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:167,failure,failure,167,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['failure'],['failure']
Availability,"// Choose better solution for the current VF,; // write down this decision and use it during vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,down,down,56,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['down'],['down']
Availability,// Choose the first remaining non-zero available register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// Clamp is available on all types after regbankselect (f16, f32, f64, v2f16).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp:12,avail,available,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,1,['avail'],['available']
Availability,// Clamp out of bounds shift amounts since they will otherwise be masked; // to 8-bits which may make it no longer out of bounds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:66,mask,masked,66,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,// Clamp the bitfield to a containable size for the sake of being able; // to lay them out. Sema will throw an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['error'],['error']
Availability,"// Clang 5.0 support for explicit conversion is still inadequate even in c++17 mode.; // (It leads to extraneous ambiguous overload errors)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h:132,error,errors,132,core/base/inc/TString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h,1,['error'],['errors']
Availability,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Recover,RecoveryExpr,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['RecoveryExpr']
Availability,// Class describing a single failure of parser.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:29,failure,failure,29,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['failure'],['failure']
Availability,// Class for identifying profitable indirect call promotion candidates when; // the indirect-call value profile metadata is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:124,avail,available,124,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,1,['avail'],['available']
Availability,// Class for less-than inequality comparason for the set `RedundantTokens`.; // We store tokens in the order they appear in the translation unit so that; // we do not need to sort them in `generateFixes()`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,Redundant,RedundantTokens,58,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['Redundant'],['RedundantTokens']
Availability,"// Class generator to make python classes available to Cling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPyClassGenerator.cxx:42,avail,available,42,bindings/tpython/src/TPyClassGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPyClassGenerator.cxx,1,['avail'],['available']
Availability,"// Class generator to make python classes available to Cling; // called if all other class generators failed, attempt to build from python class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TPyClassGenerator.cxx:42,avail,available,42,bindings/pyroot/cppyy/CPyCppyy/src/TPyClassGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TPyClassGenerator.cxx,1,['avail'],['available']
Availability,"// Class that keeps a reference structure and some tolerance values to; // make a comparision between the reference and the result of a; // fit. The options define what has to be compared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:51,toler,tolerance,51,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['toler'],['tolerance']
Availability,"// Classes; /*; for (auto const & annRcd : scan.fSelectedClasses) {; const auto rcdDeclPtr = annRcd.GetRecordDecl();. int retCode = FwdDeclFromRcdDecl(*rcdDeclPtr, interp, buffer);; if (-1 == retCode) {; ROOT::TMetaUtils::Error(""GenerateFwdDeclString"",; ""Error generating fwd decl for class %s\n"",; annRcd.GetNormalizedName());; return emptyString;; }; if (retCode == 0 && fwdDecls.insert(buffer).second); fwdDeclString += ""\"""" + buffer + ""\""\n"";; }; */; // Build the input for a transaction containing all of the selected declarations; // Cling will produce the fwd declaration payload.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:222,Error,Error,222,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,2,['Error'],['Error']
Availability,// Clean up if we had an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,"// Clean up on error, disengage it if the function returns successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['error'],['error']
Availability,// Cleanup bit manipulations on exec mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,"// Cleanup if failure ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:14,failure,failure,14,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['failure'],['failure']
Availability,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,redundant,redundant,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['redundant'],['redundant']
Availability,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,redundant,redundant,14,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['redundant'],['redundant']
Availability,// Cleanup on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,failure,failure,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['failure'],['failure']
Availability,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,2,['avail'],['available']
Availability,"// Clear any inherited file mode creation mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/daemon.cxx:42,mask,mask,42,net/rpdutils/src/daemon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/daemon.cxx,1,['mask'],['mask']
Availability,"// Clear error count and start a transaction in the workspace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:9,error,error,9,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['error'],['error']
Availability,"// Clear error list on local side",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:9,error,error,9,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,2,['error'],['error']
Availability,// Clear error states for all streams.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// Clear error states if `fflush` returns 0, but retain their EOF flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// Clear eval error log prior to forking; // to avoid confusions...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:14,error,error,14,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['error'],['error']
Availability,// Clear irrelevant bits in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],['mask']
Availability,"// Clear kill flags of the first stores register. Example:; // STRWui %w1, ...; // USE kill %w1 ; need to clear kill flag when moving STRWui downwards; // STRW %w0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:141,down,downwards,141,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['down'],['downwards']
Availability,// Clear mask to all zeros and insert the shifted byte indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Clear out the availability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:17,avail,availability,17,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avail'],['availability']
Availability,// Clear reorder since it is going to be applied to the new mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Clear sign bits based on the input sign mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:43,mask,mask,43,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['mask'],['mask']
Availability,"// Clear the asymmetric error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:24,error,error,24,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['error'],['error']
Availability,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:154,error,error,154,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['error'],['error']
Availability,"// Clear the body and queue the function itself for deletion when we; // finish inlining.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:131,error,error,131,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,1,['error'],['error']
Availability,// Clear the corresponding mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Climb the super regions to find the base symbol while recording; // the second-to-last region for error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:101,error,error,101,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,1,['error'],['error']
Availability,"// Cling does not provide a consistent ImageBase address for calculating relative addresses; // as used in Windows 64b RTTI. So, check for our own RTTI extension instead. If that fails,; // see whether the unmangled raw_name is available (e.g. if this is an MSVC compiled rather; // than JITed class) and pass on if it is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:228,avail,available,228,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['avail'],['available']
Availability,"// Cling error, treat silently",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:9,error,error,9,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['error'],['error']
Availability,// Cloning can't work if we don't have a definition. The Microsoft ABI may; // require thunks when a definition is not available. Emit an error in these; // cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:119,avail,available,119,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,// Close one end of the tracker so we can call; // getMaxUpward/DownwardPressureDelta before advancing across any; // instructions. This converts currently live regs into live ins/outs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Down,DownwardPressureDelta,64,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Down'],['DownwardPressureDelta']
Availability,"// Cmp holds the result of the compare-exchange operation: true on success,; // false on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:89,failure,failure,89,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['failure'],['failure']
Availability,// CodeGen Failure MBB if we have not codegened it yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:11,Failure,Failure,11,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['Failure'],['Failure']
Availability,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:65,error,error,65,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:258,failure,failures,258,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['failure'],['failures']
Availability,"// Codegen can't handle evaluating array range designators that have side; // effects, because we replicate the AST value for each initialized element.; // As such, set the sawArrayRangeDesignator() bit if we initialize multiple; // elements with something that has a side effect, so codegen can emit an; // ""error unsupported"" error instead of miscompiling the app.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:309,error,error,309,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,['error'],['error']
Availability,// Collect AvailableAnalysis from all the active Pass Managers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:11,Avail,AvailableAnalysis,11,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['Avail'],['AvailableAnalysis']
Availability,"// Collect a list of everything (currently) available in the namespace.; // The backend can filter by returning empty strings. Special care is; // taken for functions, which need not be unique (overloading).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:44,avail,available,44,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['avail'],['available']
Availability,"// Collect a single representative of every scope containing an indirect; // goto. For most code bases, this substantially cuts down on the number of; // jump sites we'll have to consider later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:128,down,down,128,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['down'],['down']
Availability,// Collect all available information about status of blocks after constant; // folding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:15,avail,available,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['avail'],['available']
Availability,"// Collect all instructions. Do a post order traversal for basic blocks and; // insert with list bottom up, so while we pop_back_val, we'll traverse top; // down RPOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:157,down,down,157,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,1,['down'],['down']
Availability,// Collect all the RegisterFile definitions available in this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:44,avail,available,44,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['avail'],['available']
Availability,// Collect availability attributes from all redeclarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp:11,avail,availability,11,interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp,1,['avail'],['availability']
Availability,// Collect constant bits and insert into mask/undef bit masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,// Collect error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:11,error,error,11,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['error'],['error']
Availability,"// Collect groups of consecutive bits with the same underlying value and; // rotation factor. If we're doing late masking, we ignore zeros, otherwise; // they break up groups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,mask,masking,114,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,// Collect information from the available symbols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,1,['avail'],['available']
Availability,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,mask,masked,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,2,"['Mask', 'mask']","['MaskedOp', 'masked']"
Availability,// Collect processor RetireControlUnit descriptors if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:54,avail,available,54,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['avail'],['available']
Availability,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redundant'],['redundant']
Availability,// Collect register defs and uses along with their lane masks and states.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp:56,mask,masks,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,1,['mask'],['masks']
Availability,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:61,mask,mask,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['mask'],['mask']
Availability,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:112,mask,masks,112,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['masks']
Availability,// Collect resource masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:20,mask,masks,20,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,1,['mask'],['masks']
Availability,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,redundant,redundant,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,2,"['down', 'redundant']","['downstream', 'redundant']"
Availability,// Collect the source partial masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,mask,masks,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// Collects all the ProcPfmCounters definitions available in this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp:48,avail,available,48,interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp,1,['avail'],['available']
Availability,"// Collects completion-relevant information about a concept-constrainted type T.; // In particular, examines the constraint expressions to find members of T.; //; // The design is very simple: we walk down each constraint looking for; // expressions of the form T.foo().; // If we're extra lucky, the return type is specified.; // We don't do any clever handling of && or || in constraint expressions, we; // take members from both branches.; //; // For example, given:; // template <class T> concept X = requires (T t, string& s) { t.print(s); };; // template <X U> void foo(U u) { u.^ }; // We want to suggest the inferred member function 'print(string)'.; // We see that u has type U, so X<U> holds.; // X<U> requires t.print(s) to be valid, where t has type U (substituted for T).; // By looking at the CallExpr we find the signature of print().; //; // While we tend to know in advance which kind of members (access via . -> ::); // we want, it's simpler just to gather them all and post-filter.; //; // FIXME: some of this machinery could be used for non-concept type-parms too,; // enabling completion for type parameters based on other uses of that param.; //; // FIXME: there are other cases where a type can be constrained by a concept,; // e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,down,down,201,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['down'],['down']
Availability,"// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:92,avail,available,92,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avail'],['available']
Availability,"// Combine a constant select operand into its use:; //; // (add (select cc, 0, c), x) -> (select cc, x, (add, x, c)); // (sub x, (select cc, 0, c)) -> (select cc, x, (sub, x, c)); // (and (select cc, -1, c), x) -> (select cc, x, (and, x, c)) [AllOnes=1]; // (or (select cc, 0, c), x) -> (select cc, x, (or, x, c)); // (xor (select cc, 0, c), x) -> (select cc, x, (xor, x, c)); //; // The transform is rejected if the select doesn't have a constant operand that; // is null, or all ones when AllOnes is set.; //; // Also recognize sext/zext from i1:; //; // (add (zext cc), x) -> (select cc (add x, 1), x); // (add (sext cc), x) -> (select cc (add x, -1), x); //; // These transformations eventually create predicated instructions.; //; // @param N The node to transform.; // @param Slct The N operand that is a select.; // @param OtherOp The other N operand (x above).; // @param DCI Context.; // @param AllOnes Require the select constant to be all ones instead of null.; // @returns The new node, or SDValue() on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:1015,failure,failure,1015,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['failure'],['failure']
Availability,"// Combine an arbitrary chain of shuffles + extract_subvectors into a single; // instruction if possible.; //; // Wrapper for combineX86ShuffleChain that extends the shuffle mask to a larger; // type size to attempt to combine:; // shuffle(extract_subvector(x,c1),extract_subvector(y,c2),m1); // -->; // extract_subvector(shuffle(x,y,m2),0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:174,mask,mask,174,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Combine into mla/mls.; // This works on the patterns of:; // add v1, (mul v2, v3); // sub v1, (mul v2, v3); // for vectors of type <1 x i64> and <2 x i64> when SVE is available.; // It will transform the add/sub to a scalable version, so that we can; // make use of SVE's MLA/MLS that will be generated for that pattern",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:170,avail,available,170,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// Combine masks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:11,mask,masks,11,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['masks']
Availability,"// Combine shuffles of bitcasts into a shuffle of the bitcast type, providing; // the mask can be treated as a larger type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,mask,mask,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Combine shuffles of splat-shuffles of the form:; // shuffle (shuffle V, undef, splat-mask), undef, M; // If splat-mask contains undef elements, we need to be careful about; // introducing undef's in the folded mask which are not the result of composing; // the masks of the shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['mask'],"['mask', 'masks']"
Availability,// Combine sin / cos into _sincos_stret if it is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// Combine the error set figured out by finalizeVars and the ones passed by the user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:15,error,error,15,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['error']
Availability,// Combine vector mask reductions into alltrue/anytrue,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['mask'],['mask']
Availability,"// Combine vmaxsw/h/b(a, a's negation) to abs(a); // Expose the vabsduw/h/b opportunity for down stream",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,"// Comments for which FirstInLine is false can start on arbitrary column,; // and available horizontal space can be too small to align consecutive; // lines with the first one.; // FIXME: We could, probably, align them to current indentation level, but; // now we just wrap them without stars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:82,avail,available,82,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['avail'],['available']
Availability,"// Commit acabad9ff6bf (""[InstCombine] try to canonicalize icmp with; // trunc op into mask and cmp"") added a transformation to; // convert ""(conv)a < power_2_const"" to ""a & <const>"" in certain; // cases and bpf kernel verifier has to handle the resulted code; // conservatively and this may reject otherwise legitimate program.; // Here, we change related icmp code to a builtin which will; // be restored to original icmp code later to prevent that; // InstCombine transformatin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:87,mask,mask,87,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,1,['mask'],['mask']
Availability,// Common instance state available to all overload candidate addition methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:25,avail,available,25,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avail'],['available']
Availability,"// Commute LHS and RHS to create opportunity to select mask instruction.; // (vselect M, L, R) -> (vselect ~M, R, L)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Commute mask and check again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Commute operands to match the commuted shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Compare minimization results; // Same tolerance for parameter values and error, don't compare correlations; // because for very small correlations it's usually not the same within the; // relative tolerance because you would compare two small values that are; // only different from zero because of noise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx:41,toler,tolerance,41,roofit/roofitcore/test/testRooFuncWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx,3,"['error', 'toler']","['error', 'tolerance']"
Availability,"// Compare parameter error if it's a RooRealVar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx:21,error,error,21,roofit/roofitcore/src/RooFitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx,1,['error'],['error']
Availability,"// Compared to ASSERT_NEAR, this function takes into account also the relative error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stress/TestHelper.cxx:79,error,error,79,math/mathcore/test/stress/TestHelper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stress/TestHelper.cxx,2,['error'],['error']
Availability,"// Compares two doubles with a given tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:37,toler,tolerance,37,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['toler'],['tolerance']
Availability,// Compares with fcNone are only exactly equal to fcZero if input denormals; // are not flushed.; // TODO: Handle DAZ by expanding masks to cover subnormal cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:131,mask,masks,131,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['mask'],['masks']
Availability,// Comparing if all bits outside of a constant mask are set?; // Replace (X | C) == -1 with (X & ~C) == ~C.; // This removes the -1 constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// Comparison is for live lanes; however here we compute the inverse; // (killed lanes). This is because VCMP will always generate 0 bits; // for inactive lanes so a mask of live lanes would not be correct; // inside control flow.; // Invert the comparison by swapping the operands and adjusting; // the comparison codes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:166,mask,mask,166,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,"// Compile the API notes source into a buffer.; // FIXME: Either propagate OSType through or, better yet, improve the binary; // APINotes format to maintain complete availability information.; // FIXME: We don't even really need to go through the binary format at all;; // we're just going to immediately deserialize it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:166,avail,availability,166,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,1,['avail'],['availability']
Availability,"// Complete example with use of conditional p.d.f. with per-event errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:66,error,errors,66,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['errors']
Availability,"// Complete example with use of full p.d.f. with per-event errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:59,error,errors,59,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['errors']
Availability,// Complete the definition even if error is returned.; // The RecordDecl may be already part of the AST so it is better to; // have it in complete state even if something is wrong with it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:35,error,error,35,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// Completely missing, emit error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,error,error,28,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// Components of the mask that determines which instruction types may be may be; // classified into a SchedGroup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['mask'],['mask']
Availability,// Compose range checking error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,error,error,26,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['error'],['error']
Availability,"// Compute NewVNInfo and resolve conflicts (see also joinVirtRegs()); // We should be able to resolve all conflicts here as we could successfully do; // it on the mainrange already. There is however a problem when multiple; // ranges get mapped to the ""overflow"" lane mask bit which creates unexpected; // interferences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:268,mask,mask,268,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['mask'],['mask']
Availability,// Compute a lane mask for each sub-register index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:18,mask,mask,18,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['mask'],['mask']
Availability,// Compute a mask of lanes that are defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['mask'],['mask']
Availability,// Compute a unique tail call path from the source frame address to the target; // function. Output the unique path prefix (not including `To`) in; // `UniquePath` if exists. Return the number of possibly availabe tail call; // paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h:205,avail,availabe,205,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,1,['avail'],['availabe']
Availability,// Compute a unique tail call path from the source function to the target; // function. Output the unique path prefix (not including `To`) in; // `UniquePath` if exists. Return the number of possibly availabe tail call; // paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h:200,avail,availabe,200,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,1,['avail'],['availabe']
Availability,// Compute lane mask combinations for register classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,"// Compute lane masks. This is similar to register units, but at the; // sub-register index level. Each bit in the lane mask is like a register unit; // class, and two lane masks will have a bit in common if two sub-register; // indices overlap in some register.; //; // Conservatively share a lane mask bit if two sub-register indices overlap in; // some registers, but not in others. That shouldn't happen a lot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:16,mask,masks,16,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,4,['mask'],"['mask', 'masks']"
Availability,// Compute live range for live mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,"// Compute test error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx:16,error,error,16,tmva/tmva/src/MethodDNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx,2,['error'],['error']
Availability,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:45,down,downstream,45,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,2,['down'],['downstream']
Availability,"// Compute the VSELECT mask. Note that VSELECT is really confusing in the; // mix of LLVM's code generator and the x86 backend. We tell the code; // generator that boolean values in the elements of an x86 vector register; // are -1 for true and 0 for false. We then use the LLVM semantics of 'true'; // mapping a select to operand #1, and 'false' mapping to operand #2. The; // reality in x86 is that vector masks (pre-AVX-512) use only the high bit; // of the element (the remaining are ignored) and 0 in that high bit would; // mean operand #1 while 1 in the high bit would mean operand #2. So while; // the LLVM model for boolean values in vector elements gets the relevant; // bit set, it is set backwards and over constrained relative to x86's; // actual model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// Compute the combined shuffle mask for a shuffle with SV0 as the first; // operand, and SV1 as the second operand.; // i.e. Merge SVN(OtherSVN, N1) -> shuffle(SV0, SV1, Mask) iff Commute = false; // Merge SVN(N1, OtherSVN) -> shuffle(SV0, SV1, Mask') iff Commute = true",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Compute the cost of conditionally executing the memory operations with; // variable masks. This includes extracting the individual conditions, a; // branches and PHIs to combine the results.; // NOTE: Estimating the cost of conditionally executing the memory; // operations accurately is quite difficult and the current solution; // provides a very rough estimate only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:87,mask,masks,87,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['mask'],['masks']
Availability,// Compute the effective CC mask for the new branch or select.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['mask'],['mask']
Availability,"// Compute the function only when the arg meets the criteria, using the mask computed before",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:72,mask,mask,72,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,1,['mask'],['mask']
Availability,"// Compute the largest caller's frame that is needed to fit the callees'; // frames. This 'MaxStack' is computed from:; //; // a) the fixed frame size, which is the space needed for all spilled temps,; // b) outgoing on-stack parameter areas, and; // c) the minimum stack space this function needs to make available for the; // functions it calls (a tunable ABI property).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:306,avail,available,306,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['avail'],['available']
Availability,// Compute the masks for andi/andis that would be necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,mask,masks,15,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,3,['mask'],['masks']
Availability,// Compute the next available bit offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:20,avail,available,20,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['avail'],['available']
Availability,// Compute the number of register mask instructions in this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['mask'],['mask']
Availability,"// Compute the post-shuffle mask index based on where the element; // is stored in the HOP result, and where it needs to be moved to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Compute the presumed alignment of 'this', which basically comes; // down to whether we know it's a complete object or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:71,down,down,71,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,1,['down'],['down']
Availability,"// Compute the register pressure contribution by this instruction by count up; // for uses that are not live and down for defs. Only count register classes; // that are already under high pressure. As a side effect, compute the number of; // uses of registers that are already live.; //; // FIXME: This encompasses the logic in HighRegPressure and MayReduceRegPressure; // so could probably be factored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:113,down,down,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['down'],['down']
Availability,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:24,error,error,24,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,36,['error'],['error']
Availability,"// Compute the set of alive bits for each operand. These are anded into the; // existing set, if any, and if that changes the set of alive bits, the; // operand is added to the work-list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:22,alive,alive,22,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,"// Compute the set of registers completely covered by the registers in Regs.; // The returned BitVector will have a bit set for each register in Regs,; // all sub-registers, and all super-registers that are covered by the; // registers in Regs.; //; // This is used to compute the mask of call-preserved registers from a list; // of callee-saves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:281,mask,mask,281,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['mask'],['mask']
Availability,// Compute the test mask that would return true for the ordered comparisons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['mask'],['mask']
Availability,"// Compute the widths of the characters that should be replaced with; // control character expansions. If the appropriate chars are not; // available in this font, then control character expansions will not; // be used; control chars will be invisible & zero-width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:140,avail,available,140,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['avail'],['available']
Availability,"// Compute training error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:20,error,error,20,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,3,['error'],['error']
Availability,// Compute transformation sequences for composeSubRegIndexLaneMask. The idea; // here is that for each possible target subregister we look at the leafs; // in the subregister graph that compose for this target and create; // transformation sequences for the lanemasks. Each step in the sequence; // consists of a bitmask and a bitrotate operation. As the rotation amounts; // are usually the same for many subregisters we can easily combine the steps; // by combining the masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:472,mask,masks,472,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['masks']
Availability,"// Compute validation error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:22,error,error,22,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['error'],['error']
Availability,// Compute which value this mask is pointing at.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,// Computing on 1 bit values requires extra mask or compare operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:547,down,down-aligned,547,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,2,['down'],"['down-aligned', 'down-alignment']"
Availability,"// Concurrent writes to the same cache element can result in invalid cache; // elements, causing pointer address not being available in the cache even; // though they should be, i.e. false cache misses. While can cause a; // slow-down, the cost for keeping the cache thread-local or atomic is; // much higher (yes, this was measured).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp:123,avail,available,123,interpreter/cling/lib/Utils/PlatformPosix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// Condition mask for instructions.; // Starting at first 1 (from lsb).; // '1' condition as indicated in IT.; // '0' inverse of condition (else).; // Count of instructions in IT block is; // 4 - trailingzeroes(mask); // Note that this does not have the same encoding; // as in the IT instruction, which also depends; // on the low bit of the condition code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['mask'],['mask']
Availability,// Condition-code mask assignments for CS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for TEST UNDER MASK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,2,"['MASK', 'mask']","['MASK', 'mask']"
Availability,// Condition-code mask assignments for TRANSACTION_BEGIN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for TRANSACTION_END.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for Test Data Class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for a completed SRST loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for arithmetical operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for floating-point comparisons only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for integer and floating-point; // comparisons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for logical operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask assignments for vector comparisons (and similar; // operations).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,// Condition-code mask values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['mask'],['mask']
Availability,"// Conditional ownership (when StreamOwner is non-null, it's keeping OS; // alive). We might want to replace this with a wrapper for conditional; // ownership eventually - it seems to pop up often enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h:76,alive,alive,76,interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,1,['alive'],['alive']
Availability,// Conditions in an assume trivially simplify to true. Skip uses; // in assume calls to not destroy the available information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:104,avail,available,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['avail'],['available']
Availability,"// Conditions under which the scheduler should eagerly advance the cycle:; // (1) No available instructions; // (2) All pipelines full, so available instructions must have hazards.; //; // If HazardRec is disabled, the cycle was pre-advanced before calling; // ReleasePredecessors. In that case, IssueCount should remain 0.; //; // Check AvailableQueue after ReleasePredecessors in case of zero latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:85,avail,available,85,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,"['Avail', 'avail']","['AvailableQueue', 'available']"
Availability,"// Configure the validate function to not fire assertions, instead print; // errors and return true if there's a problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:77,error,errors,77,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['errors']
Availability,"// Confusingly, the operand is an *inverted* mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,recover,recover,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['recover'],['recover']
Availability,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,down,down-collected,36,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down-collected']
Availability,// Connect the dots between the top-down-collected RetainsToMove and; // bottom-up-collected ReleasesToMove to form sets of related calls.; // This is an iterative process so that we connect multiple releases; // to multiple retains if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:36,down,down-collected,36,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down-collected']
Availability,"// Conservatively assume it's executing on error.; // Check whether the process is dead. If so, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/LockFileManager.cpp:43,error,error,43,interpreter/llvm-project/llvm/lib/Support/LockFileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/LockFileManager.cpp,1,['error'],['error']
Availability,// Conservatively bail out if there are no available dispatch entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,1,['avail'],['available']
Availability,"// Conservatively search the entire current function scope context for; // availability violations. This ensures we always correctly analyze nested; // classes, blocks, lambdas, etc. that may or may not be inside if(@available); // checks themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:75,avail,availability,75,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,2,['avail'],"['availability', 'available']"
Availability,"// Conservatively, we can recurse down the first operand; // and just mask out all affected bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:34,down,down,34,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:65,avail,available,65,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp,2,['avail'],['available']
Availability,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:675,repair,repair,675,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,2,"['avail', 'repair']","['available', 'repair']"
Availability,"// ConstZero means a bit we need to mask off.; // Variable is a bit comes from an input variable.; // VariableKnownToBeZero is also a bit comes from an input variable,; // but it is known to be already zero. So we do not need to mask them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,// Constant Fold - shift Index'th bit to lowest position and mask off; // Length bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,// Constant Mask - select 1st/2nd argument lane based on top bit of mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,Mask,Mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Constant mask splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,1,['mask'],['mask']
Availability,"// Constant masks for the ""flags"" field in llvm::MachO::section and; // llvm::MachO::section_64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['mask'],['masks']
Availability,"// Constant masks for the ""flags[23:8]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_SYS); /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,2,['mask'],"['mask', 'masks']"
Availability,"// Constant masks for the ""flags[31:24]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_USR); /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine; /// instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,2,['mask'],"['mask', 'masks']"
Availability,"// Constant masks for the ""flags[7:0]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_TYPE); /// S_REGULAR - Regular section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,2,['mask'],"['mask', 'masks']"
Availability,"// Constant masks for the ""n_desc"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64; // The low 3 bits are the for the REFERENCE_TYPE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['mask'],['masks']
Availability,"// Constant masks for the ""n_type"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['mask'],['masks']
Availability,// Constant masks for the value of an indirect symbol in an indirect; // symbol table,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,mask,masks,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['mask'],['masks']
Availability,// Constant should be a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Constant suitable as a 32-bit mask operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:33,mask,mask,33,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['mask'],['mask']
Availability,// Constant suitable as a 64-bit mask operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:33,mask,mask,33,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['mask'],['mask']
Availability,// Constant-fold the M4 and M5 mask arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:31,mask,mask,31,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,// Constant-fold the M4 mask argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:24,mask,mask,24,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,['mask'],['mask']
Availability,// ConstantRange asserts if the ranges are the same except for the min/max; // value. Leave the cases it tolerates for the empty range error below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:105,toler,tolerates,105,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,2,"['error', 'toler']","['error', 'tolerates']"
Availability,// Construct a mask for the tbl. We may need to adjust the index for types; // larger than i8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Construct a new shuffle mask that will produce a vector with the same; // number of elements as the input vector, and such that the vector we; // want will be the initial subvector of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['mask'],['mask']
Availability,// Construct a shuffle mask from constant integers or UNDEFs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,3,['mask'],['mask']
Availability,// Construct a yaml Input object from a StringRef and optional; // user-data. The DiagHandler can be specified to provide; // alternative error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:138,error,error,138,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,// Construct complete shuffle mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// Construct the mask as a combination of the partial masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,2,['mask'],"['mask', 'masks']"
Availability,// Construct the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['mask'],['mask']
Availability,"// Construct the new shuffle mask. Elements from the first source retain their; // index, but elements from the second source no longer need to skip an undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Construction vtable symbols are not part of the Itanium ABI, so we cannot; // guarantee that they actually will be available externally. Instead, when; // emitting an available_externally VTT, we provide references to an internal; // linkage construction vtable. The ABI only requires complete-object vtables; // to be the same for all instances of a type, not construction vtables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:118,avail,available,118,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['avail'],['available']
Availability,"// Constructor and ""create"" factory function. The constructor is only a thin; // wrapper around the base constructor. The ""create"" function fills out the; // XCOFF-specific information and performs the error checking along the way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:202,error,error,202,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['error'],['error']
Availability,// Consume constant adds & ors with appropriate masking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp:48,mask,masking,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,1,['mask'],['masking']
Availability,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:122,error,error,122,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,// Consume errors from missing streams.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/StreamUtil.cpp:11,error,errors,11,interpreter/llvm-project/llvm/tools/llvm-pdbutil/StreamUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/StreamUtil.cpp,1,['error'],['errors']
Availability,"// Consume the operator, saving the operator token for error reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:55,error,error,55,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,"// Consumes a token. If any problem occurred, a non-empty Error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp:58,Error,Error,58,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp,1,['Error'],['Error']
Availability,"// Consuming deferred text, so use Lexer.Lex to ignore Lexing Errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:62,Error,Errors,62,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['Error'],['Errors']
Availability,"// Consuming deferred text, so use Lexer.Lex to ignore Lexing Errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:62,Error,Errors,62,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['Error'],['Errors']
Availability,"// Contains a list of the available signatures, without the name of the; // function. Each pair consists of a signature and a cumulative index.; // E.g.: <<float, float>, 0>,; // <<float, int, int, 2>>,; // <<float>, 5>,; // ...; // <<double, double>, 35>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:26,avail,available,26,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['avail'],['available']
Availability,// Contiguous gather => masked load.; // (sve.ld1.gather.index Mask BasePtr (sve.index IndexBase 1)); // => (masked.load (gep BasePtr IndexBase) Align Mask zeroinitializer),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:24,mask,masked,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,4,"['Mask', 'mask']","['Mask', 'masked']"
Availability,// Contiguous masked store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:14,mask,masked,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['mask'],['masked']
Availability,// Contiguous scatter => masked store.; // (sve.st1.scatter.index Value Mask BasePtr (sve.index IndexBase 1)); // => (masked.store Value (gep BasePtr IndexBase) Align Mask),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:25,mask,masked,25,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,4,"['Mask', 'mask']","['Mask', 'masked']"
Availability,// Continue assigning vregs one at a time to available physical registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:45,avail,available,45,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,1,['avail'],['available']
Availability,// Continue walking down the domtree.; // Visit phi backedges to determine if the chain can generate the IV postinc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,down,down,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['down'],['down']
Availability,// Continue walking down the instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,down,down,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['down'],['down']
Availability,"// Control how to start the workers; copy-on-write (fork) is *very*; // experimental and available on Unix only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:89,avail,available,89,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['avail'],['available']
Availability,"// Controls what is ""alive"" if control flow may reach the instruction; // with a different liveness of the alloca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:21,alive,alive,21,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,1,['alive'],['alive']
Availability,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,redundant,redundant,34,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['redundant'],['redundant']
Availability,"// Convert a disguised subvector insertion into a shuffle:; // insert_vector_elt V, (bitcast X from vector type), IdxC -->; // bitcast(shuffle (bitcast V), (extended X), Mask); // Note: We do not use an insert_subvector node because that requires a; // legal subvector type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Mask,Mask,170,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,"// Convert a masked load with a constant mask into a masked load and a select.; // This allows the select operation to use a faster kind of select instruction; // (for example, vblendvps -> vblendps).; // Don't try this if the pass-through operand is already undefined. That would; // cause an infinite loop because that's what we're about to create.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,masked,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],"['mask', 'masked']"
Availability,"// Convert a strict mode transition to a pseudo transition.; // This still pre-allocates registers to prevent clobbering,; // but avoids any EXEC mask changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:146,mask,mask,146,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,"// Convert any truncs, that aren't sources, into AND masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:53,mask,masks,53,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['mask'],['masks']
Availability,// Convert extract_element(bitcast(<X x i1>) -> bitcast(extract_subvector()).; // Improves lowering of bool masks on rust which splits them into byte array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:108,mask,masks,108,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// Convert from ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:42,alive,alive,42,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,1,['alive'],['alive']
Availability,// Convert masked VPReplicateRecipes to if-then region blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,mask,masked,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['masked']
Availability,"// Convert shuffle node.; // If original node was v4i64 and the new EltVT is i32,; // cast operands to v8i32 and re-build the mask.; // Calculate new VT, the size of the new VT should be equal to original.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:126,mask,mask,126,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['mask'],['mask']
Availability,// Convert the %evl predication into vector mask predication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['mask'],['mask']
Availability,// Convert the bit in the mask based on the previous bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['mask'],['mask']
Availability,// Convert the mask from an integer type to a vector of i1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:15,mask,mask,15,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,3,['mask'],['mask']
Availability,"// Convert the mask of the given shuffle op into a byte-level mask,; // as if it had type vNi8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['mask'],['mask']
Availability,// Convert the mask to a predicated (NOTE: We don't need to worry about; // inactive lanes since VSELECT is safe when given undefined elements).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Convert the masking analysis into its equivalent with negated; // comparisons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:15,mask,masking,15,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masking']
Availability,// Convert the shuffle mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['mask'],['mask']
Availability,// Convert the shuffle mask to the right # elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['mask'],['mask']
Availability,// Convert to an ErrorDiagnostic to get location information. This is; // done here rather than printMatch/printNoMatch since now we know which; // substitution block caused the overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:17,Error,ErrorDiagnostic,17,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Error'],['ErrorDiagnostic']
Availability,// Convert vector index to bit-index and get the required bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,"// Convert; // (void, op0 address, op1 address, ..., maskedoff0, maskedoff1, ...); // to; // (void, op0 address, op1 address, ..., mask, maskedoff0, maskedoff1,; // ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:131,mask,mask,131,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,1,['mask'],['mask']
Availability,// Converting a speculatable VP intrinsic means dropping %mask and %evl.; // No need to expand %evl into the %mask only to ignore that code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,2,['mask'],['mask']
Availability,"// Copy MTracker info, including subregs if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,// Copy a predicate-as-counter register by ORRing with itself as if it; // were a regular predicate (mask) register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:101,mask,mask,101,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['mask'],['mask']
Availability,"// Copy additional error value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:19,error,error,19,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,1,['error'],['error']
Availability,"// Copy error too, if source has one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:8,error,error,8,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,1,['error'],['error']
Availability,"// Copy failed (could be because the CacheEntry was removed from the cache; // in the meantime by another process), fall back and try to write down the; // buffer to the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:143,down,down,143,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['down'],['down']
Availability,"// Copy inverted mask in b&w bitmap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c:17,mask,mask,17,graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,1,['mask'],['mask']
Availability,"// Copy mask in color (transparent pixels should be black)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c:8,mask,mask,8,graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,1,['mask'],['mask']
Availability,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,redundant,redundant,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['redundant'],['redundant']
Availability,// Copy the mask so we can do any needed cleanup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,"// Copy the parameter declarations from the declarator D to the function; // declaration NewFD, if they are available. First scavenge them into Params.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:108,avail,available,108,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,"// Copy the sorted X and Y error values back to the original arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:27,error,error,27,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,3,['error'],['error']
Availability,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,redundant,redundantly,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['redundant'],['redundantly']
Availability,// CorrectTypo used in a non error recovery situation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:29,error,error,29,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,// CorrectTypo used in normal error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:30,error,error,30,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Correction for rounding errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:27,error,errors,27,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['errors']
Availability,"// Correction for rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:27,error,errors,27,hist/hist/src/TSpline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx,1,['error'],['errors']
Availability,"// Corrupt the input values randomly on corruption Level.; //Basically inputs are masked currently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h:82,mask,masked,82,tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,1,['mask'],['masked']
Availability,"// Could be a promoted local imported from another module. We need to pass; // down more info here to find the original module id. For now, try with; // the OrigName which might have been stored in the OidGuidMap in the; // index. This would not work if there were same-named locals in multiple; // modules, however.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,down,down,79,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['down'],['down']
Availability,"// Could be an assertion, but this way we can see the failing form code; // easily, which helps track down where it came from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp:102,down,down,102,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,1,['down'],['down']
Availability,"// Could inserting the [W|D]LSTP cause some unintended affects? In a perfect; // world the [w|d]lstp instruction would be last instruction in the preheader; // and so it would only affect instructions within the loop body. But due to; // scheduling, and/or the logic in this pass (above), the insertion point can; // be moved earlier. So if the Loop Start isn't the last instruction in the; // preheader, and if the initial element count is smaller than the vector; // width, the Loop Start instruction will immediately generate one or more; // false lane mask which can, incorrectly, affect the proceeding MVE; // instructions in the preheader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:556,mask,mask,556,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['mask'],['mask']
Availability,// Could possibly produce an error or warning if one of these was non-null but; // the other was null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWP/DWP.cpp:29,error,error,29,interpreter/llvm-project/llvm/lib/DWP/DWP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWP/DWP.cpp,1,['error'],['error']
Availability,// Could remove this and the dtor if PointerUnion supported unique_ptr; // elements with a dynamic failure/assertion (like the one below) in the case; // where it was copied while being in an owning state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:99,failure,failure,99,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['failure'],['failure']
Availability,"// Couldn't find exact match. Now fall back to other available physical fonts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:53,avail,available,53,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['avail'],['available']
Availability,"// Count down from MaxSplit. When MaxSplit is -1, this will just split; // ""forever"". This doesn't support splitting more than 2^31 times; // intentionally; if we ever want that we can make MaxSplit a 64-bit integer; // but that seems unlikely to be useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,2,['down'],['down']
Availability,"// Count the number of consecutive \ characters. If even, then they are; // just escaped backslashes, otherwise it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:120,error,error,120,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,1,['error'],['error']
Availability,// Count the total number of errors printed.; // This is used to exit with an error code if there were any errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp:29,error,errors,29,interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,3,['error'],"['error', 'errors']"
Availability,// Count this failure so that we know that template argument deduction; // has failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:14,failure,failure,14,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['failure'],['failure']
Availability,// Count trailing undefs in the mask to check the final number of used; // registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Cp failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:6,failure,failure,6,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['failure'],['failure']
Availability,"// Crash if the assertion fails, printing the message and testcase.; // More elegant error handling isn't needed for unit tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Testing/Annotations/Annotations.cpp:85,error,error,85,interpreter/llvm-project/llvm/lib/Testing/Annotations/Annotations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Testing/Annotations/Annotations.cpp,1,['error'],['error']
Availability,// Create 'identity' byte level shuffle mask and then add inserted bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create 128-bit vector type based on mask size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create Mask+Rotate operation and merge with existing ops if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:10,Mask,Mask,10,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['Mask'],['Mask']
Availability,"// Create OR(AND(LHS,MASK),AND(RHS,~MASK)) bit select pattern",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,MASK,MASK,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['MASK'],['MASK']
Availability,"// Create Sumw2 if h1 or h2 have Sumw2 set, or if binomial errors are explicitly requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:59,error,errors,59,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['error'],['errors']
Availability,// Create a LiveOutReg for each bit that is set in the register mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,1,['mask'],['mask']
Availability,// Create a PHI to make the value available in this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// Create a RISCVOperand for checking later (so the error messages are; // nicer), but we don't add it to Operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:52,error,error,52,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['error'],['error']
Availability,"// Create a VPST (with a null mask for now, we'll recompute it; // later)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['mask'],['mask']
Availability,// Create a bit mask to clear the high bits beyond IterCount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['mask'],['mask']
Availability,// Create a demanded elts mask from the referenced elements of Op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create a high mask with zeros above hiBit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['mask'],['mask']
Availability,// Create a left-shift constant to get the mask bits over to the sign-bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Create a list of Mask+Rotate operations, with equivalent entries merged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:20,Mask,Mask,20,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['Mask'],['Mask']
Availability,// Create a mask for bits above (ctlz) or below (cttz) the first known one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,// Create a mask for just these two operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// Create a mask that selects <0,...,Op[i]> for each lane of the destination; // vector to replace the original ZExt. This can later be lowered to a set of; // tbl instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Create a mask to choose every nth byte from the source vector table of; // bytes to create the truncated destination vector, where 'n' is the truncate; // ratio. For example, for a truncate from Yxi64 to Yxi8, choose; // 0,8,16,..Y*8th bytes for the little-endian format",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create a mask which is filled with one from the position of lowest bit set; // to the position of highest bit set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,1,['mask'],['mask']
Availability,// Create a mask which is filled with one outside the position of lowest bit; // set and the position of highest bit set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,1,['mask'],['mask']
Availability,"// Create a mask which should be ""AND""ed; // with (overflow_arg_area + align - 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp:12,mask,mask,12,interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,1,['mask'],['mask']
Availability,// Create a masked intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:12,mask,masked,12,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,1,['mask'],['masked']
Availability,"// Create a new explicit IT block with the given condition and mask.; // The mask should be in the format used in ARMOperand and; // MCOperand, with a 1 implying 'e', regardless of the low bit of; // the condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['mask'],['mask']
Availability,// Create a new mask for the new ShuffleVectorInst so that the new; // ShuffleVectorInst is equivalent to the original one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:115,avail,available,115,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,// Create a new shuffle with a mask that is composed of the two shuffles'; // masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// Create a new variable with appropriate strings. The error is calculated as; // RMS/(2*Sqrt(N)) which is only valid if the variable has a Gaussian distribution.; // Create RMS value holder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:55,error,error,55,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['error']
Availability,"// Create a new variable with appropriate strings. The error is calculated as; // RMS/Sqrt(N) which is generally valid.; // Create holder variable for mean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:55,error,error,55,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['error']
Availability,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:1064,failure,failure,1064,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['failure'],['failure']
Availability,// Create a repeating shuffle mask for the entire vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,redundant,redundant,629,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['redundant'],['redundant']
Availability,// Create a root shuffle mask from the byte mask and the extracted index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// Create a shuffle mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:20,mask,mask,20,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,// Create a shuffle mask packing the lower elements from each VPMADDWD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create a shuffle mask that will combine the extracted element with zeros; // and undefs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// Create a static pointer to fitFunc. Every second call to the; // DoFit method, the old fitFunc is deleted. We need not to delete; // the function after the fitting in case we want to do Advaced; // graphics. The VirtualFitter need the function to be alived. One; // problem, after the last fit the function is never deleted, but; // ROOT's garbage collector will do the job for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:253,alive,alived,253,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['alive'],['alived']
Availability,// Create a vector constant by replicating an element-sized RISBG-style mask.; // The first operand specifies the starting set bit and the second operand; // specifies the ending set bit. Both operands count from the MSB of the; // element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:927,error,error,927,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,1,['error'],['error']
Availability,// Create an alternative mask with info about zeroable elements.; // Here we do not set undef elements as zeroable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Create an array of all MFI objects. We won't need all of these; // objects, but we're going to create a full array of them to make; // it easier to index into when we're counting ""uses"" down below.; // We want to be able to easily/cheaply access an object by simply; // indexing into it, instead of having to search for it every time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:189,down,down,189,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['down'],['down']
Availability,"// Create an attribute object with the specified arguments.; // The 'FromAttr' is the original (not imported) attribute, the 'ImportedArg'; // should be values that are passed to the 'Create' function of the attribute.; // (The 'Create' with 'ASTContext' first and 'AttributeCommonInfo' last is; // used here.) As much data is copied or imported from the old attribute; // as possible. The passed arguments should be already imported.; // If an import error happens, the internal error is set to it, and any; // further import attempt is ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:452,error,error,452,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:45,error,error,45,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Create an initial lane mask for all register units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,// Create an initial mask for the low word with zeros below loBit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['mask'],['mask']
Availability,// Create basic block to hold stuff that comes after switch; // statement. We also need to create a default block now so that; // explicit case ranges tests can have a place to jump to on; // failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:192,failure,failure,192,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['failure'],['failure']
Availability,"// Create data set containing parameter values, errors and pulls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:48,error,errors,48,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['error'],['errors']
Availability,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:50,mask,masks,50,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// Create input echo graphic context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:16,echo,echo,16,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,['echo'],['echo']
Availability,"// Create instruction operand for bundle instruction; // Break this into a separate function Code here is less readable; // Think about how to get an instruction error to report correctly.; // SMLoc will return the ""{""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:162,error,error,162,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,1,['error'],['error']
Availability,// Create masked intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:10,mask,masked,10,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,1,['mask'],['masked']
Availability,// Create masked policy intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:10,mask,masked,10,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,1,['mask'],['masked']
Availability,// Create masks for only the low parts/high parts of the 64 bit integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,masks,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,4,['avail'],['available']
Availability,// Create new mask for larger type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Create non-masked intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:14,mask,masked,14,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,1,['mask'],['masked']
Availability,// Create non-masked policy intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:14,mask,masked,14,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,1,['mask'],['masked']
Availability,// Create slots for last down to r13.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,1,['down'],['down']
Availability,// Create the RegMask Operand according to our updated mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,// Create the RegMask Operand according to the static mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,// Create the active lane mask for the next iteration of the loop before the; // original terminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['mask']
Availability,// Create the active lane mask instruction in the VPlan preheader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['mask']
Availability,"// Create the compile unit for the module.; // Currently down as ""fib.ks"" as a filename since we're redirecting stdin; // but we'd like actual source locations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:57,down,down,57,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,1,['down'],['down']
Availability,// Create the diagnostic client for reporting errors or for; // implementing -verify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:46,error,errors,46,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['errors']
Availability,// Create the entry for this cleanup with the appropriate handler; // properties. Finally and fault handlers are distinguished by arity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:94,fault,fault,94,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['fault'],['fault']
Availability,"// Create the formula, triggers an error if the formula doesn't compile; // correctly because the dangerous variable names haven't been treated right.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx:35,error,error,35,roofit/roofitcore/test/testRooFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx,1,['error'],['error']
Availability,"// Create the linkage between the TTreeReader's current tree and this ReaderValue; // object. After CreateProxy() is invoked, if fSetupStatus doesn't indicate an; // error, then we are pointing toward a valid TLeaf in the current tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx:166,error,error,166,tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,1,['error'],['error']
Availability,"// Create the list of available style, and select:; // - the new style, if it has been created; // - the previous selected style, if no style has been created (Cancel)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:22,avail,available,22,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avail'],['available']
Availability,"// Create the list of available styles, and select:; // - the new style, if it has been created (Ok).; // - the previous selected style, if no style has been created (Cancel).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:22,avail,available,22,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avail'],['available']
Availability,// Create the mask using vXi16 shifts. For shift-rights we need to move; // the upper byte down before splatting the vXi8 mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['down', 'mask']","['down', 'mask']"
Availability,// Create the masks - repeating the pattern every byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:14,mask,masks,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['mask'],['masks']
Availability,// Create the new shuffle with the new mask and bitcast it back to the; // original type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Create the shuffle mask and check all bits active,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// Create the stack frame object. Make sure it is aligned for both; // the source and destination types.; // In cases where the vector is illegal it will be broken down into parts; // and stored in parts - we should use the alignment for the smallest part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:164,down,down,164,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,1,['down'],['down']
Availability,// Create the stack frame object. Make sure it is aligned for both; // the source and expanded destination types.; // In cases where the vector is illegal it will be broken down into parts; // and stored in parts - we should use the alignment for the smallest part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp:173,down,down,173,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,1,['down'],['down']
Availability,"// Create the table file, which holds the table of fitted values and errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx:69,error,errors,69,roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx,1,['error'],['errors']
Availability,"// Creates a Box with limits specified by the vectors and; // content=value and error=error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx:80,error,error,80,math/mathcore/src/SparseData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx,2,['error'],['error']
Availability,"// Creating a predicated vector loop is the first step for generating a; // tail-predicated hardware loop, for which we need the MVE masked; // load/stores instructions:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:133,mask,masked,133,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['masked']
Availability,"// Creating page with list of available widgets is disabled now for security reasons; // Later one can provide functionality back only if explicitly desired by the user; // BuildWSEntryPage();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:30,avail,available,30,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['avail'],['available']
Availability,// Creating the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['error'],['error']
Availability,"// Current point may be inside the other node - geometry error that we ignore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:57,error,error,57,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['error'],['error']
Availability,"// CurrentNode is null for empty documents, which is an error in case required; // nodes are present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp:56,error,error,56,interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp,1,['error'],['error']
Availability,"// Currently all regular registers have their .l and .h subregisters, so; // we should never need to generate an error here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:113,error,error,113,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['error']
Availability,"// Currently it is allowed to mix Wasm EH with Emscripten SjLj as an interim; // measure, but some code will error out at compile time in this combination.; // See WebAssemblyLowerEmscriptenEHSjLj pass for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:109,error,error,109,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,1,['error'],['error']
Availability,// Currently memprof profiles are only added at the IR level. Mark the profile; // type as IR in that case as well and the subsequent matching needs to detect; // which is available (might be one or both).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:172,avail,available,172,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['avail'],['available']
Availability,"// Currently rootcling does not need any information on enums, except; // for the PCM / proto classes that register them to build TEnums without; // parsing. This can be removed once (real) PCMs are available.; // Note that the code below was *not* properly matching the case; // typedef enum { ... } abc;; // as the typedef is stored as an anonymous EnumDecl in clang.; // It is likely that using a direct lookup on the name would; // return the appropriate typedef (and then we would need to; // select 'both' the typedef and the anonymous enums.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx:199,avail,available,199,core/dictgen/src/SelectionRules.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx,1,['avail'],['available']
Availability,"// Currently the following features are excluded from InlineFeaturesAllowed.; // ModeThumb, FeatureNoARM, ModeSoftFloat, FeatureFP64, FeatureD32; // Depending on whether they are set or unset, different; // instructions/registers are available. For example, inlining a callee with; // -thumb-mode in a caller with +thumb-mode, may cause the assembler to; // fail if the callee uses ARM only instructions, e.g. in inline asm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:234,avail,available,234,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,1,['avail'],['available']
Availability,"// Currently the transformation only works on scalable vector types, although; // there is no fundamental reason why it cannot be made to work for fixed; // width too.; // We also need to know the minimum page size for the target in order to; // generate runtime memory checks to ensure the vector version won't fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp:312,fault,fault,312,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,1,['fault'],['fault']
Availability,// Currently udivrem always rounds down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:35,down,down,35,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['down'],['down']
Availability,// Currently we consider all ARC errors as recoverable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:33,error,errors,33,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,"['error', 'recover']","['errors', 'recoverable']"
Availability,"// Currently, all the failures dealt with this way are due to ARC; // restrictions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,failure,failures,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['failure'],['failures']
Availability,"// Currently, if Cling sees the ""key function"" of a virtual class, it; // emits typeinfo and vtable variables in every transaction llvm::Module; // that reference them. Turn them into weak linkage to avoid duplicate; // symbol errors from the JIT linker.; // FIXME: This is a hack, we should teach the frontend to emit these; // only once, or mark all duplicates as available_externally (if that; // improves performance due to optimizations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:227,error,errors,227,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['error'],['errors']
Availability,"// Currently, we instantiate the body when instantiating the lambda; // expression. However, `EvaluateConstraints` is disabled during the; // instantiation of the lambda expression, causing the instantiation; // failure of the return type requirement in the body. If p0588r1 is fully; // implemented, the body will be lazily instantiated, and this problem; // will not occur. Here, `EvaluateConstraints` is temporarily set to; // `true` to temporarily fix this issue.; // FIXME: This temporary fix can be removed after fully implementing; // p0588r1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:212,failure,failure,212,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['failure'],['failure']
Availability,// Custom lower mask ops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['mask'],['mask']
Availability,"// Custom lower unaligned loads.; // Also, for both loads and stores, verify the alignment of the address; // in case it is a compile-time constant. This is a usability feature to; // provide a meaningful error message to users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:205,error,error,205,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['error'],['error']
Availability,"// Custom streamer for function pointer reference object. When writing,; // the function pointer is substituted by its registered name. When function; // is unregistered name 'UNKNOWN' is written and a warning is issues. When; // reading back, the embedded name is converted back to a function pointer; // using the mapping service. When name UNKNOWN is encountered a warning is; // issues and a dummy null function is substituted. When the registered function; // name can not be mapped to a function pointer an ERROR is issued and a pointer; // to the dummy null function is substituted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h:513,ERROR,ERROR,513,roofit/roofit/inc/RooCFunction1Binding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h,4,['ERROR'],['ERROR']
Availability,"// Custom-legalize an EXTRACT_VECTOR_ELT where XLEN<SEW, as the SEW element; // type is illegal (currently only vXi64 RV32).; // With vmv.x.s, when SEW > XLEN, only the least-significant XLEN bits are; // transferred to the destination register. We issue two of these from the; // upper- and lower- halves of the SEW-bit vector element, slid down to the; // first element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:342,down,down,342,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"// Custom-lower EXTRACT_VECTOR_ELT operations to slide the vector down, then; // extract the first element: (extractelt (slidedown vec, idx), 0). For integer; // types this is done using VMV_X_S to allow us to glean information about the; // sign bits of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,down,down,66,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,// Custom-lower extensions and truncations from/to mask types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Custom-lower extensions from mask vectors by using a vselect either with 1; // for zero/any-extension or -1 for sign-extension:; // (vXiN = (s|z)ext vXi1:vmask) -> (vXiN = vselect vmask, (-1 or 1), 0); // Note that any-extension is lowered identically to zero-extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Custom-lower truncations from vectors to mask vectors by using a mask and a; // setcc operation:; // (vXi1 = trunc vXiN vec) -> (vXi1 = setcc (and vec, 1), 0, ne)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// Cut down to the outer-most scope from <name>, drop templates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:7,down,down,7,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['down'],['down']
Availability,"// Cut down to the outer-most scope from <name>, taking proper care of templates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:7,down,down,7,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['down'],['down']
Availability,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:387,error,error,387,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['error'],['error']
Availability,"// D e f i n e e f f i c i e n c y f u n c t i o n; // ---------------------------------------------------; // Use error function to simulate turn-on slope",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:115,error,error,115,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['error']
Availability,// DEBUG_VALUE nodes do not contribute to code generation and should; // always be ignored. Failure to do so may result in trying to modify; // KILL flags on DEBUG_VALUE nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:92,Failure,Failure,92,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['Failure'],['Failure']
Availability,// DFS down the probe inline tree,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:7,down,down,7,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['down'],['down']
Availability,"// DOWNWARDS ARROW",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx:3,DOWN,DOWNWARDS,3,graf2d/postscript/src/TSVG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx,1,['DOWN'],['DOWNWARDS']
Availability,"// DOWNWARDS ARROW WITH CORNER LEFTWARDS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx:3,DOWN,DOWNWARDS,3,graf2d/postscript/src/TSVG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx,1,['DOWN'],['DOWNWARDS']
Availability,"// Data members required:; // fA, fX0, fL; // Data members modified:; // those documented in SetInput(); // and those documented in DoUnfold(Double_t); // Return value:; // maximum global correlation coefficient; // NOTE!!! return value >=1.0 means error, and the result is junk; //; // Overflow bins of the input distribution are ignored!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:249,error,error,249,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['error'],['error']
Availability,// De-invert the mask and swap the value in B part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// Decides on the best configuration of filter(s) to use in order to decode; // the instructions. A conflict of instructions may occur, in which case we; // dump the conflict set to the standard error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:195,error,error,195,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['error'],['error']
Availability,// Declare all of the available TargetMCA initialization functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,// Declare all of the available assembly parser initialization functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,// Declare all of the available assembly printer initialization functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,// Declare all of the available disassembler initialization functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,// Declare all of the target-MC-initialization functions that are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:66,avail,available,66,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,// Declare all of the target-initialization functions that are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:63,avail,available,63,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,"// Declare constexpr static members to make them available if odr-used in C++14.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVarNew.cxx:49,avail,available,49,roofit/roofitcore/src/RooNLLVarNew.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVarNew.cxx,1,['avail'],['available']
Availability,"// Declare is not silent (yet?), so add an explicit error message; // to indicate the consequence of the syntax errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:52,error,error,52,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['error'],"['error', 'errors']"
Availability,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:100,avail,available,100,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,3,['avail'],['available']
Availability,// Declaring SLS and the callback outside of the call to ES.lookup is a; // workaround to fix build failures on AIX and on z/OS platforms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp:100,failure,failures,100,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,1,['failure'],['failures']
Availability,// Decode the shuffle mask and scale it so its shuffling subvectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// DecodePALIGNRMask returns the shuffle mask of vpalign instruction.; // vpalign works according to lanes; // Where Lane is the # of lanes in a register:; // VectorWide = 128 => Lane = 1; // VectorWide = 256 => Lane = 2; // For Lane = 1 shuffle pattern is: {DiffToJump,...,DiffToJump+VF-1}.; // For Lane = 2 shuffle pattern is:; // {DiffToJump,...,VF/2-1,VF,...,DiffToJump+VF-1}.; // Imm variable sets the offset amount. The result of the; // function is stored inside ShuffleMask vector and it built as described in; // the begin of the description. AlignDirection is a boolean that indicates the; // direction of the alignment. (false - align to the ""right"" side while true -; // align to the ""left"" side)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['mask'],['mask']
Availability,"// Decodes 4 hex digits from the stream into Out, returns false on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:67,error,error,67,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['error'],['error']
Availability,// Decompose a PerfectShuffle ID to get the Mask for lane Elt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:44,Mask,Mask,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Decompress Input. The uncompressed size must be available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Compression.h:51,avail,available,51,interpreter/llvm-project/llvm/include/llvm/Support/Compression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Compression.h,1,['avail'],['available']
Availability,"// Deduction failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:13,failure,failure,13,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['failure'],['failure']
Availability,"// Def is available in multiple successors, there's no single dominating; // insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,1,['avail'],['available']
Availability,"// Def: Val <- NewDefs; // Same number of values: copy; // Different number: Val = build_sequence Defs1, Defs2, ...; // Use: NewSources <- Val.; // Same number of values: copy.; // Different number: Src1, Src2, ... =; // extract_value Val, Src1Begin, Src1Len, Src2Begin, Src2Len, ...; // We should remember that this value is available somewhere else to; // coalesce the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:326,avail,available,326,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['avail'],['available']
Availability,// DefGenerator moved into TmpDG to ensure that it's destroyed outside the; // session lock (since it may have to send errors to pending queries).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:119,error,errors,119,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['errors']
Availability,"// Default Constructor. If tolerances are not given use default values from ROOT::Math::IntegratorOneDimOptions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussIntegrator.cxx:27,toler,tolerances,27,math/mathcore/src/GaussIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussIntegrator.cxx,1,['toler'],['tolerances']
Availability,// Default arguments cannot be substituted until the declaration context; // for the associated function or lambda capture class is available.; // This is necessary for cases like the following where construction of; // the lambda capture class for the outer lambda is dependent on the; // parameter types but where the default argument is dependent on the; // outer lambda's declaration context.; // template <typename T>; // auto f() {; // return [](T = []{ return T{}; }()) { return 0; };; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:132,avail,available,132,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['avail'],['available']
Availability,"// Default constructor: only ever created from C++, as by definition, creation; // from the Python side makes the relevant Python instance available. Calls to; // the default ctor happen eg. in STL containers. It is expected that the; // pointer to the Python object is filled in later, eg. through assign().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h:139,avail,available,139,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h,1,['avail'],['available']
Availability,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ChainedDiagnosticConsumer.h:36,error,errors,36,interpreter/llvm-project/clang/include/clang/Frontend/ChainedDiagnosticConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ChainedDiagnosticConsumer.h,6,['error'],['errors']
Availability,// Default implementation (Warnings/errors count). Keeps track of the; // number of errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:36,error,errors,36,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,2,['error'],['errors']
Availability,"// Default is, we are going to insert code to repair OpIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:46,repair,repair,46,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repair']
Availability,// Default to everything being available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,2,['avail'],['available']
Availability,// Default to print error if no filename is specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp:20,error,error,20,interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp,1,['error'],['error']
Availability,// Default to the all-true mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,2,['mask'],['mask']
Availability,"// Default to using all available threads in the system, but using only one; // thread per core (no SMT).; // Use -thinlto-threads=all to use hardware_concurrency() instead, which means; // to use all hardware threads or cores in the system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:24,avail,available,24,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,1,['avail'],['available']
Availability,"// Default to using all available threads in the system, but using only one; // thred per core, as indicated by the usage of; // heavyweight_hardware_concurrency() below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['avail'],['available']
Availability,"// Default to wave32 if available, or wave64 if not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/TargetParser.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/TargetParser/TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/TargetParser.cpp,1,['avail'],['available']
Availability,"// Defend against the user having an old version of the API by ensuring that; // any fields they didn't see are cleared. We must defend against fields being; // set to the bitwise equivalent of zero, and assume that this means ""do the; // default"" as if that option hadn't been available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp:278,avail,available,278,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,1,['avail'],['available']
Availability,// Defer to cannot select error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:26,error,error,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['error'],['error']
Availability,// Deferred Handling of non-zero offsets. This makes the error messages nicer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:57,error,error,57,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['error'],['error']
Availability,"// Define a named RooArgSet with given constituents. If importMissing is true, any constituents; // of aset that are not in the workspace will be imported, otherwise an error is returned; // for missing components; // Check if set was previously defined, if so print warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:169,error,error,169,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['error'],['error']
Availability,// Define a new register mask from the existing mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['mask'],['mask']
Availability,"// Define alternate numeric integrator configuration for bin integration; // We expect bin contents to very only very slowly so a non-adaptive; // Gauss-Kronrod integrator is expected to perform well (if RooFitMore is available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:218,avail,available,218,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,1,['avail'],['available']
Availability,// Define available target features; // These must be defined in sorted order!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp:10,avail,available,10,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp,2,['avail'],['available']
Availability,"// Define the input data for subsequent calls to DoUnfold(Double_t); // input: input distribution with errors; // scaleBias: scale factor applied to the bias; // oneOverZeroError: for bins with zero error, this number defines 1/error.; // Return value: number of bins with bad error; // +10000*number of unconstrained output bins; // Note: return values>=10000 are fatal errors,; // for the given input, the unfolding can not be done!; // Calls the SetInput method of the base class, then renames the input; // vectors fY and fVyy, then performs the background subtraction; // Data members modified:; // fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; // and those modified by TUnfold::SetInput(); // and those modified by DoBackgroundSubtraction()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:103,error,errors,103,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,5,['error'],"['error', 'errors']"
Availability,"// Define the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:28,error,error,28,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,['error'],['error']
Availability,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:214,error,errors,214,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,1,['error'],['errors']
Availability,"// Defined in PassAnalysisSupport.h; /// mustPreserveAnalysisID - This method serves the same function as; /// getAnalysisIfAvailable, but works if you just have an AnalysisID. This; /// obviously cannot give you a properly typed instance of the class if you; /// don't have the class name available (use getAnalysisIfAvailable if you; /// do), but it can tell you if you need to preserve the pass at least.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:290,avail,available,290,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['avail'],['available']
Availability,// Definition for isSuperRegister. Put it down here since it needs the; // iterator defined above in addition to the MCRegisterInfo class itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:42,down,down,42,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['down'],['down']
Availability,// Definition of a PCH-ed template declaration may be available only in the TU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:54,avail,available,54,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['avail'],['available']
Availability,// Delay error emission for the OpenMP device code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['error'],['error']
Availability,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:187,Mask,Mask,187,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['Mask'],['Mask']
Availability,// Delete output file if there were errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:36,error,errors,36,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,1,['error'],['errors']
Availability,"// Demand input element 0 or 1, given by the mask bit value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Demangle C++ names in errors. GNU ld already defaults to --demangle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:25,error,errors,25,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,1,['error'],['errors']
Availability,"// DependentTemplateTypes exist within template declarations and; // definitions. Therefore we shouldn't encounter them at the end of; // a translation unit. If we do, the caller has made an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:191,error,error,191,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,1,['error'],['error']
Availability,"// Depending of course on the number of dimensions the object; // has. These commands will raise an error message if the user; // has not defined the function properly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:100,error,error,100,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['error'],['error']
Availability,"// Depending on available argument GPRS, f64 may be passed in a pair of; // GPRs, split between a GPR and the stack, or passed completely on the; // stack. LowerCall/LowerFormalArguments/LowerReturn must recognise these; // cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avail'],['available']
Availability,"// Depending on the number of groups for a particular value, it might be; // better to rotate, mask explicitly (using andi/andis), and then or the; // result. Select this part of the result first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:95,mask,mask,95,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Depends on a template parameter or an error in some way.; // Validity depends on how the template is instantiated or the error is; // resolved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:41,error,error,41,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['error'],['error']
Availability,"// Depends on template context, or an error.; // The type/value distinction is only meaningful for expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:38,error,error,38,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,// Depth threshold above which we can efficiently use variable mask shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// DestPtr is an array*. Construct an elementType* by drilling; // down a level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:67,down,down,67,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['down'],['down']
Availability,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c:237,error,error,237,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,6,['error'],['error']
Availability,// Desugar down to a function type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:11,down,down,11,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['down']
Availability,"// Desugar the type of the surrogate down to a function type,; // retaining as many typedefs as possible while still showing; // the function type (and, therefore, its parameter types).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,down,down,37,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['down']
Availability,// Detect AMD GPUs availible on the system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:19,avail,availible,19,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['avail'],['availible']
Availability,// Detect NVIDIA GPUs availible on the system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:22,avail,availible,22,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['avail'],['availible']
Availability,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,failure,failure,22,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['failure'],['failure']
Availability,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['error'],['error']
Availability,// Detect error if 2nd arg were present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// Detect errors in the header and report any that are found. If we make it; // past this without errors, we know we have a good magic value, a supported; // version number, verified address offset size and a valid UUID size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:10,error,errors,10,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,2,['error'],['errors']
Availability,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:53,error,errors,53,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,4,['error'],['errors']
Availability,// Detect the highest available version of libc++ in include path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:22,avail,available,22,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['avail'],['available']
Availability,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:264,robust,robust,264,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,1,['robust'],['robust']
Availability,"// Determine following cluster ids and the column ids that we want to make available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:75,avail,available,75,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['avail'],['available']
Availability,"// Determine for given input error matrix covariance matrix of unfolded; // spectrum from toy simulation; // ""cov"" - covariance matrix on the measured spectrum, to be propagated; // ""ntoys"" - number of pseudo experiments used for the propagation; // ""seed"" - seed for pseudo experiments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TSVDUnfold.h:29,error,error,29,hist/hist/inc/TSVDUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TSVDUnfold.h,1,['error'],['error']
Availability,"// Determine how many non-zero's are already available in; // [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx:45,avail,available,45,math/matrix/src/TMatrixTSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx,1,['avail'],['available']
Availability,"// Determine if given server serves exclusively exactly one of the given nodes in exclLVBranches; // Special case, no LV servers available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:129,avail,available,129,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['avail'],['available']
Availability,// Determine mask of lanes that cover their registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,// Determine maximum split level (byte level masking).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,mask,masking,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,// Determine range of mask elts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Determine shuffle input and normalize the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Determine the ID of an instruction, consuming the ModR/M byte as appropriate; // for extended and escape opcodes, and using a supplied attribute mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:148,mask,mask,148,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['mask'],['mask']
Availability,// Determine the effective mask value type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Determine the number of workers giving priority to users request.; // Otherwise use the system information, if available, or just start; // the minimal number, i.e. 2 .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:114,avail,available,114,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['avail'],['available']
Availability,// Determine the set of using directives available during; // unqualified name lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,avail,available,41,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avail'],['available']
Availability,"// Determine the value of the current token from the process's environment.; // Follows the WLCG Bearer Token Discovery schema.; // On error or no token discovered, returns the empty string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h:135,error,error,135,net/davix/inc/TDavixFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h,1,['error'],['error']
Availability,"// Determine whether VECTOR_SHUFFLE is a SPLATI.; //; // It is a SPLATI when the mask is:; // <x, x, x, ...>; // where x is any valid index.; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:81,error,error,81,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,3,"['error', 'recover']","['error', 'errors', 'recover']"
Availability,"// Determine whether this is an instruction prefix.; // FIXME:; // Enhance prefixes integrity robustness. for example, following forms; // are currently tolerated:; // repz repnz <insn> ; GAS errors for the use of two similar prefixes; // lock addq %rax, %rbx ; Destination operand must be of memory type; // xacquire <insn> ; xacquire must be accompanied by 'lock'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:94,robust,robustness,94,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,3,"['error', 'robust', 'toler']","['errors', 'robustness', 'tolerated']"
Availability,// Determine whether we've already imported this decl.; // FriendDecl is not a NamedDecl so we cannot use lookup.; // We try to maintain order and count of redundant friend declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:156,redundant,redundant,156,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['redundant'],['redundant']
Availability,// Determine which mask elements are attributed to which source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['mask'],['mask']
Availability,"// Determine which of the following types of shufflevector we're checking:; // 1) unary, vector mask: (lhs, mask); // 2) binary, scalar mask: (lhs, rhs, index, ..., index)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:96,mask,mask,96,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,3,['mask'],['mask']
Availability,// Determine zeroable mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:125,mask,mask,125,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,5,"['avail', 'mask']","['available', 'mask']"
Availability,"// Dev note: do not call zmqSvc()::close_context from here! The Messenger; // is (a member of) a static variable (JobManager) and ZeroMQSvc is static; // as well (the singleton returned by zmqSvc()). Because of the ""static; // destruction order fiasco"", it is not guaranteed that ZeroMQSvc singleton; // state is still available at time of destruction of the Messenger. Instead; // of a compile time error, this will lead to segfaults at runtime when; // exiting the program (on some platforms), because even though the ZeroMQSvc; // singleton pointer may be overwritten with random data, it will usually; // not randomly become nullptr, which means the nullptr check in the getter; // will still pass and the randomized pointer will be dereferenced.; // Instead, we close context in any new ProcessManager that may be created,; // which means the Messenger will get a fresh context anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:319,avail,available,319,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,2,"['avail', 'error']","['available', 'error']"
Availability,"// Developer note on the std::move() warning above:; //; // The point here was that you don't want to clone RooAbsL's too much, because they contain clones of the pdf and; // dataset that may have been mangled for optimization. You probably don't want to be doing that all the time, although; // it is a premature optimization, since we haven't timed its impact. That is the motivation behind using unique_ptrs; // for the components. The way the classes are built, the RooSumL doesn't care about what components it gets, so by; // definition it cannot create them internally, so they have to be passed in somehow. Forcing the user to call the; // function with a std::move is a way to make them fully realize that their local components will be destroyed and the; // contents moved into the RooSumL.; //; // We could change the type to an rvalue reference to make it clearer from the compiler error that std::move is; // necessary, instead of the obscure error that you get now. Compare the compiler error messages from these two types:; //; //#include <vector>; //#include <memory>; //#include <cstdio>; //; // struct Clear {; // Clear(std::vector<std::unique_ptr<int>>&& vec) : vec_(std::move(vec)) {; // printf(""number is %d"", *vec_[0]);; // }; //; // std::vector<std::unique_ptr<int>> vec_;; //};; //; // struct Obscure {; // Obscure(std::vector<std::unique_ptr<int>> vec) : vec_(std::move(vec)) {; // printf(""number is %d"", *vec_[0]);; // }; //; // std::vector<std::unique_ptr<int>> vec_;; //};; //; // int main() {; // std::vector<std::unique_ptr<int>> vec;; // vec.emplace_back(new int(4));; // Clear thing(vec);; // Obscure thingy(vec);; //}; /// \note Compared to the RooAbsTestStatistic implementation that this was taken from, we leave out Hybrid and; /// SimComponents interleaving support here. This should be implemented by a calculator (i.e. LikelihoodWrapper or; /// LikelihoodGradientWrapper derived class), if desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooSumL.cxx:894,error,error,894,roofit/roofitcore/src/TestStatistics/RooSumL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooSumL.cxx,3,['error'],['error']
Availability,"// Developers rely on dynamic invariants such as an item should be available; // in a collection, or a collection is not empty often. Those invariants can; // not be inferred by any static analysis tool. To not to bother the users; // with too many false positives, every item retrieval function should be; // ignored for collections. The instance methods of dictionaries in Cocoa; // are either item retrieval related or not interesting nullability wise.; // Using this fact, to keep the code easier to read just ignore the return; // value of every instance method of dictionaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:67,avail,available,67,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['avail'],['available']
Availability,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,recover,recover,110,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['down', 'recover']","['downgrade', 'recover']"
Availability,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,avail,availability,12,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['Avail', 'avail']","['Availability', 'availability']"
Availability,// Diagnose availability in the context of the @interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,avail,availability,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['avail'],['availability']
Availability,// Diagnose availability in the context of the ObjC container.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,avail,availability,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['avail'],['availability']
Availability,"// Diagnose cases where a scalar was implicitly converted to a vector and; // diagnose the underlying types. Otherwise, diagnose the error; // as invalid vector logical operands for non-C++ cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:133,error,error,133,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,// Diagnose errors for things like: #define F(X) #X / F(\),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:12,error,errors,12,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,1,['error'],['errors']
Availability,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,recover,recovered,21,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['recover'],['recovered']
Availability,// Diagnose non-identical duplicates as a 'conflicting' loop attributes; // and suppress duplicate errors in cases where the two match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:99,error,errors,99,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['error'],['errors']
Availability,"// Diagnose references or pointers to incomplete types differently,; // since it's far from impossible that the incompleteness triggered; // the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:145,failure,failure,145,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['failure'],['failure']
Availability,// Diagnose the ambiguity and return an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:40,error,error,40,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Diagnose the error and pretend there is no in-class initializer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,"// Diagnose this as unqualified lookup into a dependent base class. If 'this'; // is available, suggest inserting 'this->' as a fixit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:85,avail,available,85,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avail'],['available']
Availability,"// Diagnostic with no location (e.g. file not found, command line arg error).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h:70,error,error,70,interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,1,['error'],['error']
Availability,"// Did a fail-stop error of any kind occur when parsing the specifier?; // If so, don't do any more processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,3,['error'],['error']
Availability,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:45,error,error,45,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,6,"['error', 'recover']","['error', 'recover']"
Availability,"// Did we get any overridden cursors? If not, return Vec to the pool; // of available cursor vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:76,avail,available,76,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,1,['avail'],['available']
Availability,// Did you forget to use Error / Expected in your handler?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:25,Error,Error,25,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Error'],['Error']
Availability,"// Didn't encounter an error, didn't find an ivar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// Dig through references, function pointers, and block pointers to; // get down to the likely type of an expression when the entity is; // used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:76,down,down,76,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['down'],['down']
Availability,"// Directory is not writable or not available, use default directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEventGen.cxx:36,avail,available,36,proof/proofbench/src/TSelEventGen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEventGen.cxx,1,['avail'],['available']
Availability,"// Disable ProfileMergeInlinee if profile is not loaded in top down order,; // because the profile for a function may be used for the profile; // annotation of its outline copy before the profile merging of its; // non-inlined inline instances, and that is not the way how; // ProfileMergeInlinee is supposed to work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:63,down,down,63,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['down'],['down']
Availability,"// Disable code motion if the current position is S_Retain to prevent; // moving the objc_retain call past objc_release calls. If it's; // S_CanRelease or larger, it's not necessary to disable code motion as; // the insertion points that prevent the objc_retain call from moving down; // should have been set already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:279,down,down,279,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,"// Disable core dumps in the child process as otherwise everytime we; // encounter an execution failure like a segmentation fault, we will create; // a core dump. We report the information directly rather than require the; // user inspect a core dump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:96,failure,failure,96,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,2,"['failure', 'fault']","['failure', 'fault']"
Availability,"// Disable extending masked loads for fixed-width for now, since the code; // quality doesn't look great.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:21,mask,masked,21,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['masked']
Availability,"// Disable line numbers in error messages and warnings, they don't add much; // to the output and are rather confusing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:27,error,error,27,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['error'],['error']
Availability,// Disable the abort but emit a diagnostic on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:46,failure,failure,46,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['failure'],['failure']
Availability,// Disable the presentation of standard compiler warnings when using; // --analyze. We only want to show static analyzer diagnostics or frontend; // errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:149,error,errors,149,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['errors']
Availability,"// Disable the ranges processing if we have just a single .dwo object,; // as any DW_AT_ranges will access not available range information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp:111,avail,available,111,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,1,['avail'],['available']
Availability,"// Disabled until CallFunc is informed about unloading, and can; // re-generate the wrapper (if the decl is still available). See; // https://github.com/root-project/root/issues/10898",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:114,avail,available,114,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['avail'],['available']
Availability,"// Disabled until CallFunc is informed about unloading, and can; // re-generate the wrapper (if the decl is still available). See; // https://github.com/root-project/root/issues/10898; // We still have to release the allocations which resets their addresses; // to FinalizedAlloc::InvalidAddr, or the assertion in ~FinalizedAlloc; // will be unhappy...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:114,avail,available,114,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['avail'],['available']
Availability,"// Disabling the assert and returning first call probe seen so far.; // Subsequent call probes, if any, are ignored. Due to the the way; // .pseudo_probe section is decoded, probes of the same-named independent; // static functions are merged thus multiple call probes may be seen for a; // callsite. This should only happen to compiler-generated statics, with; // -funique-internal-linkage-names where user statics get unique names.; //; // TODO: re-enable or narrow down the assert to static functions only.; //; // assert(!CallProbe &&; // ""There should be only one call probe corresponding to address ""; // ""which is a callsite."");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:468,down,down,468,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['down'],['down']
Availability,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,recover,recover,49,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['recover'],['recover']
Availability,"// Dispatch to each element type for lowering. If we don't have support for; // specific element type shuffles at 512 bits, immediately split them and; // lower them. Each lowering routine of a given type is allowed to assume that; // the requisite ISA extensions for that element type are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:290,avail,available,290,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// Display a load error message.; /*; std::stringstream ss;; ss << ""<html><body bgcolor=\""white\"">""; ""<h2>Failed to load URL ""; << failedUrl.ToString().substr(0,100) << "" with error "" << errorText.ToString() << "" ("" << errorCode; << "").</h2></body></html>"";; frame->LoadURL(GetDataURI(ss.str(), ""text/html""));; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx:18,error,error,18,gui/cefdisplay/src/gui_handler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx,4,['error'],"['error', 'errorCode', 'errorText']"
Availability,// Display the button type according to the message with the highest severity; // The priority of the message types are as follows: Error > Warning > Success > Info,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/ClientLog.controller.js:132,Error,Error,132,ui5/eve7/controller/ClientLog.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/ClientLog.controller.js,1,['Error'],['Error']
Availability,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:93,alive,alive,93,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,5,['alive'],['alive']
Availability,"// Distinguish ELF data from code symbols, which will be used later on to; // decide whether to 'disassemble' this chunk as a data declaration via; // dumpELFData(), or whether to treat it as code.; //; // If data _and_ code symbols are defined at the same address, the code; // takes priority, on the grounds that disassembling code is our main; // purpose here, and it would be a worse failure to _not_ interpret; // something that _was_ meaningful as code than vice versa.; //; // Any ELF symbol type that is not clearly data will be regarded as code.; // In particular, one of the uses of STT_NOTYPE is for branch targets; // inside functions, for which STT_FUNC would be inaccurate.; //; // So here, we spot whether there's any non-data symbol present at all,; // and only set the DisassembleAsELFData flag if there isn't. Also, we use; // this distinction to inform the decision of which symbol to print at; // the head of the section, so that if we're printing code, we print a; // code-related symbol name to go with it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:388,failure,failure,388,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['failure'],['failure']
Availability,"// Distort data such that the shape systematics will pull gamma; // down in one bin and up in the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:68,down,down,68,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['down'],['down']
Availability,// Divides Blocks having no bottom up or top down dependencies on Reserved groups.; // The new colors are computed according to the dependencies on the other blocks; // formed with colorAccordingToReservedDependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:45,down,down,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['down'],['down']
Availability,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:45,mask,masked-off,45,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['mask'],['masked-off']
Availability,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:473,avail,available,473,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,// Do a half shuffle for the low mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Do a half shuffle with the high mask after shifting its values down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,"// Do a quick check for whether that sort alone has given us a perfect; // layout with no interior padding. This is very common: if the; // fixed-layout fields have no interior padding, and they end at a; // sufficiently-aligned offset for all the flexible-layout fields,; // and the flexible-layout fields all have sizes that are multiples; // of their alignment, then this will reliably trigger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:380,reliab,reliably,380,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,1,['reliab'],['reliably']
Availability,"// Do a simple check for overlap: if the two arguments are from the same; // buffer, see if the end of the first is greater than the start of the second; // or vice versa.; // If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:222,failure,failure,222,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['failure'],['failure']
Availability,// Do as if VirtReg was assigned to PhysReg so that the underlying; // recoloring has the right information about the interferes and; // available colors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:137,avail,available,137,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['avail'],['available']
Availability,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,redundant,redundant,46,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,2,['redundant'],['redundant']
Availability,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,mask,masked,172,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,// Do not attempt to optimise across exec mask changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp,1,['mask'],['mask']
Availability,"// Do not create a ""ref-variable"" if the original is not also available; // on the host.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:62,avail,available,62,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avail'],['available']
Availability,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,// Do not emit the error when preprocessing assembler code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['error'],['error']
Availability,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,redundant,redundant,33,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,"// Do not instrument the rtti proxies with hwasan to avoid a duplicate; // symbol error. Aliases generated by hwasan will retain the same namebut; // the addresses they are set to may have different tags from different; // compilation units. We don't run into this without hwasan because the; // proxies are in comdat groups, but those aren't propagated to the alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:82,error,error,82,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['error'],['error']
Availability,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:355,mainten,maintenance,355,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,1,['mainten'],['maintenance']
Availability,// Do not mask a register that is not used further.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['mask'],['mask']
Availability,// Do not migrate to couple of bridge transfer casts which; // cancel each other out. Leave it unchanged so error gets user; // attention instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp:108,error,error,108,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,1,['error'],['error']
Availability,"// Do not pass the option to the GPU compilation. We still want it enabled; // for the host-side compilation, so seeing it here is not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:138,error,error,138,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"// Do not print a second error message here.; // Error(""ReadBuffer"", ""Memory allocation failed!\n"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:25,error,error,25,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,"// Do not print a second error message here.; //Error(""ReadBuffer"", ""Memory allocation failed!\n"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoReadBuffer.cxx:25,error,error,25,io/io/src/TStreamerInfoReadBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoReadBuffer.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,"// Do not print the error if the file already had a SysError.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:20,error,error,20,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,2,['error'],['error']
Availability,// Do not promote the mask operand of a VP OP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,"// Do not prorate the indirect callsite distribution since the original; // distribution will be used to scale down non-promoted profile target; // counts later. By doing this we lose track of the real callsite count; // for the leftover indirect callsite as a trade off for accurate call; // target counts.; // TODO: Ideally we would have two separate factors, one for call site; // counts and one is used to prorate call target counts.; // Do not update the promoted direct callsite distribution at this; // point since the original distribution combined with the callee profile; // will be used to prorate callsites from the callee if inlined. Once not; // inlined, the direct callsite distribution should be prorated so that; // the it will reflect the real callsite counts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:111,down,down,111,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['down'],['down']
Availability,"// Do not report dereferences on memory that use address space #256, #257,; // and #258. Those address spaces are used when dereferencing address spaces; // relative to the GS, FS, and SS segments on x86/x86-64 targets.; // Dereferencing a null pointer in these address spaces is not defined; // as an error. All other null dereferences in other address spaces; // are defined as an error unless explicitly defined.; // See https://clang.llvm.org/docs/LanguageExtensions.html, the section; // ""X86/X86-64 Language Extensions""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:302,error,error,302,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,2,['error'],['error']
Availability,"// Do not return ToDOrErr, error was taken out of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,// Do not serialize masked loads of constant memory with anything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:20,mask,masked,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['masked']
Availability,// Do not set custom new handler if exceptions are enabled. In this case OOM; // errors are handled by throwing 'std::bad_alloc'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:81,error,errors,81,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['error'],['errors']
Availability,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,2,['error'],['error']
Availability,// Do not sink MI if it might be used to optimize a redundant compare.; // We heuristically only look at the instruction immediately following MI to; // avoid potentially searching the entire basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:52,redundant,redundant,52,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['redundant'],['redundant']
Availability,"// Do not suppress errors on defensive code paths, because dereferencing; // a nullable pointer is always an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:19,error,errors,19,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,2,['error'],"['error', 'errors']"
Availability,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:240,avail,available,240,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avail'],['available']
Availability,// Do not terminate after processing the input. This allows us to keep various; // clang objects alive and to incrementally grow the current TU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:97,alive,alive,97,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['alive'],['alive']
Availability,// Do not treat 'std::forward' as a builtin if it takes an rvalue reference; // type and returns an lvalue reference type. The library implementation; // will produce an error in this case; don't get in its way.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:170,error,error,170,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,recover,recover,17,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['recover'],"['recover', 'recovery']"
Availability,"// Do not use the identify_magic overload taking a path: It will open the; // file and then mmap its contents, possibly causing bus errors when another; // process truncates the file while we are trying to read it. Instead just; // read the first 1024 bytes, which should be enough for identify_magic to; // do its work.; // TODO: Fix the code upstream and consider going back to calling the; // convenience function after a future LLVM upgrade.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp:132,error,errors,132,interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManager.cpp,1,['error'],['errors']
Availability,// Do nothing if no frame is open. MCStreamer should've already reported an; // error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,1,['error'],['error']
Availability,// Do nothing. These CCs are not available as attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:33,avail,available,33,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['avail'],['available']
Availability,"// Do the following transformation:; //; // x < min(a, b) -> x < a && x < b; // x > min(a, b) -> x > a || x > b; // x < max(a, b) -> x < a || x < b; // x > max(a, b) -> x > a && x > b; //; // Such patterns are introduced by LICM.cpp:hoistMinMax(); // transformation and might lead to BPF verification failures for; // older kernels.; //; // To minimize ""collateral"" changes only do it for icmp + min/max; // calls when icmp is inside a loop and min/max is outside of that; // loop.; //; // Verification failure happens when:; // - RHS operand of some `icmp LHS, RHS` is replaced by some RHS1;; // - verifier can recognize RHS as a constant scalar in some context;; // - verifier can't recognize RHS1 as a constant scalar in the same; // context;; //; // The ""constant scalar"" is not a compile time constant, but a register; // that holds a scalar value known to verifier at some point in time; // during abstract interpretation.; //; // See also:; // https://lore.kernel.org/bpf/20230406164505.1046801-1-yhs@fb.com/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:301,failure,failures,301,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,2,['failure'],"['failure', 'failures']"
Availability,// Do we actually prefer shifts over mask?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Do we have an echo statement? ""A la RooFit""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HLFactory.cxx:17,echo,echo,17,roofit/roostats/src/HLFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HLFactory.cxx,1,['echo'],['echo']
Availability,"// Does RPO traversal over all blocks in \p F and assigns weights to; // 'unreachable', 'noreturn', 'cold', 'unwind' blocks. In addition it does its; // best to propagate the weight to up/down the IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:188,down,down,188,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['down'],['down']
Availability,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,redundant,redundant,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['redundant'],['redundant']
Availability,"// Does this instruction care about mask policy. If it is not, the mask policy; // could be either agnostic or undisturbed. For example, unmasked, store, and; // reduction operations result would not be affected by mask policy, so; // compiler has free to select either one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,3,['mask'],['mask']
Availability,// Does this mask has any unset bits? If not then we can just not apply it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,"// Doing a perfect shuffle on a low-half mask (i.e. where the upper half; // is all-undef) may produce a perfect shuffle that generates legitimate; // upper half. This isn't wrong, but if the perfect shuffle was possible,; // then there is a good chance that a shorter (contracting) code may be; // used as well (e.g. V6_vshuffeb, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,// Doing this post-RA would require dataflow analysis to reliably find uses; // of the CR register set by the compare.; // No need to fixup killed/dead flag since this transformation is only valid; // before RA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:57,reliab,reliably,57,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['reliab'],['reliably']
Availability,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,redundant,redundant,15,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['redundant'],['redundant']
Availability,"// Don't add code regions for the area covered by expansion regions.; // This not only suppresses redundant regions, but sometimes prevents; // creating regions with wrong counters if, for example, a statement's; // body ends at the end of a nested macro.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:98,redundant,redundant,98,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['redundant'],['redundant']
Availability,// Don't allow a mapping to a warning override an error/fatal mapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:50,error,error,50,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,1,['error'],['error']
Availability,"// Don't allow further instantiation if a fatal error and an uncompilable; // error have occurred. Any diagnostics we might have raised will not be; // visible, and we do not need to construct a correct AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:48,error,error,48,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,2,['error'],['error']
Availability,"// Don't allow specializing in the wrong class during error recovery.; // Otherwise, things can go horribly wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Don't ask a Mach-O STAB symbol for its section unless you know that; // STAB symbol's section field refers to a valid section index. Otherwise; // the symbol may error trying to load a section that does not exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:165,error,error,165,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,2,['error'],['error']
Availability,// Don't ask a Mach-O STABS symbol for its section unless we know that; // STAB symbol's section field refers to a valid section index. Otherwise; // the symbol may error trying to load a section that does not exist.; // TODO: Add a whitelist of STABS symbol types that contain valid section; // indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/MachODumper.cpp:165,error,error,165,interpreter/llvm-project/llvm/tools/llvm-readobj/MachODumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/MachODumper.cpp,1,['error'],['error']
Availability,// Don't attempt Entry validation if any of the previous checks found errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:70,error,errors,70,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['errors']
Availability,// Don't attempt this for boolean mask vectors or unknown extraction indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Don't attempt to hoist instructions with register masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:53,mask,masks,53,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['mask'],['masks']
Availability,// Don't attempt to import nodes if we hit an error earlier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:46,error,error,46,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,// Don't bother inserting AssertZext for packed IDs since we're emitting the; // masking operations anyway.; //; // TODO: We could assert the top bit is 0 for the source copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:81,mask,masking,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,2,['mask'],['masking']
Availability,"// Don't bother moving everything down, just null out the slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:34,down,down,34,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,1,['down'],['down']
Availability,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:85,error,error,85,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,2,['error'],['error']
Availability,// Don't bother to repair a freshly calculated live interval.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:19,repair,repair,19,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['repair'],['repair']
Availability,// Don't bother using generic instructions/registers for the exec mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['mask'],['mask']
Availability,"// Don't bother with single bits.; // If this is at the root of the pattern, we emit a redundant; // CheckOpcode so that the following checks get factored properly under; // a single opcode check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:87,redundant,redundant,87,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['redundant'],['redundant']
Availability,// Don't break anti-dependencies if a use down below requires; // this exact register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:42,down,down,42,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['down'],['down']
Availability,// Don't call the normal error handler. It may allocate memory. Directly write; // an OOM to stderr and abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['error'],['error']
Availability,"// Don't check for uninitialized field values in arguments if the; // caller has a body that is available and we have the chance to inline it.; // This is a hack, but is a reasonable compromise betweens sometimes warning; // and sometimes not depending on if we decide to inline a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:96,avail,available,96,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['avail'],['available']
Availability,"// Don't clobber SP, even if the mask says it's clobbered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['mask'],['mask']
Availability,// Don't combine AND since emitComparison converts the AND to an ANDS; // (a.k.a. TST) and the test in the test bit and branch instruction; // becomes redundant. This would also increase register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:151,redundant,redundant,151,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['redundant'],['redundant']
Availability,// Don't combine if we are a AVX512/EVEX target and the mask element size; // is different from the root element size - this would prevent writemasks; // from being reused.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Don't complain for incomplete types, since we'll get an error elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,error,error,59,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['error'],['error']
Availability,// Don't consider SP to be clobbered by register masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:49,mask,masks,49,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,1,['mask'],['masks']
Availability,// Don't convert an 'and' into a shuffle that we don't directly support.; // vpblendw and vpshufb for 256-bit vectors are not available on AVX1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,avail,available,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Don't create a PCH if there were fatal failures during module loading.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp:42,failure,failures,42,interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,1,['failure'],['failures']
Availability,// Don't create illegal shuffle masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,mask,masks,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masks']
Availability,// Don't diagnose array bound narrowing here; we produce more precise; // errors by allowing the un-narrowed value through.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:74,error,errors,74,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['errors']
Availability,"// Don't diagnose previously diagnosed errors.; // If any arguments are required to be ICE's, check and diagnose.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:39,error,errors,39,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['errors']
Availability,// Don't diagnose unused-parameter errors in template instantiations; we; // will already have done so in the template itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,error,errors,35,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// Don't display an error for downloaded files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx:20,error,error,20,gui/cefdisplay/src/gui_handler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx,2,"['down', 'error']","['downloaded', 'error']"
Availability,"// Don't do PRE on GEPs. The inserted PHI would prevent CodeGenPrepare from; // sinking the addressing mode computation back to its uses. Extending the; // GEP's live range increases the register pressure, and therefore it can; // introduce unnecessary spills.; //; // This doesn't prevent Load PRE. PHI translation will make the GEP available; // to the load by moving it to the predecessor block if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:334,avail,available,334,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// Don't do any extra work if an error that is not still recovered occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:33,error,error,33,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,"['error', 'recover']","['error', 'recovered']"
Availability,// Don't do any more checking. We will just emit; // spurious errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:62,error,errors,62,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['error'],['errors']
Availability,// Don't do anything if the intrinsic is called with different function; // types. This would result in a verifier error anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:115,error,error,115,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['error'],['error']
Availability,"// Don't do anything if the mask is constant. This should not be reachable.; // InstCombine should have already unfolded this pattern, and DAGCombiner; // probably shouldn't produce it, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Don't do anything on failures other than bad conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,failure,failures,24,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['failure'],['failures']
Availability,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:133,avail,available,133,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['avail'],['available']
Availability,"// Don't duplicate into a fall-through predecessor (at least for now).; // If profile is available, findDuplicateCandidates can choose better; // fall-through predecessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avail'],['available']
Availability,// Don't emit an error when this is redefinition of a typo-corrected; // definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Don't emit module relocation error if we have -fno-validate-pch,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:32,error,error,32,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,['error'],['error']
Availability,// Don't emit warnings after this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,error,error,34,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Don't emit warnings as errors (and all other warnings too).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:26,error,errors,26,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['error'],['errors']
Availability,// Don't error if the user asked for help.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:9,error,error,9,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,1,['error'],['error']
Availability,"// Don't even go down this path for i64, since different logic will be; // necessary for rldicl/rldicr/rldimi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['down'],['down']
Availability,// Don't expand if there is a target instruction available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avail'],['available']
Availability,// Don't extend into the upper 32 bits of a 64 bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Don't fold a shuffle with undef mask elements. This may get folded in a; // better way using demanded bits or other analysis.; // TODO: Should we allow this?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,// Don't fold into a copy to a physical register with the same class. Doing; // so would interfere with the register coalescer's logic which would avoid; // redundant initializations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:157,redundant,redundant,157,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['redundant'],['redundant']
Availability,"// Don't forward into undef use operands since doing so can cause problems; // with the machine verifier, since it doesn't treat undef reads as reads,; // so we can end up with a live range that ends on an undef read, leading to; // an error that the live range doesn't end on a read of the live range; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:236,error,error,236,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['error'],['error']
Availability,"// Don't generate 24-bit multiplies on values that are in SGPRs, since; // we only have a 32-bit scalar multiply (avoid values being moved to VGPRs; // unnecessarily). isDivergent() is used as an approximation of whether the; // value is in an SGPR.; // This doesn't apply if no s_mul_hi is available (since we'll end up with a; // valu op anyway)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:291,avail,available,291,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['avail'],['available']
Availability,// Don't generate anything that came from parseAnalyzerConfigs. It would be; // redundant and may not be valid on the command line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:80,redundant,redundant,80,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['redundant'],['redundant']
Availability,// Don't give errors about ambiguities in this lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,error,errors,14,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['errors']
Availability,// Don't have an explicit extend. Try to handle a G_AND with a constant mask; // on the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['mask'],['mask']
Availability,// Don't introduce calls to memcpy/memmove intrinsics out of thin air if; // the corresponding libcalls are not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:112,avail,available,112,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,['avail'],"['availability', 'available']"
Availability,"// Don't know anything; // Depth may get bigger than max depth if it gets passed to a different; // GISelKnownBits object.; // This may happen when say a generic part uses a GISelKnownBits object; // with some max depth, but then we hit TL.computeKnownBitsForTargetInstr; // which creates a new GISelKnownBits object with a different and smaller; // depth. If we just check for equality, we would never exit if the depth; // that is passed down to the target specific GISelKnownBits object is; // already bigger than its max depth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:440,down,down,440,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,1,['down'],['down']
Availability,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,recover,recovery,148,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recovery']
Availability,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,failure,failure,42,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['failure'],['failure']
Availability,// Don't make available until backtracking is complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,// Don't mask bits on 32-bit AVX512 targets which might lose a broadcast.; // FIXME: Can we bound this better?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Don't offer a fixit for declarations with availability attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:45,avail,availability,45,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,// Don't optimize before the condition has been transformed to a legal type; // and don't ever optimize vector selects that map to AVX512 mask-registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:138,mask,mask-registers,138,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask-registers']
Availability,"// Don't pass down template parameter lists if this is just a tag; // reference. For example, we don't need the template parameters here:; // template <class T> class A *makeA(T t);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:14,down,down,14,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['down'],['down']
Availability,// Don't print 'X warnings and Y errors generated'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:33,error,errors,33,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['error'],['errors']
Availability,"// Don't print out more errors after the first one we encounter. The rest; // are just the result of the first, and have no meaning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:24,error,errors,24,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['errors']
Availability,"// Don't proceed unless we've refined at least one zeroable mask indice.; // If we didn't, then we are still trying to match the same shuffle mask; // we previously tried to match as ISD::ANY_EXTEND_VECTOR_INREG,; // and evidently failed. Proceeding will lead to endless combine loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Don't produce a duplicate error when asked to explain why the; // comparison is deleted: we diagnosed that when initially checking; // the defaulted operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,// Don't promote the alloca to LDS for shader calling conventions as the work; // item ID intrinsics are not supported for these calling conventions.; // Furthermore not all LDS is available for some of the stages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:181,avail,available,181,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['avail'],['available']
Availability,// Don't record offsets for selectors that are also available in a different; // file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:52,avail,available,52,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['avail'],['available']
Availability,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,recover,recover,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,// Don't remove output file if we exit with an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:47,error,error,47,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,2,['error'],['error']
Availability,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:63,repair,repair,63,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['repair'],['repair']
Availability,// Don't report an error if 'throw' is used in system headers or in an OpenMP; // target region compiled for a GPU architecture.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['error']
Availability,// Don't report an error if 'try' is used in system headers or in an OpenMP; // target region compiled for a GPU architecture.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,// Don't report an error inside a move related operation.; // We assume that the programmer knows what she does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['error'],['error']
Availability,// Don't report errors for missing remark files from static; // archives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:16,error,errors,16,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,1,['error'],['errors']
Availability,// Don't report typename errors for editor placeholders.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,error,errors,25,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,// Don't return the error here: maybe the file wasn't an archive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:20,error,error,20,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,1,['error'],['error']
Availability,// Don't run the actions if an error has occurred with parsing the file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['error'],['error']
Availability,// Don't scan down huge single-use chains of instrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:14,down,down,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['down'],['down']
Availability,"// Don't shrink FP constpool if SSE2 is available since cvtss2sd is more; // expensive than a straight movsd. On the other hand, it's important to; // shrink long double fp constant since fldt is very slow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:51,error,error,51,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Don't try to build an implicit initializer if there were semantic; // errors in any of the initializers (and therefore we might be; // missing some that the user actually wrote).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,error,errors,73,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,// Don't use V1/V2 if they're not the same size as the shuffle mask type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Don't use dominating conditions when folding icmp using known bits. This; // may convert signed into unsigned predicates in ways that other passes; // (especially IndVarSimplify) may not be able to reliably undo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:201,reliab,reliably,201,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reliab'],['reliably']
Availability,// Don't warn about localization errors in classes and methods that; // may be debug code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,error,errors,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['error'],['errors']
Availability,"// Don't worry about emitting an error for it not being an array,; // visitGlobalValue will complain on appending non-array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:33,error,error,33,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,"// Double the available space until it matches the new size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:14,avail,available,14,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['avail'],['available']
Availability,// Double-precision floating-point instructions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:52,avail,available,52,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,// Down,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Down,Down,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Down'],['Down']
Availability,"// Down triangle",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TImageDump.cxx:3,Down,Down,3,graf2d/postscript/src/TImageDump.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TImageDump.cxx,5,['Down'],['Down']
Availability,"// Downcast can only happen in class hierarchies, so we need classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Down,Downcast,3,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['Down'],['Downcast']
Availability,// Downcast to the dynamic type...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Down,Downcast,3,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Down'],['Downcast']
Availability,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Down,Downgrade,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Down'],['Downgrade']
Availability,"// Downsample in the traditional style",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx:3,Down,Downsample,3,test/vlazy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx,1,['Down'],['Downsample']
Availability,"// Downsample matrix - new style",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx:3,Down,Downsample,3,test/vlazy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx,1,['Down'],['Downsample']
Availability,// Downscale.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/FixedPointBuilder.h:3,Down,Downscale,3,interpreter/llvm-project/llvm/include/llvm/IR/FixedPointBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/FixedPointBuilder.h,1,['Down'],['Downscale']
Availability,"// Downsize the buffer if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:3,Down,Downsize,3,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['Down'],['Downsize']
Availability,"// Downstream users have expectations for the high bit behavior, so freeze; // incoming undefined bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:3,Down,Downstream,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['Down'],['Downstream']
Availability,"// Draw error only",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx:8,error,error,8,graf2d/graf/src/TLegend.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx,1,['error'],['error']
Availability,// Draw line and/or error (when specified),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,error,error,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['error']
Availability,"// Draw the error bars.; // Y errors are lines, but X errors are pieces of circles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,error,error,12,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,3,['error'],"['error', 'errors']"
Availability,// Drill down into arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['down'],['down']
Availability,// Drill down into concept specialization expressions to see why they; // weren't satisfied.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['down'],['down']
Availability,"// Drill down into the pointer expression V, ignoring any intervening; // casts, and determine the identity of the object it references along; // with the cumulative byte offset into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['down'],['down']
Availability,// Drill down into the reason why the class is non-structural.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['down'],['down']
Availability,"// Drill down the CXXBaseObject chains, which represent upcasts (casts from; // derived to base).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['down'],['down']
Availability,"// Drill down the array types: if global variable of a fixed type is; // not sanitized, we also don't instrument arrays of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['down'],['down']
Availability,// Drill down the chain to get the derived classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['down'],['down']
Availability,// Drill down to the __block object if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['down'],['down']
Availability,// Drill down to the base element type on both arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:9,down,down,9,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,3,['down'],['down']
Availability,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:415,avail,available,415,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['avail'],['available']
Availability,// Drop bodies of available eternally objects to improve GlobalDCE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avail'],['available']
Availability,"// Drop down listbox of combo box should react to pointer motion...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx:8,down,down,8,gui/gui/src/TGComboBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx,1,['down'],['down']
Availability,"// Drop down listbox of combo box should react to pointer motion; // so it will be able to Activate() (i.e. highlight) the different; // items when the mouse crosses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx:8,down,down,8,gui/gui/src/TGComboBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGComboBox.cxx,1,['down'],['down']
Availability,// Drop down to FormatPrecision.; // TODO: don't do more precise calculations above than are required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['down'],['down']
Availability,// Drop imp-defs/uses that would be redundant with the new def/use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,redundant,redundant,36,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['redundant'],['redundant']
Availability,// Drop initializers of available externally global variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,1,['avail'],['available']
Availability,"// Drop piece down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:14,down,down,14,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,1,['down'],['down']
Availability,"// Drop the ""avx512.mask."" to make it easier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,3,['mask'],['mask']
Availability,// Drop the bodies of available externally functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,1,['avail'],['available']
Availability,"// Drop the terminating "" so Utf-8 errors can be detected (""\xeA"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Value.cpp:35,error,errors,35,interpreter/cling/lib/Interpreter/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Value.cpp,1,['error'],['errors']
Availability,"// Dual-register instruction have the following syntax:; // <mnemonic> <predicate>? <coproc>, <Rdest>, <Rdest+1>, <Rsrc>, ..., #imm; // This function tries to remove <Rdest+1> and replace <Rdest> with a pair; // operand. If the conversion fails an error is diagnosed, and the function; // returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:248,error,error,248,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// Dual-register instructions use even-odd register pairs as their; // destination operand, in assembly such pair is spelled as two; // consecutive registers, without any special syntax. ConvertDualRegOperand; // tries to convert such operand into register pair, e.g. r2, r3 -> r2_r3.; // It returns true, if an error message has been emitted. If the function; // returns false, the function either succeeded or an error (e.g. missing; // operand) will be diagnosed elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:312,error,error,312,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['error'],['error']
Availability,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['error'],['error']
Availability,// Due to ordering in legalize types we may have a vector type that needs to; // be split. Do that manually so we can get down to a legal type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:122,down,down,122,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,"// Dummy implementation returning zero, because not all deriving classes; // need to implement a non-zero weight error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:113,error,error,113,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,2,['error'],['error']
Availability,// Dummy retval never to be used. Allows catching errors in retval; // handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:50,error,errors,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['error'],['errors']
Availability,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:133,error,error,133,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['error'],['error']
Availability,// Dumper reports all non-critical errors as warnings.; // It does not print the same warning more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ObjDumper.cpp:35,error,errors,35,interpreter/llvm-project/llvm/tools/llvm-readobj/ObjDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ObjDumper.cpp,1,['error'],['errors']
Availability,// During template instantiation of implicit special member functions we need; // a reliable TypeSourceInfo for the function prototype in order to allow; // functions to be substituted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,reliab,reliable,84,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['reliab'],['reliable']
Availability,// During template instantiation of special member functions we need a; // reliable TypeSourceInfo for the parameter types in order to allow functions; // to be substituted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:75,reliab,reliable,75,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['reliab'],['reliable']
Availability,"// During the 'Deep' part of the search we will call GetClassSharedLibsForModule; // (when module are enabled) which might end up calling AutoParsing but; // that should only be for the cases where the library has no generated pcm; // and in that case a rootmap should be available.; // This avoids a very costly operation (for generally no gain) but reduce the; // quality of the search (i.e. bad in case of library with no pcm and no rootmap; // file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:272,avail,available,272,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avail'],['available']
Availability,// During the symbol traversal more information is available to; // determine if the symbol is a parameter or a variable. At this; // stage mark it as variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['avail'],['available']
Availability,"// Dynamic Mask for cell division, h-cubic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:11,Mask,Mask,11,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['Mask'],['Mask']
Availability,// Dynamic blending was only available from SSE4.1 onward.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// E x p l o r e r e s u l t s o f s t u d y; // ------------------------------------------------; // Make plots of the distributions of mean, the error on mean and the pull of mean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:147,error,error,147,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['error']
Availability,// EF_AVR_ARCH_xxx selection mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:29,mask,mask,29,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,// EF_MIPS_MACH_xxx selection mask; // ARCH_ASE,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:30,mask,mask,30,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,"// ERROR CODES - exit() is called with these",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h:3,ERROR,ERROR,3,math/mathcore/src/mixmax.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h,1,['ERROR'],['ERROR']
Availability,"// ERROR. parameter number not valid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:3,ERROR,ERROR,3,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['ERROR'],['ERROR']
Availability,"// ERRordef - now ignored",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:3,ERRor,ERRordef,3,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['ERRor'],['ERRordef']
Availability,// EVEX_X can extend the register id to 32 for a non-GPR register that is; // encoded in RM.; // mode : MODE_64_BIT; // Only 8 vector registers are available in 32 bit mode; // mod : 3; // RM encodes a register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:148,avail,available,148,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['avail'],['available']
Availability,"// Each byte in each mask is either selector mask 0-3, or has higher; // bits set in either of masks, which can be 0xff for 0xff or 0x0c for; // zero. If 0x0c is in either mask it shall always be 0x0c. Otherwise; // mask which is not 0xff wins. By anding both masks we have a correct; // result except that 0x0c shall be corrected to give 0x0c only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,6,['mask'],"['mask', 'masks']"
Availability,// Each byte in the shuffle control mask forms an index to permute the; // corresponding byte in the destination operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,// Each element of the unpack contains Scale elements from this mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,recover,recover,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recover']
Availability,// Each mask element must be undefined or choose a vector element from one of; // the source operands without crossing vector lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Each part of a break down needs to end up in a different register.; // In other word, Reg assignment does not match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:24,down,down,24,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['down'],['down']
Availability,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:81,mask,mask,81,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,4,['mask'],"['mask', 'masks']"
Availability,"// Each time we visit a new SCC pulled off the worklist,; // a transformation of a child SCC may have also modified this parent; // and invalidated analyses. So we invalidate using the update record's; // cross-SCC preserved set. This preserved set is intersected by any; // CGSCC pass that handles invalidation (primarily pass managers) prior; // to marking its SCC as preserved. That lets us track everything that; // might need invalidation across SCCs without excessive invalidations; // on a single SCC.; //; // This essentially allows SCC passes to freely invalidate analyses; // of any ancestor SCC. If this becomes detrimental to successfully; // caching analyses, we could force each SCC pass to manually; // invalidate the analyses for any SCCs other than themselves which; // are mutated. However, that seems to lose the robustness of the; // pass-manager driven invalidation scheme.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:832,robust,robustness,832,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['robust'],['robustness']
Availability,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:333,error,errors,333,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,1,['error'],['errors']
Availability,// Early exit if errors were found by the code region parsing logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:17,error,errors,17,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['error'],['errors']
Availability,// Early exit if errors were found by the instrumentation parsing logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:17,error,errors,17,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['error'],['errors']
Availability,// Early failures in LoadFromCommandLine may return with ErrUnit unset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:9,failure,failures,9,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['failure'],['failures']
Availability,"// Eat ""mips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,error,error,72,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""mt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:68,error,error,68,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""noat"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,error,error,70,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""nocrc"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,error,error,71,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""nodsp"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,error,error,71,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""noginv"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,error,error,72,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""nomips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,error,error,74,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""nomips3d"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,error,error,74,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""nomt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,error,error,70,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""novirt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,error,error,72,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Eat ""reg"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:69,error,error,69,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,// Eat the available or __builtin_available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:11,avail,available,11,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['avail'],['available']
Availability,// Eat the hash token.; // Lexer only ever emits HashDirective if it fully formed if it's; // done the checking already so this is an internal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:143,error,error,143,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['error']
Availability,"// Echo request: an object has been sent along. If the object is a; // string, it is simply echoed back to the client from the master; // and each worker. Elsewhere, the output of TObject::Print() is; // sent. Received object is disposed after usage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Echo,Echo,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,"['Echo', 'echo']","['Echo', 'echoed']"
Availability,// Effectively merge blocks. We go in the reverse direction from the phi block; // so that the next block is always available to branch to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:116,avail,available,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['avail'],['available']
Availability,"// Either Cur is in the error state, or we have an error in ULEBSizeErr or; // MetadataDecodeErr (but not both), but we join all errors here to be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp:24,error,error,24,interpreter/llvm-project/llvm/lib/Object/ELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp,3,['error'],"['error', 'errors']"
Availability,// Either all or no operands should have an AND mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Either both of the operands were mentioned or the smaller one was; // mentioned. One more special case that we'll allow: if the tied input is; // integer, unmentioned, and is a constant, then we'll allow truncating it; // down to the size of the destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:225,down,down,225,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['down'],['down']
Availability,"// Either one or two instructions are emitted.; // They're always of the form:; // dst = in OP imm; // CPSR is set only by 16-bit Thumb instructions.; // Predicate, if any, is AL.; // S bit, if available, is always 0.; // When two are emitted the first's result will feed as the second's input,; // that value is then dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:194,avail,available,194,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['avail'],['available']
Availability,"// Either we set the error for the first time, or we already had set one and; // now we want to set the same error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,error,error,21,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,// Element indices have changed after unpacking. Calculate permute mask; // so that they will be put back to the position as dictated by the; // original shuffle mask indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Elements to provide:; // typedef NodeRef - Type of Node token in the graph, which should; // be cheap to copy.; // typedef ChildIteratorType - Type used to iterate over children in graph,; // dereference to a NodeRef.; // static NodeRef getEntryNode(const GraphType &); // Return the entry node of the graph; // static ChildIteratorType child_begin(NodeRef); // static ChildIteratorType child_end (NodeRef); // Return iterators that point to the beginning and ending of the child; // node list for the specified node.; // typedef ...iterator nodes_iterator; - dereference to a NodeRef; // static nodes_iterator nodes_begin(GraphType *G); // static nodes_iterator nodes_end (GraphType *G); // nodes_iterator/begin/end - Allow iteration over all nodes in the graph; // typedef EdgeRef - Type of Edge token in the graph, which should; // be cheap to copy.; // typedef ChildEdgeIteratorType - Type used to iterate over children edges in; // graph, dereference to a EdgeRef.; // static ChildEdgeIteratorType child_edge_begin(NodeRef); // static ChildEdgeIteratorType child_edge_end(NodeRef); // Return iterators that point to the beginning and ending of the; // edge list for the given callgraph node.; //; // static NodeRef edge_dest(EdgeRef); // Return the destination node of an edge.; // static unsigned size (GraphType *G); // Return total number of nodes in the graph; // If anyone tries to use this class without having an appropriate; // specialization, make an error. If you get this error, it's because you; // need to include the appropriate specialization of GraphTraits<> for your; // graph, or you need to define it for a new graph type. Either that or; // your argument to XXX_begin(...) is unknown or needs to have the proper .h; // file #include'd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:1468,error,error,1468,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,2,['error'],['error']
Availability,"// Elide G_AND and mask constant if possible.; // The G_AND would also be removed by the post-legalize redundant_and; // combine, but in this very common case, eliding early and regardless of; // OptLevel results in significant compile-time and O0 code-size; // improvements. Inserting unnecessary instructions between boolean defs; // and uses hinders a lot of folding during ISel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:19,mask,mask,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['mask'],['mask']
Availability,// Eliminate a potential failure point where we attempt to re-import; // something we're trying to import while completing ToRecord.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:25,failure,failure,25,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['failure'],['failure']
Availability,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,redundant,redundant,53,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['redundant'],['redundant']
Availability,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['redundant'],['redundant']
Availability,// Eliminate redundant Phi nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,redundant,redundant,13,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redundant'],['redundant']
Availability,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redundant'],['redundant']
Availability,"// Eliminate redundant instructions; //; // This transformation will identify instructions where the output register; // is the same as one of its input registers. This only works on instructions; // that define a single register (unlike post-increment loads, for example).; // The equality check is actually more detailed: the code calculates which; // bits of the output are used, and only compares these bits with the input; // registers.; // If the output matches an input, the instruction is replaced with COPY.; // The copies will be removed by another transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['redundant'],['redundant']
Availability,"// Eliminate redundant variables, e.g. x = y, or x = 5,; // but keep anything more complicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,redundant,redundant,13,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redundant'],['redundant']
Availability,// Else SubVecVT is a fractional LMUL and may need to be slid down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:62,down,down,62,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,// Else use profile data if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avail'],['available']
Availability,// Else we must have produced an integer type with the same size as the; // mask type; bitcast for the final result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:76,mask,mask,76,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Else, recursively sink the cast down into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,down,down,35,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,// EltSize & Mask is 0 since Mask is EltSize - 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Mask,Mask,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['Mask'],['Mask']
Availability,"// Emit CurDiagStateLoc. Do it last in order to match source order.; //; // This also protects against a hypothetical corner case with simulating; // -Werror settings for implicit modules in the ASTReader, where reading; // CurDiagState out of context could change whether warning pragmas are; // treated as errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:308,error,errors,308,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['error'],['errors']
Availability,"// Emit SubRegIndex lane masks, including 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:25,mask,masks,25,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['mask'],['masks']
Availability,// Emit __EIND__ if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,1,['avail'],['available']
Availability,// Emit __RAMPZ__ if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,1,['avail'],['available']
Availability,// Emit __SP_H__ if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,1,['avail'],['available']
Availability,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:625,fault,fault,625,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,4,['fault'],"['fault', 'faulting']"
Availability,// Emit a VPTERNLOG node directly - 0xCA is the imm code for A?B:C.; // VPTERNLOG is only available as vXi32/64-bit types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,avail,available,90,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Emit a descriptor for every function including functions that have an; // available external linkage. We may not want this for imported functions; // that has code in another thinLTO module but we don't have a good way to; // tell them apart from inline functions defined in header files. Therefore; // we put each descriptor in a separate comdat section and rely on the; // linker to deduplicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:77,avail,available,77,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avail'],['available']
Availability,// Emit a function to get the user-visible string to describe an operand; // match failure in diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:83,failure,failure,83,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['failure'],['failure']
Availability,// Emit a function to map register classes to operand match failure codes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:60,failure,failure,60,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['failure'],['failure']
Availability,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,recover,recoverfp,86,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['recover'],['recoverfp']
Availability,// Emit a masked pternlog intrinsic. This only exists because the header has to; // use a macro and we aren't able to pass the input argument to a pternlog; // builtin and a select builtin without evaluating it twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,mask,masked,10,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['masked']
Availability,// Emit an error and return true if the current architecture is not in the list; // of supported architectures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// Emit an error and return true if the current object format type is in the; // list of unsupported types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Emit an error if an address space was applied to decl with local storage.; // This includes arrays of objects with address space qualifiers, but not; // automatic variables that point to other address spaces.; // ISO/IEC TR 18037 S5.1.2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Emit an error if the Mach-O binary does not contain an rpath path name; // specified in -delete_rpath.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,1,['error'],['error']
Availability,// Emit an error if the values differ.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['error'],['error']
Availability,// Emit an error if two (or more) named parameters share the same name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['error'],['error']
Availability,// Emit an error if two (or more) named parameters share the same name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['error'],['error']
Availability,"// Emit an unsupported bit_cast type error. Sema refuses to build a bit_cast; // with an invalid type, so anything left is a deficiency on our part (FIXME).; // Ideally this will be unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,error,error,37,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error']
Availability,// Emit any outstanding DW_OP_piece operations to mask out subregisters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['mask'],['mask']
Availability,// Emit build attributes for the available hardware.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,1,['avail'],['available']
Availability,// Emit check that the required features are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:45,avail,available,45,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,2,['avail'],['available']
Availability,// Emit code to get the available features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:24,avail,available,24,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,2,['avail'],['available']
Availability,// Emit default error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['error'],['error']
Availability,// Emit directive as a combined directive that consists of two implicit; // directives: 'parallel' with 'masked' directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:105,mask,masked,105,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['mask'],['masked']
Availability,// Emit extra processor info if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:32,avail,available,32,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['avail'],['available']
Availability,"// Emit fatal error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNovosibirsk.cxx:14,error,error,14,roofit/roofit/src/RooNovosibirsk.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNovosibirsk.cxx,1,['error'],['error']
Availability,// Emit fault map information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:8,fault,fault,8,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['fault'],['fault']
Availability,"// Emit following codes. This clobbers SX13 which we always know is; // available here.; // lea %s13, NumBytes@lo; // and %s13, %s13, (32)0; // lea.sl %sp, NumBytes@hi(%s13, %sp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:72,avail,available,72,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,1,['avail'],['available']
Availability,// Emit notes only for the first discovered declaration of unsupported type; // to avoid mess of notes. This flag is to track that error already happened.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp:131,error,error,131,interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,1,['error'],['error']
Availability,// Emit now if we can for better errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:33,error,errors,33,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['error'],['errors']
Availability,"// Emit our diagnostic and, if it was a warning or error, output a callstack; // if Fn isn't a priori known-emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:51,error,error,51,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,// Emit pending errors if any exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:16,error,errors,16,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['errors']
Availability,"// Emit register class bit mask tables. The first bit mask emitted for a; // register class, RC, is the set of sub-classes, including RC itself.; //; // If RC has super-registers, also create a list of subreg indices and bit; // masks, (Idx, Mask). The bit mask has a bit for every superreg regclass,; // SuperRC, that satisfies:; //; // For all SuperReg in SuperRC: SuperReg:Idx in RC; //; // The 0-terminated list of subreg indices starts at:; //; // RC->getSuperRegIndices() = SuperRegIdxSeqs + ...; //; // The corresponding bitmasks follow the sub-class mask in memory. Each; // mask has RCMaskWords uint32_t entries.; //; // Every bit mask present in the list has at least one bit set.; // Compress the sub-reg index lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,8,"['Mask', 'mask']","['Mask', 'mask', 'masks']"
Availability,// Emit saved FPR mask and offset to FPR save area (0x20 of flags 3).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,1,['mask'],['mask']
Availability,// Emit saved VR mask to VR save area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,1,['mask'],['mask']
Availability,// Emit stack and fault map information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:18,fault,fault,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['fault'],['fault']
Availability,// Emit super-reg class masks for any relevant SubRegIndices that can; // project into RC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:24,mask,masks,24,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['mask'],['masks']
Availability,// Emit the *_RegMask bit mask of call-preserved registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['mask'],['mask']
Availability,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:342,fault,fault,342,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['fault'],['fault']
Availability,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:757,error,error,757,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['error'],['error']
Availability,// Emit the available features compute function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:12,avail,available,12,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,2,['avail'],['available']
Availability,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:163,error,error,163,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,15,['error'],['error']
Availability,// Emit the compact unwind info if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['avail'],['available']
Availability,// Emit the error. First figure out which DeclRefExpr in the condition; // referenced the compared variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,1,['error'],['error']
Availability,// Emit the name table for error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp:27,error,error,27,interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp,1,['error'],['error']
Availability,// Emit the shared table of regunit lane mask sequences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['mask'],['mask']
Availability,// Emit the static custom operand parser. This code is very similar with; // the other matcher. Also use MatchResultTy here just in case we go for; // a better error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:160,error,error,160,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['error'],['error']
Availability,// Emit the symbol that is used to generate linker errors if this class is; // referenced in other modules but not declared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:51,error,errors,51,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['error'],['errors']
Availability,// Emit the unsupported option error until the Clang's library integration; // support for 128-bit long double is available for AIX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,// Emit this opcode when the mask covers every registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,1,['mask'],['mask']
Availability,// Emit this the hard way. This clobbers G1 which we always know is; // available here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:72,avail,available,72,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,1,['avail'],['available']
Availability,"// Emit two handler calls: first one for set of unrecoverable checks,; // another one for recoverable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:90,recover,recoverable,90,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recoverable']
Availability,// Emits an error if we don't have a valid set of target features for the; // called function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['error'],['error']
Availability,"// Empirically determine maximum value of function by taking a large number; // of samples. The actual number depends on the number of dimensions in which; // the sampling occurs; // Generate the minimum required number of samples for a reliable maximum estimate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx:237,reliab,reliable,237,roofit/roofitcore/src/RooAcceptReject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx,1,['reliab'],['reliable']
Availability,"// Empty directories could be present in the YAML as a way to; // describe a file for a current directory after some of its subdir; // is parsed. This only leads to redundant walks, ignore it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:165,redundant,redundant,165,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['redundant'],['redundant']
Availability,// Empty mask indicates the decode failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,4,['mask'],['mask']
Availability,// Empty statement should only be possible if there already was an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:67,error,error,67,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['error'],['error']
Availability,"// Empty types can be inherited from, and non-empty types can potentially; // have tail padding, so just make sure there isn't an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:130,error,error,130,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['error'],['error']
Availability,"// Emscripten exception handling helpers; //; // This converts invoke names generated by LowerEmscriptenEHSjLj to real names; // that are expected by JavaScript glue code. The invoke names generated by; // Emscripten JS glue code are based on their argument and return types; for; // example, for a function that takes an i32 and returns nothing, it is; // 'invoke_vi'. But the format of invoke generated by LowerEmscriptenEHSjLj pass; // contains a mangled string generated from their IR types, for example,; // ""__invoke_void_%struct.mystruct*_int"", because final wasm types are not; // available in the IR pass. So we convert those names to the form that; // Emscripten JS code expects.; //; // Refer to LowerEmscriptenEHSjLj pass for more details.; // Returns true if the given function name is an invoke name generated by; // LowerEmscriptenEHSjLj pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:589,avail,available,589,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,1,['avail'],['available']
Availability,"// Enable CPU pinning. Takes as argument the list of processor IDs; // that will be used in order. Processor IDs are numbered from 0,; // use likwid to see how they are organized. A possible parameter; // format would be:; //; // cpupin=3+4+0+9+10+22+7; //; // Only the specified processor IDs will be used in a round-robin; // fashion, dealing with the fact that you can request more workers; // than the number of processor IDs you have specified.; //; // To use all available processors in their order:; //; // cpupin=*",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:469,avail,available,469,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avail'],['available']
Availability,"// Enable LoopSink only when runtime profile is available.; // With static profile, the sinking decision may be sub-optimal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:48,avail,available,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,1,['avail'],['available']
Availability,// Enable ODR indicators which allow better handling of mixed instrumented; // and uninstrumented globals. Disable them for Windows where weak odr; // indicators (.weak.__odr_asan_gen*) may cause multiple definition linker; // errors in the absence of -lldmingw.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:227,error,errors,227,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['error'],['errors']
Availability,"// Enable Upper bound unrolling universally, providing that we do not see an; // active lane mask, which will be better kept as a loop to become tail; // predicated than to be conditionally unrolled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:93,mask,mask,93,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,// Enable aliases as they should have no downside with ODR indicators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:41,down,downside,41,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['down'],['downside']
Availability,"// Enable compatilibily mode to avoid analyzer-config related errors.; // Since we can't access frontend flags through hasArg, let's manually iterate; // through them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:62,error,errors,62,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['errors']
Availability,// Enable printing of available targets when flag --version is specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:22,avail,available,22,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,2,['avail'],['available']
Availability,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:172,avail,available,172,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['avail'],['available']
Availability,// Enabling both top down and bottom up scheduling seems to give us less; // register spills than just using one of these approaches on its own.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:21,down,down,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['down'],['down']
Availability,// Encode a range MinVersion..MaxVersion into a single bit mask that can be; // checked against LangOpts using isOpenCLVersionContainedInMask().; // This must be kept in sync with OpenCLVersionID in OpenCLOptions.h.; // (Including OpenCLOptions.h here would be a layering violation.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:59,mask,mask,59,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['mask'],['mask']
Availability,"// Encoding is unpredictable if it ever results in a notional 'NV'; // predicate. Since we don't parse 'NV' directly this means an 'AL'; // predicate with an ""else"" mask bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:165,mask,mask,165,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,"// End NS Internal; //////////////////////////////////////////////////////////////////////////; /// \brief Class constructor.; /// If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was; /// called), work with the current pool of threads.; /// If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the; /// pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; ///; /// At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling; /// ROOT::EnableThreadSafety().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:449,avail,available,449,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['avail'],['available']
Availability,// End anonymous namespace.; // TODO: this implementation is likely now redundant with the default; // EmitVAArg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:72,redundant,redundant,72,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['redundant'],['redundant']
Availability,"// End block, returns -1 on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:28,failure,failure,28,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,1,['failure'],['failure']
Availability,// End of Labels should be treated as end of line for lexing; // purposes but that information is not available to the Lexer who; // does not understand Labels. This may cause us to see a Hash; // here instead of a preprocessor line comment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:102,avail,available,102,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['avail'],['available']
Availability,// End sequence means that the next line entry could have a lower address; // that the previous entries. So we clear the previous row so we don't; // trigger the line table error about address that do not monotonically; // increase.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:173,error,error,173,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['error'],['error']
Availability,"// End the packet if resource is not available, or if the instruction; // should not be added to the current packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,1,['avail'],['available']
Availability,"// End: Create ShapeFactor ParamHistFunc; // Create the constraint terms and add; // them to the workspace (proto); // as well as the list of constraint terms (constraintTermNames); // The syst should be a fractional error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:217,error,error,217,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,"// Enforce all the rest of the instruction bits in LCTP, which; // won't have been reliably checked based on LCTP's own tablegen; // record, because we came to this decode by a roundabout route.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:83,reliab,reliably,83,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['reliab'],['reliably']
Availability,"// Ensure `NS` is unloaded from the AST on transaction rollback, e.g. '.undo X'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp:55,rollback,rollback,55,interpreter/cling/lib/Interpreter/Transaction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp,1,['rollback'],['rollback']
Availability,"// Ensure accessor methods throw in case of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:44,error,errors,44,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['errors']
Availability,// Ensure each word index of the ShuffleVector Mask is consecutive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Ensure relocation global won't appear in PHI node; // This may happen if the compiler generated the following code:; // B1:; // g1 = @llvm.skb_buff:0:1...; // ...; // goto B_COMMON; // B2:; // g2 = @llvm.skb_buff:0:2...; // ...; // goto B_COMMON; // B_COMMON:; // g = PHI(g1, g2); // x = load g; // ...; // If anything likes the above ""g = PHI(g1, g2)"", issue a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:371,error,error,371,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,1,['error'],['error']
Availability,"// Ensure temporary files exist, creating or re-using them. \p FD contains; // file descriptors (-1 indicates that the file should be created) and; // \p SR contains the corresponding initial content. \p FileName will have; // the filenames filled in when creating files. Return first error code (if; // any) and stop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h:285,error,error,285,interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,1,['error'],['error']
Availability,"// Ensure that if the instruction occurs when relaxation is enabled,; // relocations are forced for the file. Ideally this would be done when there; // is enough information to reliably determine if the instruction itself may; // cause relaxations. Unfortunately instruction processing stage occurs in the; // same pass as relocation emission, so it's too late to set a 'sticky bit'; // for the entire file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:177,reliab,reliably,177,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['reliab'],['reliably']
Availability,"// Ensure that if the iterator walks to the end, the error is checked; // afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:53,error,error,53,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['error'],['error']
Availability,"// Ensure that the implementation functions (all static functions in this TU); // never call the public ASTStructuralEquivalence::IsEquivalent() functions,; // because that will wreak havoc the internal state (DeclsToCheck and; // VisitedDecls members) and can cause faulty behaviour.; // In other words: Do not start a graph search from a new node with the; // internal data of another search in progress.; // FIXME: Better encapsulation and separation of internal and public; // functionality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:267,fault,faulty,267,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,1,['fault'],['faulty']
Availability,"// Ensure that the mismatching `<double>` specialization is available, i.e. will; // be chosen given the typeid of the TTreeReaderValue template argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/branchobject.cxx:60,avail,available,60,tree/treeplayer/test/branchobject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/branchobject.cxx,1,['avail'],['available']
Availability,// Ensure that the predicate for this number of elements is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// Ensure that the type will fit the mask value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['mask'],['mask']
Availability,"// Ensure that we have actual array elements available to destroy; the; // destructors might mutate the value, so we can't run them on the array; // filler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,avail,available,45,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['avail'],['available']
Availability,"// Ensure the alignment of the RVV stack. Since we want the most-aligned; // object right at the bottom (i.e., any padding at the top of the frame),; // readjust all RVV objects down by the alignment padding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:178,down,down,178,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['down'],['down']
Availability,// Ensure the filename is passed down to CodeViewDebug.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:33,down,down,33,interpreter/llvm-project/llvm/tools/llc/llc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp,1,['down'],['down']
Availability,// Ensure this insertion is not redundant (two LFENCEs in sequence).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:32,redundant,redundant,32,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,1,['redundant'],['redundant']
Availability,// Ensure typos get diagnosed when errors were encountered while parsing the; // expression list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,error,errors,35,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['error'],['errors']
Availability,"// Ensure we actually have captured 'this'. If something was wrong with; // 'this' capture, the error would have been previously reported.; // Otherwise we can be inside of a default initialization of an object; // declared by lambda's body, so no need to return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,error,error,96,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error']
Availability,// Ensure we consume the rest of the macro body if errors occur.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:51,error,errors,51,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['errors']
Availability,"// Entire expr, for error unsupported. May not be binop.; /// Check if the binop can result in integer overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['error'],['error']
Availability,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,redundant,redundant,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redundant'],['redundant']
Availability,// Enumeration types referenced prior to definition may appear as a result of; // error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:82,error,error,82,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Equivalent to assume(V == Mask ^ C),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Mask,Mask,29,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Mask'],['Mask']
Availability,// Error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,8,['Error'],['Error']
Availability,"// Error always reported?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:3,Error,Error,3,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,3,['Error'],['Error']
Availability,// Error check sh_link here so that getRelocationSymbol can just use it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:3,Error,Error,3,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,1,['Error'],['Error']
Availability,"// Error checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:3,Error,Error,3,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['Error'],['Error']
Availability,// Error checking template argument values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['Error'],['Error']
Availability,// Error checking value list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['Error'],['Error']
Availability,// Error code 0 is absent. Use std::error_code() instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h:3,Error,Error,3,interpreter/llvm-project/llvm/include/llvm/Object/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h,1,['Error'],['Error']
Availability,// Error code returned by the target predicate when validating this; // instruction encoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:3,Error,Error,3,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,1,['Error'],['Error']
Availability,// Error code returned when validating the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:3,Error,Error,3,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,1,['Error'],['Error']
Availability,"// Error counter for a given expression processing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFactoryWSTool.h:3,Error,Error,3,roofit/roofitcore/inc/RooFactoryWSTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFactoryWSTool.h,1,['Error'],['Error']
Availability,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,"['Error', 'error']","['Error', 'error']"
Availability,// Error for floating constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['Error'],['Error']
Availability,// Error for integer constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,3,['Error'],['Error']
Availability,"// Error handler streams error-level messages to client log",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:3,Error,Error,3,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,2,"['Error', 'error']","['Error', 'error-level']"
Availability,"// Error handlers prototypes ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.h:3,Error,Error,3,net/rpdutils/src/DaemonUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.h,1,['Error'],['Error']
Availability,"// Error handling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3,Error,Error,3,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['Error'],['Error']
Availability,// Error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LLVM.h:3,Error,Error,3,interpreter/llvm-project/clang/include/clang/Basic/LLVM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LLVM.h,1,['Error'],['Error']
Availability,// Error happened in parsing integer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Error'],['Error']
Availability,"// Error has been reported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:3,Error,Error,3,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,2,['Error'],['Error']
Availability,// Error if -mvscale-min is unbounded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Error'],['Error']
Availability,// Error if a single store with another store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['Error'],['Error']
Availability,"// Error if defining ""defined"": C99 6.10.8/4, C++ [cpp.predefined]p4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['Error'],['Error']
Availability,// Error if insn may not be executed in any slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['Error'],['Error']
Availability,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,2,"['Error', 'avail']","['Error', 'available']"
Availability,// Error if no more slots available for stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,2,"['Error', 'avail']","['Error', 'available']"
Availability,// Error if the desired slots are already full.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['Error'],['Error']
Availability,"// Error if the input file does not exist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:3,Error,Error,3,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['Error'],['Error']
Availability,"// Error in opening file; make this a zombie",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:3,Error,Error,3,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['Error'],['Error']
Availability,"// Error indicator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3,Error,Error,3,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['Error'],['Error']
Availability,"// Error is zero because of B = S = 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:3,Error,Error,3,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['Error'],['Error']
Availability,"// Error is zero because of B or S = 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:3,Error,Error,3,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['Error'],['Error']
Availability,// Error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Error'],['Error']
Availability,"// Error message already issued",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:3,Error,Error,3,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['Error'],['Error']
Availability,// Error message on parse error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Error,Error,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Error', 'error']","['Error', 'error']"
Availability,"// Error might throw in experiment frameworks like CMSSW",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:3,Error,Error,3,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['Error'],['Error']
Availability,// Error on enum increments and decrements in C++ mode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Error'],['Error']
Availability,// Error out for definitions of loop registers at the end of a loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,"// Error out for explicit changes to registers also weakly defined; // (e.g., ""{ usr = r0; r0 = sfadd(...) }"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,"// Error out if ""strippedClass"" is un-scoped (and it's not a class, see `TClass::GetClass(strippedClass)` above).; // TODO: Global functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:3,Error,Error,3,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['Error'],['Error']
Availability,"// Error out if predicate register defined ""late"" multiple times or; // defined late and regularly defined; // (e.g., ""{ p3 = sp1loop0(...); p3 = cmp.eq(...) }"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,"// Error out if the new predicate register is not defined,; // or defined ""late""; // (e.g., ""{ if (p3.new)... ; p3 = sp1loop0(#r7:2, Rs) }"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,// Error out if we couldn't legalize this instruction. We may want to; // fall back to DAG ISel instead in the future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,1,['Error'],['Error']
Availability,// Error out if we haven't parsed the initializer of the pattern yet because; // we are waiting for the closing brace of the outer class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['Error'],['Error']
Availability,// Error out if we hit an instantiation cycle for this initializer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['Error'],['Error']
Availability,"// Error out on an unconditional change when there are any other; // changes, conditional or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,// Error out on an uneven byte count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,2,['Error'],['Error']
Availability,"// Error out on conditional changes based on the same predicate; // (e.g., ""{ if (!p0) r0 =...; if (!p0) r0 =... }"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,"// Error out on conditional changes based on the same predicate; // multiple times; // (e.g., ""if (p0) r0 =...; if (!p0) r0 =... }; if (!p0) r0 =..."").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Error'],['Error']
Availability,// Error out on when there's already an attribute on the type; // and the CCs don't match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Error'],['Error']
Availability,// Error parsing constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,1,['Error'],['Error']
Availability,// Error parsing the declarator?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['Error'],['Error']
Availability,// Error parsing value list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,3,['Error'],['Error']
Availability,// Error point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,3,['Error'],['Error']
Availability,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,17,['Error'],['Error']
Availability,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,5,['Error'],['Error']
Availability,"// Error really unexpected here, because construction / iteration guarantees; //inheritance;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:3,Error,Error,3,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,1,['Error'],['Error']
Availability,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,2,"['Error', 'recover']","['Error', 'recovery']"
Availability,// Error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,2,"['Error', 'recover']","['Error', 'recovery']"
Availability,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,"['Error', 'recover']","['Error', 'recovery']"
Availability,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,"['Error', 'recover']","['Error', 'recovery']"
Availability,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Error'],['Error']
Availability,"// Error returns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:3,Error,Error,3,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Error'],['Error']
Availability,"// Error should be reported by GetEntries()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:3,Error,Error,3,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,1,['Error'],['Error']
Availability,"// Error should go down faster than 0.5^nSteps because the integrator uses series acceleration,; // so test if it goes down faster than 0.333^nSteps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx:3,Error,Error,3,roofit/roofitcore/test/testRooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx,3,"['Error', 'down']","['Error', 'down']"
Availability,"// Error should go down faster than 2^nSteps because of series acceleration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx:3,Error,Error,3,roofit/roofitcore/test/testRooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx,2,"['Error', 'down']","['Error', 'down']"
Availability,"// Error we only access integer.; //NOTE: *** Need to print an error;; //fprintf(stderr,""*** Datamember %s::%s: size of array (%s) is not an interger\n"",; // member.MemberOf()->Name(), member.Name(), current);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Error,Error,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,// Error while parsing CrossTU index file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:3,Error,Error,3,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['Error'],['Error']
Availability,"// Error will be printed by GetLeaf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:3,Error,Error,3,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,2,['Error'],['Error']
Availability,"// Error(""BuildOld"", ""Could not find STL base class: %s for %s\n"", element->GetName(), GetName());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:3,Error,Error,3,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['Error'],['Error']
Availability,"// Error(""CheckModifiedFlag"", ""Cannot get toggle value with getter %s"", getter.Data());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RMenuItems.cxx:3,Error,Error,3,graf2d/gpadv7/src/RMenuItems.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RMenuItems.cxx,2,['Error'],['Error']
Availability,"// Error(""CreateClassTable"",""Why colinfos for table %s"", sqlinfo->GetClassTableName());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx:3,Error,Error,3,io/sql/src/TSQLFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx,1,['Error'],['Error']
Availability,"// Error(""GetEntryNumberWithBestIndex"",""no index found"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx:3,Error,Error,3,tree/treeplayer/src/TChainIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx,1,['Error'],['Error']
Availability,"// Error(""GetEntryNumberWithIndex"",""no index found"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx:3,Error,Error,3,tree/treeplayer/src/TChainIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx,1,['Error'],['Error']
Availability,"// Error(""MakeCopyVolume"", ""volume %s divided"", GetName());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:3,Error,Error,3,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['Error'],['Error']
Availability,"// Error(""Next"", ""No more entries, last list\n"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:3,Error,Error,3,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,1,['Error'],['Error']
Availability,"// Error(""OutscribedConvex"",""NO convex line connection to vertex %d\n"", iseg);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx:3,Error,Error,3,geom/geom/src/TGeoPolygon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx,1,['Error'],['Error']
Availability,"// Error(""ResetObjects"",""In %s, we can not reset %s (not ResetAfterMerge function)"",; // directory->GetName(),idcur->GetName());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:3,Error,Error,3,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['Error'],['Error']
Availability,"// Error(""ShootRay"", ""more than 1000 steps. Step was %f"", step);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:3,Error,Error,3,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['Error'],['Error']
Availability,"// Error(""TGLEventHandler::ExecuteEvent"", ""invalid event type"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx:3,Error,Error,3,graf3d/gl/src/TGLEventHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx,1,['Error'],['Error']
Availability,"// Error(method, ""%s:%ld:%ld:%s\n"", state, i, native, text);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx:3,Error,Error,3,sql/odbc/src/TODBCStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx,1,['Error'],['Error']
Availability,"// Error(where, ""function levels must be in increasing order"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Error,Error,3,hist/histpainter/src/TPainter3dAlgorithms.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx,1,['Error'],['Error']
Availability,"// Error(where, ""negative color index (%d)"", icl[i]);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Error,Error,3,hist/histpainter/src/TPainter3dAlgorithms.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx,1,['Error'],['Error']
Availability,"// Error, can't save dataset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:3,Error,Error,3,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,['Error'],['Error']
Availability,"// Error, was not a data member, variable, or enumerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:3,Error,Error,3,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,3,['Error'],['Error']
Availability,"// Error->debug this",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:3,Error,Error,3,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['Error'],['Error']
Availability,// Error-dependent expr should never be a null pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Error,Error-dependent,3,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['Error'],['Error-dependent']
Availability,"// Error-handling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:3,Error,Error-handling,3,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,1,['Error'],['Error-handling']
Availability,"// Error-handling for input tensor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:3,Error,Error-handling,3,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,1,['Error'],['Error-handling']
Availability,"// Error: could not open file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofResourcesStatic.cxx:3,Error,Error,3,proof/proof/src/TProofResourcesStatic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofResourcesStatic.cxx,1,['Error'],['Error']
Availability,"// Error: set entry inactive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:3,Error,Error,3,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Error'],['Error']
Availability,// Error: value 1124 out of range: -1024-1023 when resolving; // symbol in file xprtsock.S,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Error,Error,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,1,['Error'],['Error']
Availability,"// Error;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3,Error,Error,3,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['Error'],['Error']
Availability,// ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h:3,Error,ErrorCallback,3,interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,4,"['Error', 'error', 'recover']","['Error', 'ErrorCallback', 'errors', 'recoverable']"
Availability,"// ErrorList needs to be able to yank ErrorInfoBase pointers out of Errors; // to add to the error list. It can't rely on handleErrors for this, since; // handleErrors does not support ErrorList handlers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:3,Error,ErrorList,3,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,5,"['Error', 'error']","['ErrorInfoBase', 'ErrorList', 'Errors', 'error']"
Availability,"// ErrorNamespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/stltypes.h:3,Error,ErrorNamespace,3,bindings/pyroot/cppyy/cppyy/test/stltypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/stltypes.h,1,['Error'],['ErrorNamespace']
Availability,"// ErrorRateRocTst( );",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:3,Error,ErrorRateRocTst,3,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['Error'],['ErrorRateRocTst']
Availability,// Errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Error,Errors,3,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['Error'],['Errors']
Availability,"// Errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx:3,Error,Errors,3,proof/proofplayer/src/TStatus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx,1,['Error'],['Errors']
Availability,// Errors are not copy-assignable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:3,Error,Errors,3,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Errors']
Availability,// Errors are not copy-constructable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:3,Error,Errors,3,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Errors']
Availability,"// Errors during a preprocessor directive can only affect the layout of the; // preprocessor directive, and thus we ignore them. An alternative approach; // would be to use the same approach we use on the file level (no; // re-indentation if there was a structural error) within the macro; // definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Error,Errors,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,"['Error', 'error']","['Errors', 'error']"
Availability,"// Errors first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx:3,Error,Errors,3,proof/proofplayer/src/TStatus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx,1,['Error'],['Errors']
Availability,// Errors from executing the snippets are fine.; // All other errors are a framework issue and should fail.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:3,Error,Errors,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,2,"['Error', 'error']","['Errors', 'errors']"
Availability,// Errors that do not prevent the PCH from being written should not cause the; // overall compilation to fail either.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp:3,Error,Errors,3,interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GeneratePCH.cpp,1,['Error'],['Errors']
Availability,// Errors when importing the persistent decl are treated as if we; // had errors with importing the temporary decl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:3,Error,Errors,3,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,2,"['Error', 'error']","['Errors', 'errors']"
Availability,// Errors will be handled when printing the table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:3,Error,Errors,3,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['Error'],['Errors']
Availability,// Escape overrides whatever error we think happened.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['error'],['error']
Availability,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:21,down,down,21,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['down'],['down']
Availability,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:202,down,down,202,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['down'],['down']
Availability,"// Estimate the rounding error for r4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx:25,error,error,25,math/mathcore/src/RichardsonDerivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx,1,['error'],['error']
Availability,"// Estimated truncation error O(h)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx:24,error,error,24,math/mathcore/src/RichardsonDerivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx,1,['error'],['error']
Availability,"// Evaluate a call to decode_operand. Decode the instruction operand at the; // given symbol and get the value of the requested operand.; // Returns an error if the instruction cannot be decoded, or the requested; // operand is not an immediate.; // On success, returns a pair containing the value of the operand, plus; // the expression remaining to be evaluated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:152,error,error,152,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['error'],['error']
Availability,"// Evaluate a call to next_pc.; // Decode the instruction at the given symbol and return the following program; // counter.; // Returns an error if the instruction cannot be decoded.; // On success, returns a pair containing the next PC, plus of the; // expression remaining to be evaluated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:139,error,error,139,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['error'],['error']
Availability,"// Evaluate an expression containing condition register; // or condition register field symbols. Returns positive; // value on success, or -1 on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:145,error,error,145,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['error'],['error']
Availability,"// Evaluate errors with Hesse",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:12,error,errors,12,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['error'],['errors']
Availability,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:792,avail,available,792,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avail'],['available']
Availability,"// EvaluateAsRValue gives an error for undefined Div/Rem, so make sure; // we don't evaluate one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error']
Availability,"// Evaluates an XRay record and performs accounting on it.; //; // If the record is an ENTER record it pushes the FuncID and TSC onto a; // structure representing the call stack for that function.; // If the record is an EXIT record it checks computes computes the ammount of; // time the function took to complete and then stores that information in an; // edge of the graph. If there is no matching ENTER record the function tries; // to recover by assuming that there were EXIT records which were missed, for; // example caused by tail call elimination and if the option is enabled then; // then tries to recover from this.; //; // This function will also error if the records are out of order, as the trace; // is expected to be sorted.; //; // The graph generated has an immaginary root for functions called by no-one at; // FuncId 0.; //; // FIXME: Refactor this and account subcommand to reduce code duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp:440,recover,recover,440,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,3,"['error', 'recover']","['error', 'recover']"
Availability,"// Evaluation error logging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:14,error,error,14,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['error'],['error']
Availability,"// Even if CR0 register were dead before, it is alive now since the; // instruction we just built uses it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,alive,alive,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['alive'],['alive']
Availability,"// Even if the instruction is removed, we still need to update; // flags/metadata due to downstreams users of the leader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:89,down,downstreams,89,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['down'],['downstreams']
Availability,"// Even if this symbol/region was already marked as interesting as a; // condition, if we later mark it as interesting again but with; // thorough tracking, overwrite it. Entities marked with thorough; // interestiness are the most important (or most interesting, if you will),; // and we wouldn't like to downplay their importance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:306,down,downplay,306,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['down'],['downplay']
Availability,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:320,error,error,320,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['error'],['error']
Availability,"// Even though DILocations are not scopes, shove them into AliveScopes so we; // don't revisit them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:59,Alive,AliveScopes,59,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['Alive'],['AliveScopes']
Availability,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,redundant,redundant,108,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redundant'],['redundant']
Availability,"// Even though it is technically only required when the computation graph; // is changed because global observables are taken from data, it is safer; // to clone the constraint model in general to reset the normalization; // integral caches and avoid ASAN build failures (the PDF of the main; // measurement is cloned too anyway, so not much overhead). This can be; // reconsidered after the caching of normalization sets by pointer is changed; // to a more memory-safe solution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:262,failure,failures,262,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['failure'],['failures']
Availability,"// Even though one (or more) branches might be missing from the new; // tree, other branches might still be there. We know we are switching; // into the tree at this point, so we want the director to start; // reading again from local entry 0, for those branches that are; // available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:276,avail,available,276,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['avail'],['available']
Availability,"// Even though there's a Sema warning when the return type of an annotated; // function is not a kern_return_t, this warning isn't an error, so we need; // an extra check here.; // FIXME: AnyCall doesn't support blocks yet, so they remain unchecked; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:134,error,error,134,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['error'],['error']
Availability,// Even though these are just absolute symbols we need to check for failure; // to resolve/emit: the tracker for these symbols may have been removed while; // the materialization was in flight (e.g. due to a failure in some action; // triggered by the queries attached to the resolution/emission of these; // symbols).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:68,failure,failure,68,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['failure'],['failure']
Availability,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:287,error,error,287,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// Even when the analysis is technically correct, it is a widespread pattern; // not to call completion handlers in some scenarios. These usually have; // typical conditional names, such as 'error' or 'cancel'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:191,error,error,191,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['error'],['error']
Availability,// Every combination of colors given by the top down; // and bottom up Reserved node dependency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:48,down,down,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['down'],['down']
Availability,"// Everybody expects std::iostream to be available, so load it...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:41,avail,available,41,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,3,['avail'],['available']
Availability,// Exact/Strict -> Strict: save SCC; // Exact/Strict -> WQM: save SCC if WQM mask is generated from exec; // Exact/Strict -> Exact: no save,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:77,mask,mask,77,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,mainten,maintenence,163,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['mainten'],['maintenence']
Availability,"// Examine the ModRef mask. If Mod isn't present, then return NoModRef.; // This ensures that if Loc is a constant memory location, we take into; // account the fact that the store definitely could not modify the memory; // location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['mask'],['mask']
Availability,// Examine the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Examine the other elements in the Mask to see if they're in original; // order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,Mask,Mask,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,recover,recover,93,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Availability,"// Examining subobjects for records is only possible if the complete and; // valid definition is available. Also, template instantiation is not; // allowed here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:97,avail,available,97,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['avail'],['available']
Availability,// Example error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp:11,error,error,11,interpreter/llvm-project/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp,1,['error'],['error']
Availability,"// Example masks that will return true:; // v1 = <a, b, c, d>; // v2 = <e, f, g, h>; // trn1 = shufflevector v1, v2 <0, 4, 2, 6> = <a, e, c, g>; // trn2 = shufflevector v1, v2 <1, 5, 3, 7> = <b, f, d, h>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:11,mask,masks,11,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['mask'],['masks']
Availability,"// Example sequence:; // li a0, 90; // vsetivli zero, 8, e8, mf2, ta, ma (ignored); // vmv.s.x v0, a0; // vmerge.vvm v8, v9, v8, v0; // We use 2 for the cost of the mask materialization as this is the true; // cost for small masks and most shuffles are small. At worst, this cost; // should be a very small constant for the constant pool load. As such,; // we may bias towards large selects slightly more than truely warranted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:165,mask,mask,165,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,2,['mask'],"['mask', 'masks']"
Availability,// Excerpt of the input starting at the error position.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:40,error,error,40,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['error'],['error']
Availability,// Exclude r4.; // Mask off non-consecutive registers. Keep r4.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp:19,Mask,Mask,19,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMUnwindOpAsm.cpp,1,['Mask'],['Mask']
Availability,"// Excluding WaitingForTypeOfMI, MI is either connected to chains of ambiguous; // instructions or has no other adjacent instructions. Anyway InstType could; // not be determined. There could be unexplored path from some of; // WaitingForTypeOfMI's adjacent instructions to an instruction with only one; // mapping available.; // We are done with this branch, add MI to WaitingForTypeOfMI's WaitingQueue,; // this way when WaitingForTypeOfMI figures out its InstType same InstType; // will be assigned to all instructions in this branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:315,avail,available,315,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,1,['avail'],['available']
Availability,"// Executables and conf dirs; // Make rootbindir available to all the session via env",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:49,avail,available,49,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['avail'],['available']
Availability,"// Execute global pre-inliner to estimate a global top-down inline; // decision and merge profiles accordingly. This helps with profile; // merge for ThinLTO otherwise we won't be able to merge profiles back; // to base profile across module/thin-backend boundaries.; // It also helps better compress context profile to control profile; // size, as we now only need context profile for functions going to; // be inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp:55,down,down,55,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,1,['down'],['down']
Availability,"// Execute the command, write it to history file and echo it to output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:53,echo,echo,53,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['echo'],['echo']
Availability,// Execute the graph viewer. Return true if there were errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/GraphWriter.cpp:55,error,errors,55,interpreter/llvm-project/llvm/lib/Support/GraphWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/GraphWriter.cpp,1,['error'],['errors']
Availability,"// Execute the invocation, unless there were parsing errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:53,error,errors,53,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,1,['error'],['errors']
Availability,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,3,"['Error', 'error']","['ErrorKind', 'error']"
Availability,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:26,Error,ErrorKind,26,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,3,"['Error', 'error']","['ErrorKind', 'error']"
Availability,// Exit if the mask's non zero elements are not in increasing order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Expand Y = FNEG(X) -> Y = X ^ sign mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,1,['mask'],['mask']
Availability,"// Expand is only ever created as a masked instruction. It is not safe to; // unfold a masked expand because we don't know if it came from an expand load; // intrinsic or folding a plain load. If it is from a expand load intrinsic,; // Unfolding to plain load would read more elements and could trigger a fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp:36,mask,masked,36,interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,3,"['fault', 'mask']","['fault', 'masked']"
Availability,// Expand mask indices to byte indices and materialize them as operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['mask'],['mask']
Availability,// Expand ppcf128 to i32 by hand for the benefit of llvm-gcc bootstrap on; // PPC (the libcall is not available).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,avail,available,102,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['avail'],['available']
Availability,"// Expand the current designator into the set of replacement; // designators, so we have a full subobject path down to where the; // member of the anonymous struct/union is actually stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:111,down,down,111,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['down'],['down']
Availability,"// Expand the instruction; //; // Reduction instructions:; // T0_X = DP4 T1_XYZW, T2_XYZW; // becomes:; // TO_X = DP4 T1_X, T2_X; // TO_Y (write masked) = DP4 T1_Y, T2_Y; // TO_Z (write masked) = DP4 T1_Z, T2_Z; // TO_W (write masked) = DP4 T1_W, T2_W; //; // Vector instructions:; // T0_X = MULLO_INT T1_X, T2_X; // becomes:; // T0_X = MULLO_INT T1_X, T2_X; // T0_Y (write masked) = MULLO_INT T1_X, T2_X; // T0_Z (write masked) = MULLO_INT T1_X, T2_X; // T0_W (write masked) = MULLO_INT T1_X, T2_X; //; // Cube instructions:; // T0_XYZW = CUBE T1_XYZW; // becomes:; // TO_X = CUBE T1_Z, T1_Y; // T0_Y = CUBE T1_Z, T1_X; // T0_Z = CUBE T1_X, T1_Z; // T0_W = CUBE T1_Y, T1_Z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp:145,mask,masked,145,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp,6,['mask'],['masked']
Availability,// Expanding requires fill mask with zeroes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Expanding shuffles (using all elements and inserting into larger vector):; //; // V6_vunpacku{b,h} [*]; //; // [*] Only if the upper elements (filled with 0s) are ""don't care"" in Mask.; //; // Note: V6_vunpacko{b,h} are or-ing the high byte/half in the result, so; // they are not shuffles.; //; // The argument is a single vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:182,Mask,Mask,182,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Mask'],['Mask']
Availability,"// Expected values for variation down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:33,down,down,33,tree/dataframe/test/dataframe_incomplete_entries.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx,1,['down'],['down']
Availability,// Expected<T> needs to be able to steal the payload when constructed from an; // error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:82,error,error,82,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,// Expecting to get an error flag since TFC is on - and dmask is 0 Force; // dmask to be at least 1 otherwise the instruction will fail,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['error'],['error']
Availability,// Expecting to get an error flag since TFC is on - and dmask is 0; // Force dmask to be at least 1 otherwise the instruction will fail,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['error'],['error']
Availability,// Explicit mask parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,1,['mask'],['mask']
Availability,// Explicitly define the default constructor otherwise it would be implicitly; // defined at the first ODR-use which is the BFI member in the; // LazyBlockFrequencyInfo header. The dtor needs the BlockFrequencyInfoImpl; // template instantiated which is not available in the header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:258,avail,available,258,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,1,['avail'],['available']
Availability,// Explicitly error on some things we know we don't support and can't just; // ignore.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,// Explicitly removing a referenced symbol is an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFObjcopy.cpp:49,error,error,49,interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFObjcopy.cpp,1,['error'],['error']
Availability,// Explicitly zero initialize the error to work around a bug in array; // value-initialization on MinGW with gcc 4.3.5.; // Find start of normal options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:34,error,error,34,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,1,['error'],['error']
Availability,// Export & GDS instructions do not read the EXEC mask until after the export; // is granted (which can occur well after the instruction is issued).; // The shader program must flush all EXP operations on the export-count; // before overwriting the EXEC mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,2,['mask'],['mask']
Availability,// Exposed for resource monitoring & error feedback via renderer.info:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,error,error,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['error']
Availability,// Express the shuffle mask in terms of bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['mask'],['mask']
Availability,"// Expression type depends on template context, or an error.; // Value and Instantiation should also be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:54,error,error,54,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"// Expression value depends on template context, or an error.; // Instantiation should also be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:55,error,error,55,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"// Extend inputs to XLen, and shift by 32. This will add 64 trailing zeros; // to the full 128-bit clmul result of multiplying two xlen values.; // Perform clmulr or clmulh on the shifted values. Finally, extract the; // upper 32 bits.; //; // The alternative is to mask the inputs to 32 bits and use clmul, but; // that requires two shifts to mask each input without zext.w.; // FIXME: If the inputs are known zero extended or could be freely; // zero extended, the mask form would be better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:266,mask,mask,266,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,3,['mask'],['mask']
Availability,// Extend mask to match new destination vector size with; // undef values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['mask']
Availability,// Extend masks if we truncated above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,mask,masks,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// Extend the shuffle mask with undef elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:211,mask,mask,211,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['mask'],['mask']
Availability,// Extending masked load/Truncating masked stores is expensive because we; // currently don't split them. This means that we'll likely end up; // loading/storing each element individually (hence the high cost).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:13,mask,masked,13,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['mask'],['masked']
Availability,// Extends from v32i1 masks to 256-bit vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,masks,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// Extends from v64i1 masks to 512-bit vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,masks,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// Extension in C99 (defaults to error). Legal in C89, but warn about it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,error,error,33,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Extension of the Map interfaces with chunking, specific to this class and; // only available from a MapReduce call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:86,avail,available,86,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['avail'],['available']
Availability,"// External and linkonce definitions are converted to available_externally; // definitions upon import, so that they are available for inlining; // and/or optimization, but are turned into declarations later; // during the EliminateAvailableExternally pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:121,avail,available,121,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['avail'],['available']
Availability,// Extra cost for moving part of mask before unpacking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Extra error conditions are reported through diagnostics, set that up first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,1,['error'],['error']
Availability,// Extract <mask>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['mask'],['mask']
Availability,// Extract constant bits and see if they are all; // sign bit masks. Ignore the undef elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,mask,masks,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// Extract die. Stop if any error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:28,error,error,28,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['error'],['error']
Availability,// Extract down to 2 elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:11,down,down,11,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,1,['down'],['down']
Availability,// Extract down to real number of elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,down,down,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,// Extract target shuffle mask and resolve sentinels and inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Extract target shuffle mask sentinel elements to known undef/zero bitmasks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Extract the addend from the instruction.; // We shift up by two since the Value will be down shifted again; // when applying the relocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:91,down,down,91,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['down'],['down']
Availability,"// Extract the lo/hi parts to any extend to i16.; // We're going to mask off the low byte of each result element of the; // pmullw, so it doesn't matter what's in the high byte of each 16-bit; // element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Extract the mask bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Extract the mask subregister and apply the and.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['mask'],['mask']
Availability,// Extract the resulting weights from the control flow; // All weights are increased by one to avoid propagation errors introduced by; // zero weights.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:113,error,errors,113,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['error'],['errors']
Availability,"// Extract the sign bit, mask it and add it to the quotient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,// Extract the sub element from the constant bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,mask,mask,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Extract the sub-lane mask, check that it all comes from the same lane; // and normalize the mask entries to come from the first lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,redundant,redundant,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['redundant'],['redundant']
Availability,"// Extracting the lowest bit is a no-op, but it changes the type,; // so it must be kept as an operation to avoid errors related to; // type mismatches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:114,error,errors,114,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['error'],['errors']
Availability,"// Extrapolate current point with estimated error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:44,error,error,44,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['error'],['error']
Availability,"// FIXME : This is possibly an incomplete list, but it is unclear what other; // Decl kinds could be used to refer to the template parameters. This is a; // best guess so far based on examples currently available, but the; // unreachable should catch future instances/cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:203,avail,available,203,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avail'],['available']
Availability,"// FIXME As above, this drops the error on the floor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:34,error,error,34,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['error']
Availability,// FIXME Check for ODR error if the two definitions have; // different initializers?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,// FIXME Diagnose ODR error if the two initializers are different?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:22,error,error,22,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// FIXME This causes a redundant load/store if the SSE-class value is already; // in memory, such as if it is on the callstack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,redundant,redundant,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// FIXME checking magic headers is done in other places such as; // SerializedDiagnosticReader and GlobalModuleIndex, but error handling isn't; // always done the same. Unify it all with a helper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:122,error,error,122,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,// FIXME don't do a fatal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:26,error,error,26,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['error'],['error']
Availability,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:20,error,errors,20,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,22,['error'],['errors']
Availability,"// FIXME this drops the error on the floor, but; // Index/pch-from-libclang.c seems to rely on dropping at least some of; // the error conditions!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,2,['error'],['error']
Availability,"// FIXME this drops the error on the floor, which; // ThinLTO/X86/debuginfo-cu-import.ll relies on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:24,error,error,24,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['error'],['error']
Availability,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,68,['error'],['error']
Availability,// FIXME this drops the error on the floor. This code is only used for; // typo correction and drops more than just this one source of errors; // (such as the directory creation failure above). It should handle the; // error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,4,"['error', 'failure']","['error', 'errors', 'failure']"
Availability,// FIXME this drops the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,4,['error'],['error']
Availability,// FIXME this drops the errors on the floor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,error,errors,24,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['errors']
Availability,// FIXME-GFX10: How should 32 bit mask be handled?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:34,mask,mask,34,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,['mask'],['mask']
Availability,"// FIXME. This should be an error. But if block is not called, it is OK. And it; // may break including some headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:28,error,error,28,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['error'],['error']
Availability,"// FIXME: ""A(f())"" deserves a vexing-parse warning, not just a; // redundant-parens warning, but we don't know whether the function; // chunk was syntactically valid as an expression here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:67,redundant,redundant-parens,67,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redundant'],['redundant-parens']
Availability,// FIXME: A problematic debug_abbrev section is reported below in the form; // of a `note:`. We should propagate this error there (or elsewhere) to; // avoid losing the specific problem with the debug_abbrev section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:118,error,error,118,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['error']
Availability,"// FIXME: ARM looks for a case where the block containing the compare; // has been split from the block containing the branch. If this happens,; // there is a vreg available containing the result of the compare. I'm; // not sure we can do much, as we've lost the predicate information with; // the compare instruction -- we have a 4-bit CR but don't know which bit; // to test here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:164,avail,available,164,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avail'],['available']
Availability,"// FIXME: AST may contain remaining references to the failed object.; // However, the ImportDeclErrors in the shared state contains all the; // failed objects together with their error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:179,error,error,179,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// FIXME: Account for naming collisions:; // - error when name is specified by user.; // - rename to ""extractedN"" when name is implicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h:47,error,error,47,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,1,['error'],['error']
Availability,// FIXME: Add a warning about failing to specify `-mretpoline` and; // eventually switch to an error here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,1,['error'],['error']
Availability,// FIXME: Add error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,['error'],['error']
Availability,// FIXME: Add error propagation to the interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['error'],['error']
Availability,// FIXME: Add interleave.disable metadata. This will allow; // vectorize.disable to be used without disabling the pass and errors; // to differentiate between disabled vectorization and a width of 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:123,error,errors,123,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['error'],['errors']
Availability,"// FIXME: Add other cases...; // - 32-bit shifts with a zext to i64; // - zext after ctlz, bswap, etc.; // - zext after and by a constant mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:138,mask,mask,138,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:137,reliab,reliably,137,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,2,"['avail', 'reliab']","['available', 'reliably']"
Availability,"// FIXME: Although all systems tested with (Linux, OS X), do not need this; // header file included. A user on ubuntu reported, undefined symbols; // for stderr, and fprintf, and the addition of this include fixed the; // issue for them. Given that LLVM's best practices include the goal; // of reducing the number of redundant header files included, the; // correct solution would be to find out why these symbols are not; // defined for the system in question, and fix the issue by finding out; // which LLVM header file, if any, would include these symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:318,redundant,redundant,318,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: An extern template instantiation will create functions with; // linkage ""AvailableExternally"". In libc++, some classes also define; // members with attribute ""AlwaysInline"" and expect no reference to; // be generated. It is desirable to reenable this optimisation after; // corresponding LLVM changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:83,Avail,AvailableExternally,83,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['Avail'],['AvailableExternally']
Availability,"// FIXME: As usual, we could be more specific in our error messages, but; // that better waits until we've got types with source locations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:53,error,error,53,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['error'],['error']
Availability,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,recover,recovery,17,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['recover'],['recovery']
Availability,"// FIXME: CXX17: Use init-statement in if to declare `error` variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx:54,error,error,54,net/net/src/TParallelMergingFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx,1,['error'],['error']
Availability,// FIXME: Calls to OutOfRange shoudl propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:47,failure,failure,47,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,1,['failure'],['failure']
Availability,// FIXME: Can we map this down to a particular submodule? That would be; // ideal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:26,down,down,26,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['down'],['down']
Availability,// FIXME: Check for failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp:20,failure,failure,20,interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,2,['failure'],['failure']
Availability,"// FIXME: Collapse this into TemplateParamPosition; or, just move depth/index; // down here to save memory.; /// Whether this non-type template parameter is a parameter pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:82,down,down,82,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,1,['down'],['down']
Availability,// FIXME: Collect all failing symbols before erroring out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp:45,error,erroring,45,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp,1,['error'],['erroring']
Availability,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,recover,recover,87,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Availability,"// FIXME: Converting constructors should also be accepted.; // But to fix this, the logic that digs down into a CXXConstructExpr; // to find the source object needs to handle it.; // Right now it assumes the source object is passed directly as the; // first argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,down,down,100,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['down'],['down']
Availability,// FIXME: Create error types that encapsulate a bit more information than what; // StringError instances contain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,1,['error'],['error']
Availability,"// FIXME: Currently -fsanitize=leak is silently ignored in the presence of; // -fsanitize=address. Perhaps it should print an error, or perhaps; // -f(-no)sanitize=leak should change whether leak detection is enabled by; // default in ASan?; // Parse -f(no-)?sanitize-recover flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:126,error,error,126,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// FIXME: Currently the DataLayout string carries a ""preferred alignment""; // for types. As the DataLayout is module/global, this should likely be; // sunk down to an FTTI element that is queried rather than a global; // preference.; /// Layout alignment element.; ///; /// Stores the alignment data associated with a given type bit width.; ///; /// \note The unusual order of elements in the structure attempts to reduce; /// padding and make the structure slightly more cache friendly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:156,down,down,156,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['down'],['down']
Availability,"// FIXME: Currently we add the same parent multiple times, but only; // when no memoization data is available for the type.; // For example when we visit all subexpressions of template; // instantiations; this is suboptimal, but benign: the only way to; // visit those is with hasAncestor / hasParent, and those do not create; // new matches.; // The plan is to enable DynTypedNode to be storable in a map or hash; // map. The main problem there is to implement hash functions /; // comparison operators for all types that DynTypedNode supports that; // do not have pointer identity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp:100,avail,available,100,interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp,1,['avail'],['available']
Availability,"// FIXME: Currently, documentation is generated as-needed due to the fact; // that there is no way to allow a generated project ""reach into"" the docs; // directory (for instance, it may be an out-of-tree build). However, we want; // to ensure that every attribute has a Documentation field, and produce an; // error if it has been neglected. Otherwise, the on-demand generation which; // happens server-side will fail. This code is ensuring that functionality,; // even though this Emitter doesn't technically need the documentation.; // When attribute documentation can be generated as part of the build; // itself, this code can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:310,error,error,310,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['error'],['error']
Availability,"// FIXME: Currently, the set of symbolic strides is sometimes queried before; // it's collected. This happens from canVectorizeWithIfConvert, when the; // pointer is checked to reference consecutive elements suitable for a; // masked access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:227,mask,masked,227,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['mask'],['masked']
Availability,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,redundant,redundant,19,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['redundant'],['redundant']
Availability,// FIXME: Do something different for soft failure modes?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:42,failure,failure,42,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['failure'],['failure']
Availability,// FIXME: Does it make sense to just return a failure value if the size won't; // fit in the output and `!MustSucceed`?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:46,failure,failure,46,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['failure'],['failure']
Availability,// FIXME: Don't compare everything twice. Maybe use C++20 three way; // comparison instead when it's available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:101,avail,available,101,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avail'],['available']
Availability,"// FIXME: Don't compute this in advance, it makes every token larger, and is; // also not generally what we want (it is nicer for recovery etc. to lex 123br; // as a single token, then diagnose as an invalid number).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h:130,recover,recovery,130,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,1,['recover'],['recovery']
Availability,// FIXME: Don't parse a primary-expression suffix if we encountered a parse; // error already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,// FIXME: Emit a proper error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:24,error,error,24,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,2,['error'],['error']
Availability,"// FIXME: Emit checks to determine it's _actually_ safe to fold and/or; // account for unsafe cases.; //; // Example:; // MI1--> %0 = ...; // %1 = ... %0; // MI0--> %2 = ... %0; // It's not safe to erase MI1. We currently handle this by not; // erasing %0 (even when it's dead).; //; // Example:; // MI1--> %0 = load volatile @a; // %1 = load volatile @a; // MI0--> %2 = ... %0; // It's not safe to sink %0's def past %1. We currently handle; // this by rejecting all loads.; //; // Example:; // MI1--> %0 = load @a; // %1 = store @a; // MI0--> %2 = ... %0; // It's not safe to sink %0's def past %1. We currently handle; // this by rejecting all loads.; //; // Example:; // G_CONDBR %cond, @BB1; // BB0:; // MI1--> %0 = load @a; // G_BR @BB1; // BB1:; // MI0--> %2 = ... %0; // It's not always safe to sink %0 across control flow. In this; // case it may introduce a memory fault. We currentl handle; // this by rejecting all loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:875,fault,fault,875,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['fault'],['fault']
Availability,"// FIXME: Enable this message.; //Error(""FillLeaves"", ""Branch address not set for branch '%s'!"", GetName());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:34,Error,Error,34,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['Error'],['Error']
Availability,// FIXME: Error if there is no matching cfi_remember_state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:10,Error,Error,10,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,1,['Error'],['Error']
Availability,// FIXME: Error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:10,Error,Error,10,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['Error'],['Error']
Availability,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from ParseRHSOfBinaryExpression, not after.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Error,Errors,10,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,"['Error', 'error']","['Errors', 'errors']"
Availability,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from parsing the RHS, not after.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Error,Errors,10,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,"['Error', 'error']","['Errors', 'errors']"
Availability,// FIXME: Explicit conversion to std::unique_ptr<ObjectLayer> added to silence; // errors from some GCC / libstdc++ bots. Remove this conversion (i.e.; // just return ObjLinkingLayer) once those bots are upgraded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:83,error,errors,83,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,1,['error'],['errors']
Availability,// FIXME: Factor out the duplicated instantiation context setup/tear down; // code here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:69,down,down,69,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['down'],['down']
Availability,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:260,failure,failure,260,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,1,['failure'],['failure']
Availability,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,redundant,redundant,152,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: For now, ignore classes that subclass SenTestCase and XCTestCase,; // as these don't need to implement -dealloc. They implement tear down in; // another way, which we should try and catch later.; // http://llvm.org/bugs/show_bug.cgi?id=3187",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:143,down,down,143,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['down'],['down']
Availability,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:91,down,down,91,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['down'],['down']
Availability,"// FIXME: Force the precision of the source value down so we don't print; // digits which are usually useless (we don't really care here if we; // truncate a digit by accident in edge cases). Ideally, APFloat::toString; // would automatically print the shortest representation, but it's a bit; // tricky to implement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,down,down,50,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['down'],['down']
Availability,"// FIXME: Force the precision of the source value down so we don't; // print digits which are usually useless (we don't really care here if; // we truncate a digit by accident in edge cases). Ideally,; // APFloat::toString would automatically print the shortest; // representation which rounds to the correct value, but it's a bit; // tricky to implement. Could use std::to_chars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OptionalDiagnostic.h:50,down,down,50,interpreter/llvm-project/clang/include/clang/AST/OptionalDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OptionalDiagnostic.h,1,['down'],['down']
Availability,// FIXME: Get the TDK from deduction in order to provide better diagnostics; // for non-substitution-failure issues?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,failure,failure,101,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['failure'],['failure']
Availability,"// FIXME: GetAbsDifference tries to compute the length of the function; // immediately, before the whole file is emitted, but in general; // that's impossible: the size in bytes of certain assembler directives; // like .align and .fill is not known until the whole file is parsed and; // relaxations are applied. Currently, GetAbsDifference fails with a fatal; // error in that case. (We mostly don't hit this because inline assembly; // specifying those directives is rare, and we don't normally try to; // align loops on AArch64.); //; // There are two potential approaches to delaying the computation. One,; // we could emit something like "".word (endfunc-beginfunc)/4+0x10800000"",; // as long as we have some conservative estimate we could use to prove; // that we don't need to split the unwind data. Emitting the constant; // is straightforward, but there's no existing code for estimating the; // size of the function.; //; // The other approach would be to use a dedicated, relaxable fragment,; // which could grow to accommodate splitting the unwind data if; // necessary. This is more straightforward, since it automatically works; // without any new infrastructure, and it's consistent with how we handle; // relaxation in other contexts. But it would require some refactoring; // to move parts of the pdata/xdata emission into the implementation of; // a fragment. We could probably continue to encode the unwind codes; // here, but we'd have to emit the pdata, the xdata header, and the; // epilogue scopes later, since they depend on whether the we need to; // split the unwind data.; //; // If this is fixed, remove code in AArch64ISelLowering.cpp that; // disables loop alignment on Windows.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:364,error,error,364,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['error'],['error']
Availability,// FIXME: Handle '@' args (or at least error on them).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:39,error,error,39,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,1,['error'],['error']
Availability,// FIXME: Handle errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:17,error,errors,17,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,3,['error'],['errors']
Availability,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:173,reliab,reliably,173,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,1,['reliab'],['reliably']
Availability,"// FIXME: Ideally we would propagate this error upwards, but that would; // prevent us from displaying any debug info at all. For now we just consume; // the error and display everything that was parsed successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/dwarf2yaml.cpp:42,error,error,42,interpreter/llvm-project/llvm/tools/obj2yaml/dwarf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/dwarf2yaml.cpp,2,['error'],['error']
Availability,"// FIXME: If `Metadata` returns an `llvm::Expected<T>` the `AnyGenerator` will; // construct an `llvm::Expected<llvm::Any>` where no error is present but the; // `llvm::Any` holds the error. This is unlikely but potentially surprising.; // Perhaps the `llvm::Expected` should be unwrapped, or perhaps this should be a; // compile-time error. No solution here is perfect.; //; // Note: This function template accepts any type callable with a MatchResult; // rather than a `std::function` because the return-type needs to be deduced. If; // it accepted a `std::function<R(MatchResult)>`, lambdas or other callable; // types would not be able to deduce `R`, and users would be forced to specify; // explicitly the type they intended to return by wrapping the lambda at the; // call-site.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:133,error,error,133,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,3,['error'],['error']
Availability,"// FIXME: If clang-format writes enough to the standard error stream to block,; // we will never reach this point; instead, read the standard error asynchronously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:56,error,error,56,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,2,['error'],['error']
Availability,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:130,error,errors,130,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['errors']
Availability,"// FIXME: If the file is overridden and we've already opened it,; // issue an error (or split it into a separate FileEntry).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:78,error,error,78,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,"// FIXME: If this is a problem, recover from it by creating a multiplex; // source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:32,recover,recover,32,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['recover'],['recover']
Availability,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,recover,recover,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['recover'],['recover']
Availability,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// FIXME: If we get an error during a bridge cast, should we report it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['error'],['error']
Availability,"// FIXME: If we would typo-correct to an invalid declaration, it's; // probably best to just suppress all errors from this typo correction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,error,errors,106,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['errors']
Availability,"// FIXME: Implement addrspace printing/parsing in MIR.; // For now, print this even though parsing it is not available in MIR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:109,avail,available,109,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,1,['avail'],['available']
Availability,// FIXME: Implement error handling that doesn't kill the host program!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['error'],['error']
Availability,// FIXME: Improve error handling here and elsewhere in this pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:18,error,error,18,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,1,['error'],['error']
Availability,// FIXME: Improve error texts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// FIXME: In C++17 classes with non-virtual bases may be treated as; // aggregates, and in such case no top-frame constructor will be called.; // Figure out if we need to do anything in this case.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) available in this; // callback, ideally as part of CallEvent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:314,avail,available,314,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['avail'],['available']
Availability,// FIXME: In some cases we can emit an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:39,error,error,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,1,['error'],['error']
Availability,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Recover,Recover,40,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['Recover'],['Recover']
Availability,// FIXME: Instead of printing the diagnostic we should store it and have a; // better way to return errors through the format APIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:100,error,errors,100,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,1,['error'],['errors']
Availability,"// FIXME: Instead of visiting the pending Q each time, set a dirty flag on the; // available Q to release pending nodes at least once before popping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:83,avail,available,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,// FIXME: Is there a better way to do this? is256BitLaneRepeatedShuffleMask; // doesn't work because our mask is for 128 bits and we don't have an MVT; // to match that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:105,mask,mask,105,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Availability,// FIXME: It would be nicer if the keyword was ignored only for this; // declarator. Otherwise we could get follow-up errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,error,errors,118,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,"// FIXME: It would be wonderful if we could point at the actual member. In; // general, it would be useful to pass location information down the stack,; // so that we know the location (or decl) of the ""current object"" being; // initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,down,down,136,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['down'],['down']
Availability,"// FIXME: It's slightly absurd to create a new diagnostics engine here, but; // the other options that are available today are worse:; //; // 1. Teach DiagnosticsConsumers to emit diagnostics to the engine they are a; // part of. The DiagnosticsEngine would need to know not to send; // diagnostics back to the consumer that failed. This would require us to; // rework ChainedDiagnosticsConsumer and teach the engine about multiple; // consumers, which is difficult today because most APIs interface with; // consumers rather than the engine itself.; //; // 2. Pass a DiagnosticsEngine to SDiagsWriter on creation - this would need; // to be distinct from the engine the writer was being added to and would; // normally not be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:107,avail,available,107,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,1,['avail'],['available']
Availability,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:183,avail,availability,183,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,2,['avail'],['availability']
Availability,// FIXME: Make determination of operator precedence more general and; // make it broadly available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:89,avail,available,89,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,1,['avail'],['available']
Availability,// FIXME: Need to handle arbitrary downcasts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:35,down,downcasts,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['down'],['downcasts']
Availability,"// FIXME: Nodes such as CopyFromReg probably should not advance the current; // cycle. Otherwise, we can wrongly mask real stalls. If the non-machine node; // has predecessors the cycle will be advanced when they are scheduled.; // But given the crude nature of modeling latency though such nodes, we; // currently need to treat these nodes like real instructions.; // if (!SU->getNode() || !SU->getNode()->isMachineOpcode()) return;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:113,mask,mask,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['mask'],['mask']
Availability,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,3,['mask'],['mask']
Availability,"// FIXME: Once available, specialize this function for `contiguous_iterator`s,; // and use it for `ArrayRef` and `StringRef`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:15,avail,available,15,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['avail'],['available']
Availability,"// FIXME: Only available in A-class, isel not predicated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:15,avail,available,15,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avail'],['available']
Availability,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,4,"['error', 'recover']","['error', 'recovery']"
Availability,"// FIXME: Prepare forward pass for this test; /*std::cout << ""Test Back-propagation 2: "" << std::endl;; if (!testBackward2<TCpu<Scalar_t>>()) {; std::cerr << ""ERROR - Back-propagation failed "" << std::endl;; return -1;; }*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:159,ERROR,ERROR,159,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,1,['ERROR'],['ERROR']
Availability,// FIXME: Print a more useful error. We can give the current record and the; // index that we think its pointing to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['error'],['error']
Availability,// FIXME: Print available packages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp:16,avail,available,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,1,['avail'],['available']
Availability,// FIXME: Probably need to propagate Errors through the pass manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:37,Error,Errors,37,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['Error'],['Errors']
Availability,// FIXME: Probably shouldn't bother trying to fold if not an; // SGPR. PeepholeOptimizer can eliminate redundant VGPR->VGPR; // copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:103,redundant,redundant,103,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['redundant'],['redundant']
Availability,// FIXME: Produce better diagnostics for deduction failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:51,failure,failures,51,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['failure'],['failures']
Availability,// FIXME: Propagate Errors through to the caller instead of emitting; // diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:20,Error,Errors,20,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,1,['Error'],['Errors']
Availability,// FIXME: Propagate the Error to the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:24,Error,Error,24,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,1,['Error'],['Error']
Availability,// FIXME: Proper error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:17,error,error,17,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,1,['error'],['error']
Availability,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Recover,Recover,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Recover'],['Recover']
Availability,// FIXME: Recover from this by treating the declaration as a redeclaration; // of the primary template.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Recover,Recover,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Availability,"// FIXME: Redundant check, but even less readable when factored out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:10,Redundant,Redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['Redundant'],['Redundant']
Availability,"// FIXME: Redundant storage which, beyond utilizing value of; // caughtResultStore for unwindException storage, may be alleviated; // altogether with a block rearrangement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Redundant,Redundant,10,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['Redundant'],['Redundant']
Availability,// FIXME: Refactor error handling in MachOReader and report an error; // if we encounter an invalid relocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOReader.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOReader.cpp,2,['error'],['error']
Availability,"// FIXME: Remove the default statement from the switch block so that; // we'll return a valid AST. This requires recursing down the AST and; // finding it, not something we are set up to do right now. For now,; // just lop the entire switch stmt out of the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:123,down,down,123,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['down'],['down']
Availability,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,avail,availability,167,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avail'],['availability']
Availability,// FIXME: Report errors through EPC once that functionality is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:17,error,errors,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,2,"['avail', 'error']","['available', 'errors']"
Availability,// FIXME: Report the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:21,error,error,21,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['error']
Availability,// FIXME: Return failure if the RHS type doesn't match the LHS. Shifts may; // have different LHS and RHS types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,failure,failure,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['failure'],['failure']
Availability,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['avail'],['available']
Availability,"// FIXME: Set priority, availability appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:24,avail,availability,24,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avail'],['availability']
Availability,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:64,error,error-prone,64,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['error'],['error-prone']
Availability,// FIXME: Setting a dummy call-through manager in non-lazy mode prevents the; // JIT builder to instantiate a default (which would fail with an error for; // unsupported architectures).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:144,error,error,144,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['error'],['error']
Availability,// FIXME: Shall we simultaneously invalidate AvailSrc or AvailDef?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:45,Avail,AvailSrc,45,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,2,['Avail'],"['AvailDef', 'AvailSrc']"
Availability,// FIXME: Should in-progress permissions be reverted if an error occurs?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:59,error,error,59,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['error'],['error']
Availability,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,redundant,redundant,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redundant'],['redundant']
Availability,// FIXME: Should this be reported / treated as failure to materialize?; // Or should this be treated as a sanctioned bailing-out?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:47,failure,failure,47,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['failure'],['failure']
Availability,// FIXME: Should we handle this error differently?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:32,error,error,32,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['error'],['error']
Availability,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,recover,recover,49,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Availability,// FIXME: Some error handling if Start.SectionIndex != End.SectionIndex,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp,1,['error'],['error']
Availability,"// FIXME: Sometimes tryInstructionTransform() will add instructions and; // test whether they can be folded before keeping them. In this case it; // sets a kill before recursively calling tryInstructionTransform() again.; // If there is no interval available, we assume that this instruction is; // one of those. A kill flag is manually inserted on the operand so the; // check below will handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:249,avail,available,249,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['avail'],['available']
Availability,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// FIXME: Support more relocations & change this to an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:55,error,error,55,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['error'],['error']
Availability,// FIXME: Support multi-piece names.; // FIXME: better error handling (propagate error out).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:55,error,error,55,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,2,['error'],['error']
Availability,// FIXME: Suppress the warning here if there is no initializer; we're; // going to give an error anyway.; // We assume that something like 'T (&x) = y;' is highly likely to not; // be intended to be a temporary object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:91,error,error,91,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,// FIXME: The C++98 initializer is an attempt to work around compile failures; // due to http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1397.; // We should be able to switch this back to member initialization once that; // issue is fixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp:69,failure,failures,69,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp,1,['failure'],['failures']
Availability,"// FIXME: The LLVM_DEBUG macro only plays well with a modular; // build of LLVM when the header is marked as textual, but doing; // so causes redefinition errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:155,error,errors,155,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['error'],['errors']
Availability,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,redundant,redundant,29,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: The code below also handles conversion between vectors and; // non-scalars, we should break this down into fine grained specific checks; // and emit proper diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,down,down,107,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['down'],['down']
Availability,// FIXME: The current implementation only supports loading decls with; // a lookup name from a single translation unit. If multiple; // translation units contains decls with the same lookup name an; // error will be returned.; // Try to get the value from the heavily cached storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:202,error,error,202,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['error'],['error']
Availability,// FIXME: The lookup for allocation function is a standalone process.; // (We can find the logics in Sema::FindAllocationFunctions); //; // Such structure makes it a problem when we instantiate a template; // declaration using placement allocation function if the placement; // allocation function is invisible.; // (See https://github.com/llvm/llvm-project/issues/59601); //; // Here we workaround it by making the placement allocation functions; // always acceptable. The downside is that we can't diagnose the direct; // use of the invisible placement allocation functions. (Although such uses; // should be rare).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:474,down,downside,474,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['down'],['downside']
Availability,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:396,error,error-prone,396,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['error'],['error-prone']
Availability,"// FIXME: The other checks should be redundant with allStackObjectsAreDead,; // but currently hasNonSpillStackObjects is set only from source; // allocas. Stack temps produced from legalization are not counted currently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:37,redundant,redundant,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: The register allocator not only may not have given us the; // registers in sequence, but may not be in ascending registers. This; // will require changes in the register allocator that'll need to be; // propagated down here if the operands change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp:224,down,down,224,interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,1,['down'],['down']
Availability,"// FIXME: These are equivalent to the default move constructor/move; // assignment. However, using = default triggers linker errors due to the; // explicit instantiations below. Find a way to use the default and remove the; // duplicated code here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:125,error,errors,125,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['error'],['errors']
Availability,"// FIXME: These are equivalent to the default move constructor/move; // assignment. However, using = default triggers linker errors due to the; // explicit instantiations below. Find away to use the default and remove the; // duplicated code here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:125,error,errors,125,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['error'],['errors']
Availability,"// FIXME: This approach for uniquing ADL results (and removing; // redundant candidates from the set) relies on pointer-equality,; // which means we need to key off the canonical decl. However,; // always going back to the canonical decl might not get us the; // right set of default arguments. What default arguments are; // we supposed to consider on ADL candidates, anyway?; // FIXME: Pass in the explicit template arguments?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,redundant,redundant,67,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: This call uses the word ""API"" as the description of the bug;; // it should be replaced by a better error message (if this unlikely; // situation continues to exist as a separate bug type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['error'],['error']
Availability,"// FIXME: This can find a module not part of ModuleName, which is; // important so that we're consistent about whether this header; // corresponds to a module. Possibly we should lock down framework modules; // so that this is not possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:184,down,down,184,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['down'],['down']
Availability,// FIXME: This can result in errors if the definition was imported from a; // module but is hidden.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,error,errors,29,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['errors']
Availability,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,error,error-dependent,147,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error-dependent']
Availability,"// FIXME: This causes a lot of test failures, for some reason it causes; // the call to HandleMissingFunction to be elided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:36,failure,failures,36,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,1,['failure'],['failures']
Availability,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:69,Error,Error,69,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,30,['Error'],['Error']
Availability,// FIXME: This class is will be removed after the transition to llvm::Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:70,Error,Error,70,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['Error'],['Error']
Availability,"// FIXME: This code has some duplication with recordRelocation. We should; // probably merge the two into a single callback that tries to evaluate a; // fixup and records a relocation if one is needed.; // On error claim to have completely evaluated the fixup, to prevent any; // further processing from being done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:209,error,error,209,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['error'],['error']
Availability,"// FIXME: This code works, but it is unclear that we actually want to insert; // a big chain of computation in order to make a value available in a block.; // This needs to be evaluated carefully to consider its cost trade offs.; // PHI translate the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:133,avail,available,133,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,"// FIXME: This could just be RegistersByName[name] = register, except that; // causes some failures in MIPS - perhaps they have duplicate register name; // entries? (or maybe there's a reason for it - I don't know much about this; // code, just drive-by refactoring)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:91,failure,failures,91,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['failure'],['failures']
Availability,// FIXME: This doesn't currently handle early-clobber or multiple removed; // defs inside of the region to repair.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:107,repair,repair,107,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['repair'],['repair']
Availability,// FIXME: This emits a different error message than; // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:33,error,error,33,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"// FIXME: This error message could be improved, it would be nice; // to say what the bounds actually are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"// FIXME: This error return is in place temporarily so we can; // add more constraints as we hit it. Eventually, an unknown; // constraint should just be treated as 'g'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,1,['error'],['error']
Availability,"// FIXME: This error shouldn't actually occur (the front end should emit; // multiple .align directives to enforce the semantics it wants), but is; // severe enough that we want to report it. How to handle this?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['error'],['error']
Availability,"// FIXME: This is a hack so that we can override the preamble file during; // crash-recovery testing, which is the only case where the preamble files; // are not necessarily cleaned up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,recover,recovery,84,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['recover'],['recovery']
Availability,"// FIXME: This is a horrible hack. We should always respect noinline,; // and just let us hit the error when we can't handle this.; //; // Unfortunately, clang adds noinline to all functions at -O0. We have; // to override this here until that's fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp:98,error,error,98,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp,1,['error'],['error']
Availability,"// FIXME: This is a manually un-factored variant of the basic code inside; // of GEPs with checking of the inbounds invariant specified in the; // langref in a very strict sense. If we ever want to enable; // SROAStrictInbounds, this code should be factored cleanly into; // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds; // by writing out the code here where we have the underlying allocation; // size readily available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:435,avail,available,435,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avail'],['available']
Availability,"// FIXME: This is a temporary fix for the following error with ACLiC; // (and this is apparently not needed anyway):; // 48: input_line_12:8:38: error: use of undeclared identifier 'IC'; // 48: ""C:/Users/bellenot/build/debug/etc"" -IC:/Users/bellenot/build/debug/etc//cling -IC:/Users/bellenot/build/debug/include"""",; // 48: ^; // 48: Error in <ACLiC>: Dictionary generation failed!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:52,error,error,52,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,3,"['Error', 'error']","['Error', 'error']"
Availability,// FIXME: This is a ugly hack. Undo command checks its availability by looking; // at the size of the PTU list. However we have parsed something in the; // beginning of the REPL so we have to mark them as 'Irrevocable'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:55,avail,availability,55,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['avail'],['availability']
Availability,// FIXME: This is a workaround for DivergenceAnalysis not understanding always; // uniform values (as produced by the mask results of control flow intrinsics); // used outside of divergent blocks. The phi users need to also be treated as; // always uniform.; //; // FIXME: DA is no longer in-use. Does this still apply to UniformityAnalysis?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:118,mask,mask,118,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,"// FIXME: This is all a pretty gross hack. We should automatically handle; // optional operands like this via tblgen.; // Next, add the CCOut and ConditionCode operands, if needed.; //; // For mnemonics which can ever incorporate a carry setting bit or predication; // code, our matching model involves us always generating CCOut and; // ConditionCode operands to match the mnemonic ""as written"" and then we let; // the matcher deal with finding the right instruction or generating an; // appropriate error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:501,error,error,501,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// FIXME: This is here only because the VMerge transform doesn't; // know how to handle masked true inputs. Once that has been moved; // to post-ISEL, this can be deleted as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,mask,masked,88,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,// FIXME: This is not quite correct recovery as we don't transform SS; // into the corresponding dependent form (and we don't diagnose missing; // 'template' keywords within SS as a result).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,recover,recovery,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Availability,// FIXME: This is small hack. Given; // a = b + 4; // .long a; // the OS X assembler will completely drop the 4. We should probably; // include it in the relocation or produce an error if that is not; // possible.; // Allow constant expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:179,error,error,179,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['error'],['error']
Availability,// FIXME: This loop leaks the index expressions on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:51,error,error,51,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,// FIXME: This pass causes verification failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:40,failure,failures,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,2,['failure'],['failures']
Availability,// FIXME: This presumably means a pack ended up smaller than we; // expected while deducing. Should this not result in deduction; // failure? Can it even happen?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:133,failure,failure,133,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['failure'],['failure']
Availability,"// FIXME: This really shouldn't be copyable, but is currently copied in some; // error handling in Driver::generateCompilationDiagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h:81,error,error,81,interpreter/llvm-project/clang/include/clang/Driver/Job.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h,1,['error'],['error']
Availability,"// FIXME: This requires bufferoverflowu.lib, but adding:; // #pragma comment(lib, ""bufferoverflowu.lib"") still gives errors!; // Opts.setStackProtector(clang::LangOptions::SSPStrong);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:117,error,errors,117,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['error'],['errors']
Availability,"// FIXME: This should be a cast from a 1-bit integer type to a boolean type,; // but the former is not available in Clang. Instead, extend the APSInt; // directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:103,avail,available,103,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['avail'],['available']
Availability,"// FIXME: This should be the page size of the system running profiling.; // However such info isn't available at post-processing time, assuming; // 4K page now. Note that we don't use EXEC_PAGESIZE from <linux/param.h>; // because we may build the tools on non-linux.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:100,avail,available,100,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['avail'],['available']
Availability,"// FIXME: This should ideally happen in the right order without explicitly; // doing this. We started seeing failing tests (eg, tutorial-hist-cumulative,; // JITLink turned on) with assertion failure in ~FinalizedAlloc after commit; // [cling] Move generators to ProcessSymbols JITDylib; // This likely changed the destruction order that caused the assertion to; // trigger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:192,failure,failure,192,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['failure'],['failure']
Availability,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:245,down,down,245,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,['down'],['down']
Availability,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.; // SuccToSinkTo - This is the successor to sink this instruction to, once we; // decide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:245,down,down,245,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,2,['down'],['down']
Availability,// FIXME: This will produce an error if the definition of the interface has; // been imported from a module but is not visible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"// FIXME: This, like the main visit, doesn't support CUDAKernelCallExpr.; // FIXME: An isa<> would look much better but this whole switch is a; // workaround for an internal compiler error in MSVC 2015 (see r326021).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:183,error,error,183,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['error'],['error']
Availability,// FIXME: Throw error when multiple sub-architecture flag exist,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp,1,['error'],['error']
Availability,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:214,down,down,214,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,1,['down'],['down']
Availability,"// FIXME: Upgrade this to an error once modules are stable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:29,error,error,29,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['error']
Availability,// FIXME: Use a new dep-map type for FailedToMaterialize errors so that we; // don't have to manually retain/release.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:57,error,errors,57,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['errors']
Availability,"// FIXME: Use function attribute ""OptimizeForSize"" and/or CodeGenOptLevel to; // decide if we should generate a 16-byte constant mask when we only need 4 or; // 8 bytes for the scalar case.; // There are no scalar bitwise logical SSE/AVX instructions, so we; // generate a 16-byte vector constant and logic op even for the scalar case.; // Using a 16-byte mask allows folding the load of the mask with; // the logic op, so it can save (~4 bytes) on code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:129,mask,mask,129,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],['mask']
Availability,// FIXME: Use same reserved register introduced in D149775; // SGPR used to preserve EXEC MASK around WWM spill/copy instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:90,MASK,MASK,90,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['MASK'],['MASK']
Availability,// FIXME: Use std::invoke() when it's available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h,1,['avail'],['available']
Availability,// FIXME: Use std::type_identity or backport when available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:50,avail,available,50,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,1,['avail'],['available']
Availability,"// FIXME: Warn about failure to get the streamer info here?; //; // We may have allocated an object last time we were called.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:21,failure,failure,21,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['failure'],['failure']
Availability,// FIXME: We assume we never cast the mask results of a control flow; // intrinsic.; // Early exit if the type won't be consistent as a compile time hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,"// FIXME: We can promote this to an error. The function or variable can't; // be defined anywhere else, so the program must necessarily violate the; // one definition rule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:36,error,error,36,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:94,mask,mask,94,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,"// FIXME: We don't have any representation for explicit instantiations of; // member classes. Such a representation is not needed for compilation, but it; // should be available for clients that want to see all of the declarations in; // the source code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:168,avail,available,168,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avail'],['available']
Availability,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['down'],['down']
Availability,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['down'],['down']
Availability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; // Error(""TClingClassInfo::New()"", ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:75,Error,Error,75,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['Error'],['Error']
Availability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(arena)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:74,Error,Error,74,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['Error'],['Error']
Availability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(n)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:74,Error,Error,74,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['Error'],['Error']
Availability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(n, arena)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:74,Error,Error,74,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['Error'],['Error']
Availability,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,recover,recover,99,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,"// FIXME: We get an error ""'cling/module.modulemap' from the precompiled; // header has been overridden"". This comes from a bug that rootcling; // introduces by adding a lot of garbage in the PCH/PCM files because it; // essentially serializes its current state of the AST. That usually; // includes a few memory buffers which override their own contents.; // We know how to remove this: just implement a callback in clang; // which calls back the interpreter when a module file is built. This is; // a lot of work as it needs fixing rootcling. See RE-0003.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:20,error,error,20,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['error'],['error']
Availability,// FIXME: We may be able to use the NumToSkip values to recover; // appropriate indentation levels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:56,recover,recover,56,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['recover'],['recover']
Availability,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:232,down,downcasts,232,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['down'],['downcasts']
Availability,// FIXME: We might want to terminate an async initial scan early in case; // of a failure in EventsReceivingThread.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:82,failure,failure,82,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['failure'],['failure']
Availability,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:21,error,error,21,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,4,['error'],['error']
Availability,"// FIXME: We need and error message here, no streamer info, so cannot set offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:22,error,error,22,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['error'],['error']
Availability,"// FIXME: We only do this after checking for min/max to prevent infinite; // looping caused by a reverse canonicalization of these patterns for min/max.; // FIXME: The organization of folds is a mess. These would naturally go into; // canonicalizeCmpWithConstant(), but we can't move all of the above folds; // down here after the min/max restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:311,down,down,311,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['down'],['down']
Availability,"// FIXME: We only examine the pattern decl for availability violations now,; // but we should also examine instantiated templates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:47,avail,availability,47,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:109,failure,failure,109,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['failure'],['failure']
Availability,// FIXME: We probably need to make this out-of-line to avoid redundant; // generation of virtual functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:61,redundant,redundant,61,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['redundant'],['redundant']
Availability,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:82,avail,availability,82,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,"['AVAIL', 'avail']","['AVAIL-IN', 'availability']"
Availability,"// FIXME: We really need to improve the relocation validation. Basically, we; // want to implement a separate computation which evaluates the relocation; // entry as the linker would, and verifies that the resultant fixup value is; // exactly what the encoder wanted. This will catch several classes of; // problems:; //; // - Relocation entry bugs, the two algorithms are unlikely to have the same; // exact bug.; //; // - Relaxation issues, where we forget to relax something.; //; // - Input errors, where something cannot be correctly encoded. 'as' allows; // these through in many cases.; // Add a relocation to be output in the object file. At the time this is; // called, the symbol indexes are not know, so if the relocation refers; // to a symbol it should be passed as \p RelSymbol so that it can be updated; // afterwards. If the relocation doesn't refer to a symbol, nullptr should be; // used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h:495,error,errors,495,interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,1,['error'],['errors']
Availability,"// FIXME: We really want to get out of the tool chain level argument; // translation business, as it makes the driver functionality much; // more opaque. For now, we follow gcc closely solely for the; // purpose of easily achieving feature parity & testability. Once we; // have something that works, we should reevaluate each translation; // and try to push it down into tool specific logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:362,down,down,362,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['down'],['down']
Availability,// FIXME: We return error here but the definition is already created; // and available with lookups. How to fix this?..,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,4,"['avail', 'error']","['available', 'error']"
Availability,"// FIXME: We should add an error here. According to:; // [dcl.fct.def.coroutine]p12; // If no usual deallocation function is found, the program is ill-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['error'],['error']
Availability,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['error'],['error']
Availability,"// FIXME: We should load only the first available and rely on other callbacks; // such as RequireCompleteType and LookupUnqualified to load all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:40,avail,available,40,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['avail'],['available']
Availability,// FIXME: We should propagate this error or otherwise display it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAbbrev.cpp:35,error,error,35,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAbbrev.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAbbrev.cpp,1,['error'],['error']
Availability,// FIXME: We should propagate this error upwards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:35,error,error,35,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['error'],['error']
Availability,"// FIXME: We should track down all sets and potentially avoid them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.h:26,down,down,26,core/metacling/src/TClingClassInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.h,1,['down'],['down']
Availability,"// FIXME: We shouldn't be changing ""nobuiltin"" or TLI unavailable calls here.; // Some clang users checked for _chk libcall availability using:; // __has_builtin(__builtin___memcpy_chk); // When compiling with -fno-builtin, this is always true.; // When passing -ffreestanding/-mkernel, which both imply -fno-builtin, we; // end up with fortified libcalls, which isn't acceptable in a freestanding; // environment which only provides their non-fortified counterparts.; //; // Until we change clang and/or teach external users to check for availability; // differently, disregard the ""nobuiltin"" attribute and TLI::has.; //; // PR23093.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,avail,availability,124,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,2,['avail'],['availability']
Availability,// FIXME: We use a fatal error here because historically LLVM has tried; // lower some of these physreg copies and we want to ensure we get; // reasonable bug reports if someone encounters a case no other testing; // found. This path should be removed after the LLVM 7 release.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['error'],['error']
Availability,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:37,repair,repairing,37,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,6,"['down', 'repair']","['down', 'repairing']"
Availability,// FIXME: We're generating redundant loads and stores here!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:27,redundant,redundant,27,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: Why are we trying to remove files that we have not created? For; // example we should only try to remove a temporary assembly file if; // ""clang -cc1"" succeed in writing it. Was this a workaround for when; // clang was writing directly to a .s file and sometimes leaving it behind; // during a failure?; // FIXME: If this is necessary, we can still try to split; // llvm::sys::fs::remove into a removeFile and a removeDir and avoid the; // duplicated stat from is_regular_file.; // Don't try to remove files which we don't have write access to (but may be; // able to remove), or non-regular files. Underlying tools may have; // intentionally not overwritten them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:304,failure,failure,304,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,1,['failure'],['failure']
Availability,// FIXME: Workaround for syntax error reported by MSVC buildbots.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,error,error,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['error'],['error']
Availability,"// FIXME: Would it make sense to try to ""forget"" the previous; // definition, as part of error recovery?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:89,error,error,89,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// FIXME: accept a Path as a parameter, and use it for error reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:55,error,error,55,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,1,['error'],['error']
Availability,"// FIXME: better error handling here. For now, simply return an empty; // Replacements to indicate failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,2,['error'],['error']
Availability,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,2,['error'],['error']
Availability,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,8,['error'],['error']
Availability,"// FIXME: better error handling. For now, just skip the replacement for the; // release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,['error'],['error']
Availability,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,['error'],['error']
Availability,"// FIXME: call `noteSLocAddressSpaceUsage` to report details to users and; // use a source location from `Info` to point at an error.; // Currently, both cause Clang to run indefinitely, this needs to be fixed.; // FIXME: return an error instead of crashing. Returning invalid source; // locations causes compiler to run indefinitely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:127,error,error,127,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,2,['error'],['error']
Availability,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:48,error,error,48,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['error'],['error']
Availability,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:32,mask,maskstore,32,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,['mask'],"['maskload', 'maskstore']"
Availability,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:99,error,error,99,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,4,['error'],['error']
Availability,"// FIXME: different platforms make different information available ""for free""; // when traversing a directory. The design of this class wraps most of the; // information in basic_file_status, so on platforms where we can't populate; // that whole structure, callers end up paying for a stat().; // std::filesystem::directory_entry may be a better model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:57,avail,available,57,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['avail'],['available']
Availability,// FIXME: do something more useful with the error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp:44,error,error,44,interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,1,['error'],['error']
Availability,"// FIXME: don't ignore attributes.; // If it's explicit specializations all the way down, just forget; // about the template header and build an appropriate non-templated; // friend. TODO: for source fidelity, remember the headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,down,down,84,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['down'],['down']
Availability,// FIXME: double check this; // FIXME: should we error if lbase->getRegParmAttr() != 0 &&; // rbase->getRegParmAttr() != 0 &&; // lbase->getRegParmAttr() != rbase->getRegParmAttr()?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,error,error,49,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['error'],['error']
Availability,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,redundant,redundant,32,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,1,['redundant'],['redundant']
Availability,// FIXME: error check symbolIdx,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:10,error,error,10,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,1,['error'],['error']
Availability,// FIXME: error out in a more elegant fashion,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,// FIXME: find a more resilient way,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:22,resilien,resilient,22,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,1,['resilien'],['resilient']
Availability,// FIXME: find the issue and report error in clang instead of check it in; // backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp:36,error,error,36,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILOpBuilder.cpp,1,['error'],['error']
Availability,"// FIXME: gCling should be const so assignemnt is a compile time error.; // Currently the name mangling is coming up wrong for the const version; // (on OS X at least, so probably Linux too) and the JIT thinks the symbol; // is undefined in a child Interpreter. And speaking of children, should; // gCling actually be thisCling, so a child Interpreter can only access; // itself? One could use a macro (simillar to __dso_handle) to block; // assignemnt and get around the mangling issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:65,error,error,65,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['error'],['error']
Availability,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,['error'],['error']
Availability,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:20,error,error,20,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,2,['error'],['error']
Availability,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,redundant,redundant,150,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,['redundant'],['redundant']
Availability,"// FIXME: in-function stack adjustment for calls is limited to 24-bits; // because there's no guaranteed temporary register available.; //; // ADD/SUB (immediate) has only LSL #0 and LSL #12 available.; // 1) For offset <= 12-bit, we use LSL #0; // 2) For 12-bit <= offset <= 24-bit, we use two instructions. One uses; // LSL #0, and the other uses LSL #12.; //; // Most call frames will be allocated at the start of a function so; // this is OK, but it is a limitation that needs dealing with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:124,avail,available,124,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,2,['avail'],['available']
Availability,// FIXME: is there useful debug info available here?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// FIXME: it might be a worthwhile optimization to not mask loaded; // values if all the registers involved in address calculation are already; // hardened, leading to this load not able to execute on a miss-speculated; // path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['mask'],['mask']
Availability,"// FIXME: it should be an error not to find a definition for a given; // operand, rather than just failing to add it to the resulting; // instruction! (This is a longstanding bug, which will be addressed in an; // upcoming change.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:26,error,error,26,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['error'],['error']
Availability,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:60,error,error,60,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,3,"['error', 'failure']","['error', 'failures']"
Availability,"// FIXME: make ErrorReporter a member (may also need subclassing; // StatefulErrorReporter) to easily get the latest error status, for; // debugging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:15,Error,ErrorReporter,15,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,2,"['Error', 'error']","['ErrorReporter', 'error']"
Availability,"// FIXME: make this available in the public API for users to easily create their; // own selectors.; // Creates a selector from a range-selection function \p Func, which selects a; // range that is relative to a bound node id. \c T is the node type expected by; // \p Func.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:20,avail,available,20,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,1,['avail'],['available']
Availability,"// FIXME: missing DW_AT_location is OK here, but other errors should be; // reported to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:55,error,errors,55,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['error'],['errors']
Availability,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,3,['recover'],['recover']
Availability,// FIXME: recover in order to allow the body to be parsed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recover']
Availability,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,recover,recovery,10,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recovery']
Availability,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Recover,RecoveryExpr,72,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['Recover'],['RecoveryExpr']
Availability,// FIXME: should we consume the discard error?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:40,error,error,40,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['error'],['error']
Availability,"// FIXME: simplify-demanded-bits in DAGCombine will probably have; // changed the AND node to a 32-bit mask operation. We'll have to; // undo that as part of the transform here if we want to catch all; // the opportunities.; // Currently the NumberOfIgnoredLowBits argument helps to recover; // from these situations when matching bigger pattern (bitfield insert).; // For unsigned extracts, check for a shift right and mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,3,"['mask', 'recover']","['mask', 'recover']"
Availability,// FIXME: these are redundant if CmpInst < BinaryOperator,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:20,redundant,redundant,20,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['redundant'],['redundant']
Availability,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,error,error,38,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// FIXME: this is redundant with part of setFunctionDefinitionAttributes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:18,redundant,redundant,18,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['redundant'],['redundant']
Availability,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,error,error,118,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,// FIXME: we should produce an error in case of ambig and failed lookups.; // Other decls (e.g. namespaces) also have this shortcoming.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"// FIXME: when an instruction has a Killed operand, and the instruction is; // inside a bundle, seems only the BUNDLE instruction appears as the Kills of; // the register in LiveVariables, this would trigger a failure in verifier,; // we should fix it and enable the verifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:210,failure,failure,210,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['failure'],['failure']
Availability,"// FIXME? We really want the register size rather than the spill size; // since the spill size may be bigger on some targets with; // limited load/store instructions. However, we don't store the; // register size anywhere (we could sum the sizes of the subregisters; // but there may be additional bits too) and we can't derive it from; // the VT's reliably due to Untyped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp:349,reliab,reliably,349,interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp,1,['reliab'],['reliably']
Availability,"// FNSTENV changes the exception mask, so load back the stored environment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// FP X constraints get lowered to SSE1/2 registers if available, otherwise; // 'f' like normal targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,avail,available,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// FS_ALIAS: [valueid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_PERMODULE entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:159,avail,available,159,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avail'],['available']
Availability,"// FS_COMBINED_ALIAS: [valueid, modid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_COMBINED entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:174,avail,available,174,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avail'],['available']
Availability,// FTC_Manager* manager;; /**; * Current error code. Zero means no error.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTLibrary.h:41,error,error,41,graf3d/ftgl/inc/FTLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTLibrary.h,2,['error'],['error']
Availability,// F[MIN|MAX][NUM|NAN] and simple strict operations are available for all FP; // NEON types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:56,avail,available,56,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// Fail hard if there were errors. These are strictly unrecoverable and; // indicate serious issues such as conflicting option names or an; // incorrectly; // linked LLVM distribution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:27,error,errors,27,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['error'],['errors']
Availability,"// Fail if the compare was not analyzed, or it's not comparing a register; // with an immediate value. Not checking the mask here, since we handle; // the individual compare opcodes (including A4_cmpb*) later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:120,mask,mask,120,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['mask'],['mask']
Availability,// Fail out if we encounter an operand that is not available in; // the PRE predecessor. This is typically because of loads which; // are not value numbered precisely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// Fails because LookupHelper doesn't know how to instantiate function templates,; // even though at least the function template is made available to the derived; // class as per using decl. This is issue #6481.; //TFunction *funInhCtor = clInhTemplateFun->GetMethodWithPrototype(""InheritTemplateFun"", ""int, int"");; //ASSERT_NE(funInhCtor, nullptr);; //EXPECT_EQ(funInhCtor->ExtraProperty() & kIsTemplateSpec, kIsTemplateSpec);; //EXPECT_EQ(funInhCtor->Property() & kIsPrivate, kIsPrivate);; // Doesn't work either, as GetListOfFunctionTemplates() ignores using decls.; // Issue #6482; // clInhTemplateFun->GetListOfFunctionTemplates(true)->ls(); // FindObject(""InheritTemplateFun"")-",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingMethodInfoTests.cxx:137,avail,available,137,core/metacling/test/TClingMethodInfoTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingMethodInfoTests.cxx,1,['avail'],['available']
Availability,// Failure,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,1,['Failure'],['Failure']
Availability,"// Failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:3,Failure,Failure,3,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,10,['Failure'],['Failure']
Availability,"// Failure at runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Failure,Failure,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Failure'],['Failure']
Availability,// Failure cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Failure'],['Failure']
Availability,"// Failure in compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Failure,Failure,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Failure'],['Failure']
Availability,"// Failure is only failure if the file exists and is ""regular"". We checked; // for it being regular before, and llvm::sys::fs::remove ignores ENOENT,; // so we don't need to check again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,2,"['Failure', 'failure']","['Failure', 'failure']"
Availability,// Failure result files are valid unless we crashed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['Failure'],['Failure']
Availability,"// Failure to load a dictionary is not (quite) a failure load; // the top-level library. If we return false here, then; // we would end up in a situation where the library and thus; // the dictionary is loaded for ""cls"" but the TClass is; // not created and/or marked as unavailable (in case where; // AutoLoad is called from TClass::GetClass).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Failure,Failure,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,"['Failure', 'failure']","['Failure', 'failure']"
Availability,"// Failure to load a dictionary is not (quite) a failure load; // the top-level library. See detailed comment in the TProtoClass; // branch (above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Failure,Failure,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,"['Failure', 'failure']","['Failure', 'failure']"
Availability,"// Failure to match is not an error, it's just a normal return value.; // Any other error code is considered abnormal, and is logged in the Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp:3,Failure,Failure,3,interpreter/llvm-project/llvm/lib/Support/Regex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp,4,"['Error', 'Failure', 'error']","['Error', 'Failure', 'error']"
Availability,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,3,"['Failure', 'failure']","['Failure', 'failure']"
Availability,"// Failure, just remember this instance for future use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Failure,Failure,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Failure'],['Failure']
Availability,// Failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Failure,Failure,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Failure'],['Failure']
Availability,"// Failure: remove",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Failure,Failure,3,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Failure'],['Failure']
Availability,"// Fall back to extract and build (+ mask, if padding with zeros).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,// Fall back to scalarization of masked operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h:33,mask,masked,33,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,1,['mask'],['masked']
Availability,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:71,recover,recover,71,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,// Fall through to error out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['error']
Availability,// Fall through to produce an error below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:30,error,error,30,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,// Fallback to primary template if no instantiation is available yet (e.g.; // the type doesn't need to be complete).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp:55,avail,available,55,interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp,1,['avail'],['available']
Availability,// Fast path - if the constants match the mask size then copy direct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,1,['mask'],['mask']
Availability,"// Fast path for trailing mask, vector length.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,1,['mask'],['mask']
Availability,// Fast path the constant operand case both for efficiency and so we don't; // increment Depth when just zipping down an all-constant GEP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,down,down,113,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['down'],['down']
Availability,"// Fatal error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:9,error,error,9,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['error'],['error']
Availability,"// Fetch the current python error, if any, and store it for future use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:28,error,error,28,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['error'],['error']
Availability,// Few instructions are available on sm_90 only,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['avail'],['available']
Availability,"// Field length only available querying the field",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteServer.cxx:21,avail,available,21,sql/sqlite/src/TSQLiteServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteServer.cxx,1,['avail'],['available']
Availability,// Fields of may-alias structures are may-alias themselves.; // FIXME: this should get propagated down through anonymous structs; // and unions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:98,down,down,98,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['down'],['down']
Availability,"// Figure how much horizontal space is available for rendering; // this table. Store the answer in lineWidth. left_margin is; // the left-most X coordinate of the table. btm stores the top-most; // Y coordinate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:39,avail,available,39,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['avail'],['available']
Availability,"// Figure out if the weight needs to store errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:43,error,errors,43,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['errors']
Availability,"// Figure out which arguments are going to go in registers, and which in; // memory. Also, if this is a vararg function, floating point operations; // must be stored to our stack, and loaded into integer regs as well, if; // any integer regs are available for argument passing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:246,avail,available,246,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,// Figure out which bits need to be zero to achieve that mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Figure out which directive this is. Since we're lexing raw tokens,; // we don't have an identifier table available. Instead, just look at; // the raw identifier to recognize and categorize preprocessor directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:108,avail,available,108,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avail'],['available']
Availability,"// File is std::nullopt if it wasn't found.; // (We have some false negatives if PP recovered e.g. <foo> -> ""foo"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,recover,recovered,84,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['recover'],['recovered']
Availability,"// FileID redundant, but clearer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,redundant,redundant,10,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['redundant'],['redundant']
Availability,// Fill in the bits that will be shifted out with 1s. An example where this; // helps is trailing one masks with 32 or more ones. This will generate; // ADDI -1 and an SRLI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:102,mask,masks,102,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['mask'],['masks']
Availability,// Fill in the error message and copy the path (in reverse order).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['error'],['error']
Availability,// Fill in the mask bit derived from the shift constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['mask'],['mask']
Availability,"// Fill in this variable's value and error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:37,error,error,37,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['error']
Availability,"// Fill the ""else"" block, created in the previous iteration; //; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.store, label %else; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,1,['mask'],['mask']
Availability,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:187,mask,mask,187,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,1,['mask'],['mask']
Availability,"// Fill the profile histogram; // no entries/bin is available so can fill only using bin content as weight; // implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:52,avail,available,52,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avail'],['available']
Availability,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['mask'],['mask']
Availability,// Fill the rest of the mask with undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['mask'],['mask']
Availability,// Fill the reuses mask with the identity submasks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Fill the sorted X and Y error values based on the sorted indices",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:27,error,error,27,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,3,['error'],['error']
Availability,"// Fills instance of BTFParser with information stored in .BTF and; // .BTF.ext sections of the `Obj`. If this instance was already; // filled, old data is discarded.; //; // If information cannot be parsed:; // - return an error describing the failure;; // - state of the BTFParser might be incomplete but is not invalid,; // queries might be run against it, but some (or all) information; // might be unavailable;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h:224,error,error,224,interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"// Filter cold blocks off from LoopBlockSet when profile data is available.; // Collect the sum of frequencies of incoming edges to the loop header from; // outside. If we treat the loop as a super block, this is the frequency of; // the loop. Then for each block in the loop, we calculate the ratio between; // its frequency and the frequency of the loop block. When it is too small,; // don't add it to the loop chain. If there are outer loops, then this block; // will be merged into the first outer loop chain for which this block is not; // cold anymore. This needs precise profile data and we only do this when; // profile data is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:65,avail,available,65,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,2,['avail'],['available']
Availability,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:100,avail,available,100,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,// FilterProcessor scans the well-known encoding bits of the instructions and; // builds up a list of candidate filters. It chooses the best filter and; // recursively descends down the decoding tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:177,down,down,177,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,2,['down'],['down']
Availability,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Final initialized value will be in here; // If PRTStrictNull feature is enabled (the default) then initialize; // all the result registers to 0, otherwise just the error indication; // register (VGPRn+1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:167,error,error,167,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['error'],['error']
Availability,// Finalize IT mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,1,['mask'],['mask']
Availability,"// Finalize a query.; // Returns -1 in case of an error, 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:50,error,error,50,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['error'],['error']
Availability,// Finalize the output stream if there are no errors and if the client wants; // us to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:46,error,errors,46,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['errors']
Availability,"// Finalize the template instantiation observer chain.; // FIXME: This (and init.) should be done in the Sema class, but because; // Sema does not have a reliable ""Finalize"" function (it has a; // destructor, but it is not guaranteed to be called (""-disable-free"")).; // So, do the initialization above and do the finalization here:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:154,reliab,reliable,154,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['reliab'],['reliable']
Availability,// Finally check if the two mask values are adjacent and aligned with; // a pair.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Finally clear out all the data structures from the node down through the; // components. postorder_ref_scc_iterator will skip empty RefSCCs, so no need; // to adjust LazyCallGraph data structures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,down,down,59,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['down'],['down']
Availability,"// Finally, if this isn't known, return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:43,error,error,43,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,1,['error'],['error']
Availability,"// Finally, initialize the set of available and recoverable sanitizers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:34,avail,available,34,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['avail', 'recover']","['available', 'recoverable']"
Availability,"// Finally, other ops will operate on the full value, so truncate down to; // the original size, and expand out again after doing the; // operation. Bitcasts will be inserted for FP values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:66,down,down,66,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['down'],['down']
Availability,"// Finally, see if we can rewrite our exit conditions into a loop invariant; // form. If we have a read-only loop, and we can tell that we must exit down; // a path which does not need any of the values computed within the loop, we; // can rewrite the loop to exit on the first iteration. Note that this; // doesn't either a) tell us the loop exits on the first iteration (unless; // *all* exits are predicateable) or b) tell us *which* exit might be taken.; // This transformation looks a lot like a restricted form of dead loop; // elimination, but restricted to read-only loops and without neccesssarily; // needing to kill the loop entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:149,down,down,149,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['down'],['down']
Availability,"// Finally, we have to handle the case where the program point is the first in; // a block but not in the function. We use the findBackwardJoinPoint helper; // function with information about the function and helper analyses, if; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:233,avail,available,233,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['avail'],['available']
Availability,// Find IdxVal modulo ElemsPerChunk. Since ElemsPerChunk is a power of 2; // this can be done with a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,mask,mask,101,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Find a compressible register which will be available from the first; // instruction we care about to the last.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['avail'],['available']
Availability,"// Find a register matching \p RC from \p LiveUnits which is unused and; // available throughout the function. On failure, returns AMDGPU::NoRegister.; // TODO: Rewrite the loop here to iterate over MCRegUnits instead of; // MCRegisters. This should reduce the number of iterations and avoid redundant; // checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,3,"['avail', 'failure', 'redundant']","['available', 'failure', 'redundant']"
Availability,"// Find a representative copy of the vtable initializer.; // We can have multiple available_externally, linkonce_odr and weak_odr; // vtable initializers. We can also have multiple external vtable; // initializers in the case of comdats, which we cannot check here.; // The linker should give an error in this case.; //; // Also, handle the case of same-named local Vtables with the same path; // and therefore the same GUID. This can happen if there isn't enough; // distinguishing path when compiling the source file. In that case we; // conservatively return false early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:296,error,error,296,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['error'],['error']
Availability,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:120,resilien,resilient,120,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,1,['resilien'],['resilient']
Availability,// Find all the coro.ends in the function and restore the error value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:58,error,error,58,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['error'],['error']
Availability,// Find an available scavenging slot with size and alignment matching; // the requirements of the class RC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:11,avail,available,11,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['avail'],['available']
Availability,"// Find an available scratch register to hold the callee. On 64-bit, we can; // just use R11, but we scan for uses anyway to ensure we don't generate; // incorrect code. On 32-bit, we use one of EAX, ECX, or EDX that isn't; // already a register use operand to the call to hold the callee. If none; // are available, use EDI instead. EDI is chosen because EBX is the PIC base; // register and ESI is the base pointer to realigned stack frames with VLAs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,avail,available,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avail'],['available']
Availability,// Find an available version of this cast.; // Try to simplify cast first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:11,avail,available,11,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,// Find first function in FuncClonesToCallMap without an assigned; // clone of this callsite Node. We should always have one; // available at this point due to the earlier cloning when the; // FuncClonesToCallMap size was smaller than the clone number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:129,avail,available,129,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['avail'],['available']
Availability,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,redundant,redundant,297,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redundant'],['redundant']
Availability,"// Find minimum position iterating until convergence specified by the; // absolute and relative tolerance or the maximum number of iteration; // is reached.; // repeat search (Bracketing + Brent) until max number of search is reached (default is 10); // maxITer refers to the iterations inside the Brent algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BrentMinimizer1D.cxx:96,toler,tolerance,96,math/mathcore/src/BrentMinimizer1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BrentMinimizer1D.cxx,1,['toler'],['tolerance']
Availability,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:18,error,errors,18,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,1,['error'],['errors']
Availability,// Find stream with that name and read its data.; // FIXME: Consider validating (or even loading) all this in; // InjectedSourceStream so that no error can happen here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp:146,error,error,146,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp,1,['error'],['error']
Availability,// Find the (first) error node in the trimmed graph. We just need to consult; // the node map which maps from nodes in the original graph to nodes; // in the new graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,// Find the Instrumented BB and set the value. Return false on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:63,error,error,63,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['error'],['error']
Availability,"// Find the column number for this cell. Be careful to skip; // columns which extend down to this row from prior rows",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:85,down,down,85,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['down'],['down']
Availability,// Find the first non-undef value in the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:49,mask,mask,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['mask'],['mask']
Availability,"// Find the highest available register if called before RA to ensure the; // lowest registers are available for allocation. The LaneVGPR, in that; // case, will be shifted back to the lowest range after VGPR allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,2,['avail'],['available']
Availability,// Find the insertion point for the repairing code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:36,repair,repairing,36,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// Find the longest available match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:20,avail,available,20,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['avail'],['available']
Availability,// Find the mask from sorting the lanes into order. This is most likely to; // become a identity or concat mask. Undef elements are pushed to the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['mask'],['mask']
Availability,// Find the mask on the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,// Find the only mask with at least single undef mask elem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,['mask'],['mask']
Availability,// Find the range of the node stack by walking down until we pass the; // root DFS number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,2,['down'],['down']
Availability,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['down'],['down']
Availability,// Find the statement which should be enclosed in the if @available check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:58,avail,available,58,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['available']
Availability,// Find the width of the shrunk mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Finds all roots without relaying on the set of roots already stored in the; // tree.; // We define roots to be some non-redundant set of the CFG nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:123,redundant,redundant,123,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['redundant'],['redundant']
Availability,// Finds compare instruction that corresponds to supported types of branching.; // Returns the instruction or nullptr on failures or detecting unsupported; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp:121,failure,failures,121,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp,1,['failure'],['failures']
Availability,// Finish initializing the object and return success or an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:59,error,error,59,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['error'],['error']
Availability,// First assume that the first input is the mask operand and skip past it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,// First check if a CSDB needs to be inserted due to earlier registers; // that were masked and that are used by the next instruction.; // Also emit the barrier on any potential control flow changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:85,mask,masked,85,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['mask'],['masked']
Availability,"// First check if we're extending the result of a load which has a dest type; // smaller than 32 bits, then this zext is redundant. GPR32 is the smallest; // GPR register on AArch64 and all loads which are smaller automatically; // zero-extend the upper bits. E.g.; // %v(s8) = G_LOAD %p, :: (load 1); // %v2(s32) = G_ZEXT %v(s8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:121,redundant,redundant,121,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['redundant'],['redundant']
Availability,"// First convert to the same size integer, then convert to mask using; // setcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// First create an identity shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// First fix the masks for all the inputs that are staying in their; // original halves. This will then dictate the targets of the cross-half; // shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,masks,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// First handle regmasks. They clobber any entries in the mask which; // means that we need a def for those registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['mask'],['mask']
Availability,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:93,avail,available,93,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avail'],['available']
Availability,// First load the argument into the next available FPR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:41,avail,available,41,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,"// First pattern, reversed: left shift, then mask off trailing bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// First remove registers from AlreadyMaskedRegisters if their value is; // updated by this instruction - it makes them contain a new value that is; // not guaranteed to already have been masked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:188,mask,masked,188,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['mask'],['masked']
Availability,"// First scan down the BB from Load, looking for a store of the RCIdentityRoot; // of Load's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,down,down,14,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['down'],['down']
Availability,"// First set the errno value, the old state is still available at 'checkBind'; // or 'checkLocation' for errno value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:53,avail,available,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,1,['avail'],['available']
Availability,"// First symbol or new symbol, increment next available index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp:46,avail,available,46,interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp,1,['avail'],['available']
Availability,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:248,mask,mask,248,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,"['MASK', 'mask']","['MASK', 'mask']"
Availability,"// First try to load configuration from the default files, return on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:69,error,error,69,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"// First we need to confirm that this function clone is available; // for use by this callsite node clone.; //; // While FuncCloneToCurNodeCloneMap is built only for this Node and; // its callsite clones, one of those callsite clones X could have; // been assigned to the same function clone called by Edge's caller; // - if Edge's caller calls another callsite within Node's original; // function, and that callsite has another caller reaching clone X.; // We need to clone Node again in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:56,avail,available,56,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['avail'],['available']
Availability,"// First we need to recover the collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:20,recover,recover,20,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['recover'],['recover']
Availability,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:157,mask,mask,157,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// First, construct the forward decl. Don't look into Ty to compute the; // forward decl options, since it might not be available in all TUs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:120,avail,available,120,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['avail'],['available']
Availability,"// First, peek at the available data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:22,avail,available,22,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['avail'],['available']
Availability,"// First, place the repairing code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:20,repair,repairing,20,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// First, reduce the source down to 128-bit, applying BinOp to lo/hi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,down,down,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// First, the alive carry bits are determined from the alive output bits:; // Let demand ripple to the right but only up to any set bit in Bound.; // AOut = -1----; // Bound = ----1-; // ACarry&~AOut = --111-",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:14,alive,alive,14,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,"// Fit chi^2 using X and Y errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:27,error,errors,27,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],['errors']
Availability,"// Fit quadratic polynomial to weighted data; // NOTE: Maximum likelihood fit to weighted data does in general; // NOT result in correct error estimates, unless individual; // event weights represent Poisson statistics themselves.; // In general, parameter error reflect precision of SumOfWeights; // events rather than NumEvents events. See comparisons below",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:137,error,error,137,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],['error']
Availability,"// Fix numerical errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx:17,error,errors,17,graf3d/eve/src/TEveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx,3,['error'],['errors']
Availability,"// Fix the entry number for the given scalar. If it is the first entry, set; // Pair.first to 0, otherwise to 1 (currently select at max 2 nodes).; // These indices are used when calculating final shuffle mask as the vector; // offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:205,mask,mask,205,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Fix up the shuffle mask to account for the fact that the result of; // scalar_to_vector is not in lane zero. This just takes all values in; // the ranges specified by the min/max indices and adds the number of; // elements required to ensure each element comes from the respective; // position in the valid lane.; // On little endian, that's just the corresponding element in the other; // half of the vector. On big endian, it is in the same half but right; // justified rather than left justified in that half.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Fix up the shuffle mask to reflect where the desired element actually is.; // The minimum and maximum indices that correspond to element zero for both; // the LHS and RHS are computed and will control which shuffle mask entries; // are to be changed. For example, if the RHS is permuted, any shuffle mask; // entries in the range [RHSMinIdx,RHSMaxIdx) will be adjusted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['mask'],['mask']
Availability,// Fixup for section index.; // Write down the range's extent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:38,down,down,38,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['down'],['down']
Availability,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:181,mask,mask,181,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Flags for defining the section type. Masks for use with the (signed, 32-bit); // s_flags field of the section header structure, selecting for values in the; // lower 16 bits. Defined in the system header `scnhdr.h`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:40,Mask,Masks,40,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['Mask'],['Masks']
Availability,"// FlagsVal contains the complete mask:; // 3-0: Mask; // 4: Special Reg (cpsr, apsr => 0; spsr => 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Floating parameter without error estimate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:30,error,error,30,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['error'],['error']
Availability,"// Flush any errors created when initializing everything. This could happen; // for invalid command lines, which will probably give non-sensical results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp:13,error,errors,13,interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp,1,['error'],['errors']
Availability,// Flush the standard output to print the error at a; // proper place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp:42,error,error,42,interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/llvm-readobj.cpp,1,['error'],['error']
Availability,"// Focus down to the property:; // T prop = <READ>;; // W.find(""prop"").write##ValueType(prop);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:9,down,down,9,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,1,['down'],['down']
Availability,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,mask,mask,73,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Fold (iszero(A & K1) | iszero(A & K2)) -> (A & (K1 | K2)) != (K1 | K2); // Fold (!iszero(A & K1) & !iszero(A & K2)) -> (A & (K1 | K2)) == (K1 | K2); // if K1 and K2 are a one-bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:182,mask,mask,182,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,// Fold Constant Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:17,Mask,Mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['Mask'],['Mask']
Availability,"// Fold compare eq/ne with 0 from a compare result as the predicate to the; // intrinsic. The typical use is a wave vote function in the library, which; // will be fed from a user code condition compared with 0. Fold in the; // redundant compare.; // llvm.amdgcn.icmp([sz]ext ([if]cmp pred a, b), 0, ne); // -> llvm.amdgcn.[if]cmp(a, b, pred); //; // llvm.amdgcn.icmp([sz]ext ([if]cmp pred a, b), 0, eq); // -> llvm.amdgcn.[if]cmp(a, b, inv pred)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:228,redundant,redundant,228,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['redundant'],['redundant']
Availability,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,redundant,redundant,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,2,['redundant'],['redundant']
Availability,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,redundant,redundant,376,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['redundant'],['redundant']
Availability,// Fold with fabs - adjust the mask appropriately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['mask'],['mask']
Availability,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,redundant,redundant,286,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// Follow operator*() if present (available in python as __deref__), so that; // smart pointers behave as expected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:34,avail,available,34,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['avail'],['available']
Availability,"// Follow operator->() if present (available in python as __follow__), so that; // smart pointers behave as expected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:35,avail,available,35,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['avail'],['available']
Availability,// Follow sibling copies down the dominator tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['down'],['down']
Availability,// Following is also an error. But it is caused by a missing @end; // and diagnostic is issued elsewhere.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"// Following patterns use 3 instructions to materialize the Imm.; // 3-1) Patterns : {zeros}{ones}{31-bit value}{zeros}; // {zeros}{31-bit value}{zeros}; // {zeros}{ones}{31-bit value}; // {ones}{31-bit value}{zeros}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDIC to mask off the; // ones in both sides after rotation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:362,mask,mask,362,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,1,['mask'],['mask']
Availability,"// Following test does NOT adjust InputSize downwards for signed inputs,; // because the most negative value still requires all the mantissa bits; // to distinguish it from one less than that value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:44,down,downwards,44,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['down'],['downwards']
Availability,// For 'is negative?' check that the sign-bit is set and at least 1 masked; // bit is set. Example:; // (i16 X % 4) s< 0 --> (X & 32771) u> 32768,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:68,mask,masked,68,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['masked']
Availability,// For 'is positive?' check that the sign-bit is clear and at least 1 masked; // bit is set. Example:; // (i8 X % 32) s> 0 --> (X & 159) s> 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,mask,masked,70,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['masked']
Availability,"// For 'this' returns, use the R0-preserving mask if applicable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// For 'this' returns, use the X0-preserving mask if applicable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// For +new, infer availability from -init.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:19,avail,availability,19,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,"// For 32/64-bit elements, if we only reference one input (plus any undefs),; // then ensure the blend mask part for that lane just references that input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce a rotate-mask-and-insert if one is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,mask,masks,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,4,"['avail', 'mask']","['available', 'mask-and-insert', 'masks']"
Availability,"// For 64-bit values, not all combinations of rotates and masks are; // available. Produce one if it is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:58,mask,masks,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,3,"['avail', 'mask']","['available', 'masks']"
Availability,"// For AVX2, we sometimes want to combine; // (vector_shuffle <mask> (concat_vectors t1, undef); // (concat_vectors t2, undef)); // Into:; // (vector_shuffle <mask> (concat_vectors t1, t2), undef); // Since the latter can be efficiently lowered with VPERMD/VPERMQ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// For AvailableExternallyLinkage functions, change the linkage to; // LinkOnceODR and put them into comdat. This is because after renaming, there; // is no backup external copy available for the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Avail,AvailableExternallyLinkage,7,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,2,"['Avail', 'avail']","['AvailableExternallyLinkage', 'available']"
Availability,// For AvailableExternallyLinkage functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:7,Avail,AvailableExternallyLinkage,7,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['Avail'],['AvailableExternallyLinkage']
Availability,"// For BPF programs .BTF.ext section contains line numbers information,; // use it if regular DWARF is not available (e.g. for stripped binary).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp:107,avail,available,107,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,1,['avail'],['available']
Availability,"// For FABS, mask is 0x7f...; for FNEG, mask is 0x80...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// For LTO, enable use of lto-enabled sysroot libraries too, if available.; // Note that the directory is keyed to the LLVM revision, as LLVM's; // bitcode format is not stable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:64,avail,available,64,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,1,['avail'],['available']
Availability,"// For Lanai, the outgoing memory arguments area should be on top of the; // alloca area on the stack i.e., the outgoing memory arguments should be; // at a lower address than the alloca area. Move the alloca area down the; // stack by adding back the space reserved for outgoing arguments to SP; // here.; //; // We do not know what the size of the outgoing args is at this point.; // So, we add a pseudo instruction ADJDYNALLOC that will adjust the; // stack pointer. We replace this instruction with on that has the correct,; // known offset in emitPrologue().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:214,down,down,214,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['down'],['down']
Availability,"// For MVE, we have a custom lowering pass that will already have custom; // legalised any gathers that we can lower to MVE intrinsics, and want to; // expand all the rest. The pass runs before the masked intrinsic lowering; // pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h:198,mask,masked,198,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.h,1,['mask'],['masked']
Availability,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:739,avail,available,739,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['avail'],['available']
Availability,"// For ObjC2, the category name is optional (not an error).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:52,error,error,52,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,"// For PHI nodes, the value available in OldPreHeader is just the; // incoming value from OldPreHeader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['avail'],['available']
Availability,"// For PTEST(PG, PG), PTEST is redundant when PG is the result of an; // instruction that sets the flags as PTEST would. This is only valid when; // the condition is any.; // Fallthough to simply remove the PTEST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:31,redundant,redundant,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['redundant'],['redundant']
Availability,"// For PTEST(PG, PTEST_LIKE(PG, ...)), the PTEST is redundant since the; // flags are set based on the same mask 'PG', but PTEST_LIKE must operate; // on 8-bit predicates like the PTEST. Otherwise, for instructions like; // compare that also support 16/32/64-bit predicates, the implicit PTEST; // performed by the compare could consider fewer lanes for these element; // sizes.; //; // For example, consider; //; // ptrue p0.b ; P0=1111-1111-1111-1111; // index z0.s, #0, #1 ; Z0=<0,1,2,3>; // index z1.s, #1, #1 ; Z1=<1,2,3,4>; // cmphi p1.s, p0/z, z1.s, z0.s ; P1=0001-0001-0001-0001; // ; ^ last active; // ptest p0, p1.b ; P1=0001-0001-0001-0001; // ; ^ last active; //; // where the compare generates a canonical all active 32-bit predicate; // (equivalent to 'ptrue p1.s, all'). The implicit PTEST sets the last; // active flag, whereas the PTEST instruction with the same mask doesn't.; // For PTEST_ANY this doesn't apply as the flags in this case would be; // identical regardless of element size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:52,redundant,redundant,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,3,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"// For PTEST(PTRUE_ALL, WHILE), if the element size matches, the PTEST is; // redundant since WHILE performs an implicit PTEST with an all active; // mask. Must be an all active predicate of matching element size.; // For PTEST(PTRUE_ALL, PTEST_LIKE), the PTEST is redundant if the; // PTEST_LIKE instruction uses the same all active mask and the element; // size matches. If the PTEST has a condition of any then it is always; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:78,redundant,redundant,78,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,5,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"// For R600, this is totally unsupported, just custom lower to produce an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:78,error,error,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['error'],['error']
Availability,"// For Release ordering, the failure ordering should be Monotonic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,failure,failure,29,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,['failure'],['failure']
Availability,"// For SEXT, this is now done, otherwise shift the result down for; // zero-extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,down,down,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// For Thumb1, push.w isn't available, so the first push will always push; // r7 and lr onto the stack first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avail'],['available']
Availability,"// For Thumb1-only targets, we need some low registers when we save and; // restore the high registers (which aren't allocatable, but could be; // used by inline assembly) because the push/pop instructions can not; // access high registers. If necessary, we might need to push more low; // registers to ensure that there is at least one free that can be used; // for the saving & restoring, and preferably we should ensure that as; // many as are needed are available so that fewer push/pop instructions; // are required.; // Low registers which are not currently pushed, but could be (r4-r7).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:458,avail,available,458,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avail'],['available']
Availability,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,redundant,redundant,71,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redundant'],['redundant']
Availability,"// For VP operations, we must also widen the mask. Note that the mask type; // may not actually need widening, leading it be split along with the VP; // operation.; // FIXME: This could lead to an infinite split/widen loop. We only handle; // the case where the mask needs widening to an identically-sized type as; // the vector inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:45,mask,mask,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,3,['mask'],['mask']
Availability,"// For WWM vector copies, manipulate the exec mask around the copy; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerWWMCopies.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerWWMCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerWWMCopies.cpp,1,['mask'],['mask']
Availability,"// For XOR and FXOR, we want to check if constant; // bits of Op1 are sign bit masks. For FSUB, we; // have to check if constant bits of Op0 are sign; // bit masks and hence we swap the operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,mask,masks,79,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['masks']
Availability,"// For __rlwnm, __rlwimi and __rldimi, the last parameter mask must; // be a constant that represents a contiguous bit field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:58,mask,mask,58,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['mask'],['mask']
Availability,"// For `.global x; .weak x`, both MC and GNU as set the binding to STB_WEAK.; // We emit a warning for now but may switch to an error in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:128,error,error,128,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,1,['error'],['error']
Availability,"// For `.weak x; .global x`, GNU as sets the binding to STB_WEAK while we; // traditionally set the binding to STB_GLOBAL. This is error-prone, so we; // error on such cases. Note, we also disallow changed binding from .local.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:131,error,error-prone,131,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,2,['error'],"['error', 'error-prone']"
Availability,"// For a VECTOR_SHUFFLE(VEC1, VEC2), if the VEC2 is undef, then the negate; // of this is VECTOR_SHUFFLE(-VEC1, UNDEF). The mask can be anything here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:124,mask,mask,124,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:185,fault,fault,185,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['fault'],['fault']
Availability,"// For a left shift, we can fold if the comparison is not signed. We can; // also fold a signed comparison if the mask value and comparison value; // are not negative. These constraints may not be obvious, but we can; // prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:114,mask,mask,114,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// For a logical right shift, we can fold if the comparison is not signed.; // We can also fold a signed comparison if the shifted mask value and the; // shifted comparison value are not negative. These constraints may not be; // obvious, but we can prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:131,mask,mask,131,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// For a method call, check the 'this' conversion here too. DR1391 doesn't; // require that, but this check should never result in a hard error, and; // overload resolution is permitted to sidestep instantiations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:138,error,error,138,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,redundant,redundant,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redundant'],['redundant']
Availability,"// For access to concrete addresses, return UnknownVal. Checks; // for null dereferences (and similar errors) are done by checkers, not; // the Store.; // FIXME: We can consider lazily symbolicating such memory, but we really; // should defer this when we can reason easily about symbolicating arrays; // of bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:102,error,errors,102,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['error'],['errors']
Availability,"// For all debug values in the destination block, the sunk instruction; // will still be available, so they do not need to be dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avail'],['available']
Availability,"// For an expression like x&255 that merely masks off the high bits,; // use zext(trunc(x)) as the SCEV expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,mask,masks,44,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['mask'],['masks']
Availability,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:108,avail,availability,108,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['avail'],['availability']
Availability,"// For any DoubleWidthResultInstrs we found whilst scanning instructions, they; // need to compute an output size that is smaller than the VCTP mask operates; // on. The VecSize of the DoubleWidthResult is the larger vector size - the; // size it extends into, so any VCTP VecSize <= is valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:144,mask,mask,144,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['mask'],['mask']
Availability,// For argument parsing errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:24,error,errors,24,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['error'],['errors']
Availability,"// For backward compatibility, for rootd we need to understand; // whether we are talking to a OLD client: protocol information is; // available only later on ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:135,avail,available,135,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['avail'],['available']
Availability,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// For better error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// For compatibility with the AIX XL compiler, the float args in the; // parameter save area are initialized even if the argument is available; // in register. The caller is required to initialize both the register; // and memory, however, the callee can choose to expect it in either.; // The memloc is dismissed here because the argument is retrieved from; // the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,avail,available,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,"// For count in blocks of 8 bits we don't have to mask high 4 bits before; // addition since count value sits in range {0,...,8} and 4 bits are enough; // to hold such binary values. After addition high 4 bits still hold count; // of set bits in high 4 bit block, set them to zero and get 8 bit result.; // B8Count = { B4Count + (B4Count >> 4) } & 0x0F0F0F0F",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['mask']
Availability,"// For datasets with weight errors or sumW2, the interface to fill; // RooDataHist and RooDataSet is not the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:28,error,errors,28,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['errors']
Availability,"// For debug-info, in instruction referencing mode, we need to perform some; // post-isel maintenence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:90,mainten,maintenence,90,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['mainten'],['maintenence']
Availability,"// For each already-localized instruction which has multiple users, then we; // scan the block top down from the current position until we hit one of them.; // FIXME: Consider doing inst duplication if live ranges are very long due to; // many users, but this case may be better served by regalloc improvements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:99,down,down,99,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,1,['down'],['down']
Availability,"// For each byte of the fragment that the fixup touches, mask in the bits from; // the fixup value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp,1,['mask'],['mask']
Availability,"// For each byte of the fragment that the fixup touches, mask in the bits from; // the fixup value. The Value has been ""split up"" into the appropriate; // bitfields above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,1,['mask'],['mask']
Availability,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the appropriate; // bitfields above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp,1,['mask'],['mask']
Availability,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,2,['mask'],['mask']
Availability,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,7,['mask'],['mask']
Availability,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,1,['mask'],['mask']
Availability,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa. Possible permutations inserting an element; // from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7; // 0, X, 2, 3, 4, 5, 6, 7; // 0, 1, X, 3, 4, 5, 6, 7; // 0, 1, 2, X, 4, 5, 6, 7; // 0, 1, 2, 3, X, 5, 6, 7; // 0, 1, 2, 3, 4, X, 6, 7; // 0, 1, 2, 3, 4, 5, X, 7; // 0, 1, 2, 3, 4, 5, 6, X; // Inserting from V1 into V2 will be similar, except mask range will be [8,15].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// For each mask element, find out if we're just inserting something; // from V2 into V1 or vice versa.; // Possible permutations inserting an element from V2 into V1:; // X, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // 0, X, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; // ...; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, X; // Inserting from V1 into V2 will be similar, except mask range will be; // [16,31].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:280,mask,mask,280,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,"// For each of these checks we need to be careful if the sign flag is; // being used. It is only safe to use the sign flag in two conditions,; // either the sign bit in the shrunken mask is zero or the final test; // size is equal to the original compare size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:182,mask,mask,182,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// For each predecessors of BB, compute the benefit of duplicating BB,; // if it is larger than the threshold, add it into Candidates.; //; // If we have following control flow.; //; // PB1 PB2 PB3 PB4; // \ | / /\; // \ | / / \; // \ |/ / \; // BB----/ OB; // /\; // / \; // SB1 SB2; //; // And it can be partially duplicated as; //; // PB2+BB; // | PB1 PB3 PB4; // | | / /\; // | | / / \; // | |/ / \; // | BB----/ OB; // |\ /|; // | X |; // |/ \|; // SB2 SB1; //; // The benefit of duplicating into a predecessor is defined as; // Orig_taken_branch - Duplicated_taken_branch; //; // The Orig_taken_branch is computed with the assumption that predecessor; // jumps to BB and the most possible successor is laid out after BB.; //; // The Duplicated_taken_branch is computed with the assumption that BB is; // duplicated into PB, and one successor is layout after it (SB1 for PB1 and; // SB2 for PB2 in our case). If there is no available successor, the combined; // block jumps to all BB's successor, like PB3 in this example.; //; // If a predecessor has multiple successors, so BB can't be duplicated into; // it. But it can beneficially fall through to BB, and duplicate BB into other; // predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:929,avail,available,929,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avail'],['available']
Availability,"// For each section that remains alive, we want to remove the dead references.; // This either might update the content of the section (e.g. remove symbols; // from symbol table that belongs to removed section) or trigger an error if; // a live section critically depends on a section being removed somehow; // (e.g. the removed section is referenced by a relocation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:33,alive,alive,33,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,2,"['alive', 'error']","['alive', 'error']"
Availability,"// For each select group in an inner-most loop,; // a branch is more preferable than a select/conditional-move if:; // i) conversion to branches for all the select groups of the loop satisfies; // loop-level heuristics including reducing the loop's critical path by; // some threshold (see SelectOptimizeImpl::checkLoopHeuristics); and; // ii) the total cost of the select group is cheaper with a branch compared; // to its predicated version. The cost is in terms of latency and the cost; // of a select group is the cost of its most expensive select instruction; // (assuming infinite resources and thus fully leveraging available ILP).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:623,avail,available,623,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['avail'],['available']
Availability,"// For each symbol, we want to check its address and size; // if it's a function and write the information to the perf; // map file, otherwise we just ignore the symbol and any; // related errors. This implementation is adapted from LLVM:; // llvm/src/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp:189,error,errors,189,interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,1,['error'],['errors']
Availability,"// For each unknwon option, call ErrorFn with a formatted error message. The; // message includes a suggested alternative option spelling if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:33,Error,ErrorFn,33,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,3,"['Error', 'avail', 'error']","['ErrorFn', 'available', 'error']"
Availability,"// For early returns, we have more specific errors, consume the Error in; // cursor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp:44,error,errors,44,interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp,2,"['Error', 'error']","['Error', 'errors']"
Availability,// For error messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:7,error,error,7,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['error'],['error']
Availability,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,redundant,redundant,235,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redundant'],['redundant']
Availability,"// For example, i64 = BITCAST v4i16 on alpha. Typically the vector will; // end up being split all the way down to individual components. Convert the; // split pieces into integers and reassemble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:107,down,down,107,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['down'],['down']
Availability,// For fadd reductions we have pairwise operations available. We treat the; // usual legal types as legal and handle the lowering to pairwise instructions; // later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['avail'],['available']
Availability,"// For floating-point precision of 12:; //; // Log10ofMantissa =; // -0.64831180f +; // (0.91751397f +; // (-0.31664806f + 0.47637168e-1f * x) * x) * x;; //; // error 0.00019228036, which is better than 12 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:161,error,error,161,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 12:; //; // Log2ofMantissa =; // -2.51285454f +; // (4.07009056f +; // (-2.12067489f +; // (.645142248f - 0.816157886e-1f * x) * x) * x) * x;; //; // error 0.0000876136000, which is better than 13 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:185,error,error,185,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 12:; //; // LogOfMantissa =; // -1.7417939f +; // (2.8212026f +; // (-1.4699568f +; // (0.44717955f - 0.56570851e-1f * x) * x) * x) * x;; //; // error 0.000061011436, which is 14 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:180,error,error,180,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 12:; //; // TwoToFractionalPartOfX =; // 0.999892986f +; // (0.696457318f +; // (0.224338339f + 0.792043434e-1f * x) * x) * x;; //; // error 0.000107046256, which is 13 to 14 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:170,error,error,170,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 6:; //; // Log10ofMantissa =; // -0.50419619f +; // (0.60948995f - 0.10380950f * x) * x;; //; // error 0.0014886165, which is 6 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:132,error,error,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 6:; //; // Log2ofMantissa = -1.6749035f + (2.0246817f - .34484768f * x) * x;; //; // error 0.0049451742, which is more than 7 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:120,error,error,120,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 6:; //; // LogofMantissa =; // -1.1609546f +; // (1.4034025f - 0.23903021f * x) * x;; //; // error 0.0034276066, which is better than 8 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:128,error,error,128,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// For floating-point precision of 6:; //; // TwoToFractionalPartOfX =; // 0.997535578f +; // (0.735607626f + 0.252464424f * x) * x;; //; // error 0.0144103317, which is 6 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:141,error,error,141,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,// For for ARM mode generate an error if the .n qualifier is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:32,error,error,32,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// For fpxx and when mfhc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmfc1 is available doesn't need to be handled here; // because it never creates a ExtractElementF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mfc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,2,['avail'],['available']
Availability,"// For fpxx and when mthc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mtc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,2,['avail'],['available']
Availability,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,5,['redundant'],['redundant']
Availability,"// For general purpose register loads, harden the registers loaded into.; // For other loads, harden the address loaded from.; // Masking the loaded value is expected to result in less performance; // overhead, as the load can still execute speculatively in comparison to; // when the address loaded from gets masked. However, masking is only; // easy to do efficiently on GPR registers, so for loads into non-GPR; // registers (e.g. floating point loads), mask the address loaded from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:130,Mask,Masking,130,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,4,"['Mask', 'mask']","['Masking', 'mask', 'masked', 'masking']"
Availability,"// For getAsInteger, we require the whole string to be consumed or else we; // consider it a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:93,failure,failure,93,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['failure'],['failure']
Availability,"// For getAsSignedInteger, we require the whole string to be consumed or else; // we consider it a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:99,failure,failure,99,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['failure'],['failure']
Availability,"// For getAsUnsignedInteger, we require the whole string to be consumed or; // else we consider it a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:101,failure,failure,101,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['failure'],['failure']
Availability,"// For i8 remainder, we can't reference ah directly, as we'll end; // up with bogus copies like %r9b = COPY %ah. Reference ax; // instead to prevent ah references in a rex instruction.; //; // The current assumption of the fast register allocator is that isel; // won't generate explicit references to the GR8_NOREX registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:391,robust,robust,391,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['robust'],['robust']
Availability,"// For iOS and watchOS, also error about implicit function declarations,; // as that can impact calling conventions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['error'],['error']
Availability,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,recover,recover,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['recover'],['recover']
Availability,"// For inscrutable reasons, __finite(), the double-precision version of; // __finitef, does not exist when compiling for MacOS. __isfinited is available; // everywhere and is just as good.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:143,avail,available,143,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,1,['avail'],['available']
Availability,"// For integer-valued instructions, set up an initial empty set of alive; // bits and add the instruction to the work list. For other instructions; // add their operands to the work list (for integer values operands, mark; // all bits as live).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:67,alive,alive,67,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,1,['alive'],['alive']
Availability,"// For intrinsics which take an immediate value as part of the instruction,; // range check them here.; // FIXME: VFP Intrinsics should error if VFP not present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:136,error,error,136,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:14,mask,masked,14,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,8,['mask'],"['mask', 'masked']"
Availability,"// For kernel addresses, bits 56-63 need to be set, so we sign extend bit 55; // into bits 56-63 instead of masking them out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp:108,mask,masking,108,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,1,['mask'],['masking']
Availability,"// For little endian, we must swap the input operands and adjust; // the mask elements (reverse and invert them).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,mask,mask,73,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// For looping down the escape sequence collision chain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:15,down,down,15,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['down'],['down']
Availability,// For masked intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:7,mask,masked,7,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,3,['mask'],['masked']
Availability,"// For masked load/store intrinsics, the local_dep may actually be; // a normal load or store instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:7,mask,masked,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['mask'],['masked']
Availability,"// For masked shuffles, we're trying to match the root width for better; // writemask folding, attempt to scale the mask.; // TODO - variable shuffles might need this to be widened again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:7,mask,masked,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// For masks that have been widened to 128-bit elements or more,; // narrow back down to 64-bit elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:7,mask,masks,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['down', 'mask']","['down', 'masks']"
Availability,"// For modern targets, promote certain warnings to errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:51,error,errors,51,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['error'],['errors']
Availability,"// For node (shl (and val, mask), N)), returns true if the node is equivalent to; // UBFIZ.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// For non-AVX512 if the Mask is of 16bit elements in lane then try to split; // since after split we get a more efficient code than vblend by using; // vpunpcklwd and vpunpckhwd instrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Mask,Mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// For non-AVX512 if the Mask is of 16bit elements in lane then try to split; // since after split we get a more efficient code using vpunpcklwd and; // vpunpckhwd instrs than vblend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Mask,Mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// For non-constant cases we don't support non-pow2 shift masks.; // TODO: Is it worth matching urem as well?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,mask,masks,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masks']
Availability,"// For non-constant masks, we can always use the record-form and.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,mask,masks,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['masks']
Availability,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,error,errors,170,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['errors']
Availability,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.; //; // NOTE: Don't warn about comparison expressions resulting from macro; // expansion. Also don't warn about comparisons which are only self; // comparisons within a template instantiation. The warnings should catch; // obvious cases in the definition of the template anyways. The idea is to; // warn when the typed comparison operator will always evaluate to the same; // result.; // Used for indexing into %select in warn_comparison_always",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,error,errors,170,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['errors']
Availability,// For now we assume all probe encoding should be either based on; // leading probe address or function start address.; // The scheme is for downwards compatibility.; // TODO: retire this scheme once compatibility is no longer an issue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:141,down,downwards,141,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['down'],['downwards']
Availability,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:218,down,down,218,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// For now, no need to lock this routines as fRuntimeProperties is; // the only atomic set here and this is done at the end; // and there is no downside if the execution is done twice.; // Note SetRuntimeProperties is set to const as it is technically; // thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:144,down,downside,144,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['down'],['downside']
Availability,"// For now, reserve highest available SGPR pair. After RA,; // shift down to a lower unused pair of SGPRs; // If all registers are used, then findUnusedRegister will return; // AMDGPU::NoRegister.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRALongBranchReg.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRALongBranchReg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRALongBranchReg.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// For one bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Mask,Mask,19,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Mask'],['Mask']
Availability,"// For others:; // Do nothing. Retained out parameters will either point to a +1 reference; // or NULL, but the way you check for failure differs depending on the; // API. Consequently, we don't have a good way to track them yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:130,failure,failure,130,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['failure'],['failure']
Availability,"// For parameters, pick the newer one. This is either an error or (in; // Objective-C) permitted as an extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:57,error,error,57,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['error'],['error']
Availability,"// For parameters, use ParamState which includes constant range info if; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['avail'],['available']
Availability,"// For pattern ""and(any_extend(shl(val, N)), shifted-mask)""; // ShlVal == shl(val, N), which is a left shift on a smaller type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// For pattern ""and(shl(val, N), shifted-mask)"", 'ShlOp0' is set to 'val'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// For pointer size address spaces, go down the same type mangling path as; // non address space types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:39,down,down,39,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['down'],['down']
Availability,// For positive steps (counting up until unsigned overflow):; // N = -Start/Step (as unsigned); // For negative steps (counting down to zero):; // N = Start/-Step; // First compute the unsigned distance from zero in the direction of Step.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,down,down,128,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:24,error,errors,24,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['error'],['errors']
Availability,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,recover,recovery,7,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['recover'],['recovery']
Availability,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:84,down,down,84,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['down'],['down']
Availability,"// For saturating operations, we need to shift up the LHS to get the; // proper saturation width, and then shift down again afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:113,down,down,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['down'],['down']
Availability,"// For scalar, if we have bmi prefer rotate for rorx. Otherwise prefer; // rotate unless we have a zext mask+shr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// For scalar, just use the sign mask (0x80... or the inverse, 0x7f...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// For sibling tail calls, memory operands are available in our caller's stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// For small tables with integer elements, we can pack them into a bitmap; // that fits into a target-legal register. Values are retrieved by; // shift and mask operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:156,mask,mask,156,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['mask'],['mask']
Availability,"// For split transfer intrinsics we have an incredibly useful assurance:; // the source and destination do not reside within the same alloca, and at; // least one of them does not escape. This means that we can replace; // memmove with memcpy, and we don't need to worry about all manner of; // downsides to splitting and transforming the operations.; // If this doesn't map cleanly onto the alloca type, and that type isn't; // a single value type, just emit a memcpy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:295,down,downsides,295,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['down'],['downsides']
Availability,"// For standard syntax attributes, which would normally appertain to the; // declaration here, suggest moving them to the type instead. But only; // do this for our own vendor attributes; moving other vendors'; // attributes might hurt portability.; // There's one special case that we need to deal with here: The; // `MatrixType` attribute may only be used in a typedef declaration. If; // it's being used anywhere else, don't output the warning as; // ProcessDeclAttributes() will output an error anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:493,error,error,493,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,// For stores the order is actually a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// For stores with return values we'd have to collect downward depenencies.; // There are no such stores that we handle at the moment, so omit that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:54,down,downward,54,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['down'],['downward']
Availability,"// For stores, make sure the size of the object is equal to the size of; // the store. If the object is larger, the extra bits would be garbage. If; // the object is smaller we might overwrite another object or fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:211,fault,fault,211,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['fault'],['fault']
Availability,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:51,avail,available,51,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,1,['avail'],['available']
Availability,"// For targets where __sync_* routines are reliably available, we use them; // if necessary.; //; // ARM Linux always supports 64-bit atomics through kernel-assisted atomic; // routines (kernel 3.1 or later). FIXME: Not with compiler-rt?; //; // ARMv6 targets have native instructions in ARM mode. For Thumb mode,; // such targets should provide __sync_* routines, which use the ARM mode; // instructions. (ARMv6 doesn't have dmb, but it has an equivalent; // encoding; see ARMISD::MEMBARRIER_MCR.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:43,reliab,reliably,43,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,"['avail', 'reliab']","['available', 'reliably']"
Availability,"// For the digamma function, that is the derivative of lgamma. We get it via; // mathmore from the GSL, so the pullbacks that use digamma are only available; // with mathmore=ON.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/CladDerivator.h:147,avail,available,147,math/mathcore/inc/Math/CladDerivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/CladDerivator.h,1,['avail'],['available']
Availability,"// For the error message, use the original type server name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,2,['error'],['error']
Availability,"// For the gamma parameters, HistFactory will figure out the ranges; // itself based on the template bin contents and errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/JSONTool.cxx:118,error,errors,118,roofit/histfactory/src/JSONTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/JSONTool.cxx,1,['error'],['errors']
Availability,"// For the general case, we need to mask with 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['mask'],['mask']
Availability,"// For the given explicit prefix-definition of a namespace, travel downwards; // from a node recursively, and for every implicit, inherited default usage of; // that namespace replace it with that explicit prefix use. This is important; // when namespace overriding occurs when merging, so that elements unique to a; // namespace will still stay in that namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:67,down,downwards,67,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,1,['down'],['downwards']
Availability,"// For the last segment, tolerate a missing number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:25,toler,tolerate,25,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['toler'],['tolerate']
Availability,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:22,error,error,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// For the remaining optimizations, we need to be able to make a negative; // number through a combination of mask and undemanded bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,mask,mask,110,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:256,down,downstream,256,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['down'],['downstream']
Availability,"// For the users of the source value being used for compare instruction, if; // the number of signed predicate is greater than unsigned predicate, we; // prefer to use SIGN_EXTEND.; //; // With this optimization, we would be able to reduce some redundant sign or; // zero extension instruction, and eventually more machine CSE opportunities; // can be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:245,redundant,redundant,245,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['redundant'],['redundant']
Availability,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,mask,masked,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// For typedefs, if the typedef declaration appears available look; // to the underlying type to see if it is more restrictive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:52,avail,available,52,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['available']
Availability,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:126,mask,masked,126,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,"// For unsigned extracts, check for a shift right and mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// For v16i8 cases we need to perform UMIN on pairs of byte elements,; // shuffling each upper element down and insert zeros. This means that the; // v16i8 UMIN will leave the upper element as zero, performing zero-extension; // ready for the PHMINPOS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:103,down,down,103,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,// For variadic dbg_values we will now insert an undef.; // FIXME: We can potentially recover these!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:86,recover,recover,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['recover'],['recover']
Availability,"// For vector, create a sign mask (0x80...) or its inverse (for fabs,; // 0x7f...) per element and splat it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// For vectorcall, do a first pass over the arguments, assigning FP and vector; // arguments to XMM registers as available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:113,avail,available,113,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"// For vectors that are exactly getMaxSVEVectorSizeInBits big, we can use; // AArch64SVEPredPattern::all, which can enable the use of unpredicated; // variants of instructions when available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:181,avail,available,181,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// For vectors, we don't have a preference, but we probably want a mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// For writes, handle extended mask bits if the DSP extension is present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,1,['mask'],['mask']
Availability,"// For zero bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,Mask,Mask,20,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Mask'],['Mask']
Availability,// Force compiler error on invalid conversion specifiers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"// Force emission of the __text, __eh_frame, and __gcc_except_tab sections; // if they're present. Otherwise call down to the impl to handle other; // sections that have already been emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp:114,down,down,114,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp,1,['down'],['down']
Availability,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['avail'],['available']
Availability,"// Force very small components to zero to avoid rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:57,error,errors,57,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['error'],['errors']
Availability,"// Form old servers this meant success (failure was signaled with the; // dangerous kPROOF_FATAL)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:40,failure,failure,40,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['failure'],['failure']
Availability,"// Format text given a format string and replacement parameters.; //; // ===General Description===; //; // Formats textual output. `Fmt` is a string consisting of one or more; // replacement sequences with the following grammar:; //; // rep_field ::= ""{"" index ["","" layout] ["":"" format] ""}""; // index ::= <non-negative integer>; // layout ::= [[[char]loc]width]; // format ::= <any string not containing ""{"" or ""}"">; // char ::= <any character except ""{"" or ""}"">; // loc ::= ""-"" | ""="" | ""+""; // width ::= <positive integer>; //; // index - A non-negative integer specifying the index of the item in the; // parameter pack to print. Any other value is invalid.; // layout - A string controlling how the field is laid out within the available; // space.; // format - A type-dependent string used to provide additional options to; // the formatting operation. Refer to the documentation of the; // various individual format providers for per-type options.; // char - The padding character. Defaults to ' ' (space). Only valid if; // `loc` is also specified.; // loc - Where to print the formatted text within the field. Only valid if; // `width` is also specified.; // '-' : The field is left aligned within the available space.; // '=' : The field is centered within the available space.; // '+' : The field is right aligned within the available space (this; // is the default).; // width - The width of the field within which to print the formatted text.; // If this is less than the required length then the `char` and `loc`; // fields are ignored, and the field is printed with no leading or; // trailing padding. If this is greater than the required length,; // then the text is output according to the value of `loc`, and padded; // as appropriate on the left and/or right by `char`.; //; // ===Special Characters===; //; // The characters '{' and '}' are reserved and cannot appear anywhere within a; // replacement sequence. Outside of a replacement sequence, in order to print; // a literal '{' ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h:731,avail,available,731,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,1,['avail'],['available']
Availability,"// Forward decl or instantiation failure, we cannot use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:33,failure,failure,33,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,2,['failure'],['failure']
Availability,// Forward declare because the autogenerated code will reference this.; // Definition is further down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp:97,down,down,97,interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp,1,['down'],['down']
Availability,// Forward declare these because the auto-generated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:106,down,down,106,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,1,['down'],['down']
Availability,// Forward declare these because the autogenerated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64Disassembler.cpp:105,down,down,105,interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64Disassembler.cpp,1,['down'],['down']
Availability,"// Forward the request one step down, if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:32,down,down,32,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['down'],['down']
Availability,// Found a cycle; report error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,// Found a mismatch with the repeated mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// Found a valid a/zext mask! Try various lowering strategies based on the; // input type and available ISA extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,// Found an available register?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:12,avail,available,12,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['avail'],['available']
Availability,// Found non-matching nodes - need to estimate the cost for the matched; // and transform mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,mask,mask,90,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Found that operand is used already.; // 1. Fix the mask for the reused operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,// Four-bit Xtensa machine type mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,"// Fragment already valid, offset is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,1,['avail'],['available']
Availability,// Friend classes are available as the TypeSourceInfo of the FriendDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:22,avail,available,22,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['avail'],['available']
Availability,"// Friend declarations in dependent contexts aren't anonymous in the usual; // sense, but they cannot be found by name lookup in their semantic context; // (or indeed in any context), so we treat them as anonymous.; //; // This doesn't apply to friend tag decls; Sema makes those available to name; // lookup in the surrounding context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:280,avail,available,280,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,1,['avail'],['available']
Availability,// Friend functions are available through the NamedDecl of FriendDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:24,avail,available,24,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['avail'],['available']
Availability,"// Friend template-ids are treated as references unless; // they have template headers, in which case they're ill-formed; // (FIXME: ""template <class T> friend class A<T>::B<int>;"").; // We diagnose this error in ActOnClassTemplateSpecialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:204,error,error,204,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,// Friendly methods that need to access us for the maintenence of; // debug-info attachments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:51,mainten,maintenence,51,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['mainten'],['maintenence']
Availability,"// From experience, it's rather the members of the RooProduct that is; // still correct in these inconsistent cases. That's why we try to; // recover by setting the proxy in the _proxyList to be equal to the; // member proxy. But that might be wrong, so it's important to warn the; // user anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:142,recover,recover,142,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['recover'],['recover']
Availability,// From second mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['mask'],['mask']
Availability,"// From the above 'select' check, we know that the mask has the same number; // of elements as the vector input operands. We also know that each constant; // input element is used in its lane and can not be used more than once by; // the shuffle. Therefore, replace the constant in the shuffle's constant; // vector with the insertelt constant. Replace the constant in the shuffle's; // mask vector with the insertelt index plus the length of the vector; // (because the constant vector operand of a shuffle is always the 2nd; // operand).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// From the error node to the root, ascend the bug path and construct the bug; // report.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,// From the first-implied list we have to finish building the final protocol; // list. If a protocol in the first-implied list was already implied via some; // inheritance path through some other protocols then it would be redundant to; // add it here and so we skip over it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:223,redundant,redundant,223,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['redundant'],['redundant']
Availability,"// From the preconditions we checked above, we know the mask and thus glue; // for the result node will be taken from True.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// From this point on the errors will be only for the YAML parts, so we; // consume the errors at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:26,error,errors,26,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,2,['error'],['errors']
Availability,// From which operand of the shuffle does this shuffle mask element pick?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:92,avail,available,92,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['avail'],['available']
Availability,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:470,failure,failure,470,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['failure'],['failure']
Availability,"// Function evaluation and error tracing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:27,error,error,27,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['error'],['error']
Availability,"// Function that compares to doubles up to an error limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx:46,error,error,46,gui/fitpanel/test/UnitTesting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx,1,['error'],['error']
Availability,"// Function updateAddressSpace moves the address space down a lattice; // path. Therefore, nothing to do if User is already inferred as flat (the; // bottom element in the lattice).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:55,down,down,55,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['down'],['down']
Availability,"// Functions like isZIPMask return true when a ISD::VECTOR_SHUFFLE's mask; // represents the same logical operation as performed by a ZIP instruction. In; // isolation these functions do not mean the ISD::VECTOR_SHUFFLE is exactly; // equivalent to an AArch64 instruction. There's the extra component of; // ISD::VECTOR_SHUFFLE's value type to consider. Prior to SVE these functions; // only operated on 64/128bit vector types that have a direct mapping to a; // target register and so an exact mapping is implied.; // However, when using SVE for fixed length vectors, most legal vector types; // are actually sub-vectors of a larger SVE register. When mapping; // ISD::VECTOR_SHUFFLE to an SVE instruction care must be taken to consider; // how the mask's indices translate. Specifically, when the mapping requires; // an exact meaning for a specific vector index (e.g. Index X is the last; // vector element in the register) then such mappings are often only safe when; // the exact SVE register size is know. The main exception to this is when; // indices are logically relative to the first element of either; // ISD::VECTOR_SHUFFLE operand because these relative indices don't change; // when converting from fixed-length to scalable vector types (i.e. the start; // of a fixed length vector is always the start of a scalable vector).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:69,mask,mask,69,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Functions marked with the swifttailcc and tailcc calling conventions; // require special handling when outlining musttail functions. The; // calling convention must be passed down to the outlined function as; // well. Further, there is special handling for musttail calls as well,; // requiring a return call directly after. For now, the outliner does not; // support this, so we do not handle matching this case either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:178,down,down,178,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['down'],['down']
Availability,// Functions to print errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp:22,error,errors,22,interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,1,['error'],['errors']
Availability,// Functions to print fatal errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp:28,error,errors,28,interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Error.cpp,1,['error'],['errors']
Availability,"// Functions with local linkage should already have been handled, except if; // they are fully alive (e.g., called indirectly) and except for the fragile; // (variadic) ones. In these cases, we may still be able to improve their; // statically known call sites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:95,alive,alive,95,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"// Functions; // for (auto const& fcnDeclPtr : scan.fSelectedFunctions){; // int retCode = FwdDeclFromFcnDecl(*fcnDeclPtr, interp, buffer);; // newFwdDeclString += Decl2FwdDecl(*fcnDeclPtr,interp);; // if (-1 == retCode){; // ROOT::TMetaUtils::Error(""GenerateFwdDeclString"",; // ""Error generating fwd decl for function %s\n"",; // fcnDeclPtr->getNameAsString().c_str());; // return emptyString;; // }; // if (retCode == 0 && fwdDecls.insert(buffer).second); // fwdDeclString+=""\""""+buffer+""\""\n"";; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:244,Error,Error,244,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,2,['Error'],['Error']
Availability,// Further compression optimization: For invalid compositions resulting; // in a sequence with 0 entries we can just pick any other. Choose; // Mask 0xffffffff with Rotation 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:144,Mask,Mask,144,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['Mask'],['Mask']
Availability,"// Furthermore, shuffles require a constant mask, whereas extractelts; // accept variable indices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// GCC does an implicit conversion to the pointer or integer ValType. This; // can fail in some cases (1i -> int**), check for this error case now.; // Initialize the argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:132,error,error,132,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// GCC does not enforce these rules for GNU atomics, but we do to help catch; // trivial type errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,error,errors,94,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['errors']
Availability,// GEP down to the array type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:7,down,down,7,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['down'],['down']
Availability,// GEP/bitcast of unrelocated pointer is legal by itself but this def; // shouldn't appear in any AvailableSet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:98,Avail,AvailableSet,98,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableSet']
Availability,"// GL buffer read operation gives bottom-up order of pixels, but XImage; // require top-down. So, change RGB lines first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TX11GL.cxx:88,down,down,88,graf3d/gl/src/TX11GL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TX11GL.cxx,1,['down'],['down']
Availability,"// GLAPI void GLAPIENTRY gluEndSurface (GLUnurbs* nurb);; // GLAPI void GLAPIENTRY gluEndTrim (GLUnurbs* nurb);; // GLAPI const GLubyte * GLAPIENTRY gluErrorString (GLenum error);; // GLAPI void GLAPIENTRY gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);; // GLAPI const GLubyte * GLAPIENTRY gluGetString (GLenum name);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/GL_glu.h:172,error,error,172,graf3d/eve7/glu/GL_glu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/GL_glu.h,1,['error'],['error']
Availability,"// GNU addr2line assumes the address is hexadecimal and allows a redundant; // ""0x"" or ""0X"" prefix; do the same for compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp:65,redundant,redundant,65,interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,1,['redundant'],['redundant']
Availability,"// Gather / Scatter for vector 2 is not profitable on KNL / SKX; // Vector-4 of gather/scatter instruction does not exist on KNL. We can extend; // it to 8 elements, but zeroing upper bits of the mask vector will add more; // instructions. Right now we give the scalar cost of vector-4 for KNL. TODO:; // Check, maybe the gather/scatter instruction is better in the VariableMask; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:196,mask,mask,196,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Gather all imported weighted datasets to infer the weight variable name; // and whether we need weight errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:106,error,errors,106,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['errors']
Availability,// Gather instructions have a mask output not in the ISD node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Gather the actual live-in masks for all MBBs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:29,mask,masks,29,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['mask'],['masks']
Availability,"// Gauss integral sometimes returns an error of 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx:39,error,error,39,math/mathmore/test/StatFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx,1,['error'],['error']
Availability,"// Gaussian errors are the 'sigma' in the constraint term; // Get the name of the 'sigma' for the gaussian; // (I don't know of a way of doing RooGaussian::GetSigma() ); // For alpha's, the sigma points to a global RooConstVar; // with the name ""1""; // For gamma_stat_*, the sigma is named *_sigma",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:12,error,errors,12,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['error'],['errors']
Availability,// General case. Parse all available expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,avail,available,27,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avail'],['available']
Availability,"// General vmerge node with mask, true, false, passthru, and vl operands.; // Tail agnostic vselect can be implemented by setting passthru to undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Generally behaves like Nullable, except when used in a block parameter; // that was imported into a swift async method. There, swift will assume; // that the parameter can get null even if no error occurred. _Nullable; // parameters are assumed to only get null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h:195,error,error,195,interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,2,['error'],['error']
Availability,"// Generate BMixing data with above set of event errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:49,error,errors,49,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['errors']
Availability,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:83,avail,available,83,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['avail'],['available']
Availability,"// Generate a BFI/BFXIL from 'or (and X, MaskImm), OrImm' iff the value being; // inserted only sets known zero bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:41,Mask,MaskImm,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Mask'],['MaskImm']
Availability,"// Generate a BFXIL from 'or (and X, Mask0Imm), (and Y, Mask1Imm)' iff; // Mask0Imm and ~Mask1Imm are equivalent and one of the MaskImms is a shifted; // mask (e.g., 0x000ffff0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:128,Mask,MaskImms,128,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,"['Mask', 'mask']","['MaskImms', 'mask']"
Availability,// Generate a byte wise shuffle mask for the BSWAP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// Generate a mask operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,"// Generate a per-byte mask() operator for the symbol, which looks like:; // .global .u8 addr[] = {0xFF(foo), 0xFF00(foo), 0xFF0000(foo), ...};; // See https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#initializers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['mask'],['mask']
Availability,"// Generate a vector-predicated load if it is custom/legal on the target. To; // avoid possible recursion, only do this if the widened mask type is legal.; // FIXME: Not all targets may support EVL in VP_LOAD. These will have been; // removed from the IR by the ExpandVectorPredication pass but we're; // reintroducing them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:135,mask,mask,135,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,"// Generate a vector-predicated store if it is custom/legal on the target.; // To avoid possible recursion, only do this if the widened mask type is; // legal.; // FIXME: Not all targets may support EVL in VP_STORE. These will have been; // removed from the IR by the ExpandVectorPredication pass but we're; // reintroducing them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:136,mask,mask,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,// Generate an error node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,8,['error'],['error']
Availability,// Generate an error node. Check for a null node in case; // we cache out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,1,['error'],['error']
Availability,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,1,['error'],['error']
Availability,"// Generate code for return value conversion and error handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:49,error,error,49,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['error'],['error']
Availability,// Generate constants for final shuffle and build a mask for them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Generate error if there is a problem with the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['error']
Availability,// Generate hi masked load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:15,mask,masked,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['masked']
Availability,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,3,['mask'],"['mask', 'masks']"
Availability,// Generate only one error node to use for all bug reports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:21,error,error,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,1,['error'],['error']
Availability,// Generate scaled UNPCKL shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Generate state for non-failed case.; // Return value is the passed stream pointer.; // According to the documentations, the stream is closed first; // but any close error is ignored. The state changes to (or remains) opened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:168,error,error,168,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,// Generate the error reports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['error'],['error']
Availability,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,2,['error'],['error']
Availability,// Generic fallthrough match failure case for operands that don't have; // specialized diagnostic types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:29,failure,failure,29,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['failure'],['failure']
Availability,// Gep is available if all operands of GepOp are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,['avail'],['available']
Availability,// Gep is not available if it has operands other than GEPs that are; // defined in blocks not dominating HoistPt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avail'],['available']
Availability,// Get a VPERM-like permute mask and see whether the bytes covered; // by the extracted element are a contiguous sequence from one; // source operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Get a register mask for the lowered call.; // FIXME: The 32-bit calls have non-standard calling conventions. Use a; // proper register mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Get a stack slot 8 bytes wide, aligned on an 8-byte boundary.; // Note that if have STFIWX available, we could use a 4-byte stack; // slot for i32, but this being fast-isel we'll just go with the; // easiest code gen possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avail'],['available']
Availability,"// Get a uniform base for the Gather/Scatter intrinsic.; // The first argument of the Gather/Scatter intrinsic is a vector of pointers.; // We try to represent it as a base pointer + vector of indices.; // Usually, the vector of pointers comes from a 'getelementptr' instruction.; // The first operand of the GEP may be a single pointer or a vector of pointers; // Example:; // %gep.ptr = getelementptr i32, <8 x i32*> %vptr, <8 x i32> %ind; // or; // %gep.ptr = getelementptr i32, i32* %ptr, <8 x i32> %ind; // %res = call <8 x i32> @llvm.masked.gather.v8i32(<8 x i32*> %gep.ptr, ..; //; // When the first GEP operand is a single pointer - it is the uniform base we; // are looking for. If first operand of the GEP is a splat vector - we; // extract the splat value and use it as a uniform base.; // In all other cases the function returns 'false'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:540,mask,masked,540,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['masked']
Availability,// Get all alive instructions that depend on the current instruction.; // Takes Instruction* instead of index because the instruction is already; // shuffled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:11,alive,alive,11,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,1,['alive'],['alive']
Availability,// Get all the available registers in the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:15,avail,available,15,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,// Get an anonymous type for index type.; // FIXME: This type should be passed down from the front end; // as different languages may have different sizes for indexes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:79,down,down,79,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['down'],['down']
Availability,// Get constant shift/rotate amount and possibly mask (if its shift+and; // variant).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,mask,mask,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Get data value and error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:22,error,error,22,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,1,['error'],['error']
Availability,// Get errors for all the parameters before bailing out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:7,error,errors,7,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['errors']
Availability,// Get mask/evl value handles for the current configuration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h:7,mask,mask,7,interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,1,['mask'],['mask']
Availability,"// Get next batch if available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:21,avail,available,21,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,2,['avail'],['available']
Availability,// Get other's error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h:15,error,error,15,interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h,2,['error'],['error']
Availability,"// Get protocol first; // Failure typically indicate special actions like cleanup; // which do not need additional work; // The calling program will then decide what to do",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:26,Failure,Failure,26,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Failure'],['Failure']
Availability,// Get saved GPR/FPR/VPR masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:25,mask,masks,25,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,1,['mask'],['masks']
Availability,// Get target/faux shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Get the Thread Pointer, which is %fs:__tls_array (32-bit) or; // %gs:0x58 (64-bit). On MinGW, __tls_array is not available, so directly; // use its literal value of 0x2C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:116,avail,available,116,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Get the address of the one scalar element that is specified by the mask; // using the appropriate offset from the base pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:70,mask,mask,70,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Get the attribute value as a section offset. No need to produce an; // error here if the encoding isn't correct because we validate this in; // the .debug_info verifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:74,error,error,74,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['error']
Availability,// Get the blocks the Reg should be alive through,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:36,alive,alive,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['alive'],['alive']
Availability,"// Get the closest edge (point should be on this edge within tolerance)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:61,toler,tolerance,61,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,1,['toler'],['tolerance']
Availability,"// Get the constraint type and the; // rel error threshold from the (last); // EstimateSummary looped over (but all; // should be the same); // Get the type of StatError constraint from the channel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:43,error,error,43,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,// Get the costs of the shuffles + binops before and after with the new; // shuffle masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:84,mask,masks,84,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['masks']
Availability,"// Get the degree of precision we want from 32-bit floating point division; // operations.; //; // 0 - Use ptx div.approx; // 1 - Use ptx.div.full (approximate, but less so than div.approx); // 2 - Use IEEE-compliant div instructions, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:238,avail,available,238,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,1,['avail'],['available']
Availability,// Get the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:11,error,error,11,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['error'],['error']
Availability,"// Get the error of the Box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx:11,error,error,11,math/mathcore/src/SparseData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx,1,['error'],['error']
Availability,// Get the four mask elementd from the 2 inputs. Perfect shuffles encode undef; // elements with value 8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PerfectShuffle.h:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PerfectShuffle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PerfectShuffle.h,1,['mask'],['mask']
Availability,// Get the function call frame set-up and tear-down instruction opcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['down'],['down']
Availability,"// Get the header block, which contains the redundant range check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:44,redundant,redundant,44,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,1,['redundant'],['redundant']
Availability,"// Get the histogram Error type (E1, .., E4)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TH1Editor.h:21,Error,Error,21,gui/ged/inc/TH1Editor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TH1Editor.h,1,['Error'],['Error']
Availability,// Get the known-zero mask for the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Get the known-zero masks for each operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,mask,masks,22,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['masks']
Availability,"// Get the list of available dirs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgrLite.cxx:19,avail,available,19,proof/proof/src/TProofMgrLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgrLite.cxx,1,['avail'],['available']
Availability,"// Get the locality (disable warnings or errors in connection attempts)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:41,error,errors,41,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,2,['error'],['errors']
Availability,"// Get the location of the error. If a block literal has been passed; // (BlockExpr) then we can point straight to the offending argument,; // else we just point to the variable reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// Get the mask index that M points at in the corresponding operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,// Get the mask of active threads in the warp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:11,mask,mask,11,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['mask'],['mask']
Availability,// Get the name of the callee (if it is available); // from the tracked SVal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:40,avail,available,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,1,['avail'],['available']
Availability,// Get the source line text for LineInfo:; // - use LineInfo::LineSource if available;; // - use LineCache if LineInfo::Source otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp:76,avail,available,76,interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp,1,['avail'],['available']
Availability,"// Get the target from the triple. If a triple is not specified, then select; // the default triple for the host. If the triple doesn't correspond to any; // registered target, then exit with an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:195,error,error,195,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['error'],['error']
Availability,// Get the vector or mask register type for this packing and element type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,1,['mask'],['mask']
Availability,// Get the version from the SDKSettings.json if it's available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:53,avail,available,53,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['avail'],['available']
Availability,"// GetN() returns the number of allocated cells if any.; // GetN() > 0 shows how many cells; // can be available via GetP() method.; // GetN() == 0 then GetP() must return 0 as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TPoints3DABC.h:103,avail,available,103,graf3d/g3d/inc/TPoints3DABC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TPoints3DABC.h,1,['avail'],['available']
Availability,// Gets bits for specified mask from specified src packed instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['mask'],['mask']
Availability,"// Gets the two common ""VL"" operands: an all-ones mask and the vector length.; // VecVT is a vector type, either fixed-length or scalable, and ContainerVT is; // the vector type that the fixed-length vector is contained in. Otherwise if; // VecVT is scalable, then ContainerVT should be the same as VecVT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Getting the basket should fail here and an error should have been triggered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx:46,error,error,46,tree/tree/test/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx,1,['error'],['error']
Availability,"// Give BB, return the auxiliary information if it's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h:53,avail,available,53,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,1,['avail'],['available']
Availability,// Give a nice error for 'ptr*'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['error'],['error']
Availability,// Give an error on multiple outputs to same physreg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['error'],['error']
Availability,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,recover,recover,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['recover'],['recover']
Availability,// Give non-deduced 'auto' types external linkage. We should only see them; // here in error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:87,error,error,87,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// Give reasonable starting point for pre-fit errors by setting it to the; // absolute sigma Mostly useful for pre-fit plotting.; // Note: in commit 2129c4d920 ""[HF] Reduce verbosity of HistFactory.""; // from 2020, there was a check added to do this only for Gaussian; // constrained parameters and for Poisson constrained parameters if they; // are stat errors without any justification. In the ROOT 6.30; // development cycle, this check got removed again to cause less surprise; // to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx:46,error,errors,46,roofit/histfactory/src/HistFactoryImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx,2,['error'],['errors']
Availability,// Give the target a chance to adjust the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,1,['mask'],['mask']
Availability,"// Give up on i/o failure.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:18,failure,failure,18,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,"['error', 'failure']","['error', 'failure']"
Availability,"// Give up unless it is converted to a pointer where there is a single very; // valuable mapping we can do reliably.; // FIXME: It would be nice to propagate this in more ways, but the type; // conversions make it hard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:107,reliab,reliably,107,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['reliab'],['reliably']
Availability,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,recover,recover,21,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,"// Given (and (lshr y, c2), mask) in which mask has c2 leading zeros and; // c3 trailing zeros. We can use an SRLI by c2 + c3 followed by a SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,2,['mask'],['mask']
Availability,"// Given (and (shl x, c2), mask) in which mask is a shifted mask with; // 32 - ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2 - ShAmt followed by SHXADD_UW with ShAmt for x amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,3,['mask'],['mask']
Availability,"// Given (and (shl y, c2), mask) in which mask has no leading zeros and; // c3 trailing zeros. We can use an SRLI by c3 - c2 followed by a SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,2,['mask'],['mask']
Availability,"// Given (lshr (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c3 - c1 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,2,['mask'],['mask']
Availability,"// Given (shl (and y, mask), c2) in which mask has 32 leading zeros and; // c3 trailing zeros. If c1 + c3 == ShAmt, we can emit SRLIW + SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,2,['mask'],['mask']
Availability,"// Given a ISD::EXTRACT_VECTOR_ELT, which is a glorified bit sequence extract,; // recursively analyse all of it's users. and try to model themselves as; // bit sequence extractions. If all of them agree on the new, narrower element; // type, and all of them can be modelled as ISD::EXTRACT_VECTOR_ELT's of that; // new element type, do so now.; // This is mainly useful to recover from legalization that scalarized; // the vector as wide elements, but tries to rebuild it with narrower elements.; //; // Some more nodes could be modelled if that helps cover interesting patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:374,recover,recover,374,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['recover'],['recover']
Availability,"// Given a OR operation, check if we have the following pattern; // ubfm c, b, imm, imm2 (or something that does the same jobs, see; // isBitfieldExtractOp); // d = e & mask2 ; where mask is a binary sequence of 1..10..0 and; // countTrailingZeros(mask2) == imm2 - imm + 1; // f = d | c; // if yes, replace the OR instruction with:; // f = BFM Opd0, Opd1, LSB, MSB ; where LSB = imm, and MSB = imm2; // OR is commutative, check all combinations of operand order and values of; // BiggerPattern, i.e.; // Opd0, Opd1, BiggerPattern=false; // Opd1, Opd0, BiggerPattern=false; // Opd0, Opd1, BiggerPattern=true; // Opd1, Opd0, BiggerPattern=true; // Several of these combinations may match, so check with BiggerPattern=false; // first since that will produce better results by matching more instructions; // and/or inserting fewer extra instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:183,mask,mask,183,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Given a call 'E' to one of the builtins __builtin_os_log_format() or; // __builtin_os_log_format_buffer_size(), compute the layout of the buffer that; // the call will write into and store it in 'layout'. Returns 'false' if there; // was some error encountered while computing the layout, and 'true' otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OSLog.h:246,error,error,246,interpreter/llvm-project/clang/include/clang/AST/OSLog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OSLog.h,1,['error'],['error']
Availability,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,recover,recover,173,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['recover'],['recover']
Availability,"// Given a floating point store from an extracted vector, with an integer; // VGETLANE that already exists, store the existing VGETLANEu directly. This can; // help reduce fp register pressure, doesn't require the fp extract and allows; // use of more integer post-inc stores not available with vstr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:280,avail,available,280,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:187,failure,failure,187,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,1,['failure'],['failure']
Availability,"// Given a shuffle mask like <3, 0, 1, 2, 7, 4, 5, 6> for v8i8, we can; // reinterpret it as a v2i32 and rotate it right by 8 instead. We can lower this; // as a vror.vi if we have Zvkb, or otherwise as a vsll, vsrl and vor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Given a value and a basic block we are trying to see if it is available in,; // see if the value has a leader available in that block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:65,avail,available,65,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,['avail'],['available']
Availability,"// Given an iterator (Iter) that points at an instruction with a ""Then""; // predicate, tries to create the largest block of continuous predicated; // instructions possible, and returns the VPT Block Mask of that block.; //; // This will try to perform some minor optimization in order to maximize the; // size of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp:199,Mask,Mask,199,interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEVPTBlockPass.cpp,1,['Mask'],['Mask']
Availability,"// Given something like this:; //; // %x = ...Something...; // %one = G_CONSTANT i64 1; // %zero = G_CONSTANT i64 0; // %and = G_AND %x, %one; // %cmp = G_ICMP intpred(ne), %and, %zero; // %cmp_trunc = G_TRUNC %cmp; // G_BRCOND %cmp_trunc, %bb.3; //; // We want to try and fold the AND into the G_BRCOND and produce either a; // TBNZ (when we have intpred(ne)) or a TBZ (when we have intpred(eq)).; //; // In this case, we'd get; //; // TBNZ %x %bb.3; //; // Check if the AND has a constant on its RHS which we can use as a mask.; // If it's a power of 2, then it's the same as checking a specific bit.; // (e.g, ANDing with 8 == ANDing with 000...100 == testing if bit 3 is set)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:524,mask,mask,524,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['mask'],['mask']
Availability,"// Given that caller already checked isRVVType() before calling this function,; // if we don't have at least zve32x supported, then we need to emit error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:148,error,error,148,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:57,recover,recover,57,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,2,['recover'],['recover']
Availability,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:877,failure,failure,877,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,6,['failure'],['failure']
Availability,"// Given:; // (icmp eq/ne (and X, C0), (shift X, C1)); // or; // (icmp eq/ne X, (rotate X, CPow2)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Do we prefer the shift to be shift-right, shift-left, or rotate.; // Note: Its only valid to convert the rotate version to the shift version iff; // the shift-amt (`C1`) is a power of 2 (including 0).; // If ShiftOpc (current Opcode) is returned, do nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:114,mask,mask,114,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],['mask']
Availability,"// Global data and static data in namespaces is found lazily, thus if the first; // use is setting of the global data by the user, it will not be reflected on; // the C++ side, b/c there is no descriptor yet. This triggers the creation for; // for such data as necessary. The many checks to narrow down the specific case; // are needed to prevent unnecessary lookups and recursion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:298,down,down,298,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['down'],['down']
Availability,"// Global logical predicate that acts on all lanes; // of the input and output mask concurrently. For; // example, it is implied by the `M` token in the; // Vector Function ABI mangled name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h:79,mask,mask,79,interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,1,['mask'],['mask']
Availability,"// Global symbols with internal or private linkage are not visible to; // the linker, and thus would cause an error when the linker tried to; // preserve the symbol due to the `/include:` directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:110,error,error,110,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['error'],['error']
Availability,// Go ahead and trim whitespace rather than either erroring or; // accepting it weirdly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:51,error,erroring,51,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,1,['error'],['erroring']
Availability,// Go down one level if there is a unvisited successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:6,down,down,6,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,1,['down'],['down']
Availability,"// Go down to the package directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:6,down,down,6,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['down'],['down']
Availability,// Go through all leaf subregisters and find the ones that compose with; // Idx. These make out all possible valid bits in the lane mask we want to; // transform. Looking only at the leafs ensure that only a single bit in; // the mask is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:132,mask,mask,132,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,2,['mask'],['mask']
Availability,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,redundant,redundant,178,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redundant'],['redundant']
Availability,// Go through the mask of half-words to find an element that's being moved; // from one vector to the other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// Go through trace blocks in top-down order, stopping after the center block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,down,down,34,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['down'],['down']
Availability,"// Go to next in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:25,failure,failure,25,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['failure'],['failure']
Availability,"// Goes though all SU. RPTracker captures what had to be alive for the SUs; // to execute, and what is still alive at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:57,alive,alive,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['alive'],['alive']
Availability,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the template parameter into the local scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,avail,available,31,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['avail'],['available']
Availability,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the type parameter into the local scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,avail,available,31,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['avail'],['available']
Availability,// Grab the name from the StringMap. Since the Section is going to keep a; // copy of this StringRef we need to make sure the underlying string stays; // alive as long as we need it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:154,alive,alive,154,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,1,['alive'],['alive']
Availability,// Grab the source from the first valid mask. All subsequent elements need; // to use this same source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// HMOTF_ConstExtended; // Addendum to above, indicates a const extended op; // Can be used as a mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:97,mask,mask,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,1,['mask'],['mask']
Availability,"// HOP(X,X) can refer to the elt from the lower/upper half of a lane.; // TODO: Handle MaskSize != NumElts?; // TODO: Handle HOP(X,Y) vs HOP(Y,X) equivalence cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,Mask,MaskSize,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['MaskSize']
Availability,"// Hack: We must update *ResultType if available in order to set the; // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.; // Worst case: 'const int (&arref)[] = {1, 2, 3};'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:39,avail,available,39,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avail'],['available']
Availability,// Handle AVX masked loads which don't support passthru other than 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,mask,masked,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,// Handle AVX512 MASK/MASXZ write mask comments.; // MASK: zmmX {%kY}; // MASKZ: zmmX {%kY} {z},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:17,MASK,MASK,17,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,4,"['MASK', 'mask']","['MASK', 'MASKZ', 'mask']"
Availability,"// Handle AVX512 mask widening.; // Fold not(insert_subvector(undef,sub)) -> insert_subvector(undef,not(sub))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Handle Apple-specific options available here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:33,avail,available,33,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avail'],['available']
Availability,"// Handle CPUDispatch/CPUSpecific versions.; // Only 1 CPUDispatch function is allowed, this will make it go through; // the redeclaration errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,error,errors,139,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// Handle abort() in msvcrt -- It has exit code as 3. abort(), aka; // unreachable, should be recognized as a crash. However, some binaries use; // exit code 3 on non-crash failure paths, so only do this if we expect a; // crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp:173,failure,failure,173,interpreter/llvm-project/llvm/utils/not/not.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp,1,['failure'],['failure']
Availability,// Handle allocation failure if 'ReturnStmtOnAllocFailure' was provided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:21,failure,failure,21,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['failure'],['failure']
Availability,// Handle any required masking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,mask,masking,23,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['masking']
Availability,"// Handle any_extend (not (truncate X)) pattern, where Mask only sets; // bits in the non-extended part.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:55,Mask,Mask,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Mask'],['Mask']
Availability,// Handle autoupgrade for masked PALIGNR and VALIGND/Q intrinsics.; // PALIGNR handles large immediates by shifting while VALIGN masks the immediate; // so we need to handle both cases. VALIGN also doesn't have 128-bit lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:26,mask,masked,26,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['mask'],"['masked', 'masks']"
Availability,"// Handle cases where there are other cache slices; // Iterator over available slice positions and fill each; // Determine number of bins for each slice position observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:69,avail,available,69,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['avail'],['available']
Availability,// Handle deferred errors encountered during merging. If the number of errors; // is equal to the number of inputs the merge failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:19,error,errors,19,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,2,['error'],['errors']
Availability,"// Handle division by zero. gas just emits a warning and keeps going,; // we try to be stricter.; // FIXME: Currently the caller of this function has no way to understand; // we're bailing out because of 'division by zero'. Therefore, it will; // emit a 'expected relocatable expression' error. It would be nice to; // change this code to emit a better diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:288,error,error,288,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['error'],['error']
Availability,// Handle downcasts and upcasts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:10,down,downcasts,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['down'],['downcasts']
Availability,"// Handle error condition, if the parameter is us, we cannot find the parent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:10,error,error,10,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['error'],['error']
Availability,"// Handle errors here by skipping up to the next semicolon or '}', and; // eat the semicolon if that's what stopped us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,error,errors,10,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['error'],['errors']
Availability,// Handle errors in the reader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:10,error,errors,10,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['error'],['errors']
Availability,// Handle errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:10,error,errors,10,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,2,['error'],['errors']
Availability,// Handle explicit options being passed to the compiler here: if we've; // explicitly turned off vsx and turned on any of:; // - power8-vector; // - direct-move; // - float128; // - power9-vector; // - paired-vector-memops; // - mma; // - power10-vector; // then go ahead and error since the customer has expressed an incompatible; // set of options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:276,error,error,276,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['error'],['error']
Availability,// Handle failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,failure,failure,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['failure'],['failure']
Availability,"// Handle fatal llvm errors by throwing an exception.; // Yes, throwing exceptions in error handlers is bad.; // Doing nothing is pretty terrible, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:21,error,errors,21,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,4,['error'],"['error', 'errors']"
Availability,// Handle fixed and variable vector arguments differently.; // Fixed vector arguments go into registers as long as registers are; // available. Variable vector arguments always go into memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:133,avail,available,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,// Handle incomplete and sizeless types with a specific error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,error,error,56,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Handle integer-to-integer widening and narrowing.; // FIXME: Use DW_OP_convert when it's available everywhere.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:92,avail,available,92,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['avail'],['available']
Availability,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:162,avail,available,162,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,2,['avail'],['available']
Availability,// Handle pipeline errors here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:19,error,errors,19,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['error'],['errors']
Availability,// Handle the basic 8-bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,1,['mask'],['mask']
Availability,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:28,error,error,28,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,3,['error'],['error']
Availability,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,error,errors,103,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,2,['error'],['errors']
Availability,// Handle the degenerate case of no successors by replacing the indirectbr; // with unreachable as there is no successor available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:121,avail,available,121,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,1,['avail'],['available']
Availability,// Handle the error to store the code for next call to this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['error'],['error']
Availability,// Handle the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp:14,error,error,14,interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,1,['error'],['error']
Availability,// Handle the error. Allow it to be checked through HasError and; // GetErrorMessage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/RemarkParser.cpp,1,['error'],['error']
Availability,"// Handle the mask for IT and VPT instructions. In ARMOperand and; // MCOperand, this is stored in a format independent of the; // condition code: the lowest set bit indicates the end of the; // encoding, and above that, a 1 bit indicates 'else', and an 0; // indicates 'then'. E.g.; // IT -> 1000; // ITx -> x100 (ITT -> 0100, ITE -> 1100); // ITxy -> xy10 (e.g. ITET -> 1010); // ITxyz -> xyz1 (e.g. ITEET -> 1101); // Note: See the ARM::PredBlockMask enum in; // /lib/Target/ARM/Utils/ARMBaseInfo.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,// Handle the masking aspect of the intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,mask,masking,14,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['masking']
Availability,"// Handle thread local data for mach-o which requires us to output an; // additional structure of data and mangle the original symbol so that we; // can reference it later.; //; // TODO: This should become an ""emit thread local global"" method on TLOF.; // All of this macho specific stuff should be sunk down into TLOFMachO and; // stuff like ""TLSExtraDataSection"" should no longer be part of the parent; // TLOF class. This will also make it more obvious that stuff like; // MCStreamer::EmitTBSSSymbol is macho specific and only called from macho; // specific code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:304,down,down,304,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['down'],['down']
Availability,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,redundant,redundant,237,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redundant'],['redundant']
Availability,// Handled masked instructions since we need to skip over the mask input; // and the preserved input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,mask,masked,11,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// Hardware divide in ARM mode is part of base arch, starting from ARMv8.; // If only Thumb hwdiv is present, it must also be in base arch (ARMv7-R/M).; // It is not possible to produce DisallowDIV: if hwdiv is present in the base; // arch, supplying -hwdiv downgrades the effective arch, via ClearImpliedBits.; // AllowDIVExt is only emitted if hwdiv isn't available in the base arch;; // otherwise, the default value (AllowDIVIfExists) applies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:258,down,downgrades,258,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,2,"['avail', 'down']","['available', 'downgrades']"
Availability,"// Has any parameter asymmetric errors?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx:32,error,errors,32,roofit/roofitcore/src/RooFitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx,1,['error'],['errors']
Availability,"// Hash a subtree with compress_subtree_wide(), and then condense the resulting; // list of chaining values down to a single parent node. Don't compress that; // last parent node, however. Instead, return its message bytes (the; // concatenated chaining values of its children). This is necessary when the; // first call to update() supplies a complete subtree, because the topmost; // parent node of that subtree could end up being the root. It's also necessary; // for extended output in the general case.; //; // As with compress_subtree_wide(), this function is not used on inputs of 1; // chunk or less. That's a different codepath.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:108,down,down,108,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['down'],['down']
Availability,// Hash mask for the extended hash bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:8,mask,mask,8,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['mask'],['mask']
Availability,// Hash mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:8,mask,mask,8,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['mask'],['mask']
Availability,"// Have error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:8,error,error,8,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,1,['error'],['error']
Availability,// Have we parsed all available arguments?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['avail'],['available']
Availability,"// Have we've found a parsing error, or found no (expected) {z} mark; // - report an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,['error'],['error']
Availability,"// Having side effects keeps R alive, but do remove conditional assume; // instructions as their conditions may be flattened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,alive,alive,31,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['alive'],['alive']
Availability,"// Header search paths should be handled by each of the subclasses.; // Historically, they have not been, and instead have been handled inside of; // the CC1-layer frontend. As the logic is hoisted out, this generic function; // will slowly stop being called.; //; // While it is being called, replicate a bit of a hack to propagate the; // '-stdlib=' flag down to CC1 so that it can in turn customize the C++; // header search paths with it. Once all systems are overriding this; // function, the CC1 flag and this line can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:357,down,down,357,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['down'],['down']
Availability,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,error,error,56,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,// Helper for parsing the StringTable. Returns an 'Error' if parsing failed; // and an XCOFFStringTable if parsing succeeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:51,Error,Error,51,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['Error'],['Error']
Availability,"// Helper for splitting operands of an operation to legal target size and; // apply a function on each part.; // Useful for operations that are available on SSE2 in 128-bit, on AVX2 in; // 256-bit and on AVX512BW in 512-bit. The argument VT is the type used for; // deciding if/how to split Ops. Ops elements do *not* have to be of type VT.; // The argument Builder is a function that will be applied on each split part:; // SDValue Builder(SelectionDAG&G, SDLoc, ArrayRef<SDValue>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:144,avail,available,144,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['error'],['error']
Availability,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['error'],['error']
Availability,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['error'],['error']
Availability,// Helper function that logs the error(s) and exits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:33,error,error,33,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,1,['error'],['error']
Availability,// Helper functions of redundant load elimination,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:23,redundant,redundant,23,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['redundant'],['redundant']
Availability,"// Helper lambda for reporting failures: via assertion, printing, and return; // value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:31,failure,failures,31,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['failure'],['failures']
Availability,// Helper to attempt to widen/narrow blend masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:43,mask,masks,43,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['masks']
Availability,// Helper to extract and decode the next ULEB128 value as unsigned int.; // Returns zero and sets ULEBSizeErr if the ULEB128 value exceeds the unsigned; // int limit.; // Also returns zero if ULEBSizeErr is already in an error state.; // ULEBSizeErr is an out variable if an error occurs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp:221,error,error,221,interpreter/llvm-project/llvm/lib/Object/ELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp,2,['error'],['error']
Availability,// Helper to look for a normal load that can be narrowed into a vzload with the; // specified VT and memory VT. Returns SDValue() on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,failure,failure,133,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['failure'],['failure']
Availability,"// Helper to look for repeated mask in each split sublane, and that those; // sublanes can then be permuted into place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,redundant,redundantly,146,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['redundant'],['redundantly']
Availability,// Helper to split and extend a v16i1 mask to v16i8 or v16i16.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Here both Predicate and Mask are true or unknown.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Mask,Mask,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['Mask'],['Mask']
Availability,"// Here comes stuff that we only do once the entire chain is loaded. Do *not*; // remove modules from this point. Various fields are updated during reading; // the AST block and removing the modules would result in dangling pointers.; // They are generally only incidentally dereferenced, ie. a binary search; // runs over `GlobalSLocEntryMap`, which could cause an invalid module to; // be dereferenced but it wouldn't actually be used.; // Load the AST blocks of all of the modules that we loaded. We can still; // hit errors parsing the ASTs at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:521,error,errors,521,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['errors']
Availability,"// Here the copy keeps the refcounted value alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:44,alive,alive,44,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['alive'],['alive']
Availability,"// Here we ""fuse"" clusters together if the number of clusters is too big with respect to; // the number of slots, otherwise we can incur in an overhead which is big enough; // to make parallelisation detrimental to performance.; // For example, this is the case when, following a merging of many small files, a file; // contains a tree with many entries and with clusters of just a few entries each.; // Another problematic case is a high number of slots (e.g. 256) coupled with a high number; // of files (e.g. 1000 files): the large amount of files might result in a large amount; // of tasks, but the elevated concurrency level makes the little synchronization required by; // task initialization very expensive. In this case it's better to simply process fewer, larger tasks.; // Cluster-merging can help reduce the number of tasks down to a minumum of one task per file.; //; // The criterion according to which we fuse clusters together is to have around; // TTreeProcessorMT::GetTasksPerWorkerHint() clusters per slot.; // Concretely, for each file we will cap the number of tasks to ceil(GetTasksPerWorkerHint() * nWorkers / nFiles).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:836,down,down,836,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['down'],['down']
Availability,"// Here we can test the type of VT and return false when the type does not; // match, but since it is done prior to that call in the current context; // we turned that into an assert to avoid redundant code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:192,redundant,redundant,192,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['redundant'],['redundant']
Availability,"// Here we do not use a RAII but we empty the proxy to then fill it.; // This is done because we are returning a pointer and we need to keep; // alive the memory it points to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:145,alive,alive,145,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,1,['alive'],['alive']
Availability,"// Here, Pred2MBB is the BB to which we need to append a compare inst.; // We cannot move the compare instruction if operands are not available; // in Pred2MBB (i.e. defined in MBB by an instruction other than PHI).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:134,avail,available,134,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['avail'],['available']
Availability,"// Here, we make sure that -Wa,-mfpu/cpu/arch/hwdiv will be passed down; // to the assembler correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:67,down,down,67,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['down'],['down']
Availability,"// Here, we need to loosen the tolerance because the estimated error is determined on-the-fly with a fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/testHypoTestInvResult.cxx:31,toler,tolerance,31,roofit/roostats/test/testHypoTestInvResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/testHypoTestInvResult.cxx,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,redundant,redundant,85,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redundant'],['redundant']
Availability,"// Hide this, by moving all other args one down...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx:43,down,down,43,core/rint/src/TRint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx,1,['down'],['down']
Availability,// High byte shifted right to place of low byte: (Src >> ShiftAmt) & Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:69,Mask,Mask,69,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Mask'],['Mask']
Availability,"// Higher tolerance: Expect a pull due to shape syst.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:10,toler,tolerance,10,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,2,['toler'],['tolerance']
Availability,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// Hoist vector bitcasts that don't change the number of lanes out of unary; // shuffles, where they are less likely to get in the way of other combines.; // (shuffle (vNxT1 (bitcast (vNxT0 x))), undef, mask) ->; // (vNxT1 (bitcast (vNxT0 (shuffle x, undef, mask))))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:203,mask,mask,203,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,2,['mask'],['mask']
Availability,// Holds most recent error string.; // *** Not thread safe ***,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp:21,error,error,21,interpreter/llvm-project/llvm/tools/lto/lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp,1,['error'],['error']
Availability,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:54,Error,Error,54,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,5,"['Error', 'down', 'error']","['Error', 'downgraded', 'error']"
Availability,"// Host triple is not really needed for unbundling operation, so do not; // treat missing host triple as error if we do unbundling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:105,error,error,105,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,1,['error'],['error']
Availability,// How many bits are in our mask?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:183,mask,mask,183,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,"// However we loaded the old byte, either by plain load or atomicrmw, shift; // the bit into the low position and mask it to 0 or 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:114,mask,mask,114,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,4,['mask'],['mask']
Availability,"// However, if the right shift isn't masked out then it might be because; // it's not needed. See if we can spot that too. If the high bits aren't; // demanded, we only need bits 23:16 to be zero. Otherwise, we need all; // upper bits to be zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,mask,masked,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"// However, we can still recover without crashing.; // If either location is invalid, set it to std::nullopt to avoid; // letting users of RegionStack think that region has a valid start/end; // location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:25,recover,recover,25,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['recover'],['recover']
Availability,"// I am going down 1 level",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:14,down,down,14,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['down'],['down']
Availability,"// I was unable to retrieve a list of replicas: propagate the original; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:75,error,error,75,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['error'],['error']
Availability,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:22,down,down,22,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['down'],['down']
Availability,// IMPORTANT NOTE: we mask off the upper bit of this value because we only; // reserve two bits for the integer in the PointerIntPair. See the comments; // in `InfoPtr` for more details.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:22,mask,mask,22,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['mask'],['mask']
Availability,"// INCLUDED BELOW #include ""qpsrt2.c""; /* The smallest interval has the largest error. Before bisecting; decrease the sum of the errors over the larger intervals; (error_over_large_intervals) and perform extrapolation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:80,error,error,80,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,2,['error'],"['error', 'errors']"
Availability,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:41,Error,ErrorPC,41,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,2,['Error'],['ErrorPC']
Availability,"// IT masks are encoded as a sequence of replacement low-order bits; // for the condition code. So if the low bit of the starting; // condition code is 1, then we have to flip all the bits above the; // terminating bit (which is the lowest 1 bit).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:6,mask,masks,6,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,2,['mask'],['masks']
Availability,"// Ideally canonicalizeShuffleMaskWithCommute should have caught this, but; // we can get here due to other paths (e.g repeated mask matching) that we; // don't want to do another round of lowerVECTOR_SHUFFLE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,mask,mask,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Ideally, operations with undef should be folded before we get here, but we; // can't guarantee it. Bail out because optimizing undefs is a waste of time.; // Without this, we have to forward undef state to new register operands to; // avoid machine verifier errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:261,error,errors,261,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['error'],['errors']
Availability,"// Ideally, we want to calculate tagged stack base pointer, and rewrite all; // alloca addresses using that. Unfortunately, offsets are not known yet; // (unless we use ASan-style mega-alloca). Instead we keep the base tag in a; // temp, shift-OR it into each alloca address and xor with the retag mask.; // This generates one extra instruction per alloca use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:298,mask,mask,298,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['mask'],['mask']
Availability,"// Identifier(Tok).empty() is redundant 1st time, but simplifies code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:30,redundant,redundant,30,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['redundant'],['redundant']
Availability,"// Identify pairs of available registers which hold identical values.; // In such cases, only one of them needs to be calculated, the other one; // will be defined as a copy of the first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['avail'],['available']
Availability,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:116,down,downwards,116,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['down'],['downwards']
Availability,// Identity mask is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Identity masks for the operands of the (padded) shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,mask,masks,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masks']
Availability,"// If $rs is the same as $rd, we need to use AT.; // If it is not available we exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:66,avail,available,66,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,['avail'],['available']
Availability,"// If 'Def' is previously source of another copy, then this earlier copy's; // source is no longer available. e.g.; // %xmm9 = copy %xmm2; // ...; // %xmm2 = copy %xmm0; // ...; // %xmm2 = copy %xmm9",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:99,avail,available,99,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,// If (Val & Mask) != 0 then the value must be larger than the lowest set; // bit of Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Mask,Mask,13,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,['Mask'],['Mask']
Availability,// If (Val & Mask) == C then all the masked bits are known and we can; // compute a value range based on that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Mask,Mask,13,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,"['Mask', 'mask']","['Mask', 'masked']"
Availability,"// If -Werror is enabled, map warnings to errors unless explicitly disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:42,error,errors,42,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['error'],['errors']
Availability,"// If -Wfatal-errors is enabled, map errors to fatal unless explicitly; // disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:14,error,errors,14,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,['error'],['errors']
Availability,"// If -Wmodule-file-config-mismatch is mapped as an error or worse, allow the; // ASTReader to diagnose it, since it can produce better errors that we can.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:52,error,error,52,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,2,['error'],"['error', 'errors']"
Availability,// If -mfloat-abi=hard or -mhard-float are specified explicitly then check that; // floating point registers are available on the target CPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:113,avail,available,113,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['avail'],['available']
Availability,"// If -pedantic or -pedantic-errors was specified, then we want to map all; // extension diagnostics onto WARNING or ERROR unless the user has futz'd; // around with them explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:29,error,errors,29,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"// If -r was used, this error will be printed later.; // Otherwise, we ignore the error and print what; // would have been printed without using relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:24,error,error,24,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,2,['error'],['error']
Availability,"// If 2nd operand is undefined, we should only look for element 7 in the; // Mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:77,Mask,Mask,77,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// If A and B occur in reverse order in RHS, then canonicalize by commuting; // RHS operands and shuffle mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:105,mask,mask,105,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,toler,tolerable,36,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['toler'],['tolerable']
Availability,"// If BMsOrErr fails, consume the error and use the error message from; // parseIR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:34,error,error,34,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,2,['error'],['error']
Availability,"// If BPI is not available, set the default probability as 1 / N, where N is; // the number of successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['avail'],['available']
Availability,"// If BaseReg is a vector register and IndexReg is not, swap them unless; // Scale was specified in which case it would be an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:126,error,error,126,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['error']
Availability,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['mask'],['mask']
Availability,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['mask'],['mask']
Availability,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['mask'],"['mask', 'masked-high-bits']"
Availability,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,mask,masked-high-bits,97,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['masked-high-bits']
Availability,"// If C1 masks off the upper bits only (but can't be formed as an; // ANDI), use an unsigned bitfield extract (e.g., th.extu), if; // available.; // Transform (and x, C1); // -> (<bfextract> x, msb, lsb)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:9,mask,masks,9,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,"['avail', 'mask']","['available', 'masks']"
Availability,"// If CPP dialects are different then return with error.; //; // Consider this STL code:; // template<typename _Alloc>; // struct __alloc_traits; // #if __cplusplus >= 201103L; // : std::allocator_traits<_Alloc>; // #endif; // { // ...; // };; // This class template would create ODR errors during merging the two units,; // since in one translation unit the class template has a base class, however; // in the other unit it has none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:50,error,error,50,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,2,['error'],"['error', 'errors']"
Availability,"// If Col is 7 long and I is 2 and BlockNumElts is 2 the mask is: 0, 1, 7,; // 8, 4, 5, 6",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['mask'],['mask']
Availability,"// If CurrentElement is from V1 [0,15], then we the rest of the Mask to be; // from V2 [16,31] and vice versa. Unless the 2nd operand is undefined,; // in which we always assume we're always picking from the 1st operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,Mask,Mask,64,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// If DIVREM is going to get expanded into a libcall,; // but there is no libcall available, then don't combine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,avail,available,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"// If DV has any VReg location operands which haven't been mapped then; // either that node is no longer available or we just haven't visited the; // node yet. In the former case we should emit an undef dbg_value, but we; // can do it later. And for the latter we'll want to wait until all; // dependent nodes have been visited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:105,avail,available,105,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['avail'],['available']
Availability,"// If DestType is a function type (not to be confused with the function; // pointer type), it will be possible to resolve the function address,; // but the type cast should be considered as failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:190,failure,failure,190,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['failure'],['failure']
Availability,"// If E is a no_data_found error, returns success. Otherwise returns E.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:27,error,error,27,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['error'],['error']
Availability,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,redundant,redundant,62,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redundant'],['redundant']
Availability,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,redundant,redundant,62,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redundant'],['redundant']
Availability,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1191,Mask,Mask,1191,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['Mask'],['Mask']
Availability,"// If EmitVAArg fails, emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,2,['error'],['error']
Availability,"// If ErrorOnTagTypeMismatch is set, return the error, otherwise get the; // relevant warning for the input error diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:6,Error,ErrorOnTagTypeMismatch,6,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,3,"['Error', 'error']","['ErrorOnTagTypeMismatch', 'error']"
Availability,"// If Extended(false) was explicitly set, but the pdf MUST be extended, then; // it's time to print an error. This happens when you're fitting a RooAddPdf; // with coefficient that represent yields, and without the additional; // constraint these coefficients are degenerate because the RooAddPdf; // normalizes itself. Nothing correct can come out of this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:103,error,error,103,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['error'],['error']
Availability,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:297,error,errors,297,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['error'],['errors']
Availability,"// If F1 <= F2, then F2 >= F1, otherwise report failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:48,failure,failure,48,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['failure'],['failure']
Availability,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,2,['avail'],['available']
Availability,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:244,down,down,244,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['down'],['down']
Availability,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:77,error,error,77,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,3,['error'],['error']
Availability,"// If GridZ is not programmed in an entry function then the hardware will set; // it to all zeros, so there is no need to mask the GridY value in the low; // order bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:122,mask,mask,122,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,2,['mask'],['mask']
Availability,"// If HasNCSR is asserted (attribute NoCallerSavedRegisters exists),; // use X86_INTR calling convention because it has the same CSR mask; // (same preserved registers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:133,mask,mask,133,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:309,down,down,309,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['down'],['down']
Availability,"// If I is IP, move the insert point down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp:37,down,down,37,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp,1,['down'],['down']
Availability,"// If I is a non-local compare-with-constant instruction, use more-rich; // 'getPredicateOnEdge' method. This would be able to handle value; // inequalities better, for example if the compare is ""X < 4"" and ""X < 3""; // is known true but ""X < 4"" itself is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:259,avail,available,259,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// If ICMP(AND(LHS,MASK),MASK) - reduce using AND splits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,MASK,MASK,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['MASK'],['MASK']
Availability,"// If IfClr is not yet set, and Op0Op1 is an appropriate mask, try the same; // thing again using this mask.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// If IsMasked, insert PrototypeDescriptor:Mask as first input operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:43,Mask,Mask,43,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,1,['Mask'],['Mask']
Availability,"// If LHS's width is changed, shift the mask value accordingly.; // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any; // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.; // If newRHS == newLHS, we want to remap any references from newRHS to; // newLHS so that we can properly identify splats that may occur due to; // obfuscation across the two vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// If LongBranchReservedReg is null then we didn't find a long branch; // and never reserved a register to begin with so there is nothing to; // shift down. Then if UnusedLowSGPR is null, there isn't available lower; // register to use so just keep the original one we set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:151,down,down,151,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// If LoopSimplify form is not available, stay out of trouble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,2,['avail'],['available']
Availability,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['avail'],['available']
Availability,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:161,Mask,MaskMI,161,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,4,"['Mask', 'mask']","['MaskMI', 'mask']"
Availability,"// If MI is in cycle and all its operands are alive across the whole cycle or; // if no operand sinking make register pressure set exceed limit, it is; // profitable to sink MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,alive,alive,46,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['alive'],['alive']
Availability,"// If MO does not have a register bank, we should have just been; // able to set one unless we have to break the value down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:119,down,down,119,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['down'],['down']
Availability,"// If MS bitfield layout is required, figure out what type is being; // laid out and align the field to the width of that type.; // Resolve all typedefs down to their base type and round up the field; // alignment if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:153,down,down,153,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['down'],['down']
Availability,"// If MaskVT has smaller or bigger elements than ToMaskVT, a vector sign; // extend or truncate is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:6,Mask,MaskVT,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['Mask'],['MaskVT']
Availability,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,redundant,redundant,100,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redundant'],['redundant']
Availability,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,avail,available,204,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal; // on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,avail,available,204,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"// If N0's type does not split or is a sign mask, it does not introduce; // add carry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,mask,mask,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// If Name is already in an error state then just bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:28,error,error,28,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If NewImm or its bitwise NOT is a shifted mask, it is a bitmask immediate; // or all-ones or all-zeros, in which case we can stop searching. Otherwise,; // we halve the element size and continue the search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,redundant,redundant,92,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redundant'],['redundant']
Availability,"// If OP in PTEST(PG, OP(PG, ...)) has a flag-setting variant change the; // opcode so the PTEST becomes redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:105,redundant,redundant,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['redundant'],['redundant']
Availability,"// If ObjectBody has template arguments, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:49,error,error,49,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// If ObjectEntry or Object has an error, no binary exists, therefore no; // reflection sections exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:35,error,error,35,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,1,['error'],['error']
Availability,"// If Op0Op0 is an appropriate mask, try to find it's inverse in either; // Op1Op0, or Op1Op1. Keep track of the Cond, IfSet, and IfClr nodes, while; // looking.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['mask'],['mask']
Availability,"// If OpInst is an instruction that appears earlier in the same BB as; // I, then it is okay to move since OpInst will still be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:128,avail,available,128,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,1,['avail'],['available']
Availability,// If P is an analysis pass and it is available then do not; // generate the analysis again. Stale analysis info should not be; // available at this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:38,avail,available,38,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,2,['avail'],['available']
Availability,"// If P is in the middle of a word, process it manually here, because; // the trailing bits need to be masked off to use findFirstSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:103,mask,masked,103,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['mask'],['masked']
Availability,"// If PHI translation was unable to find an available pointer in this; // predecessor, then we have to assume that the pointer is clobbered in; // that predecessor. We can still do PRE of the load, which would insert; // a computation of the pointer in this predecessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['avail'],['available']
Availability,"// If PredND is FrameSetup, we should not pre-scheduled the node,; // or else, when bottom up scheduling, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP may hold CallResource too long and make other; // calls can't be scheduled. If there's no other available node; // to schedule, the schedular will try to rename the register by; // creating copy to avoid the conflict which will fail because; // CallResource is not a real physical register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:242,avail,available,242,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,"// If PrevDecl was a definition and D is also a definition, diagnose.; // This happens in cases like:; //; // template<typename T, typename U>; // struct Outer {; // template<typename X> struct Inner;; // template<> struct Inner<T> {};; // template<> struct Inner<U> {};; // };; //; // Outer<int, int> outer; // error: the explicit specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:312,error,error,312,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,"// If RHS is going to be replaced (case 3 or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,// If ResTy is v2i64 then the type legalizer will break this node down into; // an equivalent v4i32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:66,down,down,66,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['down'],['down']
Availability,"// If Root use can somehow reach N through a path that doesn't contain; // U then folding N would create a cycle. e.g. In the following; // diagram, Root can reach N through X. If N is folded into Root, then; // X is both a predecessor and a successor of U.; //; // [N*] //; // ^ ^ //; // / \ //; // [U*] [X]? //; // ^ ^ //; // \ / //; // \ / //; // [Root*] //; //; // * indicates nodes to be folded together.; //; // If Root produces glue, then it gets (even more) interesting. Since it; // will be ""glued"" together with its glue use in the scheduler, we need to; // check if it might reach N.; //; // [N*] //; // ^ ^ //; // / \ //; // [U*] [X]? //; // ^ ^ //; // \ \ //; // \ | //; // [Root*] | //; // ^ | //; // f | //; // | / //; // [Y] / //; // ^ / //; // f / //; // | / //; // [GU] //; //; // If GU (glue use) indirectly reaches N (the load), and Root folds N; // (call it Fold), then X is a predecessor of GU and a successor of; // Fold. But since Fold and GU are glued together, this will create; // a cycle in the scheduling graph.; // If the node has glue, walk down the graph to the ""lowest"" node in the; // glueged set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:1072,down,down,1072,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['down'],['down']
Availability,// If SVE is available then i64 vector multiplications can also be made; // legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:13,avail,available,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// If ShallowAutoLoadImpl() has an error, we have an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:35,error,error,35,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['error'],['error']
Availability,"// If ShiftLHS is unsigned bit extraction: ((x >> C) & mask), then do not; // combine it with shift 'N' to let it be lowered to UBFX except:; // ((x >> C) & mask) << C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If SrcMI mask is full, no need to update MBMI and MEMI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// If Start is an immediate and End is a register, the trip count; // will be ""reg - imm"". Hexagon's ""subtract immediate"" instruction; // is actually ""reg + -imm"".; // If the loop IV is going downwards, i.e. if the bump is negative,; // then the iteration count (computed as End-Start) will need to be; // negated. To avoid the negation, just swap Start and End.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:192,down,downwards,192,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['down'],['downwards']
Availability,"// If TClonesArray object does not exist we have no information, so let go; // on. This is a weakish test since the TClonesArray object might exist in; // the next entry ... In other word, we ONLY rely on the information available; // in entry #0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:221,avail,available,221,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['avail'],['available']
Availability,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,redundant,redundant,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['redundant'],['redundant']
Availability,"// If True (default): write all training results (weights) as text files only;; // if False: write also in ROOT format (not available for all methods - will abort if not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:124,avail,available,124,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['avail'],['available']
Availability,"// If UnwindDest is null at this point, either the pad in question can; // be exited by unwind to caller, or it cannot be exited by unwind. In; // either case, reporting such cases as unwinding to caller is correct.; // This can lead to EH tables that ""look strange"" -- if this pad's is in; // a parent funclet which has other children that do unwind to an enclosing; // pad, the try region for this pad will be missing the ""duplicate"" EH; // clause entries that you'd expect to see covering the whole parent. That; // should be benign, since the unwind never actually happens. If it were; // an issue, we could add a subsequent pass that pushes unwind dests down; // from parents that have them to children that appear to unwind to caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:659,down,down,659,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['down'],['down']
Availability,"// If VPU is enabled, always expand non-mask vector loads to VVP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['mask'],['mask']
Availability,"// If VPU is enabled, always expand non-mask vector stores to VVP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['mask'],['mask']
Availability,"// If VT is i64, Width > 64 is insensible since NonZeroBits is uint64_t, and; // Width == 64 indicates a missed dag-combine from ""(and val, AllOnes)"" to; // ""val"".; // If VT is i32, what Width >= 32 means:; // - For ""(and (any_extend(shl val, N)), shifted-mask)"", the`and` Op; // demands at least 'Width' bits (after dag-combiner). This together with; // `any_extend` Op (undefined higher bits) indicates missed combination; // when lowering the 'and' IR instruction to an machine IR instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:256,mask,mask,256,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If VirtReg is live across any register mask operands, compute a list of; // gaps with register masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// If X has no high-bits set above an xor mask:; // add (xor X, LowMaskC), C --> sub (LowMaskC + C), X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['mask'],['mask']
Availability,// If \p AllowPCMWithCompilerErrors is set return 'success' even if errors; // occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:68,error,errors,68,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['errors']
Availability,"// If _MSC_VER is defined, we must have SEH. Use it if it's available. It's way; // better than VEH. Vectored exception handling catches all exceptions happening; // on the thread with installed exception handlers, so it can interfere with; // internal exception handling of other libraries on that thread. SEH works; // exactly as you would expect normal exception handling to work: it only; // catches exceptions if they would bubble out from the stack frame with __try /; // __except.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['avail'],['available']
Availability,"// If `R` and all existing replacements are order-independent, then merge it; // with `Replaces` and returns the merged replacements; otherwise, returns an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:160,error,error,160,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['error'],['error']
Availability,"// If a 'template' keyword was used, a lookup that finds only non-template; // names is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,error,error,91,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"// If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,2,['error'],['error']
Availability,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,redundant,redundant,356,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,2,"['mask', 'redundant']","['masked', 'redundant']"
Availability,"// If a compare and swap is lowered to LL/SC, we can do smarter fence; // insertion, with a stronger one on the success path than on the; // failure path. As a result, fence insertion is directly done by; // expandAtomicCmpXchg in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:141,failure,failure,141,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['failure'],['failure']
Availability,"// If a fatal error has already been emitted, silence all subsequent; // diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['error'],['error']
Availability,"// If a field of the parent record is incomplete, lookup will fail.; // and we would return InvalidFieldName instead of Incomplete.; // But this erroneous results does protects again a hidden assertion failure; // in the RecordLayoutBuilder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:202,failure,failure,202,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['failure'],['failure']
Availability,"// If a function scope is available, set it on the line 0 location. When; // hoisting a call to a predecessor block, using the function scope avoids; // making it look like the callee was reached earlier than it should be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avail'],['available']
Availability,"// If a location isn't available, try to approximate it using the associated; // function definition. We use the definition's right brace to differentiate; // from diagnostics that genuinely relate to the function itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:23,avail,available,23,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['avail'],['available']
Availability,"// If a non-metadata argument is passed in a metadata slot then the; // error will be caught earlier when the incorrect argument doesn't; // match the specification in the intrinsic call table. Thus, no; // argument type check is needed here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:72,error,error,72,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:148,error,error,148,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['error'],['error']
Availability,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,failure,failure,49,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,4,['failure'],['failure']
Availability,"// If a promoted integer type is used, truncate down to the original",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:48,down,down,48,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['down'],['down']
Availability,"// If a timeout has been specified extract the value and try to apply it (it requires; // support for asynchronous open, though; the following is completely transparent if; // such support if not available for the required protocol)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:196,avail,available,196,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['avail'],['available']
Availability,"// If a value is defined by an invoke instruction, it is only available in; // its normal destination and not in its unwind destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:62,avail,available,62,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['avail'],['available']
Availability,"// If accessing a stand-alone ivar in a class method, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,error,error,65,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// If alignment information is not available, fall back to the; // default function param optimized type alignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['avail'],['available']
Availability,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// If all insertions are zero value, try to convert to AND mask.; // TODO: Do this for -1 with OR mask?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"// If all of these were an outright failure, report it in a useless way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:36,failure,failure,36,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,['failure'],['failure']
Availability,// If all oldBP[i] are zeroes then the proportional distribution results; // in all zero probabilities and the error stays big. In this case we; // evenly spread NewReachableSum over the reachable edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:111,error,error,111,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['error'],['error']
Availability,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:112,mask,mask,112,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,redundant,redundant,289,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['redundant'],['redundant']
Availability,// If all the indices come from the same MaskNumElts sized portion of; // the sources we can use extract. Also make sure the extract wouldn't; // extract past the end of the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:41,Mask,MaskNumElts,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Mask'],['MaskNumElts']
Availability,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,redundant,redundant,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,2,['redundant'],['redundant']
Availability,"// If all zero mask bits are set, this was just a weird way to; // generate a zero vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,"// If an ASTContext is not available, a less capable ASTDumper is; // constructed for which color diagnostics are, regrettably, disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:27,avail,available,27,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,1,['avail'],['available']
Availability,"// If an immediate successor isn't available, look for the best viable; // block among those we've identified as not violating the loop's CFG at; // this point. This won't be a fallthrough, but it will increase locality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avail'],['available']
Availability,"// If an unrecoverable error occurred, we need to return true here,; // because the token stream is in a damaged state. We may not; // return a valid identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['error'],['error']
Availability,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,recover,recover,138,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Availability,"// If any bit of the mask operand is poisoned, then the whole thing is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['mask'],['mask']
Availability,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,failure,failure,94,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['failure'],['failure']
Availability,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,error,errors,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,error,errors,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// If any of Add's ops are Adds or Muls with a constant, apply this; // transformation as well.; //; // TODO: There are some cases where this transformation is not; // profitable; for example, Add = (C0 + X) * Y + Z. Maybe the scope of; // this transformation should be narrowed down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:279,down,down,279,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// If any of the debug loc fields is missing, return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp:56,error,error,56,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,1,['error'],['error']
Availability,"// If any of the directives is an align_to_end directive, the whole nested; // group is align_to_end. So don't downgrade from align_to_end to just locked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSection.cpp:111,down,downgrade,111,interpreter/llvm-project/llvm/lib/MC/MCSection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSection.cpp,1,['down'],['downgrade']
Availability,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:149,mask,masked,149,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,"// If any of the operands were immediates with predicates on them, strip; // them down to a signature that doesn't have predicates so that we can; // associate them with the stripped predicate version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp:82,down,down,82,interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,1,['down'],['down']
Availability,"// If any of the stack slot references may be out of range of an immediate; // offset, make sure a register (or a spill slot) is available for the; // register scavenger. Note that if we're indexing off the frame pointer, the; // effective stack size is 4 bytes larger since the FP points to the stack; // slot of the previous FP. Also, if we have variable sized objects in the; // function, stack slot references will often be negative, and some of; // our instructions are positive-offset only, so conservatively consider; // that case to want a spill slot (or register) as well. Similarly, if; // the function adjusts the stack pointer during execution and the; // adjustments aren't already part of our stack size estimate, our offset; // calculations may be off, so be conservative.; // FIXME: We could add logic to be more precise about negative offsets; // and which instructions will need a scratch register for them. Is it; // worth the effort and added fragility?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:129,avail,available,129,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avail'],['available']
Availability,"// If any of the symbols are currently materializing, return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:64,error,error,64,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If any of the symbols are not defined, return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:52,error,error,52,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If any of these registers is available in the MBB, but also a live out of; // the block, then we know outlining is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['avail'],['available']
Availability,"// If any other error occurred, there is no point in trying again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:16,error,error,16,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['error'],['error']
Availability,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:103,avail,available,103,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['avail'],['available']
Availability,// If any symbols were in the error state then bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['error'],['error']
Availability,"// If any top-down local-use or possible-dec has a succ which is earlier in; // the sequence, forget it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:14,down,down,14,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,// If anything goes wrong materializing Sym then report it to the session; // and return the ErrorHandlerAddress;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:93,Error,ErrorHandlerAddress,93,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,1,['Error'],['ErrorHandlerAddress']
Availability,"// If anything went wrong we issue an error or warning and then skip the rest; // of the selector. However, commas are ambiguous so we look for the nesting; // of parentheses here as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,error,error,38,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['error'],['error']
Availability,"// If anything went wrong we issue an error or warning and then skip the rest; // of the set. However, commas are ambiguous so we look for the nesting; // of braces here as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,error,error,38,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['error'],['error']
Availability,"// If arg is a numeric string, throw error as lvalue is required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:37,error,error,37,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['error'],['error']
Availability,// If argument mismatch error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,error,error,24,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,17,['error'],['error']
Availability,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,mask,masked,52,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['masked']
Availability,"// If at least one proxy was there and no error occurred, we assume the proxies to be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:42,error,error,42,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['error'],['error']
Availability,"// If at least one value used by this debug value is no longer available,; // i.e. one of the values was killed before we finished defining all of; // the values used by this variable, discard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:63,avail,available,63,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,// If atomic AND need to be masking all be one bit and testing the one bit; // unset in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,mask,masking,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// If authentication failure, check if other methods could be tried ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:21,failure,failure,21,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['failure'],['failure']
Availability,"// If available, prefer to use vcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:6,avail,available,6,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avail'],['available']
Availability,"// If available, run an external AA providing callback over the results as; // well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:6,avail,available,6,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['avail'],['available']
Availability,// If available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:6,avail,available,6,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['avail'],['available']
Availability,"// If block B is an end block, it should not propagate kills as the; // blocks following coro.end() are reached during initial invocation; // of the coroutine while all the data are still available on the; // stack or in the registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:188,avail,available,188,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avail'],['available']
Availability,"// If blocks are disabled, emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,error,error,35,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,"// If both arguments of a commutative binop are select-shuffles that use the; // same mask with commuted operands, the shuffles are unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,mask,mask,86,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// If both arguments of the binary operation are shuffles that use the same; // mask and shuffle within a single vector, move the shuffle after the binop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// If both arguments of the cmp are shuffles that use the same mask and; // shuffle within a single vector, move the shuffle after the cmp:; // cmp (shuffle V1, M), (shuffle V2, M) --> shuffle (cmp V1, V2), M",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// If both elements are undef, new mask is undef too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:110,avail,available,110,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['avail'],['available']
Availability,// If both inputs are splats of the same value then we can safely merge this; // to a single BUILD_VECTOR with undef elements based on the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,mask,mask,147,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// If both operands are defined.; // Target order is [8,15] if the current mask is between [0,7].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:75,mask,mask,75,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// If both readers fail, build a new error that includes all information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:37,error,error,37,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,1,['error'],['error']
Availability,"// If both vector operands for the shuffle are the same vector, the mask will; // contain only elements from the first one and the second one will be undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['mask'],['mask']
Availability,"// If both vector operands for the shuffle are the same vector, the mask; // will contain only elements from the first one and the second one will be; // undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// If bound_ctrl = 1, row mask = bank mask = 0xf we can omit old value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,2,['mask'],['mask']
Availability,"// If caret diagnostics are enabled and we have location, we want to; // emit the caret. However, we only do this if the location moved; // from the last diagnostic, if the last diagnostic was a note that; // was part of a different warning or error diagnostic, or if the; // diagnostic has ranges. We don't want to emit the same caret; // multiple times if one loc has multiple diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:244,error,error,244,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['error'],['error']
Availability,"// If category for this implementation not found, it is an error which; // has already been reported eralier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:59,error,error,59,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['error'],['error']
Availability,"// If cfi.functions is present and we are in regular LTO mode, LowerTypeTests; // will rename local functions in the merged module as ""<function name>.1"".; // This causes linking errors, since other parts of the module expect the; // original function name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:179,error,errors,179,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['error'],['errors']
Availability,"// If cling cannot find a name it should ask ROOT before it issues an error.; // If ROOT knows the name then it has to create a new variable with that name; // and type in dedicated for that namespace (eg. __ROOT_SpecialObjects).; // For example if the interpreter is looking for h in h-Draw(), this routine; // will create; // namespace __ROOT_SpecialObjects {; // THist* h = (THist*) the_address;; // }; //; // Later if h is called again it again won't be found by the standart lookup; // because it is in our hidden namespace (nobody should do using namespace; // __ROOT_SpecialObjects). It caches the variable declarations and their; // last address. If the newly found decl with the same name (h) has different; // address than the cached one it goes directly at the address and updates it.; //; // returns true when declaration is found and no error should be emitted.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:70,error,error,70,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['error'],['error']
Availability,"// If compares returns 0/-1, all bits are sign bits.; // We know that we have an integer-based boolean since these operations; // are only available for integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:139,avail,available,139,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,1,['avail'],['available']
Availability,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,recover,recover,52,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recover']
Availability,"// If crash recovery is disabled, do nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:12,recover,recovery,12,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['recover'],['recovery']
Availability,"// If current Type, Reg, Offset and Mask is in proper order then; // merge in the state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,1,['Mask'],['Mask']
Availability,"// If current error logging state is not the same as remote state; // update the remote state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:14,error,error,14,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['error'],['error']
Availability,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,recover,recovery-expr,35,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery-expr']
Availability,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:36,avail,available,36,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['avail'],['available']
Availability,"// If dominator tree is available, insert nodes to represent cloned blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['avail'],['available']
Availability,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avail'],['available']
Availability,"// If either input operand is a zero vector, use VPERM2X128 because its mask; // allows us to replace the zero input with an implicit zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If either is marked with throrough tracking, return that, we wouldn't like; // to downplay a note's importance by 'only' mentioning it as a condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:85,down,downplay,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['down'],['downplay']
Availability,"// If either operand is a constant mask, then only the elements that aren't; // allones are actually demanded by the other operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If either operand is a constant mask, then only the elements that aren't; // zero are actually demanded by the other operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If element is not in Mask, no need to handle the operand 1 (element to; // be inserted). Just evaluate values in operand 0 according to Mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,Mask,Mask,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['Mask'],['Mask']
Availability,"// If elements picked from Va and Vb have all different (source) indexes; // (relative to the start of the argument), do a mux, and update the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:143,mask,mask,143,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// If enabled and available, use fast short rep mov.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,1,['avail'],['available']
Availability,"// If error parsing the expression, ignore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:6,error,error,6,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['error']
Availability,"// If error parsing type, ignore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,error,error,6,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// If evaluation error printing is disabled, we don't need to collect the; // errors and only need to count them. This significantly reduces the; // performance overhead when having evaluation errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:17,error,error,17,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,3,['error'],"['error', 'errors']"
Availability,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,4,"['avail', 'recover']","['available', 'recover']"
Availability,"// If explicitly requested, map fatal errors to errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:38,error,errors,38,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,['error'],['errors']
Availability,"// If failure prepare or continue negotiation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:6,failure,failure,6,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['failure'],['failure']
Availability,"// If fatbin is available from early finalization, create a string; // literal containing the fat binary loaded from the given file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:16,avail,available,16,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['avail'],['available']
Availability,"// If fatbin is not available, create an external symbol; // __hip_fatbin in section .hip_fatbin. The external symbol is supposed; // to contain the fat binary but will be populated somewhere else,; // e.g. by lld through link script.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:20,avail,available,20,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['avail'],['available']
Availability,"// If file content is not available, let LineOff = 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,1,['avail'],['available']
Availability,"// If filling top down (default), we want the offset after incrementing it.; // If filling bottom up (WinCFI) we need the original offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:18,down,down,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['down'],['down']
Availability,"// If final mask is 0, MI result should be 0 too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// If genParams() are not available, skip this check for now",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRandomizeParamMCSModule.cxx:26,avail,available,26,roofit/roofitcore/src/RooRandomizeParamMCSModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRandomizeParamMCSModule.cxx,2,['avail'],['available']
Availability,"// If global profile summary is available, then callsite's coldness is; // determined based on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,"// If global profile summary is available, then callsite's hotness is; // determined based on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,recover,recover,47,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['recover'],['recover']
Availability,"// If hiBit is not aligned, we need a high mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['mask'],['mask']
Availability,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,redundant,redundant,117,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redundant'],['redundant']
Availability,"// If in read mode, uses the cached file status, if available, to avoid; // costly dc_stat() call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx:52,avail,available,52,io/dcache/src/TDCacheFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx,1,['avail'],['available']
Availability,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['mask'],['mask']
Availability,"// If inserted, ensure the original iterator points to the newly inserted; // element, so it can be used downstream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp:105,down,downstream,105,interpreter/llvm-project/clang/lib/Basic/Sarif.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp,1,['down'],['downstream']
Availability,"// If instruction is not yet put in a basic block (e.g. when cloning; // a function during inlining), Call's caller may not be available.; // So check Call's BB first before querying Call->getCaller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:127,avail,available,127,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avail'],['available']
Availability,"// If integer and float booleans have different contents then we can't; // reliably optimize in all cases. There is a full explanation for this in; // DAGCombiner::visitSELECT() where the same issue affects folding; // (select C, 0, 1) to (xor C, 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:75,reliab,reliably,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['reliab'],['reliably']
Availability,"// If intrinsic is pointing at a live SSA value, there may be an; // earlier optimization bug: if we know the location of the variable,; // why isn't the scope of the location alive?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:176,alive,alive,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['alive'],['alive']
Availability,"// If invalid, report the error with report_fatal_error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:26,error,error,26,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,3,['error'],['error']
Availability,"// If it exists, fixup the single node we allow in the tree that needs; // masking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,mask,masking,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,"// If it generates more than 8 stores it is likely to be expanded as an; // inline memcpy so we take that as an upper bound. Otherwise we assume; // one load and one store per word copied.; // FIXME: The maxStoresPerMemcpy setting from the target should be used; // here instead of a magic number of 8, but it's not available via; // DataLayout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:316,avail,available,316,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,// If it is VP_ADD/VP_SUB mask operation then turn it to VP_XOR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// If it is VP_MUL mask operation then turn it to VP_AND,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// If it is VP_REDUCE_ADD mask operation then turn it to VP_REDUCE_XOR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// If it is VP_REDUCE_MUL mask operation then turn it to VP_REDUCE_AND,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// If it is VP_REDUCE_SMAX/VP_REDUCE_UMIN mask operation then turn it to; // VP_REDUCE_AND.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// If it is VP_REDUCE_SMIN/VP_REDUCE_UMAX mask operation then turn it to; // VP_REDUCE_OR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,redundant,redundant,138,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redundant'],['redundant']
Availability,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,redundant,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redundant'],['redundant']
Availability,"// If it's a recoverable error, swallow it and retry the write.; //; // Ideally we wouldn't ever see EAGAIN or EWOULDBLOCK here, since; // raw_ostream isn't designed to do non-blocking I/O. However, some; // programs, such as old versions of bjam, have mistakenly used; // O_NONBLOCK. For compatibility, emulate blocking semantics by; // spinning until the write succeeds. If you don't want spinning,; // don't use O_NONBLOCK file descriptors with raw_ostream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:13,recover,recoverable,13,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,2,"['error', 'recover']","['error', 'recoverable']"
Availability,"// If it's a store, use the leader of the value operand, if it's always; // available, or the value operand. TODO: We could do dominance checks to; // find a dominating leader, but not worth it ATM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avail'],['available']
Availability,"// If it's available out of the predecessor, then we're ok.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:11,avail,available,11,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,"// If it's none of the above, then it must be a parameter declaration.; // NOTE: This will pick up errors in the closure of the template parameter; // list (e.g., template < ; Check here to implement >> style closures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:99,error,errors,99,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['errors']
Availability,"// If it's written directly, that's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:39,error,error,39,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"// If lambda can capture this, then emit default shadowing warning,; // Otherwise it is not really a shadowing case since field is not; // available in lambda's body.; // At this point we don't know that lambda can capture this, so; // remember that this was shadowed and delay until we know.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,avail,available,139,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,"// If largest set of observables that can be integrated is empty set, problem was ill defined; // Postpone error messaging and handling to end of function, exit loop here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:107,error,error,107,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['error']
Availability,"// If lexPreprocessor() encountered an error during lexing this; // preprocessor idiom, then return false to the calling lexPreprocessor().; // This will force tgtok::Error to be returned to the tokens processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:39,error,error,39,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,"// If lifetime information is available, we check it first since it's; // more precise. We look at every pair of lifetime.start intrinsic and; // every basic block that uses the pointer to see if they cross suspension; // points. The uses cover both direct uses as well as indirect uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:30,avail,available,30,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avail'],['available']
Availability,"// If loWord and hiWord are equal, then we combine the masks. Otherwise,; // set the bits in hiWord.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:55,mask,masks,55,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['mask'],['masks']
Availability,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:149,error,error,149,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// If lower 4G is not available, then we must use rip-relative addressing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// If mad is not available this depends only on if f32 fma is full rate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avail'],['available']
Availability,"// If mask contains a zero, use it by placing that vector first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:6,mask,mask,6,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// If masked interleaving is required, we expect that the user/target had; // enabled it, because otherwise it either wouldn't have been created or; // it should have been invalidated by the CostModel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,mask,masked,6,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,"// If missing, either import or report error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:39,error,error,39,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,3,['error'],['error']
Availability,"// If module doesn't have named metadata anchors or COFF debug section; // is not available, skip any debug info related stuff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:82,avail,available,82,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['avail'],['available']
Availability,"// If modules are not available, there is no reason to perform this merge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:22,avail,available,22,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,4,['avail'],['available']
Availability,"// If more than one metadata info require the specification of the objpath;; // the order in which they appear is not guaranteed and the error may be; // very difficult to find.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:137,error,error,137,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,1,['error'],['error']
Availability,"// If movrel is available, use it instead of expanding for vector of 8; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avail'],['available']
Availability,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:250,error,error,250,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// If needed, replace operands based on zero mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['mask']
Availability,"// If neither the SrcReg nor the TrgReg are $0, we need AT to perform the; // expansions. If it is not available, we return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:103,avail,available,103,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['avail'],['available']
Availability,"// If never entered the while block, there's a chance an error occured",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:57,error,error,57,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['error'],['error']
Availability,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,redundant,redundant,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,"// If no 16 bit instr is available, lower into different instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:25,avail,available,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['avail'],['available']
Availability,"// If no V1 inputs are used in place, then the result is created only from; // the zero mask and the V2 insertion - so remove V1 dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If no availability attributes are found, inherit the attribute from the; // containing decl or the class or category interface decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:9,avail,availability,9,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['avail'],['availability']
Availability,"// If no callbacks were found, or none used the underlying call site operand; // exclusively, use the direct callee argument if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:128,avail,available,128,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['avail'],['available']
Availability,"// If no custom ranges, add the range of the statement corresponding to; // the error node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,recover,recover,112,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Availability,"// If no error has been generated before now, assume the problem is in; // the body and generate a message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,1,['error'],['error']
Availability,"// If no errors have been reported, try perror",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/cling.cpp:9,error,errors,9,interpreter/cling/tools/driver/cling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/cling.cpp,1,['error'],['errors']
Availability,"// If no iterations are available, multiply with N.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"// If no match, return failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:23,failure,failure,23,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['failure'],['failure']
Availability,"// If no physical register is available for LRI, we assign one at random; // and bail out of this function immediately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:30,avail,available,30,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['avail'],['available']
Availability,"// If no state change is required, exit early.; // FIXME: In future we probably want to complain if we made a request which; // was with the same state as before in order to catch programming errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:192,error,errors,192,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['error'],['errors']
Availability,"// If non RSA encoding available try passwd inversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:23,avail,available,23,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['avail'],['available']
Availability,"// If none of speculative promotions for NewExts is profitable, rollback; // and save the current extension (I) as the last profitable extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,rollback,rollback,64,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['rollback'],['rollback']
Availability,"// If none of the above, it's definitely an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['error'],['error']
Availability,"// If none of the attributes applied, that's fine, we can recover by; // returning the substatement directly instead of making an AttributedStmt; // with no attributes on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:58,recover,recover,58,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recover']
Availability,"// If none of the mapping worked that means they are all impossible.; // Thus, pick the first one and set an impossible repairing point.; // It will trigger the failed isel mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:120,repair,repairing,120,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// If none of the previous checks caused a CFG build, trigger one here; // for the logical error handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:91,error,error,91,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['error'],['error']
Availability,"// If none of these succeed, return the error we got when trying to match; // outside any IT blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:40,error,error,40,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If not, report failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx:18,failure,failure,18,hist/histv7/src/RAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx,1,['failure'],['failure']
Availability,"// If not, see if next level down can be cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:29,down,down,29,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['down'],['down']
Availability,"// If not, then show an error message and leave.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:24,error,error,24,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['error'],['error']
Availability,"// If onSymbolStart returns Fail, that means it identified some kind; // of special data at this address, but wasn't able to disassemble it; // meaningfully. So we fall back to disassembling the failed region; // as bytes, assuming that the target detected the failure before; // printing anything.; //; // Return values Success or SoftFail (i.e no 'real' failure) are; // expected to mean that the target has emitted its own output.; //; // Either way, 'Size' will have been set to the amount of data; // covered by whatever prologue the target identified. So we advance; // our own position to beyond that. Sometimes that will be the entire; // distance to the next symbol, and sometimes it will be just a; // prologue and we should start disassembling instructions from where; // it left off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:261,failure,failure,261,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,2,['failure'],['failure']
Availability,"// If one instruction matched with an invalid operand, report this as an; // operand failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:85,failure,failure,85,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,['failure'],['failure']
Availability,"// If one or more successors has been unscheduled, then the current; // node is no longer available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:90,avail,available,90,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,"// If one side is an fneg/fabs and the other is a constant, we can push the; // fneg/fabs down. If it's an fabs, the constant needs to be non-negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:90,down,down,90,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['down'],['down']
Availability,"// If only 1 GPR was available, there will only be one custom GPR and; // the argument will also pass in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,"// If only immediate blends, then bail if the blend mask can't be widened to; // i16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If only some modules were split, flag this in the index so that; // we can skip or error on optimizations that need consistently split; // modules (whole program devirt and lower type tests).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:86,error,error,86,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['error'],['error']
Availability,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:231,error,error,231,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,2,['error'],['error']
Availability,"// If only the low half of a general register is needed, generate; // a GPRC copy instead of a G8RC copy. (EXTRACT_SUBREG can't be; // used along the fast-isel path (not lowered), and downstream logic; // also doesn't like a direct subreg copy on a physical reg.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:184,down,downstream,184,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['down'],['downstream']
Availability,"// If optimization is enabled, and the value was held in a; // __strong variable, we need to tell the optimizer that this; // value has to stay alive until we're doing the store back.; // This is because the temporary is effectively unretained,; // and so otherwise we can violate the high-level semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:144,alive,alive,144,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['alive'],['alive']
Availability,"// If optional error message is not empty, append it to the message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,2,['error'],['error']
Availability,"// If our expression contained SCEVUnknown Phis, and we split it down and now; // need to prove something for them, try to prove the predicate for every; // possible incoming values of those Phis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,down,down,65,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,redundant,redundant,145,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['redundant'],['redundant']
Availability,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Recover,Recover,159,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['Recover'],['Recover']
Availability,"// If outline atomic available, prepare its arguments and expand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avail'],['available']
Availability,"// If passing a variadic argument, or if no FPR is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['avail'],['available']
Availability,"// If pasting the two tokens didn't form a full new token, this is an; // error. This occurs with ""x ## +"" and other stuff. Return with LHSTok; // unmodified and with RHS as the next token to lex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:74,error,error,74,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['error'],['error']
Availability,// If pcmpeqq is missing but pcmpeqd is available synthesize pcmpeqq with; // pcmpeqd + pshufd + pand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If perfect forwarding is required a variadic method, a method using; // inalloca, or an unprototyped thunk, use musttail. Emit an error if this; // thunk requires a return adjustment, since that is impossible with musttail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:133,error,error,133,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['error'],['error']
Availability,"// If profile information is available, findDuplicateCandidates can do more; // precise benefit analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avail'],['available']
Availability,"// If program is correct, BaseClass cannot be null, but if it is, the error; // must be reported elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:70,error,error,70,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// If recovery created an ambiguity, just bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:6,recover,recovery,6,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recovery']
Availability,"// If relative deviation is greater than tolerance divide and iterate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:41,toler,tolerance,41,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['toler'],['tolerance']
Availability,// If reqd_work_group_size is present it narrows value down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:55,down,down,55,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['down'],['down']
Availability,"// If requested by the caller and the module hasn't already been read; // or compiled, mark modules on error as out-of-date.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,4,['avail'],['available']
Availability,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:65,error,error,65,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,2,['error'],['error']
Availability,"// If return address signing is enabled, tail calls are emitted as follows:; //; // ```; // <authenticate LR>; // <check LR>; // TCRETURN ; the callee may sign and spill the LR in its prologue; // ```; //; // LR may require explicit checking because if FEAT_FPAC is not implemented; // and LR was tampered with, then `<authenticate LR>` will not generate an; // exception on its own. Later, if the callee spills the signed LR value and; // neither FEAT_PAuth2 nor FEAT_EPAC are implemented, the valid PAC replaces; // the higher bits of LR thus hiding the authentication failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:571,failure,failure,571,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['failure'],['failure']
Availability,"// If running with -E, treat as a C input (this changes the; // builtin macros, for example). This may be overridden by -ObjC; // below.; //; // Otherwise emit an error but still use a valid type to avoid; // spurious errors (e.g., no inputs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:163,error,error,163,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,2,['error'],"['error', 'errors']"
Availability,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,redundant,redundant,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"// If so, update the mask to reflect the inserted poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// If so, update the mask to reflect the inserted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// If some bits of Input are already known ones, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// If some bits of Input are already known zeros, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,mask,mask,97,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// If some of the successors are in the existing node-set, then use the; // top-down ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:80,down,down,80,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['down'],['down']
Availability,"// If somehow the Setup fails call the original Read to; // have the proper error handling (message only if the Setup fails; // and the current proxy entry is different than the TTree's current entry)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:76,error,error,76,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['error'],['error']
Availability,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:216,down,down,216,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['down'],['down']
Availability,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,mask,mask,139,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// If source or target has a variant or reference as a parent, error out",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx:63,error,error,63,tree/ntuple/v7/src/RNTupleModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx,1,['error'],['error']
Availability,"// If strict matches are requested, don't tolerate any extra defines in; // the AST file that are missing on the command line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,toler,tolerate,42,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['toler'],['tolerate']
Availability,"// If strict matches are requested, don't tolerate any extra defines; // on the command line that are missing in the AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,toler,tolerate,42,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['toler'],['tolerate']
Availability,"// If structDecl is a forward declaration, this loop won't do; // anything except look at designated initializers; That's okay,; // because an error should get printed out elsewhere. It might be; // worthwhile to skip over the rest of the initializer, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:143,error,error,143,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['error'],['error']
Availability,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:63,Recover,RecoveryExpr,63,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,6,"['Recover', 'down']","['RecoveryExpr', 'downstream']"
Availability,"// If successful, the top of the file stack will mark the end of the Argv; // stream. A failure here indicates a bug in the stack popping logic above.; // Note that FileStack may have more than one element at this point because we; // don't have a chance to pop the stack when encountering recursive files at; // the end of the stream, so seeing that doesn't indicate a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:88,failure,failure,88,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['failure'],['failure']
Availability,"// If tail is folded by masking, introduce selects between the phi; // and the live-out instruction of each reduction, at the beginning of the; // dedicated latch block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,mask,masking,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masking']
Availability,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:59,avail,available,59,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,"// If that failed, give an error and recover using __strong. __strong; // is the option most likely to prevent spurious second-order diagnostics,; // like when binding a reference to a field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,recover,recover,26,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,"// If that function's not in a system header, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// If the $rs is different from $rd or if $rs isn't specified and we; // have $at available:; // (d)la $rd, sym/sym($rs) => lui $rd, %highest(sym); // lui $at, %hi(sym); // daddiu $rd, $rd, %higher(sym); // daddiu $at, $at, %lo(sym); // dsll32 $rd, $rd, 0; // daddu $rd, $rd, $at; // (daddu $rd, $rd, $rs); //; // Which is preferred for superscalar issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:82,avail,available,82,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['avail'],['available']
Availability,"// If the 2nd shift is bigger than the 1st, we can fold:; // lshr (shl X, C1), C2 --> and (shl X, C1 - C2), C3; // shl (lshr X, C1), C2 --> and (lshr X, C1 - C2), C3; // but it isn't profitable unless we know the and'd out bits are already zero.; // Also, check that the inner shift is valid (less than the type width) or; // we'll crash trying to produce the bit mask for the 'and'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:364,mask,mask,364,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,"// If the AVL value is a register (other than our VLMAX sentinel),; // we need to prove the value is available at the point we're going; // to insert the vsetvli at.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:101,avail,available,101,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['avail'],['available']
Availability,// If the BinOp1 is `and` we don't need to check the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// If the Bits are within an aligned 8-byte, set the RecordAlignment; // to 8, other report the fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:102,error,error,102,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['error'],['error']
Availability,"// If the FPOffset is negative and we're producing a signed immediate, we; // have to keep in mind that the available offset range for negative; // offsets is smaller than for positive ones. If an offset is available; // via the FP and the SP, use whichever is closest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:108,avail,available,108,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,2,['avail'],['available']
Availability,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:414,avail,available,414,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['avail'],['available']
Availability,"// If the I->getSection() call would return an error, the earlier I->getType(); // call will already have returned the same error first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:47,error,error,47,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,2,['error'],['error']
Availability,"// If the LHS and RHS of the ADC node are zero, then it can't overflow and; // the result is either zero or one (depending on the input carry bit).; // Strength reduce this down to a ""set on carry"" aka SETCC_CARRY&1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:173,down,down,173,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:216,mask,mask,216,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,17,['mask'],"['mask', 'masks']"
Availability,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,Mask,MaskedOff,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['Mask'],"['Mask', 'MaskedOff']"
Availability,"// If the SRL is only used by a masking AND, we may be able to adjust; // the ExtVT to make the AND redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,mask,masking,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['mask', 'redundant']","['masking', 'redundant']"
Availability,"// If the VSELECT is on a 512-bit type, we have to convert a non-i1 condition; // into an i1 condition so that we can use the mask-based 512-bit blend; // instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,mask,mask-based,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask-based']
Availability,"// If the a model is available, returns the value of a given bitvector symbol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h:21,avail,available,21,interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h,1,['avail'],['available']
Availability,"// If the a model is available, returns the value of a given boolean symbol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h:21,avail,available,21,interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SMTAPI.h,1,['avail'],['available']
Availability,"// If the actual AND mask is allowing unallowed bits, this doesn't match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,2,['mask'],['mask']
Availability,"// If the actual mask exactly matches, success!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,2,['mask'],['mask']
Availability,"// If the add button is down don't replace the fEnteredFunc text",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:24,down,down,24,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['down'],['down']
Availability,"// If the address is an externally defined symbol, a symbol with common; // or externally available linkage, a non-local function address, or a; // jump table address (not yet needed), or if we are generating code; // for large code model, we generate:; // LDtocL(GV, ADDIStocHA8(%x2, GV)); // Otherwise we generate:; // ADDItocL(ADDIStocHA8(%x2, GV), GV); // Either way, start with the ADDIStocHA8:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:90,avail,available,90,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avail'],['available']
Availability,"// If the address of the block is taken and it is being deleted (e.g. because; // it is dead), this means that there is either a dangling constant expr; // hanging off the block, or an undefined use of the block (source code; // expecting the address of a label to keep the block alive even though there; // is no indirect branch). Handle these cases by zapping the BlockAddress; // nodes. There are no other possible uses at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:280,alive,alive,280,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['alive'],['alive']
Availability,"// If the alignment for the load is 16 or bigger, we don't need the; // permutated mask to get the required value. The value must be the 0; // element in big endian target or 7/15 in little endian target in the; // result vsx register of lvx instruction.; // Select the instruction in the .td file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,mask,mask,83,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,redundant,redundant,112,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['redundant'],['redundant']
Availability,"// If the and is only masking out bits that cannot effect the shift,; // eliminate the and.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:22,mask,masking,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['masking']
Availability,"// If the argument before the = is a valid option name and the option allows; // non-prefix form (ie is not AlwaysPrefix), we match. If not, signal match; // failure by returning nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:158,failure,failure,158,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['failure'],['failure']
Availability,"// If the argument has *required* alignment greater than four bytes, pass; // it indirectly. Prior to MSVC version 19.14, passing overaligned; // arguments was not supported and resulted in a compiler error. In 19.14; // and later versions, such arguments are now passed indirectly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:201,error,error,201,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['error'],['error']
Availability,"// If the argument parsing failed or more than one argument was; // consumed, the -Xarch_ argument's parameter tried to consume; // extra arguments. Emit an error and ignore.; //; // We also want to disallow any options which would alter the; // driver behavior; that isn't going to work in our model. We; // use options::NoXarchOption to control this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:157,error,error,157,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['error'],['error']
Availability,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:368,alive,alive,368,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['alive'],['alive']
Availability,"// If the attribute list includes ""optnone"" we need to make sure it also; // includes ""noinline"" otherwise we will get a verifier failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:130,failure,failure,130,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['failure'],['failure']
Availability,"// If the available queue is empty, it is safe to reset MinAvailableCycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['avail'],['available']
Availability,"// If the available register tuples are aligned with the kernarg to be; // preloaded use that register, otherwise we need to use a set of SGPRs and; // merge them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['avail'],['available']
Availability,"// If the base node is invalid in itself, then we've already printed all the; // errors we wanted to print.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:81,error,errors,81,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['errors']
Availability,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:126,error,error,126,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,3,"['error', 'recover']","['error', 'recover']"
Availability,"// If the bit convert changed the number of elements, it is unsafe; // to examine the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,mask,mask,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,redundant,redundant,27,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redundant'],['redundant']
Availability,"// If the block has its address taken, it may be a tree of dead constants; // hanging off of it. These shouldn't keep the block alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,alive,alive,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['alive'],['alive']
Availability,// If the block isn't marked as fixpoint yet; // (the Unavailable and Available states are fixpoints),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:70,Avail,Available,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Avail'],['Available']
Availability,"// If the body was previously defined, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:50,error,error,50,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// If the bucket is not available, probe for a spot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['avail'],['available']
Availability,"// If the callee has an AArch64 SME attribute to indicate that it is an; // __arm_streaming function, then the caller requires SME to be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:137,avail,available,137,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['avail'],['available']
Availability,"// If the caller passed an Error by value, then stream_operator_format_adapter; // would be responsible for consuming it.; // Make the caller opt into this by calling fmt_consume().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h:27,Error,Error,27,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,1,['Error'],['Error']
Availability,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,error,error,120,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['error'],['error']
Availability,"// If the child is only used in GEP instructions (i.e. is not used in; // non-GEP instructions), the nearest dominator computed for it may; // have been null. In such case it won't have a location available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:197,avail,available,197,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,1,['avail'],['available']
Availability,"// If the client is only demanding bits we know to be zero, return; // `llvm.ptrmask(p, 0)`. We can't return `null` here due to pointer; // provenance, but making the mask zero will be easily optimizable in; // the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:167,mask,mask,167,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['mask'],['mask']
Availability,"// If the collection has not been updated since MinInterval, call update() and; // return true. Otherwise return false. If update returns an error, return the; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:141,error,error,141,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,2,['error'],['error']
Availability,"// If the combined shift fits in the source width:; // (trunc (X >>u C1)) >>u C --> and (trunc (X >>u (C1 + C)), MaskC; //; // If the first shift covers the number of bits truncated, then the; // mask instruction is eliminated (and so the use check is relaxed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:113,Mask,MaskC,113,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,2,"['Mask', 'mask']","['MaskC', 'mask']"
Availability,"// If the comparison is testing for a positive value, we have to invert; // the sign bit mask, so only do that transform if the target has a bitwise; // 'and not' instruction (the invert is free).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:89,mask,mask,89,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// If the constants are not already the same, but can be with the demand; // mask, use the constant value from the ICmp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:77,mask,mask,77,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['mask'],['mask']
Availability,"// If the context of this function is less available than D, we should not; // emit a diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:43,avail,available,43,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['available']
Availability,"// If the conv button is down don't replace the fEnteredFunc text",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:25,down,down,25,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['down'],['down']
Availability,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:83,avail,availability,83,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,2,['avail'],"['availability', 'available']"
Availability,"// If the current setup has imm64 mask, then inverse will have; // at least imm32 mask (or be zext i32 -> i64).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If the current source has extra fields and we're in Strict mode, error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:68,error,error,68,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['error'],['error']
Availability,"// If the current source is missing some fields and we're not in Union mode, error; // (if we are in Union mode, MergeSourceClusters will fill the missing fields with default values).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:77,error,error,77,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['error'],['error']
Availability,"// If the current template argument causes an error, give up now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,error,error,46,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,redundant,redundant,131,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['redundant'],['redundant']
Availability,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,error,error,39,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,4,['error'],['error']
Availability,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:191,failure,failures,191,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,1,['failure'],['failures']
Availability,"// If the declarations don't match, this is an error condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,error,error,47,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If the declarator-id has a scope specifier, it must redeclare a; // previously-declared entity. If that's a type (and this is not a; // typedef), that's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:159,error,error,159,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,recover,recover,73,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,3,['recover'],['recover']
Availability,"// If the default clause is unreachable, propagate that knowledge into; // JTH->FallthroughUnreachable which will use it to suppress the range; // check.; //; // However, don't do this if we're doing branch target enforcement,; // because a table branch _without_ a range check can be a tempting JOP; // gadget - out-of-bounds inputs that are impossible in correct; // execution become possible again if an attacker can influence the; // control flow. So if an attacker doesn't already have a BTI bypass; // available, we don't want them to be able to get one out of this; // table branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:508,avail,available,508,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avail'],['available']
Availability,"// If the deletion request completely covers the child, delete it and move; // the rest down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:88,down,down,88,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,1,['down'],['down']
Availability,"// If the demanded bits has leading zeroes, we don't demand those from the; // mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,mask,mask,79,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the dependency is in an error state then note this and continue,; // we will move this symbol to the error state below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['error'],['error']
Availability,// If the dependency was not in the error state then add it to; // our list of dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:36,error,error,36,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If the displacement is a constant, check overflows. For 64-bit addressing,; // gas requires isInt<32> and otherwise reports an error. For others, gas; // reports a warning and allows a wider range. E.g. gas allows; // [-0xffffffff,0xffffffff] for 32-bit addressing (e.g. Linux kernel uses; // `leal -__PAGE_OFFSET(%ecx),%esp` where __PAGE_OFFSET is 0xc0000000).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:130,error,error,130,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['error']
Availability,"// If the element is masked, handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,mask,masked,21,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['masked']
Availability,"// If the element type is itself an array, drill down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:49,down,down,49,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['down'],['down']
Availability,"// If the end does not reside in the same file, try to recover by; // picking the end of the file of begin location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,recover,recover,55,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['recover'],['recover']
Availability,"// If the expression is immediate escalating, it is not an error;; // The outer context itself becomes immediate and further errors,; // if any, will be handled by DiagnoseImmediateEscalatingReason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,error,error,59,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],"['error', 'errors']"
Availability,"// If the file is empty, we return the original error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:48,error,error,48,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,1,['error'],['error']
Availability,"// If the final mask is an alternating blend of vXi8/vXi16, convert to an; // UNPCKL(SHUFFLE, SHUFFLE) pattern.; // TODO: It doesn't have to be alternating - but each lane mustn't have more; // than half the elements coming from each source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the first byte is zero, use mask as first operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the first character on the new line is a lambda's closing brace, the; // stack still contains that lambda's parenthesis. As such, we need to; // recurse further down the stack than usual to find the parenthesis level; // containing the lambda, which is where we want to set; // BreakBeforeParameter.; //; // We specifically special case ""OuterScope""-formatted lambdas here; // because, when using that setting, breaking before the parameter; // directly following the lambda is particularly unsightly. However, when; // ""OuterScope"" is not set, the logic to find the parent parenthesis level; // still appears to be sometimes incorrect. It has not been fixed yet; // because it would lead to significant changes in existing behaviour.; //; // TODO: fix the non-""OuterScope"" case too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:167,down,down,167,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['down'],['down']
Availability,"// If the first decl is in an extern ""C"" context, any other redeclaration; // will have C language linkage. If the first one is not in an extern ""C""; // context, we would have reported an error for any other decl being in one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,error,error,188,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['error'],['error']
Availability,"// If the first part of the nested-name-specifier was a template type; // parameter, instantiate that type parameter down to a tag type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:117,down,down,117,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['down'],['down']
Availability,"// If the first shift does not cover the number of bits truncated, then; // we require a mask to get rid of high bits in the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:89,mask,mask,89,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,"// If the following two conditions are met:; //; // 1. mask B covers only a single bit that's not covered by mask D, that is,; // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of; // B and D has only one bit set) and,; //; // 2. RHS (and E) indicates that the rest of B's bits are zero (in other; // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0; //; // then that single bit in B must be one and thus the whole expression can be; // folded to; // (A & (B | D)) == (B & (B ^ D)) | E.; //; // For example,; // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9); // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],['mask']
Availability,"// If the friend does not have a TTreeIndex, the cause of a failure reading an entry; // is most probably a difference in number of entries between main tree and friend tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:60,failure,failure,60,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['failure'],['failure']
Availability,"// If the function is already unavailable, it's not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:55,error,error,55,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// If the function is being compiled right now, this is a recursive call.; // In that case, the function can't be valid yet, even though it will be; // later.; // If the function is already fully compiled but not constexpr, it was; // found to be faulty earlier on, so bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:247,fault,faulty,247,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['fault'],['faulty']
Availability,"// If the function ran by the CrashRecoveryContext crashes or fails, then; // 'RetCode' represents the returned error code, as if it was returned by a; // process. 'Context' represents the signal type on Unix; on Windows, it is; // the ExceptionContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:112,error,error,112,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['error'],['error']
Availability,"// If the function violates [temp.friend]p9 because it is missing; // a definition, and adding a definition would make it templated,; // then let that error take precedence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:151,error,error,151,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If the function we call is further DOWN the hierarchy than the; // FieldDesc of our pointer, just get the DeclDesc instead, which; // is the furthest we might go up in the hierarchy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:38,DOWN,DOWN,38,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['DOWN'],['DOWN']
Availability,"// If the guard was conditional executed, it may never be reached; // dynamically. There are two potential downsides to hoisting it out of the; // conditionally executed region: 1) we may spuriously deopt without need and; // 2) we have the extra cost of computing the guard condition in the common; // case. At the moment, we really only consider the second in our heuristic; // here. TODO: evaluate cost model for spurious deopt; // NOTE: As written, this also lets us hoist right over another guard which; // is essentially just another spelling for control flow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:107,down,downsides,107,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['down'],['downsides']
Availability,"// If the guard/stackslot do not equal, branch to failure MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:50,failure,failure,50,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['failure'],['failure']
Availability,"// If the heading is still empty, it is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:43,error,error,43,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['error'],['error']
Availability,"// If the immediate value is too big for the immoffset field, put only bits; // that would normally fit in the immoffset field. The remaining value that; // is copied/added for the voffset field is a large power of 2, and it; // stands more chance of being CSEd with the copy/add for another similar; // load/store.; // However, do not do that rounding down if that is a negative; // number, as it appears to be illegal to have a negative offset in the; // vgpr, even if adding the immediate offset makes it positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:353,down,down,353,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,3,['down'],['down']
Availability,"// If the index is a constant, we can really break this down as you would; // expect, and index into the target size pieces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:56,down,down,56,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['down'],['down']
Availability,"// If the index is larger than the pointer offset size of the target, truncate; // the index down like the GEP would do implicitly. We don't have to do this; // for an inbounds GEP because the index can't be out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,down,down,93,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['down'],['down']
Availability,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:88,error,error,88,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['error'],['error']
Availability,"// If the initializing element is a vector, try to copy-initialize; // instead of breaking it apart (which is doomed to failure anyway).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:120,failure,failure,120,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['failure'],['failure']
Availability,"// If the inline asm had metadata associated with it, pull out a location; // cookie corresponding to which line the error occurred on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:117,error,error,117,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,1,['error'],['error']
Availability,"// If the inner operand is a known splat with no undefs, just return that directly.; // TODO: Create DemandedElts mask from Shuf's mask.; // TODO: Allow undef elements and merge with the shuffle code below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:114,mask,mask,114,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"// If the input has multiple uses and we can either fold the negate down, or; // the other uses cannot, give up. This both prevents unprofitable; // transformations and infinite loops: we won't repeatedly try to fold around; // a negate that has no 'good' form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp:68,down,down,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,2,['down'],['down']
Availability,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,redundant,redundant,75,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// If the inputs are not the same as the output, bail. This is not an; // error situation, but complicates the handling and the default expansion; // (into BUILD_VECTOR) should be adequate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:74,error,error,74,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['error'],['error']
Availability,"// If the inserted element was extracted from some other fixed-length vector; // and both indexes are valid constants, try to turn this into a shuffle.; // Can not handle scalable vector type, the number of elements needed to; // create shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:245,mask,mask,245,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:304,avail,available,304,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['avail'],['available']
Availability,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,redundant,redundant,94,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,"// If the interrupt we're tied to is the EIC, switch the source for the; // masking off interrupts to the cause register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:76,mask,masking,76,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['mask'],['masking']
Availability,"// If the intrinsic has a mask operand, handle that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['mask'],['mask']
Availability,// If the iterators differ and this is a comparison against end then mark; // the Error as checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:82,Error,Error,82,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['Error'],['Error']
Availability,"// If the key is related to and object that inherits from TTree::Class we; // set treeName with the name of this key if treeName is empty, otherwise; // error occurs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:153,error,error,153,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['error'],['error']
Availability,"// If the left brace is in a new line, we should consume it first so that; // it does not make the namespace non-empty.; // FIXME: error handling if there is no left brace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:131,error,error,131,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['error'],['error']
Availability,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,mask,masked,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"// If the load command is present but the data offset has been zeroed out,; // as is the case for dylib stubs, return std::nullopt (no error).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:135,error,error,135,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['error'],['error']
Availability,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,redundant,redundant,93,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,redundant,redundant,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"// If the loaded operand is defined in the LoadBB and its not a phi,; // it can't be available in predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:85,avail,available,85,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,2,['avail'],['available']
Availability,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,2,"['avail', 'redundant']","['available', 'redundant']"
Availability,// If the low N bits of Op1 are zero than the low N bits of Op0 can; // be masked off without changing the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:75,mask,masked,75,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['masked']
Availability,"// If the macro is not defined, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,error,error,43,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,['error'],['error']
Availability,"// If the macro name token is tok::eod, there was an error that was; // already reported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,error,error,53,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,"// If the mask allows, we can do all the index computation in 16 bits. This; // requires less work and less register pressure at high LMUL, and creates; // smaller constants which may be cheaper to materialize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask and the type are different sizes, unroll the vector op. This; // can occur when getSetCCResultType returns something that is different in; // size from the operand types. For example, v4i8 = select v4i32, v4i8, v4i8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,['mask'],['mask']
Availability,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,3,['mask'],['mask']
Availability,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"// If the mask covers the whole destination register, there's nothing to; // extend",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,"// If the mask element was already set, there's nothing to do; // (demanded elements analysis may unset it later).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// If the mask has 32 trailing ones, use SRLI on RV32 or SRLIW on RV64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If the mask has an undef, replace it with the current index.; // Note that it might still be undef if the current index is also undef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask has less elements than the operands, each mask bit maps to; // multiple elements of the operands. Bitcast back and forth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['mask'],['mask']
Availability,"// If the mask is all -1's, generate ""undef"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,// If the mask is all 0s there's nothing to do here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// If the mask is all ones just emit a regular store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['mask'],['mask']
Availability,// If the mask is all ones just emit the first operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['mask'],['mask']
Availability,// If the mask is all ones just return first argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,mask,mask,10,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,['mask'],['mask']
Availability,"// If the mask is all ones or undefs, this is a plain vector load of the 1st; // argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"// If the mask is all ones, erase the AND. (Currently, the target-independent; // code won't do this, so we have to do it explicitly to avoid an infinite; // loop in obscure cases.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask is all ones, this is a plain vector store of the 1st argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"// If the mask is all zeros or undef, the ""passthru"" argument is the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// If the mask is all zeros this is a splat, no need to go through all; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['mask'],['mask']
Availability,"// If the mask is all zeros, a scatter does nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"// If the mask is all zeros, let the target-independent code replace the; // result with zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask is all zeros, this instruction does nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"// If the mask is extracting all bits from X or Y as is, we can skip; // this AND op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// If the mask is fully covered by the unpack, we don't need to push; // a new AND onto the operand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask is known to be all ones, optimize to an unmasked intrinsic;; // the selection of the masked intrinsics doesn't do this for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,8,['mask'],"['mask', 'masked']"
Availability,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,6,['mask'],['mask']
Availability,"// If the mask is smaller, recompute the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// If the mask is suitable for andi. or andis. we should sink the and.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask is twice as long as the input vector then we need to check the; // upper and lower parts of the mask with a matching value for WhichResult; // FIXME: A mask with only even values will be rejected in case the first; // element is undefined, e.g. [-1, 4, 2, 6] will be rejected, because only; // M[0] is used to determine WhichResult",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['mask'],['mask']
Availability,"// If the mask on the insertee is correct, we have a BFXIL operation. We; // can share the ImmR and ImmS values from the already-computed UBFM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If the mask only uses one non-undef element, then fully 'splat' it to; // improve later broadcast matching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the mask value has been legalized to a non-boolean vector, try to; // simplify ops leading up to it. We only demand the MSB of each lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,mask,masked,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['masked']
Availability,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,mask,masked,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['masked']
Availability,"// If the module isn't available, it doesn't make sense to enter it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:23,avail,available,23,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['avail'],['available']
Availability,"// If the module stream does not exist, it is not an error condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:53,error,error,53,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,1,['error'],['error']
Availability,"// If the most significant bit (bit[7]) of each byte of the shuffle; // control mask is set, then zero is written in the result byte.; // The zero vector is in the right-hand side of the resulting; // shufflevector.; // The value of each index for the high 128-bit lane is the least; // significant 4 bits of the respective shuffle control byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,down,down,50,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"// If the name is invalid, issue an error message and return a nullptr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:36,error,error,36,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['error'],['error']
Availability,"// If the nested-name-specifier is an invalid type def, don't emit an; // error because a previous error should have already been emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:74,error,error,74,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['error'],['error']
Availability,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,recover,recover,59,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['recover'],['recover']
Availability,"// If the next token wasn't a header-name, diagnose the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:56,error,error,56,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['error']
Availability,"// If the non-SP source operand and the destination operand are not the; // same, we need thumb2 (for the wide encoding), or we have an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:136,error,error,136,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If the non-SP source operand and the destination operand are not the; // same, we need to use the 32-bit encoding if it's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:125,avail,available,125,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avail'],['available']
Availability,"// If the normadd button is down don't replace the fEnteredFunc text",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:28,down,down,28,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['down'],['down']
Availability,"// If the object is not derived, will downcast to toBase first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:38,down,downcast,38,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,1,['down'],['downcast']
Availability,"// If the offset doesn't fit, emit following codes. This clobbers SX13; // which we always know is available here.; // lea %clobber, Offset@lo; // and %clobber, %clobber, (32)0; // lea.sl %clobber, Offset@hi(FrameReg, %clobber)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp:99,avail,available,99,interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp,1,['avail'],['available']
Availability,// If the offset is a known constant then try to recover the pointer; // info,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,recover,recover,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['recover'],['recover']
Availability,// If the only instruction immediately following this END_CF is another; // END_CF in the only successor we can avoid emitting exec mask restore here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:132,mask,mask,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,recover,recover,119,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recover']
Availability,"// If the operand is a logical right shift, we can fold it into this; // instruction: rldicl(rldicl(x, 64-n, n), 0, mb) -> rldicl(x, 64-n, mb); // for n <= mb. The right shift is really a left rotate followed by a; // mask, and this mask is a more-restrictive sub-mask of the mask implied; // by the shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:218,mask,mask,218,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,4,['mask'],['mask']
Availability,"// If the operand is too big, we must see if cmpxchg8/16b is available; // and default to library calls otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,avail,available,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If the original definition is still around, add it as an available; // value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avail'],['available']
Availability,"// If the original outer latch has only one predecessor, then values defined; // further inside the looploop, e.g., in the innermost loop, will be available; // at the new outer latch after interchange.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:147,avail,available,147,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['avail'],['available']
Availability,"// If the original shl may be shifting out bits, do not perform this; // transformation.; // TODO: Add MaskedValueIsZero check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Mask,MaskedValueIsZero,103,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['MaskedValueIsZero']
Availability,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,recover,recover,83,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recover']
Availability,"// If the path doesn't exist, return failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:37,failure,failure,37,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,1,['failure'],['failure']
Availability,"// If the preamble rebuild counter > 1, it's because we previously; // failed to build a preamble and we're not yet ready to try; // again. Decrement the counter and return a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:175,failure,failure,175,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['failure'],['failure']
Availability,"// If the predicate is true or false and we're using constrained intrinsics,; // we don't have a compare intrinsic we can use. Just use the legacy X86; // specific intrinsic.; // If the intrinsic is mask enabled and we're using constrained intrinsics,; // use the legacy X86 specific intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:199,mask,mask,199,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,"// If the predicate register is defined between DefI and TfrI, the only; // potential thing to do would be to move the DefI down to TfrI, and then; // predicate. The reaching def (DefI) must be movable down to the location; // of the TfrI.; // If the target register of the TfrI (RD) is not used or defined between; // DefI and TfrI, consider moving TfrI up to DefI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:124,down,down,124,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,2,['down'],['down']
Availability,"// If the program is not still broken, then loop extraction did something; // that masked the error. Stop loop extraction now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:83,mask,masked,83,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,2,"['error', 'mask']","['error', 'masked']"
Availability,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,recover,recovery,81,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['recover'],['recovery']
Availability,"// If the proxies in the proxy list still don't correspond to _compRSet and; // _compCSet, it's time to print errors. And try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:110,error,errors,110,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,2,"['error', 'recover']","['errors', 'recover']"
Availability,"// If the qualifiers come from a conversion function type, don't diagnose; // them -- they're not necessarily redundant, since such a conversion; // operator can be explicitly called as ""x.operator const int()"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:110,redundant,redundant,110,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redundant'],['redundant']
Availability,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:162,error,error,162,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,3,"['checkPoint', 'error']","['checkPointerTypesForAssignment', 'error']"
Availability,"// If the real class is available, make it available via the arrow operator:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx:24,avail,available,24,tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,2,['avail'],['available']
Availability,"// If the register has an alternate name for this index, use it.; // Otherwise, leave it empty as an error flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:101,error,error,101,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['error'],['error']
Availability,"// If the register is defined within loop, then we can't perform TP.; // TODO: Check whether this is just a mov of a register that would be; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:144,avail,available,144,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['avail'],['available']
Availability,"// If the register list contains any high registers, or if the writeback; // doesn't match what tLDMIA can do, we need to use the 32-bit encoding; // instead if we're in Thumb2. Otherwise, this should have generated; // an error in validateInstruction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:223,error,error,223,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:165,error,error,165,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['error'],['error']
Availability,"// If the replacement sequence does not start with a non-negative integer,; // this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp:90,error,error,90,interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp,1,['error'],['error']
Availability,"// If the result is masked, then no matter what kind of bool it is we can; // return. If it isn't, then we need to make sure the bool type is either 0 or; // 1 and not other values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,mask,masked,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"// If the result mask is equal to one of the original shuffle masks,; // or is a splat, do the replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:177,alive,alive,177,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"// If the return type is a CPPInstance, owned by Python, and the ref-count down; // to 1, the return will hold a dangling pointer, so set it to nullptr instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:75,down,down,75,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['down'],['down']
Availability,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,recover,recover,76,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['recover'],['recover']
Availability,"// If the saved register wasn't CR0LT, shift the bits left so that the bit; // to store is the first one. Mask all but that bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:106,Mask,Mask,106,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['Mask'],['Mask']
Availability,"// If the scalar integer is greater than the vector element size, then we; // must split it down into sub-sections for broadcasting. For example:; // i16 -> v16i8 (i16 -> v8i16 -> v16i8) with 2 sub-sections.; // i32 -> v32i8 (i32 -> v8i32 -> v32i8) with 4 sub-sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// If the scale is negative, the low and high errors must be swapped",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:46,error,errors,46,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,1,['error'],['errors']
Availability,"// If the second argument to a memset is a sizeof expression and the third; // isn't, this is also likely an error. This should catch; // 'memset(buf, sizeof(buf), 0xff)'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:89,mask,masked,89,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['masked']
Availability,"// If the shift amount is masked with an AND, check that the mask covers the; // bits that are implicitly ANDed off by the above opcodes and if so, skip; // the AND.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:26,mask,masked,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// If the shift right was arithmetic, it could have included some 1 bits.; // It is still ok to generate extract, but only if the mask eliminates; // those bits (i.e. M does not have any bits set beyond U).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:130,mask,mask,130,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,1,['mask'],['mask']
Availability,"// If the shift subsumes the mask, emit the 0 directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,"// If the shifted mask extends into the high half and is 8/16/32 bits; // wide, then replace it with a SHR and a TEST8rr/TEST16rr/TEST32rr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If the shrunk mask fits in sign extended 12 bits, let the target; // independent code apply it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// If the shuffle mask is repeated in each 128-bit lane we can use more; // efficient instructions that mirror the shuffles across the four 128-bit; // lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// If the shuffle mask is repeated in each 128-bit lane we can use more; // efficient instructions that mirror the shuffles across the two 128-bit; // lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the shuffle mask is repeated in each 128-bit lane, we have many more; // options to efficiently lower the shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If the shuffle result was smaller than the root, we need to adjust the; // mask indices and pad the mask with undefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:78,mask,mask,78,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If the size is not even, it's not an interleaving mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['mask'],['mask']
Availability,"// If the source half mask maps over the inputs, turn those into; // swaps and use the swapped lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the source is already a VMOVIMM or VMVNIMM splat, the VDUPLANE is; // redundant. Ignore bit_converts for now; element sizes are checked below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:76,redundant,redundant,76,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:22,down,down,22,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,3,['down'],['down']
Availability,"// If the stack pointer has been marked as reserved, then produce an error if; // the frame requires stack allocation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:69,error,error,69,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['error'],['error']
Availability,"// If the state N has multiple predecessors P, it means that successors; // of P are all equivalent.; // In turn, that means that all nodes at P are equivalent in terms; // of observable behavior at N, and we can follow any of them.; // FIXME: a more robust solution which does not walk up the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:251,robust,robust,251,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['robust'],['robust']
Availability,"// If the state is not SCHEDULED, then we previously errored on start.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:53,error,errored,53,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['errored']
Availability,"// If the store is truncating then it's going down to i16 or smaller, which; // means it can be implemented in a single store anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:46,down,down,46,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['down'],['down']
Availability,"// If the stride is equal to the element size in bytes, we can use; // a masked.load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,mask,masked,73,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['masked']
Availability,"// If the stride is equal to the element size in bytes, we can use; // a masked.store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,mask,masked,73,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['masked']
Availability,// If the sub-mask has at most 2 input sub-vectors then re-cost it using; // getShuffleCost. If not then cost it using the worst case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:288,down,down,288,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"// If the sum of weights does not fit in 32 bits, scale every weight down; // accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:69,down,down,69,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,2,['down'],['down']
Availability,"// If the symbol is external the linker will handle it.; // FIXME: Should we handle it as an optimization?; // If the symbol is out of range, produce a relocation and hope the; // linker can handle it. GNU AS produces an error in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:221,error,error,221,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,1,['error'],['error']
Availability,"// If the symbol isn't found, this is probably a legacy plugin, which is an; // error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp,1,['error'],['error']
Availability,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,mask,masking,34,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,"['down', 'mask']","['down', 'masking']"
Availability,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,mask,masked,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"// If the target is M Class then need to validate that the register string; // is an acceptable value, so check that a mask can be constructed from the; // string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:119,mask,mask,119,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// If the target mask is undef/zero then we must zero the element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If the target supports an 'and-not' or 'and-complement' logic operation,; // try to use that to make a comparison operation more efficient.; // But don't do this transform if the mask is a single bit because there are; // more efficient ways to deal with that case (for example, 'bt' on x86 or; // 'rlwinm' on PPC).; // Bail out if the compare operand that we want to turn into a zero is; // already a zero (otherwise, infinite loop).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:182,mask,mask,182,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,"// If the target supports the cmpb instruction, do the idiom recognition here.; // We don't do this as a DAG combine because we don't want to do it as nodes; // are being combined (because we might miss part of the eventual idiom). We; // don't want to do it during instruction selection because we want to reuse; // the logic for lowering the masking operations already part of the; // instruction selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:344,mask,masking,344,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,// If the target was M Class then need to validate the special register value; // and retrieve the mask for use in the instruction node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:99,mask,mask,99,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If the template parameter has pointer type but the address of; // this object was not taken, complain and (possibly) recover by; // taking the address of the entity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:120,recover,recover,120,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:185,error,error,185,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['error'],['error']
Availability,"// If the time between now and when the instruction will be ready can cover; // the spill code, then avoid adding it to the ready queue. This gives long; // stalls highest priority and allows hoisting across calls. It should also; // speed up processing the available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:258,avail,available,258,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,error,error,71,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:150,error,errors,150,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['errors', 'recover']"
Availability,"// If the top level header is expected to be findable at run-time,; // the direct header might not because the include path might be; // different enough and only the top-header is guaranteed to be seen; // by the user as an interface header to be available on the; // run-time include path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoloadCallback.cpp:248,avail,available,248,interpreter/cling/lib/Interpreter/AutoloadCallback.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoloadCallback.cpp,1,['avail'],['available']
Availability,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:266,down,down,266,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['down'],['down']
Availability,"// If the tripcount values are inconsistent, we can't insert the VCTP and; // trigger tail-predication; keep the intrinsic as a get.active.lane.mask; // and legalize this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:144,mask,mask,144,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['mask'],['mask']
Availability,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,redundant,redundant,86,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['redundant'],['redundant']
Availability,"// If the two registers are available, we're all good.; // Note that we only return here if both R0 and R12 are available because; // although the function may not require two unique registers, it may benefit; // from having two so we should try to provide them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,2,['avail'],['available']
Availability,"// If the type hash matches an invalid pattern, mask the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['mask'],['mask']
Availability,"// If the use of an extension results in an error diagnostic, extensions are; // effectively unavailable, so just return false here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['error'],['error']
Availability,// If the user explicitly sets -sve-tail-folding= then treat as an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:67,error,error,67,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['error'],['error']
Availability,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:34,error,error,34,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,4,"['error', 'recover']","['error', 'recover']"
Availability,"// If the user is manually typing in these decorated names, don't echo; // them to the terminal a second time. If they're coming from redirected; // input, however, then we should display the input line so that the; // mangled and demangled name can be easily correlated in the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-undname/llvm-undname.cpp:66,echo,echo,66,interpreter/llvm-project/llvm/tools/llvm-undname/llvm-undname.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-undname/llvm-undname.cpp,1,['echo'],['echo']
Availability,"// If the user passed -Qunused-arguments or there were errors, don't warn; // about any unused arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:55,error,errors,55,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['errors']
Availability,"// If the user passes in a function that we can't take the address of, we; // generally end up emitting really bad error messages. Here, we attempt to; // emit better ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:115,error,error,115,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,redundant,redundant,240,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['redundant'],['redundant']
Availability,"// If the user requested a flag that requires source locations available in; // the backend, make sure that the backend tracks source location information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:63,avail,available,63,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['avail'],['available']
Availability,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:110,error,error,110,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// If the value is naturally an i1, we don't need to mask it. We only know; // if a value is naturally an i1 if it is definitely lowered by FastISel,; // not a DAG ISel fallback.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,1,['mask'],['mask']
Availability,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:80,avail,available,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// If the value isn't available in all predecessors, then there will be; // exactly one where it isn't available. Insert a load on that edge and add; // it to the AvailablePreds list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,3,"['Avail', 'avail']","['AvailablePreds', 'available']"
Availability,"// If the value of the Mask is not 0, we have a constraint in the size of; // the integer argument so here we ensure the argument is a constant that; // is in the valid range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:23,Mask,Mask,23,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Mask'],['Mask']
Availability,"// If the value of the invoke is used outside of its defining block, make it; // available as a virtual register.; // We already took care of the exported value for the statepoint instruction; // during call to the LowerStatepoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:81,avail,available,81,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avail'],['available']
Availability,"// If the value of the load is locally available within the block, just use; // it. This frequently occurs for reg2mem'd allocas.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// If the value operand is divergent, each lane is contributing a different; // value to the atomic calculation. We can only optimize divergent values if; // we have DPP available on our subtarget, and the atomic operation is 32; // bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:170,avail,available,170,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,2,['avail'],['available']
Availability,"// If the value selected is an poison value, explicitly specify it; // with a -1 mask value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,redundant,redundant,215,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['redundant'],['redundant']
Availability,"// If the values are build vectors, we can look through them to find; // equivalent inputs that make the shuffles equivalent.; // TODO: Handle MaskSize != Op.getNumOperands()?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:143,Mask,MaskSize,143,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['MaskSize']
Availability,"// If the variable doesn't have any locations, just ignore it. We don't; // report an error or warning here as that could be noisy on optimised; // code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp:86,error,error,86,interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/SourcePrinter.cpp,1,['error'],['error']
Availability,"// If the vector is scalable, SVE is enabled, implying support for complex; // numbers. Otherwise, we need to ensure complex number support is available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:143,avail,available,143,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// If the xor constant is a demanded mask, do a 'not' before the; // shift:; // xor (X << ShiftC), XorC --> (not X) << ShiftC; // xor (X >> ShiftC), XorC --> (not X) >> ShiftC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,"// If the zero mask is being used with a single input or the zero mask; // overrides the destination lane, this is a shuffle with the zero vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['mask'],['mask']
Availability,"// If there are 3 arguments, it's a masked intrinsic so we need a select.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,mask,masked,36,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['masked']
Availability,"// If there are any forms of this signature available that operate on; // constrained forms of the immediate (e.g., 32-bit sext immediate in a; // 64-bit operand), check them first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp:44,avail,available,44,interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,1,['avail'],['available']
Availability,// If there are any load-<modified> options then turn on flag overrides; // to avoid flag mismatch errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:99,error,errors,99,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['error'],['errors']
Availability,"// If there are any pending errors, report them now. Clients wishing; // to avoid report_fatal_error calls should check for errors with; // has_error() and clear the error flag with clear_error() before; // destructing raw_ostream objects which may have errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:28,error,errors,28,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,4,['error'],"['error', 'errors']"
Availability,"// If there are available intervals that contain the reference point,; // traverse them; otherwise move to the left or right node, depending; // on the middle point value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:16,avail,available,16,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['avail'],['available']
Availability,"// If there are errors before or when releasing the Builder, reset; // the module to stop here before invoking the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp:16,error,errors,16,interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,1,['error'],['errors']
Availability,"// If there are more high registers that need pushing than low registers; // available, push some more low registers so that we can use fewer push; // instructions. This might not reduce RegDeficit all the way to zero,; // because we can only guarantee that r4-r6 are available, but r8-r11 may; // need saving.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:77,avail,available,77,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,2,['avail'],['available']
Availability,"// If there are more operands that weren't in the DAG, they have to; // be operands that have default values, or we have an error. Currently,; // Operands that are a subclass of OperandWithDefaultOp have default values.; // Validate that each result pattern argument has a matching (by name); // argument in the source instruction, in either the (outs) or (ins) list.; // Also check that the type of the arguments match.; //; // Record the mapping of the source to result arguments for use by; // the lowering emitter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp:124,error,error,124,interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,1,['error'],['error']
Availability,"// If there are more than 8 elements in the vector, then any immediate blend; // mask wraps around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,1,['mask'],['mask']
Availability,"// If there are no bits set in the payload, we have to set; // *something* to make it a NaN instead of an infinity;; // conventionally, this is the next bit down from the QNaN bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:157,down,down,157,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['down'],['down']
Availability,"// If there are no instructions available, don't try to issue anything, and; // don't advance the hazard recognizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['avail'],['available']
Availability,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:103,avail,available,103,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['avail'],['available']
Availability,"// If there are registers in the cost vector, but all of them have infinite; // costs, then ... there is no available register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:108,avail,available,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,1,['avail'],['available']
Availability,"// If there are still available units in RR.first,; // then we are done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['avail'],['available']
Availability,"// If there are too many or too few arguments, that's the high-order bit we; // want to sort by, even if the immediate failure kind was something else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:119,failure,failure,119,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['failure'],['failure']
Availability,"// If there are two attempts to define the same mangled name, issue an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:75,error,error,75,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,['error'],['error']
Availability,"// If there are uses of mul result other than the comparison, we know that; // they are truncation or binary AND. Change them to use result of; // mul.with.overflow and adjust properly mask/size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:185,mask,mask,185,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// If there aren't enough stubs available then allocate some more.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,1,['avail'],['available']
Availability,// If there is a DISubprogram for this function available then use it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:48,avail,available,48,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avail'],['available']
Availability,"// If there is a T_XYZW alu available, use it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,1,['avail'],['available']
Availability,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,redundant,redundant,276,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['redundant'],['redundant']
Availability,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,redundant,redundant,93,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['redundant'],['redundant']
Availability,"// If there is a free slot in the source half mask adjacent to one of; // the inputs, place the other input in it. We use (Index XOR 1) to; // compute an adjacent index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If there is a large requested alignment and we can, bump up the alignment; // of the global. If the memory we set aside for the global may not be the; // memory used by the final program then it is impossible for us to reliably; // enforce the preferred alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:222,reliab,reliably,222,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['reliab'],['reliably']
Availability,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// If there is a string table, then the buffer must contain at least 4 bytes; // for the string table's size. Not having a string table is not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:146,error,error,146,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,1,['error'],['error']
Availability,// If there is a subprogram for this function available then use it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:46,avail,available,46,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['avail'],['available']
Availability,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:26,avail,available,26,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['avail'],['available']
Availability,"// If there is a word P in Worklist that matches multiple possibilities,; // then if any other word Q matches any of the possibilities matched by P,; // then Q matches all the possibilities matched by P. In fact, P == Q.; // In other words, for each words P, Q, the sets of possibilities matched; // by P and Q are either equal or disjoint (no partial overlap).; //; // Illustration: For 4-bit values there are 4 complete sequences:; // a: 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1; // b: 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1; // c: 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1; // d: 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1; //; // Words containing unknown bits that match two of the complete; // sequences:; // ab: 0 u u 1 0 u u 1 0 u u 1 0 u u 1; // ac: 0 u 0 u u 1 u 1 0 u 0 u u 1 u 1; // ad: 0 u 0 u 0 u 0 u u 1 u 1 u 1 u 1; // bc: 0 0 u u u u 1 1 0 0 u u u u 1 1; // bd: 0 0 u u 0 0 u u u u 1 1 u u 1 1; // cd: 0 0 0 0 u u u u u u u u 1 1 1 1; //; // Proof of the claim above:; // Let P be a word that matches s0 and s1. For that to happen, all known; // bits in P must match s0 and s1 exactly.; // Assume there is Q that matches s1. Note that since P and Q came from; // the same shuffle mask, the positions of unknown bits in P and Q match; // exactly, which makes the indices of known bits be exactly the same; // between P and Q. Since P matches s0 and s1, the known bits of P much; // match both s0 and s1. Also, since Q matches s1, the known bits in Q; // are exactly the same as in s1, which means that they are exactly the; // same as in P. This implies that P == Q.; // There can be a situation where there are more entries with the same; // bits set than there are set bits (e.g. value 9 occuring more than 2; // times). In such cases it will be impossible to complete this to a; // perfect shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:1159,mask,mask,1159,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// If there is already a pragma handler with the name of this namespace,; // we either have an error (directive with the same name as a namespace) or; // we already have the namespace to insert into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['error']
Availability,"// If there is an error in hasSymbols(), the error should be encountered in; // function getSymbolNamesFromObject first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:18,error,error,18,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,2,['error'],['error']
Availability,"// If there is an error or there are no lines, just return the; // empty vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp:18,error,error,18,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,1,['error'],['error']
Availability,// If there is an existing availability attribute for this platform that; // has a lower priority use the existing one and discard the new; // attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:27,avail,availability,27,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['avail'],['availability']
Availability,"// If there is another one available, set the second scratch register to that.; // Otherwise, set it to either PPC::NoRegister if this function requires two; // or to whatever SR1 is set to if this function doesn't require two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,"// If there is at least one register remaining, pick the first one,; // and consolidate the masks of all of its units contained in this; // aggregate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp:92,mask,masks,92,interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp,1,['mask'],['masks']
Availability,"// If there is enough room in the type to upscale the LHS or downscale the; // RHS before the division, we can perform it in this type without having to; // resize. For signed operations, the LHS headroom is the number of; // redundant sign bits, and for unsigned ones it is the number of zeroes.; // The headroom for the RHS is the number of trailing zeroes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:61,down,downscale,61,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,"['down', 'redundant']","['downscale', 'redundant']"
Availability,"// If there is no CNT instruction available, GPR popcount can; // be more efficiently lowered to the following sequence that uses; // AdvSIMD registers/instructions as long as the copies to/from; // the AdvSIMD registers are cheap.; // FMOV D0, X0 // copy 64-bit int to vector, high bits zero'd; // CNT V0.8B, V0.8B // 8xbyte pop-counts; // ADDV B0, V0.8B // sum 8xbyte pop-counts; // UMOV X0, V0.B[0] // copy byte result back to integer reg",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:76,error,error,76,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,recover,recover,103,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['recover'],['recover']
Availability,"// If there is no declaration, there was an error parsing it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['error'],['error']
Availability,"// If there is no declaration, there was an error parsing it. Ignore it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If there is no declaration, there was an error parsing it. Just ignore it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If there is no declaration, there was an error parsing it. Just ignore; // the initializer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// If there is no error but the content pointer is null then this is a; // zero-fill symbol/section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:18,error,error,18,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['error'],['error']
Availability,"// If there is no initializer, either this is a VLA or an error has; // occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:58,error,error,58,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error']
Availability,// If there is no line table we will have created an error in the; // .debug_info verifier or in verifyDebugLineStmtOffsets().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:53,error,error,53,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['error']
Availability,"// If there is no red zone, ScratchReg may be needed for holding a useful; // value (although not the base register). Make sure it is not overwritten; // too early.; // If we need to restore both the LR and the CR and we only have one; // available scratch register, we must do them one at a time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:239,avail,available,239,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,"// If there is no space, an error message is shown:; // Error in <TString::AssertElement>: out of bounds: i = -1, Length = 0; // If there is no function selected, then put nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:28,error,error,28,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:156,down,downward,156,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['down'],['downward']
Availability,"// If there is one use and it can splat the value, prefer that operation.; // TODO: This could be expanded to more operations if they reliably use the; // index variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:134,reliab,reliably,134,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reliab'],['reliably']
Availability,"// If there is only one use of save exec register and that use is SI_END_CF,; // we can optimize SI_IF by returning the full saved exec mask instead of; // just cleared bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:136,mask,mask,136,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,"// If there is support for an i1 vector mask (or only scalar i1 conditions),; // don't touch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,"// If there is support for an i1 vector mask, don't touch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,"// If there was a semantic or parse error earlier with the; // operand, fail now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:36,error,error,36,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,"// If there was a tail-folding hint/switch, but we can't fold the tail by; // masking, fallback to a vectorization with a scalar epilogue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,mask,masking,78,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['mask'],['masking']
Availability,"// If there was already an existing matching node, use ReplaceAllUsesWith; // to replace the dead one with the existing one. This can cause; // recursive merging of other unrelated nodes down the line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:187,down,down,187,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['down'],['down']
Availability,"// If there was an error coming from the transformers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:19,error,error,19,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['error'],['error']
Availability,"// If there was an error creating the selected interpreter, quit with error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,2,['error'],['error']
Availability,"// If there was an error evaluating the RHS, return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['error'],['error']
Availability,// If there was an error in the construction of the Header; // then just return with the error now set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,2,['error'],['error']
Availability,// If there was an error loading the file then skip it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['error'],['error']
Availability,"// If there was an error parsing parenthesized declarator, declarator; // scope may have been entered before. Don't do it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If there was an error parsing the arguments, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['error'],['error']
Availability,"// If there was an error parsing the arguments, they may have; // tried to use ^(x+y) which requires an argument list. Just; // skip the whole block literal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// If there was an error parsing the replacement item, treat it as an; // invalid replacement spec, and just continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormatVariadic.cpp,1,['error'],['error']
Availability,// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:19,error,error,19,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,1,['error'],['error']
Availability,"// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/cling.cpp:19,error,error,19,interpreter/cling/tools/driver/cling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/cling.cpp,1,['error'],['error']
Availability,// If there was an error then fail the query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If there was an error, or there's nothing left to evaluate, return the; // result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,1,['error'],['error']
Availability,"// If there was an error, return the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,2,['error'],['error']
Availability,"// If there was no explicit type bound (or we removed it due to an error),; // use 'id' instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,error,error,67,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:107,error,error,107,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,7,['error'],['error']
Availability,"// If there were any buckets with invalid values, skip further checks as they; // will likely produce many errors which will only confuse the actual root; // problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:107,error,errors,107,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['errors']
Availability,"// If there were any errors while handling and emitting the label,; // early return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:21,error,errors,21,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['error'],['errors']
Availability,"// If there were errors building the compilation, quit now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:17,error,errors,17,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,3,['error'],['errors']
Availability,"// If there were errors in processing arguments, don't do anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:17,error,errors,17,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,1,['error'],['errors']
Availability,"// If there were errors, disable 'unused' warnings since they will mostly be; // noise. Don't warn for a use from a module: either we should warn on all; // file-scope declarations in modules or not at all, but whether the; // declaration is used is immaterial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,error,errors,17,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['errors']
Availability,// If there were extra definitions then report the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:51,error,error,51,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['error'],['error']
Availability,// If there were missing symbols then report the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:49,error,error,49,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['error'],['error']
Availability,"// If there were no errors commit the transaction, cancel it otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:20,error,errors,20,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['error'],['errors']
Availability,"// If there were unreachable blocks shift everything down, and delete them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:53,down,down,53,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['down'],['down']
Availability,"// If there's a G_AND feeding into this branch, try to fold it away by; // emitting a TB(N)Z instead.; //; // Note: If we have LT, then it *is* possible to fold, but it wouldn't be; // beneficial. When we have an AND and LT, we need a TST/ANDS, so folding; // would be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:269,redundant,redundant,269,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['redundant'],['redundant']
Availability,// If there's already an error then bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,1,['error'],['error']
Availability,// If there's an error then bail out here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,1,['error'],['error']
Availability,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,redundant,redundant,55,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,"// If there's no previous declaration, AND this isn't attempting to cause; // multiversioning, this isn't an error condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If this RooAbsReal is a RooRealVar in the fit result, we don't need to; // propagate anything and can just return the error in the fit result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:121,error,error,121,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['error'],['error']
Availability,"// If this VSELECT has a vector if i1 as a mask, it will be directly matched; // with patterns on the mask registers on AVX-512.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// If this a GPR ZEXT that we want to just reduce down into a copy.; // The sizes will be mismatched with the source < 32b but that's ok.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:50,down,down,50,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['down'],['down']
Availability,// If this address is not associated with a compile callback then report an; // error to the execution session and return ErrorHandlerAddress to the; // callee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,2,"['Error', 'error']","['ErrorHandlerAddress', 'error']"
Availability,"// If this allocation function is not declared as non-throwing, failures; // /must/ be signalled by exceptions, and thus the return value will never; // be NULL. -fno-exceptions does not influence this semantics.; // FIXME: GCC has a -fcheck-new option, which forces it to consider the case; // where new can return NULL. If we end up supporting that option, we can; // consider adding a check for it here.; // C++11 [basic.stc.dynamic.allocation]p3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:64,failure,failures,64,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,2,['failure'],['failures']
Availability,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,redundant,redundant,161,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redundant'],['redundant']
Availability,"// If this block is 'Cleared', then nothing LiveIn to this block can be; // available after this block completes. Note: This turns out to be; // really important for reducing memory consuption of the initial available; // sets and thus peak memory usage by this verifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['avail'],['available']
Availability,"// If this block's live-in value is a VPHI, try to pick a machine-value; // for it. This makes the machine-value available and propagated; // through all blocks by the time value propagation finishes. We can't; // do this any earlier as it needs to read the block live-outs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,avail,available,113,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,"// If this call requires more stack than we have available from; // LowerFormalArguments, tell FrameLowering to reserve space for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// If this feature is currently available, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:32,avail,available,32,interpreter/llvm-project/clang/lib/Basic/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp,1,['avail'],['available']
Availability,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:261,avail,available,261,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['avail'],['available']
Availability,"// If this identifier was poisoned and from a paste, emit an error. This; // won't be handled by Preprocessor::HandleIdentifier because this is coming; // from a macro expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:61,error,error,61,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['error'],['error']
Availability,"// If this identifier was poisoned, and if it was not produced from a macro; // expansion, emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:99,error,error,99,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['error'],['error']
Availability,"// If this is ""((X & C) == 0) ? Y : Z"" and C is a constant mask vector of; // single bits, then invert the predicate and swap the select operands.; // This can lower using a vector shift bit-hack rather than mask and compare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If this is ""store (or X, Y), P"" and X is ""(and (load P), cst)"", where cst; // is a byte mask indicating a consecutive number of bytes, check to see if; // Y is known to provide just those bytes. If so, we try to replace the; // load + replace + store sequence with a single (narrower) store, which makes; // the load dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,mask,mask,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,redundant,redundant,98,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['redundant'],['redundant']
Availability,"// If this is 'and (uunpklo/hi (extload MemTy -> ExtTy)), mask', then check; // to see if the mask is all-ones of size MemTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If this is a ## token, change its kind to unknown so that repreprocessing; // it will not produce an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:104,error,error,104,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,1,['error'],['error']
Availability,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,error,error,57,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,3,['error'],['error']
Availability,"// If this is a #else with a #else before it, report the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,error,error,57,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,['error'],['error']
Availability,"// If this is a 64-bit zero-extension mask, emit rldicl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,redundant,redundant,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,"// If this is a TRUNC followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.; // TODO: Try combine to masked compress store if possiable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,mask,masked,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['mask'],['masked']
Availability,"// If this is a UZP1 followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:35,mask,masked,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['mask'],['masked']
Availability,"// If this is a big-endian system, we need to shift the value down to the low; // bits so that a truncate will work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:62,down,down,62,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['down'],['down']
Availability,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,down,down,240,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,"// If this is a canonical idempotent atomicrmw w/no uses, we have a better; // lowering available in lowerAtomicArith.; // TODO: push more cases through this path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,avail,available,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If this is a chain call, we need to pass in the EXEC mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['mask'],['mask']
Availability,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Recover,Recover,100,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['Recover'],['Recover']
Availability,"// If this is a friend function defined in a class template, it does not; // have a body until it is used, nevertheless it is a definition, see; // [temp.inst]p2:; //; // ... for the purpose of determining whether an instantiated redeclaration; // is valid according to [basic.def.odr] and [class.mem], a declaration that; // corresponds to a definition in the template is considered to be a; // definition.; //; // The following code must produce redefinition error:; //; // template<typename T> struct C20 { friend void func_20() {} };; // C20<int> c20i;; // void func_20() {}; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:461,error,error,461,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['error'],['error']
Availability,"// If this is a leader that is always available, and it's a; // constant or has no equivalences, just replace everything with; // it. We then update the congruence class with whatever members; // are left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:38,avail,available,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avail'],['available']
Availability,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['avail'],['available']
Availability,"// If this is a load on a phi pointer, phi-translate it and search; // for available load/store to the pointer in predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:75,avail,available,75,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['mask'],['mask']
Availability,"// If this is a mask reg operation, it only cares about VLMAX.; // TODO: Possible extensions to this logic; // * Probably ok if available VLMax is larger than demanded; // * The policy bits can probably be ignored..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// If this is a masked load followed by an UUNPKLO, fold this into a masked; // extending load. We can do this even if this is already a masked; // {z,}extload.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:16,mask,masked,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['mask'],['masked']
Availability,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, compressing, or truncating stores?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,mask,masked,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,mask,masked,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// If this is a module entry function, we can also sanity check against; // the static frame. Strictly it would be better to check against the; // attribute, i.e. that the variable is within the always-allocated; // section, and not within some other non-absolute-address object; // allocated here, but the extra error detection is minimal and we would; // have to pass the Function around or cache the attribute value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp:313,error,error,313,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,1,['error'],['error']
Availability,"// If this is a negated 64-bit zero-extension mask,; // i.e. the immediate is a sequence of ones from most significant side; // and all zero for reminder, we should use rldicr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Availability,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:30,recover,recover,30,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recover']
Availability,"// If this is a register mask operand, clobber all debug values in; // non-CSRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,1,['mask'],['mask']
Availability,"// If this is a scalar LLVM value then assume LLVM will pass it in the right; // place naturally.; //; // This assumption is optimistic, as there could be free registers available; // when we need to pass this argument in memory, and LLVM could try to pass; // the argument in the free register. This does not seem to happen currently,; // but this code would be much safer if we could mark the argument with; // 'onstack'. See PR12193.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:170,avail,available,170,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"// If this is a scalar to vector to v1i1 from an AND with 1, bypass the and.; // This occurs frequently in our masked scalar intrinsic code and our; // floating point select lowering with AVX512.; // TODO: SimplifyDemandedBits instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:111,mask,masked,111,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,redundant,redundant,64,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,"// If this is a store through Ptr, the value is available!; // (This is true even if the store is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:48,avail,available,48,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['avail'],['available']
Availability,// If this is a strong definition then error out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:39,error,error,39,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:234,down,down,234,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['down'],['down']
Availability,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:240,mask,mask,240,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,recover,recover,97,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Availability,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,recover,recover,78,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Availability,"// If this is an 'and R, 1234' where the operation is AND/OR and the RHS is; // a constant without a predicate fn that has more than one bit set, handle; // this as a special case. This is usually for targets that have special; // handling of certain large constants (e.g. alpha with it's 8/16/32-bit; // handling stuff). Using these instructions is often far more efficient; // than materializing the constant. Unfortunately, both the instcombiner; // and the dag combiner can often infer that bits are dead, and thus drop; // them from the mask in the dag. For example, it might turn 'AND X, 255'; // into 'AND X, 254' if it knows the low bit is set. Emit code that checks; // to handle this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:542,mask,mask,542,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['mask'],['mask']
Availability,"// If this is an 'and' with a mask, try to emit rlwinm/rldicl/rldicr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If this is an AND, check if we have a compare on either side. As long as; // one side guarantees the mask is zero extended, the AND will preserve those; // zeros.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If this is an FP_ROUND followed by a store, fold this into a truncating; // store. We can do this even if this is already a truncstore.; // We purposefully don't care about legality of the nodes here as we know; // they can be split down into something legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:236,down,down,236,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['down'],['down']
Availability,"// If this is an and of a value rotated between 0 and 31 bits and then and'd; // with a mask, emit rlwinm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// If this is an extending load and the mask type is not the same as; // load's type then we have to extend the mask type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If this is an extension, perform the shift now that the storage is; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:74,avail,available,74,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avail'],['available']
Availability,"// If this is an implicit member reference and we find a; // non-instance member, it's not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:94,error,error,94,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['error'],['error']
Availability,"// If this is an output operand with a matching input operand, look up the; // matching input. If their types mismatch, e.g. one is an integer, the; // other is floating point, or their sizes are different, flag it as an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:225,error,error,225,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['error'],['error']
Availability,"// If this is just a masked value where the input is not handled, and; // is not a rotate-left (handled by a pattern in the .td file), emit rlwinm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,mask,masked,21,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,redundant,redundant,19,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['redundant'],['redundant']
Availability,"// If this is not a note, and we're in a template instantiation; // that is different from the last template instantiation where; // we emitted an error, print a template instantiation; // backtrace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:147,error,error,147,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// If this is not a typedef name, don't parse it as part of the declspec,; // it must be an implicit int or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If this is not a variadic macro, and too many args were specified, emit; // an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:82,error,error,82,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,2,['error'],['error']
Availability,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,error,error,54,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,28,['error'],['error']
Availability,"// If this is specified to be in a namespace, step down into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:51,down,down,51,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,2,['down'],['down']
Availability,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:137,error,error,137,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['error'],['error']
Availability,"// If this is the end of the buffer, we have an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:48,error,error,48,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,"// If this is the root of the dag we're matching, we emit a redundant opcode; // check to ensure that this gets folded into the normal top-level; // OpcodeSwitch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:60,redundant,redundant,60,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,2,['redundant'],['redundant']
Availability,"// If this is the second of two arguments, it must be the error code. It; // appears first on the stack, and is then followed by the five slot; // interrupt struct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:58,error,error,58,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['error'],['error']
Availability,"// If this is zero masking instruction with a tied operand, we need to; // move the first index back to the first input since this must; // be a 3 input instruction and we want the first two non-mask inputs.; // Otherwise this is a 2 input instruction with a preserved input and; // mask, so we need to move the indices to skip one more input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:19,mask,masking,19,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,3,['mask'],"['mask', 'masking']"
Availability,"// If this isn't an aggregate type, there is nothing we can do to drill down; // and find a bitcastable constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:72,down,down,72,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['down'],['down']
Availability,"// If this isn't an identifier, report the error and skip until ')'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,error,error,43,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If this lane has two sources, see if it fits with the repeat mask so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,redundant,redundant,57,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['redundant'],['redundant']
Availability,// If this node generates masked gather load then it is not a terminal node.; // Hence address operand cost is estimated separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,mask,masked,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masked']
Availability,"// If this not a file or a block device (e.g. it's a named pipe; // or character device), we can't mmap it, so error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:111,error,error,111,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['error'],['error']
Availability,"// If this occurs outside a template instantiation, warn the user about; // it; they probably didn't mean to specify a redundant qualifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:119,redundant,redundant,119,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redundant'],['redundant']
Availability,"// If this packet contains an instruction that bars slot-1 stores,; // we should mask off slot 1 from all of the store instructions in; // this packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['mask'],['mask']
Availability,"// If this returned as a missing feature failure, remember that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:41,failure,failure,41,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,3,['failure'],['failure']
Availability,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:115,mask,mask,115,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,3,['mask'],['mask']
Availability,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,3,"['down', 'mask']","['down', 'mask']"
Availability,// If this symbol dependended on any symbols in the error state then move; // this symbol to the error state too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:52,error,error,52,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['error'],['error']
Availability,"// If this token isn't valid, report the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:41,error,error,41,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,2,['error'],['error']
Availability,"// If this undef block is dominated by any predecessor(before; // structurization) of reconstructed PHI with constant incoming value,; // don't mark the available value as undefined. Setting undef to such; // block will stop us from getting optimal phi insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:153,avail,available,153,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['avail'],['available']
Availability,// If this unnamed complete type is already in the process of being defined; // then the description of the type is malformed and cannot be emitted; // into CodeView correctly so report a fatal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:194,error,error,194,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['error'],['error']
Availability,"// If this value didn't fit into uintmax_t, error and force to ull.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// If this was an error, refuse to perform any rewriting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,1,['error'],['error']
Availability,"// If this was the only error, then don't let it stop anything",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:24,error,error,24,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['error'],['error']
Availability,"// If this wasn't a cache hit, we hit a clobber when walking. That's a; // failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:75,failure,failure,75,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['failure'],['failure']
Availability,"// If this would require more than 2 unpack instructions to expand, use; // pshufb when available. We can only use more than 2 unpack instructions; // when zero extending i8 elements which also makes it easier to use pshufb.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,avail,available,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If too few arguments are available (and we don't have default; // arguments for the remaining parameters), don't make the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,avail,available,28,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avail'],['available']
Availability,"// If too few arguments are available, we'll fill in the rest with defaults.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,avail,available,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avail'],['available']
Availability,"// If too many are passed and not variadic, error on the extras and drop; // them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// If treeName is yet empty, error occurs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:29,error,error,29,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['error'],['error']
Availability,"// If trimming results in zero error, restore default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:31,error,error,31,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['error'],['error']
Availability,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:22,redundant,redundant,22,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,2,['redundant'],['redundant']
Availability,// If turning on conversion for stderr fails then the error message; // may be garbled. There is no solution to this problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp:54,error,error,54,interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,1,['error'],['error']
Availability,"// If user just wants to list available options, skip module loading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:30,avail,available,30,interpreter/llvm-project/llvm/tools/llc/llc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp,1,['avail'],['available']
Availability,"// If using a SETCC would result in a different type than the mask type,; // unroll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// If value is passed by pointer we have address passed instead of the value; // itself. No need to extend if the mask value and location share the same; // absolute size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:114,mask,mask,114,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,"// If vec width < 512, widen i8/i16 even with BWI as blendd/blendps/blendpd; // are preferable to blendw/blendvb/masked-mov.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,mask,masked-mov,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked-mov']
Availability,"// If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['mask'],"['mask', 'maskedoff']"
Availability,"// If vr is not alive in any block, then defaults to dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:16,alive,alive,16,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['alive'],['alive']
Availability,"// If w or h are much larger than the window size, there is probably no need; // to draw it. Moreover a to large text size may produce a Seg Fault in; // malloc in RenderString.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx:141,Fault,Fault,141,graf2d/x11ttf/src/TGX11TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx,1,['Fault'],['Fault']
Availability,"// If warnings are disabled with the current verbosity settings, lower; // it so that the user sees the warning that caused the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:128,failure,failure,128,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['failure'],['failure']
Availability,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,recover,recovery,74,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Availability,"// If we already have a scale of this value, we can add to it, otherwise, we; // need an available scale field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avail'],['available']
Availability,"// If we already have a string, error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp:32,error,error,32,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,1,['error'],['error']
Availability,"// If we are comparing (and (shr X, C, Mask) with 0, emit a BEXTR followed; // by a test instruction. The test should be removed later by; // analyzeCompare if we are using only the zero flag.; // TODO: Should we check the users and use the BEXTR flags directly?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:39,Mask,Mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// If we are enabling this feature, just set the diagnostic mappings to map to; // errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:83,error,errors,83,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,1,['error'],['errors']
Availability,"// If we are enabling this feature, just set the diagnostic mappings to map to; // fatal errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:89,error,errors,89,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,1,['error'],['errors']
Availability,"// If we are extracting from 2 different indexes, then one operand must be; // shuffled before performing the vector operation. The shuffle mask is; // poison except for 1 lane that is being translated to the remaining; // extraction lane. Therefore, it is a splat shuffle. Ex:; // ShufMask = { poison, poison, 0, poison }; // TODO: The cost model has an option for a ""broadcast"" shuffle; // (splat-from-element-0), but no option for a more general splat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:140,mask,mask,140,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,"// If we are in a operator context, convert it back into a type specifier; // context for better error handling later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:97,error,error,97,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If we are in a pixel shader, because of how we have to mask out helper; // lane invocations, we need to record the entry and exit BB's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['mask'],['mask']
Availability,"// If we are in a system header, we ignore it. We look at the diagnostic class; // because we also want to ignore extensions and warnings in -Werror and; // -pedantic-errors modes, which *map* warnings/extensions to errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:167,error,errors,167,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,['error'],['errors']
Availability,"// If we are initializing an anonymous union field, drill down to the field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:58,down,down,58,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['down'],['down']
Availability,"// If we are inserting whole bytes, we can convert this to a shuffle.; // Lowering can recognize EXTRQI shuffle masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:112,mask,masks,112,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['masks']
Availability,"// If we are inserting whole bytes, we can convert this to a shuffle.; // Lowering can recognize INSERTQI shuffle masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:114,mask,masks,114,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['masks']
Availability,"// If we are linking an image for multiple archs then the linker wants; // -arch_multiple and -final_output <final image name>. Unfortunately, this; // doesn't fit in cleanly because we have to pass this information down.; //; // FIXME: This is a hack; find a cleaner way to integrate this into the; // process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:216,down,down,216,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['down'],['down']
Availability,"// If we are loading the first and last elements of a vector, it is safe and; // always faster to load the whole vector. Replace the masked load with a; // vector load and select.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,mask,masked,133,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,"// If we are masking the result of the add down to exactly one bit and; // the constant we are adding has no bits set below that bit, then the; // add is flipping a single bit. Example:; // (X + 4) & 4 --> (X & 4) ^ 4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,mask,masking,13,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,"['down', 'mask']","['down', 'masking']"
Availability,"// If we are performing substituting explicitly-specified template arguments; // or deduced template arguments into a function template and we reach this; // point, we are now past the point where SFINAE applies and have committed; // to keeping the new function template specialization. We therefore; // convert the active template instantiation for the function template; // into a template instantiation for this specific function template; // specialization, which is not a SFINAE context, so that we diagnose any; // further errors in the declaration itself.; //; // FIXME: This is a hack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:530,error,errors,530,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['errors']
Availability,"// If we are pointed to real data, Start is not a nullptr, then there must be; // a non-null Err pointer available to report malformed data on. Only in; // the case sentinel value is being constructed is Err is permitted to be a; // nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:105,avail,available,105,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['avail'],['available']
Availability,"// If we are rotating by the exact number of bits as are in the mask; // and the mask is in the least significant bits of the register,; // that's just an andis. (as long as the GPR result has no uses).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['mask'],['mask']
Availability,// If we are shuffling a splat (and not introducing zeros) then we can just; // use it directly. This works for smaller elements as well as they already; // repeat across each mask element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:176,mask,mask,176,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we are stress testing VPlan builds, do not attempt to generate vector; // code. Masked vector code generation support will follow soon.; // Also, do not attempt to vectorize if no vector code will be produced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:86,Mask,Masked,86,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Mask'],['Masked']
Availability,"// If we are subtracting a low-bit masked subset of some value from an add; // of that same value with no low bits changed, that is clearing some low bits; // of the sum:; // sub (X + AddC), (X & AndC) --> and (X + AddC), ~AndC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:35,mask,masked,35,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['mask'],['masked']
Availability,"// If we are supposed to rebuild the global module index, do so now unless; // there were any module-build failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:107,failure,failures,107,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['failure'],['failures']
Availability,// If we are tail calling and generating PIC/GOT style code load the; // address of the callee into ECX. The value in ecx is used as target of; // the tail jump. This is done to circumvent the ebx/callee-saved problem; // for tail calls on PIC/GOT architectures. Normally we would just put the; // address of GOT into ebx and then call target@PLT. But for tail calls; // ebx would be restored (since ebx is callee saved) before jumping to the; // target@PLT.; // Note: The actual moving to ECX is done further down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:510,down,down,510,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['down'],['down']
Availability,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,mask,masking,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,3,['mask'],"['mask', 'masking']"
Availability,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:129,error,error,129,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['error'],['error']
Availability,"// If we aren't changing the mask, just return true to keep it and prevent; // the caller from optimizing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we asked for a non-typename and we got a type, error out,; // but only if this is an instantiation of an unresolved using; // decl. Otherwise just silently find the type name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,error,error,53,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// If we asked for a typename and got a non-type decl, error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:55,error,error,55,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// If we can prove that the current context is unrelated to all the; // declaring classes, it can't be an implicit member reference (in; // which case it's an error if any of those members are selected).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:159,error,error,159,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['error'],['error']
Availability,"// If we can shrink the constant mask below 8-bits or 32-bits, then this; // transform should reduce code size. It may also enable secondary transforms; // from improved known-bits analysis or instruction selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we can't construct the EVL mask efficiently, it's better to unroll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,"// If we can't make use of BEXTR then we can't fuse shift+mask stages.; // Let's perform the mask first, and apply shift later. Note that we need to; // widen the mask to account for the fact that we'll apply shift afterwards!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,3,['mask'],['mask']
Availability,"// If we can, perform BSWAP first and then the mask+swap the i4, then i2; // and finally the i1 pairs.; // TODO: We can easily support i4/i2 legal types if any target ever does.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['mask'],['mask']
Availability,"// If we cannot find a must-alias with any of the existing MemoryLocs, we; // must downgrade to may-alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:83,down,downgrade,83,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,1,['down'],['downgrade']
Availability,"// If we consumed the entire line, tell MC that.; // Also do this if we consumed nothing as a way of reporting failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:111,failure,failure,111,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['failure'],['failure']
Availability,"// If we couldn't create it as a glob, report the error, but try again; // with a literal if the error reporting is non-fatal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/CommonConfig.cpp:50,error,error,50,interpreter/llvm-project/llvm/lib/ObjCopy/CommonConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/CommonConfig.cpp,2,['error'],['error']
Availability,"// If we couldn't find an existing region to construct into, assume we're; // constructing a temporary. Notify the caller of our failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:129,failure,failure,129,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['failure'],['failure']
Availability,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,recover,recover,18,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['recover'],['recover']
Availability,"// If we didn't find a use of this identifier, the ExternalSource; // may be able to handle the situation.; // Note: some lookup failures are expected!; // See e.g. R.isForRedeclaration().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:129,failure,failures,129,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['failure'],['failures']
Availability,// If we didn't find anything conclusive (neither definitely alive or; // definitely dead) return whether it lives into the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:61,alive,alive,61,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['alive'],['alive']
Availability,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:123,error,error,123,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['error'],['error']
Availability,"// If we didn't pre-compute the expected return address into a register, then; // red zones are enabled and the return address is still available on the; // stack immediately after the call. As the very first instruction, we load it; // into a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:136,avail,available,136,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avail'],['available']
Availability,"// If we didn't relocate a value, we'll essentialy end up inserting an; // additional use of the original value when lowering the gc.relocate.; // We need to make sure the value is available at the new use, which; // might be in another block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:181,avail,available,181,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['avail'],['available']
Availability,"// If we didn't remove all poisoned instructions, it's a hard error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:62,error,error,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['error'],['error']
Availability,"// If we didn't see any strict differences, we won't see any loose; // differences. In ARC, however, we also need to check for loose; // mismatches, because most of them are errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:174,error,errors,174,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['errors']
Availability,// If we don't have PSHUFB then its worth avoiding an AND constant mask; // by performing 3 byte shifts. Shuffle combining can kick in above that.; // TODO: There may be some cases where VSH{LR}DQ+PAND is still better.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we don't have SSE2 available, convert to v4f32 so the generated; // register is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:25,avail,available,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['avail'],['available']
Availability,"// If we don't have a comma, it is either the end of the list (a ';') or an; // error, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If we don't have a comma, it is either the end of the list (a ';') or; // an error, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['error'],['error']
Availability,"// If we don't have a comma, it is either the end of the list (a ';'); // or an error, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['error'],['error']
Availability,"// If we don't have a constant dimension length, we have to consider; // the current section as having any size, so it is not necessarily; // unitary. If it happen to be unity size, that's user fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:194,fault,fault,194,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['fault'],['fault']
Availability,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,failure,failure,52,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['failure'],['failure']
Availability,// If we don't have a module then just exit now. We do this down; // here since the CPU/Feature help is underneath the target machine; // creation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:60,down,down,60,interpreter/llvm-project/llvm/tools/llc/llc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp,1,['down'],['down']
Availability,"// If we don't have a pp-identifier now, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:52,error,error,52,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['error'],['error']
Availability,"// If we don't have any valid available info, wait until we do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:30,avail,available,30,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,"// If we don't have chaining, the mask could still include r11,; // expressed as part of IntRegs Instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['mask'],['mask']
Availability,"// If we don't have enough horizontal space to accomodate the minimum table; // width, then try to move down past some obstruction (such as an; // <IMG ALIGN=LEFT>) to give us more room.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:104,down,down,104,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['down'],['down']
Availability,"// If we don't have enough to output NumRemaining, output only what's available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp:70,avail,available,70,core/textinput/src/textinput/TerminalDisplay.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp,1,['avail'],['available']
Availability,"// If we don't have red zones, we need to compute the expected return; // address prior to the call and store it in a register that lives across; // the call.; //; // In some ways, this is doubly satisfying as a mitigation because it will; // also successfully detect stack smashing bugs in some cases (typically,; // when a callee-saved register is used and the callee doesn't push it onto; // the stack). But that isn't our primary goal, so we only use it as; // a fallback.; //; // FIXME: It isn't clear that this is reliable in the face of; // rematerialization in the register allocator. We somehow need to force; // that to not occur for this particular instruction, and instead to spill; // or otherwise preserve the value computed *prior* to the call.; //; // FIXME: It is even less clear why MachineCSE can't just fold this when we; // end up having to use identical instructions both before and after the; // call to feed the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:520,reliab,reliable,520,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['reliab'],['reliable']
Availability,"// If we don't import specialization, they are not available via lookup; // because the lookup result is imported TemplateDecl and it does not; // reference its specializations until they are imported explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:51,avail,available,51,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,1,['avail'],['available']
Availability,"// If we don't know the precise trip count, or if the trip count that we; // found modulo the vectorization factor is not zero, try to fold the tail; // by masking.; // FIXME: look for a smaller MaxVF that does divide TC rather than masking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,mask,masking,156,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['mask'],['masking']
Availability,"// If we don't know the trip count, but have reason to believe the average; // trip count is low, peeling should be beneficial, since we will usually; // hit the peeled section.; // We only do this in the presence of profile information, since otherwise; // our estimates of the trip count are not reliable enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:298,reliab,reliable,298,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['reliab'],['reliable']
Availability,"// If we don't recognize the option passed to the .nan; // directive (e.g. no option or unknown option), emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:113,error,error,113,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// If we effectively only demand the 0'th element of \p Input, and not only; // as 0'th element, then broadcast said input,; // and change \p InputMask to be a no-op (identity) mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:177,mask,mask,177,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// If we encountered an error while filtering generation candidates then; // bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:24,error,error,24,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If we end up changing the VL or mask of True, then we need to make sure it; // doesn't raise any observable fp exceptions, since changing the active; // elements will affect how fflags is set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If we end up repairing twice at the same place before materializing the; // insertion point, we may think we have to split an edge twice.; // We should have a factory for the insert point such that identical points; // are the same instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,repair,repairing,16,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// If we end up using the vmerge mask the vmerge is actually a vmv.v.v, create; // an all-ones mask to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// If we failed print error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:22,error,error,22,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['error'],['error']
Availability,"// If we find an IT instruction, we need to parse its condition; // code and mask operands so that we can apply them correctly; // to the subsequent instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:77,mask,mask,77,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['mask'],['mask']
Availability,"// If we found an available value, ensure that the instructions in between; // did not modify the memory location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['avail'],['available']
Availability,"// If we found bad indices but no other errors, try doing another pass and see; // if we can resolve the indices that weren't in the map on the first pass.; // This may require multiple passes, but we should always make progress. MASM; // is the only known CodeView producer that makes type streams that aren't; // topologically sorted. The standard library contains MASM-produced objects,; // so this is important to handle correctly, but we don't have to be too; // efficient. MASM type streams are usually very small.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:40,error,errors,40,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['error'],['errors']
Availability,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:201,down,downgrade,201,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,2,"['down', 'error']","['downgrade', 'error']"
Availability,"// If we found elements, we emit an error if none of those were for the host; // in case host bundle name was provided in command line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp:36,error,error,36,interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,1,['error'],['error']
Availability,"// If we gave up at the completion point, the initializer list was; // likely truncated, so don't eat more tokens. We'll hit some extra; // errors, but they should be ignored in code completion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:140,error,errors,140,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['error'],['errors']
Availability,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Recover,Recover,68,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Availability,"// If we get here then we've finished searching all JITDylibs.; // If we matched all symbols then move to phase 2, otherwise fail the query; // with a SymbolsNotFound error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:167,error,error,167,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If we get here, it's because name lookup did not find a; // type. Emit an appropriate diagnostic and return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:114,error,error,114,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"// If we get here, we should have issued a diagnostic and formed a recovery; // lookup result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,recover,recovery,67,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recovery']
Availability,"// If we got a null return and something *was* parsed, ignore it. This; // is due to a top-level semicolon, an action override, or a parse error; // skipping something.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:139,error,error,139,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['error'],['error']
Availability,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,recover,recover,161,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Availability,"// If we got a simplified select_cc node back from SimplifySelectCC, then; // break it down into a new SETCC node, and a new SELECT node, and then return; // the SELECT node, since we were called with a SELECT node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,down,down,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['down'],['down']
Availability,"// If we got an ambiguity involving a non-function template, treat this; // as a template name, and pick an arbitrary template for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:131,error,error,131,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// If we got an error when parsing expression list, we don't call; // the CodeCompleteCall handler inside the parser. So call it here; // to make sure we get overload suggestions even when we are in the; // middle of a parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,"// If we got down to a value of the right type, we win, try inserting into the; // right element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:13,down,down,13,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['down'],['down']
Availability,"// If we got here, the loaded value is transparent through to the start of the; // block. Check to see if it is available in any of the predecessor blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:112,avail,available,112,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// If we had a VPT predication code on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:87,error,error,87,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If we had a carry-set on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:76,error,error,76,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If we had a phi translation failure, we'll have a single entry which is a; // clobber in the current block. Reject this early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,failure,failure,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['failure'],['failure']
Availability,"// If we had a predication code on an instruction that can't do that, issue an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:83,error,error,83,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If we had a sema error parsing this case, then just ignore it and; // continue parsing the sub-stmt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['error'],['error']
Availability,"// If we had an error processing our arguments, don't let the program execute",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['error'],['error']
Availability,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,error,errors,13,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['error'],['errors']
Availability,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,error,errors,13,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['error'],['errors']
Availability,"// If we had no init and an empty pack, and we're not retaining an expansion,; // then produce a fallback value or error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:115,error,error,115,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"// If we have 'maybe called' at this point, we have an error; // that there is at least one path where this parameter; // is not called.; //; // However, reporting the warning with only that information can be; // too vague for the users. For this reason, we mark such parameters; // as ""interesting"" for further analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:55,error,error,55,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['error'],['error']
Availability,"// If we have 3 or more shuffle instructions or a chain involving a variable; // mask, we can replace them with a single PSHUFB instruction profitably.; // Intel's manuals suggest only using PSHUFB if doing so replacing 5; // instructions, but in practice PSHUFB tends to be *very* fast so we're; // more aggressive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we have 4 elements for the shuffle and a Mask, get the cost straight; // from the perfect shuffle tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['Mask'],['Mask']
Availability,// If we have AVX512 we can use a mask compare and masked movss/sd.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// If we have T2 ops, we can materialize the address directly via movt/movw; // pair. This is always cheaper. If need to generate Execute Only code, and we; // only have Thumb1 available, we can't use a constant pool and are forced to; // use immediate relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:177,avail,available,177,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// If we have TBM we can use an immediate for the control. If we have BMI; // we should only do this if the BEXTR instruction is implemented well.; // Otherwise moving the control into a register makes this more costly.; // TODO: Maybe load folding, greater than 32-bit masks, or a guarantee of LICM; // hoisting the move immediate would make it worthwhile with a less optimal; // BEXTR?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:270,mask,masks,270,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// If we have a Lexer Error we are on an Error Token. Load in Lexer Error; // for printing ErrMsg via Lex() only if no (presumably better) parser error; // exists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:22,Error,Error,22,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,12,"['Error', 'error']","['Error', 'error']"
Availability,"// If we have a Mask, and the LT is being legalized somehow, split the Mask; // into smaller vectors and sum the cost of each shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:16,Mask,Mask,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,2,['Mask'],['Mask']
Availability,"// If we have a branch that match a name preceded by a dot; // then we assume we are trying to drill down the branch; // Let look if one of the top level branch has a branch with the name; // we are looking for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:101,down,down,101,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['down'],['down']
Availability,"// If we have a condition, narrow it down to the specific failed; // condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:37,down,down,37,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['down'],['down']
Availability,"// If we have a fake unary shuffle, the shuffle mask is spread across two; // inputs that are actually the same node. Re-map the mask to always point; // into the first input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If we have a forward-declared type, we can't do this check.; // Under ARC, it is an error not to have a forward-declared class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:87,error,error,87,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['mask'],['mask']
Availability,"// If we have a masked cmpxchg, match AND dst, DestReg, MaskReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:16,mask,masked,16,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,2,"['Mask', 'mask']","['MaskReg', 'masked']"
Availability,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,avail,available,58,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['avail'],['available']
Availability,"// If we have a non-splat but still powers-of-2 mask, AVX1 can use pmulld; // and AVX2 can use vpsllv{dq}. 8-bit lacks a proper shift or multiply.; // 16-bit lacks a proper blendv.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we have a redefinition of a typedef in C, emit a warning. This warning; // is normally mapped to an error, but can be controlled with; // -Wtypedef-redefinition. If either the original or the redefinition is; // in a system header, don't emit this for compatibility with GCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,error,error,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If we have a scope node, walk down all of the children.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:33,down,down,33,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['down'],['down']
Availability,"// If we have a semicolon, print a gentle error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:42,error,error,42,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// If we have a single input shuffle with different shuffle patterns in the; // 128-bit lanes and don't lane cross, use variable mask VPERMILPS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:129,mask,mask,129,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// If we have a single input shuffle with different shuffle patterns in the; // the 128-bit lanes use the variable mask to VPERMILPS.; // TODO Combine other mask types at higher depths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:115,mask,mask,115,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// If we have a single input shuffle with different shuffle patterns in the; // two 128-bit lanes use the variable mask to VPERMILPS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:115,mask,mask,115,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we have a strict compare with a vXi1 result and the input is 128/256; // bits we can't use a masked compare unless we have VLX. If we use a wider; // compare like we do for non-strict, we might trigger spurious exceptions; // from the upper elements. Instead emit a AVX compare and convert to mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:99,mask,masked,99,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// If we have a suitable base register available, use it; otherwise; // create a new one. Note that any offset encoded in the; // instruction itself will be taken into account by the target,; // so we don't have to adjust for it here when reusing a base; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['avail'],['available']
Availability,"// If we have a universal binary and Arch doesn't identify any of its slices,; // it's user error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:92,error,error,92,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['error'],['error']
Availability,"// If we have a zero rotate count, we have:; // M = mask(MB,ME); // Op0 = (Op1 & ~M) | (Op2 & M); // Change this to:; // M = mask((ME+1)&31, (MB-1)&31); // Op0 = (Op2 & ~M) | (Op1 & M); // Swap op1/op2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['mask'],['mask']
Availability,"// If we have already emitted a message for a superclass, don't also report; // the sub-class. We consider all operand classes that we don't have a; // specialised diagnostic for to be equal for the propose of this check,; // so that we don't report the generic error multiple times on the same; // operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:262,error,error,262,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Recover,Recovery,171,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['Recover'],['Recovery']
Availability,"// If we have an available predecessor but it requires casting, insert the; // cast in the predecessor and use the cast. Note that we have to update the; // AvailablePreds vector as we go so that all of the PHI entries for this; // predecessor use the same bitcast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,2,"['Avail', 'avail']","['AvailablePreds', 'available']"
Availability,"// If we have an available version of this call, and if it is the right; // generation, replace this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"// If we have an available version of this load, and if it is the right; // generation or the load is known to be from an invariant location,; // replace this instruction.; //; // If either the dominating load or the current load are invariant, then; // we can assume the current load loads the same value as the dominating; // load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,// If we have an error assume that we've already handled it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['error']
Availability,"// If we have an error getting the name then we print the index of the archive; // member. Since we are already in an error state, we just ignore this error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:17,error,error,17,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,3,['error'],['error']
Availability,"// If we have an error, print it and skip to the end of line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp:17,error,error,17,interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp,2,['error'],['error']
Availability,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,mask,masking,191,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['masking']
Availability,"// If we have an invalid decl, just return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:46,error,error,46,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,"// If we have an unary mask, ensure the other op is set to null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we have chaining, the mask must have included r11.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['mask'],['mask']
Availability,"// If we have characters left over, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VersionTuple.cpp:44,error,error,44,interpreter/llvm-project/llvm/lib/Support/VersionTuple.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VersionTuple.cpp,1,['error'],['error']
Availability,"// If we have integer vector types available, use the integer opcodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If we have less than 8 elements (1, 2 or 4), then the starting mask was an; // i8 and we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,"// If we have less than 8 elements, then the starting mask was an i8 and; // we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:54,mask,mask,54,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,"// If we have more than 128-bits, only the low 128-bits of shuffle mask; // matter. Check that the upper masks are repeats and remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// If we have more than 3 arguments, we need to do masking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:51,mask,masking,51,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['masking']
Availability,"// If we have multiple sources in the chain, combine them via perms (using; // calculated perm mask) and Ors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:95,mask,mask,95,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we have run out of child nodes and there _isn't_ a default; // value we can use for the next operand, give an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:116,error,error,116,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['error'],['error']
Availability,"// If we have seen this block before, but it was with a different; // pointer then we have a phi translation failure and we have to treat; // this as a clobber.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:109,failure,failure,109,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['failure'],['failure']
Availability,"// If we have self-init, downgrade all uses to 'may be uninitialized'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:25,down,downgrade,25,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['down'],['downgrade']
Availability,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:191,mask,mask,191,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,14,"['Mask', 'mask']","['MaskShAmt', 'mask']"
Availability,"// If we have some text available for output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp:24,avail,available,24,core/textinput/src/textinput/TerminalDisplay.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp,1,['avail'],['available']
Availability,"// If we have split DWARF, then recurse down into the .dwo files as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:40,down,down,40,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,1,['down'],['down']
Availability,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['mask'],['mask']
Availability,// If we have the same ModuleCachePath and PrebuiltModulePath pointing; // to the same folder we should not cache the file lookup failure as it; // may be currently building an implicit module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:130,failure,failure,130,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['failure'],['failure']
Availability,"// If we have to invert the sign bit mask, only do that transform if the; // target has a bitwise 'and not' instruction (the invert is free).; // (Cond0 s< -0) ? 0 : N2 --> ~(Cond0 s>> BW-1) & N2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// If we have two arguments, the stack slot is *after* the error code; // argument. Pretend it doesn't consume stack space, and account for it when; // we assign the second argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:59,error,error,59,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['error'],['error']
Availability,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,2,"['error', 'recover']","['error', 'recovered']"
Availability,"// If we hit the end of the buffer, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:46,error,error,46,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,2,['error'],['error']
Availability,"// If we instantiated a definition, check that it's usable, even if; // instantiation produced an error, so that repeated calls to this; // function give consistent answers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:98,error,error,98,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"// If we know the caller will be emitted, we know this wrong-side call; // will be emitted, so it's an immediate error. Otherwise, defer the; // error until we know the caller is emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:113,error,error,113,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,2,['error'],['error']
Availability,"// If we know the register class needed for the result of this; // instruction, use it. Otherwise pick the register class of the; // correct size that does not contain X0/R0, since we don't know; // whether downstream uses permit that assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:207,down,downstream,207,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['down'],['downstream']
Availability,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:141,error,error,141,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,4,['error'],['error']
Availability,// If we matched against this symbol but it is in the error state; // then bail out and treat it as a failure to materialize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:54,error,error,54,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,4,"['error', 'failure']","['error', 'failure']"
Availability,"// If we must find eviction, the candidate should be masked out of the; // decision making process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:53,mask,masked,53,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['mask'],['masked']
Availability,"// If we need an alignment gap in the stack, align the topmost stack; // object. A stack frame with a gap looks like this, bottom up:; // x19, d8. d9, gap.; // Set extra alignment on the topmost stack object (the first element in; // CSI, which goes top down), to create the gap above it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:254,down,down,254,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['down'],['down']
Availability,// If we need the symbol table to do the operation then check it here to; // produce a good error message as to where the Mach-O file comes from in; // the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:92,error,error,92,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,2,['error'],['error']
Availability,"// If we need this expected index to be a zero element, then update the; // relevant zero mask and perform the known bits at the end to minimize; // repeated computes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,mask,mask,90,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we need to apply a mask, there are several more restrictions we have.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,"// If we need to insert new load in multiple predecessors, reject it.; // FIXME: If we could restructure the CFG, we could make a common pred with; // all the preds that don't have an available Load and insert a new load into; // that one block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:184,avail,available,184,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// If we need to mask out a subregister, do it now, unless the next; // operation would emit an OpPiece anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,2,['mask'],['mask']
Availability,"// If we need to spill the CR and the LR but we don't have two separate; // registers available, we must spill them one at a time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,// If we only used V2 then splat the lane blend mask to avoid any demanded; // elts from V1 in this lane (the V1 equivalent is implicit with a zero; // blend mask bit).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// If we otherwise get a NAN; // it's an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:41,error,error,41,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,"// If we reached here, there was an error or a ud-suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:36,error,error,36,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['error'],['error']
Availability,"// If we reached the end of the loop without connecting to a valid endpoint,; // dump the last error that was logged in socket() or connect().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:95,error,error,95,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['error'],['error']
Availability,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,recover,recover,32,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Availability,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,recover,recovered,9,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recovered']
Availability,"// If we removed any equal matchers, we may need to slide the rest of the; // elements down for the next iteration of the outer loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:87,down,down,87,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['down'],['down']
Availability,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:9,repair,repair,9,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,4,['repair'],"['repair', 'repairing']"
Availability,"// If we see a return block with successors, this must be a funclet return,; // which does not preserve any registers. If there are no successors, we don't; // care what kind of return it is, putting a mask after it is a no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:202,mask,mask,202,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['mask'],['mask']
Availability,"// If we see an identifier that is not a type name, we normally would; // parse it as the identifier being declared. However, when a typename; // is typo'd or the definition is not included, this will incorrectly; // parse the typename as the identifier name and fall over misparsing; // later parts of the diagnostic.; //; // As such, we try to do some look-ahead in cases where this would; // otherwise be an ""implicit-int"" case to see if this is invalid. For; // example: ""static foo_t x = 4;"" In this case, if we parsed foo_t as; // an identifier with implicit int, we'd get a parse error because the; // next token is obviously invalid for a type. Parse these as a case; // with an invalid type specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:587,error,error,587,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// If we split apart the field's value, try to collapse it down to a; // single value now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:59,down,down,59,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['down'],['down']
Availability,"// If we succeeded, or had any error other than the parent not existing, just; // return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/Support/Path.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp,1,['error'],['error']
Availability,"// If we successfully parsed the operand or if there as an error parsing,; // we are done.; //; // If we are parsing after we reach EndOfStatement then this means we; // are appending default values to the Operands list. This is only done; // by custom parser, so we shouldn't continue on to the generic parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:59,error,error,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['error']
Availability,"// If we switched context to translation unit while we are still lexically in; // an objc container, it means the parser missed emitting an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:140,error,error,140,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"// If we threw this parsing error after a lexing error, this should; // supercede the lexing error and so we remove it from the Lexer; // before it can propagate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp:28,error,error,28,interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp,3,['error'],['error']
Availability,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// If we were able to compute an unfolded reg class, any failure here; // is just a programming error so just assert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:57,failure,failure,57,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"// If we were unable to find a config file deduced from executable name,; // that is not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:92,error,error,92,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:309,error,errors,309,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// If we widened, we need to shrink the mask VT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// If we'll need a fixup FMOV, don't bother. Testing has shown that this; // happens infrequently and when it does it has at least a 50% chance of; // slowing code down instead of speeding it up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:164,down,down,164,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['down'],['down']
Availability,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:82,mask,mask,82,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,3,['mask'],['mask']
Availability,"// If we're allowed to diagnose this and recover, do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:41,recover,recover,41,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,"// If we're already within a VAOPT, emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,"// If we're currently in unreachable code, we suppress errors completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp:55,error,errors,55,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,1,['error'],['errors']
Availability,"// If we're defining a specialization and the previous definition; // is from an implicit instantiation, don't emit an error; // here; we'll catch this in the general case below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:119,error,error,119,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// If we're defining a specialization and the previous; // definition is from an implicit instantiation, don't emit an; // error here; we'll catch this in the general case below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:123,error,error,123,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['error'],['error']
Availability,// If we're demanding all elements don't bother trying to simplify the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we're doing late masking, then the first bit group always starts; // at zero (even if the first bits were zero).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,mask,masking,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,"// If we're down to a single pattern to match, then we don't need this scope; // anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:12,down,down,12,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['down'],['down']
Availability,"// If we're handling a missing symbol error, using modules, and the; // special search all modules option is used, look for a missing import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,error,error,38,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['error'],['error']
Availability,"// If we're here, it means we didn't get an END_BLOCK yet, but we're at the; // end of the stream. In this case, error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkParser.cpp:113,error,error,113,interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkParser.cpp,1,['error'],['error']
Availability,"// If we're hunting down a 'case' or 'default' label, recurse through; // substatements until we hit the label.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,down,down,20,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['down'],['down']
