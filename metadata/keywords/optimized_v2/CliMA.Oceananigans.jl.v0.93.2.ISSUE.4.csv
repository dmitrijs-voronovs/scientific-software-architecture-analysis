quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1169,message,message,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319,2,['message'],['message']
Integrability,"> All 6 boundaries are something like; > ; > ```julia; > using Oceananigans.AbstractOperations: flip; > ; > east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); > south_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j, k, grid); > bottom_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k, grid); > ; > west_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i+1, j, k, grid) ; > north_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j+1, k, grid); > top_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k+1, grid); > ```; > ; > something like that. There could be a mistake. Yep I think this would work...; Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not), in that case we would need ; ```; bottom_bounded(LX, LY, LZ, i, j, k, grid) = solid_node(LX, LY, LZ, i, j, k-1, grid) & !solid_node(LX, LY, LZ, i, j, k, grid)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083:1022,Depend,Depends,1022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083,1,['Depend'],['Depends']
Integrability,"> Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?. This PR _defines_ the ""buffer"" as the halo dependent region of the domain. Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056:113,depend,dependent,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056,4,['depend'],['dependent']
Integrability,"> Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions. That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939:75,depend,depend,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939,1,['depend'],['depend']
Integrability,"> Also we get some deprecation warnings. E.g., for; > ; > ```; > SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); > ```; > ; > we get; > ; > ```; > Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; > ```; > ; > I don't understand what that means tho. I think a39445a and [bf06da1](https://github.com/CliMA/Oceananigans.jl/pull/3100/commits/bf06da180131d8cbede895913d21aa9348684095) dealt with this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284:195,Wrap,Wrapping,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,"> Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though. Doesn't this depend on the setup? The actual ocean bottom is littered with boulders and other features of various sizes, and there's plenty of work in very steep canyons, ie https://en.wikipedia.org/wiki/Scripps_Canyon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067:261,depend,depend,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067,1,['depend'],['depend']
Integrability,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:1147,depend,depend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822,1,['depend'],['depend']
Integrability,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336:387,depend,dependant,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336,4,['depend'],['dependant']
Integrability,> Another issue to add into this discussion is the fact of how to handle output (e.g. file.nc) with checkpoints and file_splitting. I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684:280,interface,interface,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684,1,['interface'],['interface']
Integrability,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,2,['interface'],['interface']
Integrability,> Another place I think we need to change is particle advection:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161; > ; > Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually. Totally agree particles should be advected with prognostic + background,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693:292,integrat,integrated,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693,1,['integrat'],['integrated']
Integrability,"> Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?. Sorry I forgot to reply to this sooner. If we use `ch` then we can write the advection term as a divergence form, and then use a lot of the existing code that we have for the other models. This seems easier to me, rather than having to write different solvers for the alternative form of advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447,1,['integrat'],['integrated']
Integrability,"> As far as I know there isn't a unified interface to getting these fields. The interface for `AbstractScalarDiffusivity` is the function `viscosity(closure, diffusivities)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114,2,['interface'],['interface']
Integrability,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:100,depend,depends,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605,2,['depend'],['depends']
Integrability,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:197,interface,interface,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,2,['interface'],['interface']
Integrability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:314,Depend,Depending,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['Depend'],['Depending']
Integrability,"> Before I push my local commits, does Manifest.toml require any changes?. `Manifest.toml` typically has to be synchronized with `Project.toml`, so it probably will have to be updated if you've changed `Project.toml`. In a perfect world (if our package compatibility bounds in `Project.toml` were perfect) then users could generate `Manifest.toml` on their local machine without requiring a committed version. However, it turns out to be a bit annoying to keep compatibility bounds up to date, so we use the `Manifest.toml` as a hack. Since we can't really review changes to the `Manifest.toml` it's best to be conservative about updating packages, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260:111,synchroniz,synchronized,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260,1,['synchroniz'],['synchronized']
Integrability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:1040,interface,interfaces,1040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,1,['interface'],['interfaces']
Integrability,"> Building on what @jm-c said, I think we want to design an interface in which an equation is expressed as something like ; > ; > ```; > φ_t = Lφ + Ν(φ); > ```; > ; > where `φ` is the solution (an array of fields in this case, probably), `L` is a linear operator that can be treated implicitly (depending on the time-stepping scheme), and `N(φ)` is a nonlinear operator.; > ; > The challenge is including the pressure correction in this paradigm. I think it should be possible --- we may just have to consider only time-steppers that invoke the special pressure correction substep.; > ; > I think the design should be about more than just 'marking' the terms. We can tackle the problem of designing a time-stepper to step forward an equation of a certain form completely independent from the development of an algorithm to calculate nonlinear terms, pressure corrections, and linear terms for a specific kind of equation. Then we put the pieces together to solve the problem.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463209211_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/95:60,interface,interface,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/95,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:319,interface,interface,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818,3,"['Depend', 'interface']","['Depending', 'interface']"
Integrability,"> But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good. @glwagner, what do you mean here by ""kernel functions""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192:260,interface,interface,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192,1,['interface'],['interface']
Integrability,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:164,depend,dependencies,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022,1,['depend'],['dependencies']
Integrability,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470,8,"['integrat', 'interface']","['integrated', 'interface', 'interfaces']"
Integrability,"> Can spatial units be set?. Spatial attributes can be set but Oceananigans.jl assumes meters right now so more unit misattribution. If the time units can be set, then we should be able to set the spatial units. > Are packages like Unitful.jl not mature enough to be used for these purposes? I understand this is a pretty extreme solution for this problem specifically, but It would be pretty cool if Oceananigans could understand units. I think it's mature enough but not I guess we're not sure where to use it (we discussed a bit in #1116). Would be perfect for specifying these kinds of units as long as it's not a heavy dependency. For other simulations, e.g. icy moons, it's nice to use rotation periods. Another place where units are assumed is `prettytime` so the `Simulation` always thinks your units are SI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502:624,depend,dependency,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502,1,['depend'],['dependency']
Integrability,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:9,wrap,wrap,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984,1,['wrap'],['wrap']
Integrability,"> Can you help me figure out what we are using as a reconstruction?. For the velocity field or tracer?. For the tracer it depends on the advection scheme. For the velocity field, I think our method is consistent with either a constant or linear reconstruction. I'm not sure about higher. Not that if we use a different reconstruction for computing tracer fluxes, we'd have to use the same reconstruction for calculating the divergence of the velocity field so that they are consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792:122,depend,depends,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792,1,['depend'],['depends']
Integrability,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:919,depend,depending,919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,2,['depend'],['depending']
Integrability,> Can you point me to where in the code this goes down?. It happens in this halo fill:. https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20. after the tendency integration but before the pressure correction,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522:257,integrat,integration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522,1,['integrat'],['integration']
Integrability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:353,rout,route,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,3,"['interface', 'rout']","['interface', 'route']"
Integrability,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:205,integrat,integration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['integrat'],['integration']
Integrability,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:696,interface,interface,696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324,2,['interface'],['interface']
Integrability,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:472,interface,interface,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731,3,"['Depend', 'interface']","['Depends', 'interface']"
Integrability,"> Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:296,depend,depends,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,2,['depend'],['depends']
Integrability,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point?. > > Can you point me to where in the code this goes down?; > ; > It happens in this halo fill:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20; > ; > after the tendency integration but before the pressure correction. Where is the halo filling code?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421:387,integrat,integration,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421,1,['integrat'],['integration']
Integrability,"> Do you think this will be ready to merge soon-ish?. Yes I think so. . The main clarifications here are that. 1. The concept of 'buoyancy' is on solid ground for any equation of state, provided we are within the Boussinesq approximation. 2. The dynamic component of the buoyancy gradient (the squared buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:400,contract,contraction,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['contract'],['contraction']
Integrability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:110,depend,depends,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['depend'],['depends']
Integrability,"> Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact. Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854:274,integrat,integrated,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> Does it make more sense for Open to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set OpenBoundaryCondition(nothing) unless a user sets something else. This choice should not merely be a question about user interface / convenience but also about how the code internals work. . One problem is that the topology refers to both sides. We want to support domains that are, for example, bounded on the west but open on the east. We do have an abstraction called `RightConnected` for distributed cases. Possibly, we can implement topologies that represent doubly open and single-sided open. But to motivate such an abstraction, I think this needs to have implications on the grid level --- not just a way to generate boundary conditions conveniently. I think there are other solutions for generating boundary conditions conveniently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859:288,interface,interface,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859,1,['interface'],['interface']
Integrability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:460,depend,depend,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,4,['depend'],['depend']
Integrability,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996,1,['message'],['message']
Integrability,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:241,wrap,wrapping,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032,1,['wrap'],['wrapping']
Integrability,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:221,depend,dependency,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010,1,['depend'],['dependency']
Integrability,"> For the record, I did try this yesterday with FlatExtrapolationOpenBCs and it also blew-up. Ok great. How about the same problem (including CG pressure solver) but no immersed boundaries?. Something to keep an eye on is the number of iterations the CG solver does. It'd be good to report what is going on with those during / prior to breakup. You can call `iteration(model.pressure_solver)` to diagnose it (where it will correspond to the previous solve). > interestingly, when I run your exact example things take a little longer to blow up. This is important; the dependence on time step should be diagnosed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770:568,depend,dependence,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770,1,['depend'],['dependence']
Integrability,"> Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different; target arch. Right --- we can use a wrapper that redefines `getindex` (and potentially also is associated with a certain loop ordering). Looks like there's a julia type that does this:. https://github.com/JuliaLang/julia/blob/master/base/permuteddimsarray.jl. I doubt it would be very hard to figure out how to abstract away loop ordering so it can be flexibly changed for a target architecture. One question still remains: which is the most intuitive convention for `getindex` calls? I personally like `i, j, k` for `x, y, z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865:188,wrap,wrapper,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865,1,['wrap'],['wrapper']
Integrability,"> Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. It's a very breaking change!. > Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though. This PR doesn't remove `StateChecker`, it just stops exporting it. > I use it in almost every script I write haha, but that's because I wrote it to my liking. Touche, but none of the examples use it so it isn't very visible. I'm not even quite sure what the application is, which might be part of the issue? Anyways the point is not to remove this functionality but just not stop exporting it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194:107,interface,interface,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194,1,['interface'],['interface']
Integrability,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:584,rout,routines,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,1,['rout'],['routines']
Integrability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:485,interface,interface,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,3,['interface'],['interface']
Integrability,"> Hi, is there a reason why this isn't in the official examples?. Is it ready? This comment suggests it's not:. > This PR in a work-in-progress and depends on #1091. I still need to make it Literate. Perhaps @ali-ramadhan wouldn't mind some help though. It's probably stale right now and would need a merge master and update.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915:148,depend,depends,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915,1,['depend'],['depends']
Integrability,"> Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:64,depend,depend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,1,['depend'],['depend']
Integrability,"> Hmmm, I don't know if many log levels will be that helpful. I'm not entirely sure either. It's worth considering whether the standard `Info` and `Debug` levels might be enough for some of your uses, but there's also nothing wrong with trying out some custom levels and removing them if they don't end up making sense. For general logging I've often wondered whether it would be helpful to have a `Notice` level with severity between `Info` and `Warn` to allow informational messages to be stratified into two groups, though we would need clear guidelines for how to use it. Likewise, to have a `Debug2` or `VerboseDebug` level for ""really verbose"" debugging messages (possibly compiled out by default, though that would need a minor tweak in Base to make it possible). > but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. This is basically what the standard `Info` level printing does in `Logging.ConsoleLogger` - it just ignores the line and file info captured by the fontend to simplify the pretty printing of the message. Btw, the pretty printing of log events can be separate from the storage format if desired. For example we could serialize log records to a binary file (including all file,line information etc) but have a tool to pretty print them with extra filtering, replay the messages from a simulation in faster than real time etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159:476,message,messages,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159,5,['message'],"['message', 'messages']"
Integrability,"> Honestly I think this is already pretty handy and enforces the idea that in order to compute something it needs to be a field. Hmm, I think the key concept here is that in order to _store_ the result of a computation, we need to allocate memory. That's what invoking `Field` does. It's worth mentioning for posterity the subtlety that calling `compute!` does have an affect on abstract operation, because it triggers the computation of all the leaves. So if an AbstractOperation depends on a field that needs to be computed, calling `compute!` on the abstract operation will cause that child field to get computed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718:481,depend,depends,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718,1,['depend'],['depends']
Integrability,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200:620,message,message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200,2,['message'],['message']
Integrability,"> How is this possible with a periodic solution?. Maybe I'm missing something, but I can't imagine how that would _not_ happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257:194,message,message,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257,1,['message'],['message']
Integrability,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:110,interface,interface,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980,3,['interface'],"['interface', 'interfaces']"
Integrability,"> I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction.; > ; > ; > ; > ```; > ; > Immersed Fluid; > ; > ----------- ...........; > ; > | ∘ | ∘; > ; > f c f c; > ; > k-1 k-1 k k; > ; > ```; > ; > My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The question is where bottom_height lies in these diagrams. GridFittedBottom is not a limiting case of PartialCellBottom in the way we have coded it, because GridFittedBottom uses the cell center to determine whether the cell is immersed or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605:558,interface,interface,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605,1,['interface'],['interface']
Integrability,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988:343,integrat,integrate,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988,2,['integrat'],['integrate']
Integrability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:535,depend,dependent,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['depend'],['dependent']
Integrability,"> I am thinking about the ease of use in bc, for example; > ; > ```julia; > @inline time_interpolated_bc(i, j, grid, clock, fields, p) = p.time_array[i, j, 1, clock]; > ```; > ; > vs; > ; > ```julia; > @inline function time_interpolated_bc(i, j, grid, clock, fields, p) ; > time = Time(clock); > return p.time_array[i, j, 1, time]; > end; > ```; > ; > I find the first implementation a bit more straightforward, but we can also have both. I propose we prioritize the user interface rather than the source code implementation, which basically has to be written once then left alone",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206:472,interface,interface,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206,1,['interface'],['interface']
Integrability,"> I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. . Ok, after changing from `IterationInterval` to `TimeInterval` in the 1D diffusion example ([source](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl)), I am able to reproduce the same problem now. . Here is the progress message after picking up the checkpoint:; <img width=""580"" alt=""image"" src=""https://github.com/user-attachments/assets/9ef385f4-b53d-4954-97f9-54656420c232"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596:423,message,message,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596,1,['message'],['message']
Integrability,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:959,depend,depends,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,2,['depend'],['depends']
Integrability,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:906,depend,depend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685,2,['depend'],['depend']
Integrability,"> I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up. I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285:113,depend,depends,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285,1,['depend'],['depends']
Integrability,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803:209,depend,dependence,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803,2,['depend'],['dependence']
Integrability,"> I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. Yeah, I thought so too, but even using the pre-compiled binaries doesn't seem to fix this so idk anymore... > It'll be nice if upgrading to 1.6 (#1514) solves this. I have high hopes that it will!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928:171,depend,dependencies,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928,1,['depend'],['dependencies']
Integrability,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371:605,wrap,wrap,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371,2,['wrap'],['wrap']
Integrability,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:41,depend,dependency,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418,1,['depend'],['dependency']
Integrability,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:111,rout,routines,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038,6,['rout'],['routines']
Integrability,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:106,depend,depend,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,1,['depend'],['depend']
Integrability,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:313,depend,depends,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413,2,['depend'],['depends']
Integrability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:1167,depend,depend,1167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['depend'],['depend']
Integrability,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:370,depend,depends,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,1,['depend'],['depends']
Integrability,"> I haven't gone through everything but I get the feeling that there is a lot of leftover docstrings/docs that are related to the previous default T, S option. Am I right? We should have T, S where is needed for the demonstration, not just have it everywhere because it's a leftover from before.; > ; > I don't. @navidcy Thanks for the review! I think your message got a little cut in the end. But I totally agree. I have modified these instances where I identified them (for example in model_setup/tracers.md), but a busy schedule kept me from doing a more thorough search for occasions where these happen. I'll fix the ones you found and look for some more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993:357,message,message,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993,1,['message'],['message']
Integrability,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:232,depend,dependent,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103,2,['depend'],['dependent']
Integrability,"> I like it! I changed the NonhydrostaticModel to be the same.; > ; > A way to facilitate users is that we leave the option to specify a global `advection` (so that we keep the keyword) or two separate `momentum_advection` and `tracer_advection`. I would rather just change it to be consistent with the HydrostaticFreeSurfaceModel directly.; > ; > what do you guys think?. I think we should do that in a different PR because it's a major, major breaking change to the most popular model!. As for the syntax I'd prefer --- I would prefer one keyword argument `advection`. We need that for the changes proposed in #2454 --- because the schemes for different components can depend on one another. So it's easier to put it in one object. I also feel it's better to just specify `grid` once to the `advection` constructor. But that would be harder to implement now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720:671,depend,depend,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720,1,['depend'],['depend']
Integrability,"> I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though. Ok, I see. I agree that that discussion can be left to the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025:150,interface,interface,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025,1,['interface'],['interface']
Integrability,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844,2,['interface'],['interface']
Integrability,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954:98,wrap,wrapper,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954,6,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"> I see, I think having an open boundary does necessarily have grid level implications because every tracer needs to have some open boundary specified if the grid has an open boundary right?. What are those implications?. For example, `Periodic` implies that there is one fewer interface for `Face` fields in that direction. As a result, `Periodic` direction changes the way that a grid needs to be constructed. This is what I mean by ""grid-level implication"". What's the difference between `Open` and `Bounded` in terms of data layout? It seems to me that `Open` is a boundary condition rather than dictating a different data layout. For example, would the different topology change the way that we construct the grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013:278,interface,interface,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013,1,['interface'],['interface']
Integrability,"> I see. My aversion to putting something like this in the condition is that we would have to make a lot of changes to allow users to specify the external state, because if we just have the condition like all of the other boundary types then we don't have todo anything for the user to be able to put in anything as the external state.; > ; > We could change `Open` to be:; > ; > ```julia; > @kwdef struct Open{MS} <: AbstractBoundaryConditionClassification; > matching_scheme :: MS = nothing; > end; > ```; > ; > then by default this behaves exactly as it does now, but we could add `_fill_halo_...` methods for different matching schemes. For example if a user want to specify an external state: `OpenBoundaryCondition(1)`, or if they want to use a matching scheme `BoundaryCondition(Open(SomeMatchingScheme()), 1)` or we could make a utility like `SomeMatchingSchemeBoundaryCondition(val)` which returns `BoundaryCondition(Open{SomeMatchingScheme}, val)`. I like the examples you provide, but need to clarify that this discussion has no effect at all on existing code. Adding a new `condition` that is specific to `Open` does not stop us from also using `OpenBoundaryCondition(1)`. To emphasize --- we are talking about how information is organized under the hood. We are not talking about the user interface. For the user interface, I suggest the following syntax:. ```julia; OpenBoundaryCondition(nothing) # impenetrable; OpenBoundaryCondition(1) # external state = 1, no matching scheme; OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328:1302,interface,interface,1302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328,2,['interface'],['interface']
Integrability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:489,depend,dependent,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,2,['depend'],['dependent']
Integrability,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:175,message,message,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255,2,['message'],['message']
Integrability,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:521,interface,interface,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691,3,['interface'],['interface']
Integrability,"> I think it is good to use it in hydrostatic simulations where the aspect ratio is very high (for example drag on the sides should not be equal to drag on the bottom). Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703:242,depend,depend,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703,1,['depend'],['depend']
Integrability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,2,"['interface', 'rout']","['interface', 'route']"
Integrability,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:889,integrat,integration,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887,4,"['depend', 'integrat']","['depends', 'integration']"
Integrability,"> I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. It's definitely possible, but I think this isn't the example to do that. Since it's a tilted boundary layer, there's some extra complexity in the TKE budget. It's not a technical obstacle of anything, but it would require more explanation. I think the ocean convection example would be a much better option for a TKE budget.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752:262,integrat,integrated,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752,1,['integrat'],['integrated']
Integrability,"> I think its a fine idea to merge, though it is interesting that the code will still be called Oceananigans :-D. > Agree we need another name, perhaps a variant of shenanigans. True. The window of opportunity to change names is closing though. It might not be good to change package name after the JOSS paper comes out. I'm open to a name change if we can all agree on a new name. > I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:546,depend,depend,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['depend'],['depend']
Integrability,"> I think overwrite_existing = false could be the default. Seems to me that users could easily add the overwrite_existing = true in their script if they know they are experimenting with something and don't wanna be deleting the output every time. So, `overwrite_existing=false` is the current default. I don't dispute that it's ""easy"" to add `overwrite_existing=true`, but I don't think we should design the interface only up to the point where ""easy"" changes close the gap between the default and what users want to do, most of the time. I think the default should legitimately be useful. I think that `overwrite_existing=false` is rarely desirable -- users only want this when they run big, expensive simulations. I would say that it's almost impossible to set up a big, expensive simulation without going through some prototyping phase first. Moreover, prototyping consumes much more human time than big, expensive simulations. Therefore `overwrite_existing=true` is the correct default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490:408,interface,interface,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490,1,['interface'],['interface']
Integrability,"> I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!; > ; > ```julia; > julia> using Oceananigans, Test; > Precompiling Oceananigans; > 1 dependency successfully precompiled in 11 seconds. 129 already precompiled.; > ; > julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); > 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; > ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; > └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5; > ; > julia> closure = ""not a closure""; > ""not a closure""; > ; > julia> NonhydrostaticModel(; grid, closure); > ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String); > ; > Closest candidates are:; > with_tracers(::Any, ::Nothing, Any...; kwargs...); > @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; > with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; > with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; > ...; > ; > Stacktrace:; > [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266:80,message,message,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:85,depend,depends,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,6,['depend'],"['dependencies', 'depends']"
Integrability,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:848,depend,depends,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502,2,['depend'],['depends']
Integrability,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891,6,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,"> I think we need an required_biogeochemical_auxiliary_fields like required_biogeochemical_tracers because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field). Should the user specify this, or should the biogeochemical model add it its struct (taking in `grid` for this purpose) and evaluate it during `update_biogeochemical_state`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513:298,depend,dependence,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513,2,"['depend', 'integrat']","['dependence', 'integrating']"
Integrability,"> I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code. I will try (feel free to edit):. The use cases we want to add support for is advection of user specified values into the domain (in a ""soft"" way, i.e. not directly specifying incase the interior solution has diverged from the boundary specified solution), we also want to be able to advect information out of the interior domain. . We want to be able todo this with both user specified bulk velocities as well as velocities that depend on the wall normal velocity and possibly wall normal acceleration (some also consider oblique waves but from what I have read it doesn't help that much). The calculated bulk velocities might be the different at every point (i.e. computed within the fill kernel), but may also (often) be the same at every point on the boundary so should be computed before the fill kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760:562,depend,depend,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760,1,['depend'],['depend']
Integrability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:10,wrap,wrapping,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['wrap'],['wrapping']
Integrability,"> I think you can define in `ImmerdsedBoundaries`; > ; > ```; > return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); > ```; > ; > and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings) ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment). Good point!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847:225,depend,depend,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847,1,['depend'],['depend']
Integrability,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:124,depend,depending,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799,1,['depend'],['depending']
Integrability,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:1608,message,message,1608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,1,['message'],['message']
Integrability,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:331,wrap,wrapped,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525,2,"['message', 'wrap']","['message', 'wrapped']"
Integrability,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:243,depend,dependency,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,6,"['depend', 'synchroniz']","['dependency', 'synchronization', 'synchronizations', 'synchronize', 'synchronizing']"
Integrability,"> I'm not sure that the corner points are used in the prognostic calculations right?. It depends on the physics. You should check for coriolis, VectorInvariant advection, and biharmonic viscosities. I suspect the corners come into play for those. > Do you mind pointing me in the right direction?. Check out `Oceananigans.Utils.KernelParameters` and use this when launching the kernel that fills the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342:89,depend,depends,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342,1,['depend'],['depends']
Integrability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:920,integrat,integrate,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['integrat'],['integrate']
Integrability,"> I'm wondering if it might be a bit much to put docstrings on every single AbstractGridMetric for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like IntegratedField down the line). Fair point. But internal docstrings also help I think. It's way easier for me to contribute, for example, when the internal functions are well-documented. I think the more we add these, the more likely we are to get contributions from people outside of the regular group, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043:232,Integrat,IntegratedField,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043,1,['Integrat'],['IntegratedField']
Integrability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:108,integrat,integrate,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['integrat'],['integrate']
Integrability,"> I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > ; > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum. Thought more about this and I think it might be quite complicated to change to this so I will leave for now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739:198,depend,dependant,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739,1,['depend'],['dependant']
Integrability,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:32,wrap,wrap,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503,2,['wrap'],"['wrap', 'wrapper']"
Integrability,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:308,rout,routines,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045,3,"['integrat', 'rout']","['integration', 'routines']"
Integrability,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962:136,message,message,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962,4,"['message', 'wrap']","['message', 'wrapper']"
Integrability,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999:481,interface,interface,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999,2,['interface'],['interface']
Integrability,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:231,interface,interface,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293,2,['interface'],['interface']
Integrability,"> In dealing with a stretched grid, don't we need these to depenend on the horizontal grid?. Not in general; without bathymetry we would only need this for three-dimensional curvilinearity. If we have only horizontal curvilinearity (as arises in a thin approximation to the spherical shell), then vertical spacing are independent of horizontal location. But as noted in this issue, vertical spacing *do* depend on horizontal location with an immersed boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864:404,depend,depend,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864,1,['depend'],['depend']
Integrability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:573,depend,depends,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['depend'],['depends']
Integrability,"> Interesting that it modifies `field` in place. I think perhaps a starting point could be an implementation that puts the result in a new field, perhaps?. Yes, in my case, I created a copy of the field I wanted to integrate and then applied the function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682:215,integrat,integrate,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682,1,['integrat'],['integrate']
Integrability,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:363,depend,dependencies,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,2,['depend'],['dependencies']
Integrability,> Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. Julia can handle the dependencies if we want to use it. See `PyPlot.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482:139,depend,dependencies,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482,1,['depend'],['dependencies']
Integrability,> Is that message going to display _every_ time a model is created?. No. Only when a model is created with `gravity_unit_vector != NegativeZDirection()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936,1,['message'],['message']
Integrability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:210,depend,depend,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,1,['depend'],['depend']
Integrability,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:240,interface,interface,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,> Is there a way for me to cancel tests so they don't have to run every commit?. You can include `[skip ci]` in the commit message: https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165,1,['message'],['message']
Integrability,"> Is there any other reason why it should be positional?. I guess I'm just arguing that it's not consistent with most of the API, eg we write `CenterField(grid)`. I find the position representation of required arguments to be a natural and concise interface but perhaps I shouldn't die on that hill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107:248,interface,interface,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107,1,['interface'],['interface']
Integrability,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,4,['interface'],['interface']
Integrability,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:536,interface,interfaces,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['interface'],['interfaces']
Integrability,"> It may be that several other dependencies need to be updated. Yep, a few others updated when I ran . ```julia; (Oceananigans) pkg> update SeawaterPolynomials; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980,1,['depend'],['dependencies']
Integrability,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,2,['interface'],['interface']
Integrability,"> It will allow us embed a little more multi process in the code. Can you explain this point?. To me it looks like the main difference / improvement of (3) is the _user interface_ rather than functionality, because every grid has an `architecture`. Thus in source code it's the difference between `grid.architecture.partition` or `grid.partition`. With a `process_partition(grid)` interface (which we should have...) even that distinction is lost. The primary tradeoff against the user interface change is an increase in code complexity. New developers have to wrestle with and users have to puzzle over `grid.partition`, even though it's relevant only in a minority of cases (particularly because we are GPU-focused, and are providing features for multi-GPU). For example with `MultiRegionGrid` we'd have `grid.partition` and `grid.region_grids[1].partition`. But maybe I am missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110:381,interface,interface,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110,2,['interface'],['interface']
Integrability,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:889,depend,depend,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['depend'],['depend']
Integrability,"> It's because the two fields use the same data:; > ; > ```julia; > u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); > v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); > ```; > ; > therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array. That makes sense, especially because if I don't specify the scratch data it goes away. But any guesses as to why it only pops up when using IBMs?. https://github.com/CliMA/Oceananigans.jl/pull/2582 seems to suggest that it's because the Average is only computed at fluid nodes and therefore is applied conditionally. Is that it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131:285,depend,dependent,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131,1,['depend'],['dependent']
Integrability,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203,3,['interface'],['interface']
Integrability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:193,depend,depending,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"> Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; > ; > ```; > Updating `~/git/Oceananigans.jl/Project.toml`; > [de688a37] + BitInformation v0.6.1; > Updating `~/git/Oceananigans.jl/Manifest.toml`; > [66dad0bd] + AliasTables v1.1.2; > [de688a37] + BitInformation v0.6.1; > [49dc2e85] + Calculus v0.5.1; > [31c24e10] + Distributions v0.25.108; > [fa6b7ba4] + DualNumbers v0.6.8; > [1a297f60] + FillArrays v1.11.0; > [34004b35] + HypergeometricFunctions v0.3.23; > [77ba4419] + NaNMath v1.0.2; > [90014a1f] + PDMats v0.11.31; > [1fd47b50] + QuadGK v2.9.4; > [79098fc4] + Rmath v0.7.1; > [2913bbd2] + StatsBase v0.34.3; > [4c63d2b9] + StatsFuns v1.3.1; > [f50d1b31] + Rmath_jll v0.4.0+0; > ```; > ; > also why is the Manifest.toml committed?. Through past experience we found that we needed the Manifest committed to make sense of the errors we encounter during CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793:56,depend,dependency,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793,1,['depend'],['dependency']
Integrability,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766:218,integrat,integrate,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766,2,['integrat'],['integrate']
Integrability,"> Lagrangian-averaged should be slightly less diffusive right?. Hmm, I'm not aware of that. afaik it's about the same in a doubly periodic domain. Looking at Bou-Zeid's Figure 1 I also don't see any obvious trend that way. What is generally true is that scale-dependent formulations (not implemented here) tend to be less diffusive then scale-invariant ones (which is the one implemented here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206:260,depend,dependent,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206,1,['depend'],['dependent']
Integrability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['interface'],['interface']
Integrability,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:264,integrat,integrating,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672,1,['integrat'],['integrating']
Integrability,"> Maybe I'm missing something, but I can't imagine how that would not happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed. I think the problem is that we cannot impose a `b` that has a non-zero domain average. This is consistent with its definition (eg it is proportional to the density _perturbation_; we subtract out a reference density in Boussinesq). Consider the x-momentum equation:. ```; du/dt + ... = b sin(theta); ```. if `b` has no net average, then the average of this equation is just. ```; d <u> / dt = 0; ```. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035:144,message,message,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035,1,['message'],['message']
Integrability,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:216,interface,interface,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,4,['interface'],['interface']
Integrability,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:190,depend,dependencies,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767,1,['depend'],['dependencies']
Integrability,"> More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be 1027 and in the other its 1024. Sorry that was a typo. Just fixed it. > But otherwise I don't see why it wouldn't work and I am a bit stumped. Yes, I've dedicated several hours to investigating this issue also and got nothing. The issue also is that I'm actually depending on that result for research, and it's pretty expensive to calculate that offline. Do you have any suggested workarounds?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625:424,depend,depending,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625,1,['depend'],['depending']
Integrability,"> My primitive logic: for a flux boundary condition, bc.calc() ""calculates"" the flux at the given grid point and time-step. For a ""value"" boundary condition, bc.calc() ""calculates"" the value of the boundary condition at the given grid point and time-step. But I agree it is a weird name. What is a better name?. It may not stand up to mathematical rigor but I still like `bc.impose()`. In your two examples, I feel like a flux is being _imposed_ and a value is being _imposed_. If `bc.calc()` calculates a number then it should be used as; ```julia; something = bc.calc(args...); ```; while `bc.impose` should be used like; ```julia; bc.impose!(args...); ```. But now we're just arguing semantics instead of what's important. > There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend. I think so too. API suggests more front-end. I also think discussing these dense and complicated issues (e.g. this PR and #120) among multiple busy people is difficult on GitHub. Little far ahead but maybe the Monday CliMA meetings are a good place to get high-level feedback?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439:776,interface,interface,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439,1,['interface'],['interface']
Integrability,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:333,integrat,integrated,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928,1,['integrat'],['integrated']
Integrability,"> No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`. Ah, I see. That's a good point, I'll investigate that. I'm wrapping things in `Field()` calls because I use the `data` option in all of them to reuse scratch space and save memory. But indeed when averages are involved that might not be the best way to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870:178,wrap,wrapping,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870,1,['wrap'],['wrapping']
Integrability,"> Nono in the code it should stay the same, because pressure due to `h` and `hB` should have opposite signs. Also for the `VectorInvariantFormulation` I directly calculate `g ∂xᵢ(h - hB)`. That depends on whether `b` is positive or negative. Before, `b <0`, and therefore the total height was `h = \eta -b`, where `\eta` is the free-surface. However, if `b > 0`, then `h = \eta + b`. . This becomes important when we evaluate the pressure graident. . In the first case we have, which is not what we had; ```; -∇η = -∇(h + b) = - ∇h - ∇b; ```; In the second case, we should have ; ```; -∇η = -∇(h - b) = - ∇h + ∇b; ```; which is what we have. Actually, now it seems that with changing the sign of `b`, the code is consistant with the equations we are now solving. Does that make sense?. But if you compute it directly, then do we need to extra `bathymetry` terms that I pointed to above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793:194,depend,depends,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793,1,['depend'],['depends']
Integrability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:169,depend,depends,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['depend'],['depends']
Integrability,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417,1,['interface'],['interface']
Integrability,"> OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans...; > ; > I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest. Can you just get rid of the constant called ""R_Earth""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295:201,depend,depending,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295,1,['depend'],['depending']
Integrability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:740,inject,injects,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['inject'],['injects']
Integrability,"> Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`. `nameof` is a cool idea. Is there a similar julia function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999:205,wrap,wrapper,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999,1,['wrap'],['wrapper']
Integrability,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1192,interface,interface,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195,1,['interface'],['interface']
Integrability,"> On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Agreed!. > If we have an array, say b_array, then can we can turn it into a field using b_field = ComputedField(b_array)?. Just `b_field .= b_array`. > Would it be of interest to have an option for it to not compute it at every time?. There are two ways to achieve this. The underlying data for a concrete `BackgroundField` can be updated via the `progress` callback every time step. A better method that's currently only possible currently with `HydrostaticFreeSurfaceModel` is to add it to the model's list of `auxiliary_fields`. In this case `compute!(field)` is called on every member of that list, so if the `BackgroundField` has a `compute!` method (eg if it's a `ComputedField`, or some other custom `Field` with a `compute!` method) then it will be updated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940:54,depend,dependent,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940,1,['depend'],['dependent']
Integrability,"> On a side note, since you asked, I am going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. What GPU are you running on? You'll need an Nvidia GPU and the CUDA library installed. Installing Oceananigans through the Julia package manager should install all the required Julia package dependencies (but won't install CUDA itself). Are you getting any errors?. Hmmm, so there is a small caveat that `Nx` and `Ny` need to be multiples of 16 on the GPU right now, although you'd get an error about this. > Should I create another issue?. Hmmm yeah that might be a good idea just to keep each issue self-contained. > (I'm not sure how much you guys want to be involved in these debugging processes...). We're very interested in being involved with the debugging process! We're still in early development so I'd expect things to break quite often, and we still haven't ironed out all the bugs and usability issues. We've also mostly been using the model ourselves (hard to improve usability if you know all the internals haha), so if you're willing to report issues it would be a huge help with development!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740,1,['depend'],['dependencies']
Integrability,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:348,depend,dependent,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996,1,['depend'],['dependent']
Integrability,"> Once the simulation is chugging along, it seems like the Poisson problem is not as difficult. It does seem like the solution becomes more accurate in time (but unfortunately, the CG solver does not start to converge more quickly...). The issue is interestingly related to this comment in MITgcm (which may be wrong by the way, but nevertheless reflects some observation about the CG solver): . https://github.com/MITgcm/MITgcm/blob/c7a06a2c29b2186c216f05f729b330d10e23c8be/model/src/cg3d.F#L86C1-L88C81. For this MWE, the RHS is 0 with `OpenBoundaryCondition(0.01)` on both sides, but not with `FlatExtrapolationOpenBoundaryCondition()`. @jm-c remarked that the RHS is also not zero for the Poisson equation beneath a free surface (which, in a z-coordinate, also essentially has an open boundary since $w(z=0) \ne 0$). > I'll close this issue since the original MWE works now. It's just a matter of setting maxiter. I think this comment is true in a practical sense. Possibly we do need another issue about the non-convergence of the CG solver. I think there is scope for someone to put in some effort to document this (eg come up with tools to evaluate convergence) and present a few nice MWEs (I think in addition to the present one with `FlatExtrapolationOpenBoundaryCondition()`, it would be nice to have a demonstration with impenetrable boundary conditions as well). . The way that the Poisson solver and open boundary conditions are intertwined is also a good reason to implement new open boundary condition matching schemes directly in Oceananigans @jagoosw . Note that we are also thinking about how to develop an interface to `Krylov.jl` in #3803 which may open up additional avenues for progress on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019:1625,interface,interface,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019,1,['interface'],['interface']
Integrability,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['interface'],['interface']
Integrability,"> One thing that I noticed is that advection seemed to be commented out for tracers. Did I read that right?. Yes --- because we are still finalizing the user interface that controls the advection term + advection scheme for momentum and tracers. I think ideally we want to preserve the ability to use high-order advection schemes for momentum when we are on a `RegularCartesianGrid`. However, we also have to use a ""vector-invariant form"" of the advection term when running on curvilinear grids. So we need a way to specify both continuous and numerical aspects of the advection term implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674:158,interface,interface,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674,1,['interface'],['interface']
Integrability,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:152,message,message,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890,1,['message'],['message']
Integrability,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:48,integrat,integrate,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764,4,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"> Out of curiosity @simone-silvestri could you check; > ; > ```julia; > fts2[1, 2, 3, 4] == fts2[1, 2, 3, 4.0]; > ```; > ; > in your example with the `.jld2` file above?. the outcome depends on whether `fts.times = [1, 2, 3, 4]` or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759:183,depend,depends,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759,1,['depend'],['depends']
Integrability,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:359,integrat,integrate,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827,2,['integrat'],['integrate']
Integrability,"> Perhaps this usage should be demonstrated in the `Forcing` docs or something... Yes, I think that would be really helpful. I just checked and, across all of the examples, callbacks are only used for the timestep wizard and progress messages. Probably for this reason a lot of others users also don't realize they are more generally useful!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659:234,message,messages,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659,1,['message'],['messages']
Integrability,"> Please add a small description of this PR in the top comment. Done. > Question: is Oceananigans the right place for the extension to be or an extension for Oceananigans in Enzyme?; > ; > (I'm not arguing for one or the other; I'm just wondering.). So I think here is the right place, since code has a dependency on Oceananigans itself and EnzymeCore (which is dependency free). It also is how other packages (like NNlib, LinearSolve, SciMLSensitivity, etc) work with Enzyme and other AD tools.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051:303,depend,dependency,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051,2,['depend'],['dependency']
Integrability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:882,mediat,mediated,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['mediat'],['mediated']
Integrability,"> Quick general question: with this interface IBM immediately goes to drag BC, right?. That's correct. There's no way to run IBM without a drag BC with this implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244:36,interface,interface,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244,1,['interface'],['interface']
Integrability,"> Requires [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) # On hold at the moment. At the top comment it says this PR depends on another KA PR that isn't merged. However, this PR is merged (and tagged). Does this not depend on https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 anymore?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719:168,depend,depends,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719,2,['depend'],"['depend', 'depends']"
Integrability,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:237,depend,depend,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788,1,['depend'],['depend']
Integrability,"> Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. I think my suggestion is being misinterpreted --- I was referring only to changes to software and data structures; not changes to the partial differential equations being solved. . If we do not ""add"" the constant background viscosity component to `model.diffusivities.νₑ`, we would instead add the contribution of the constant background viscosity to the total diffusive flux divergence separately from the contribution associated with the nonlinear eddy viscosity (similar to how the diffusive flux divergence for constant background viscosity is currently calculated without the auxiliary field `model.diffusivities.νₑ`). Thus my suggestion only changes the content of `model.diffusivities.νₑ` and otherwise preserves both the user interface and the default behavior for `Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation`. We could also completely remove ""constant background"" parameter from `AnisotropicMinimumDissipation` and preserve existing behavior, since users can use multiple turbulence closures to achieve the same effect, as in. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicViscosity(ν=1.05e-6)); ```. for example. This might be a better user interface than what we have now. As a side note, since there's no constant background viscosity that's appropriate for all scenarios, it should probably be zero by default if we continue to allow users to set it as a parameter in `AnisotropicMinimumDissipation` (eg #1278).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051:982,interface,interface,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051,2,['interface'],['interface']
Integrability,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,2,['interface'],['interface']
Integrability,"> So seems that all is good? So the problem comes when I continue the integration longer?. It appears that the issue does get worse the longer you run, yes. The original MWE I posted runs for 18 time steps and it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Running it for 2 time steps it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/220152519-7dab5501-6636-4c57-851d-5a944ab1d524.png). The results are still different from different tracers, but not visibly so. (The order of magnitude of the differences is around 1e-5 in this case)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615:70,integrat,integration,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615,1,['integrat'],['integration']
Integrability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:570,wrap,wrapper,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['wrap'],['wrapper']
Integrability,"> So the problem comes when I continue the integration longer?. This could be worth trying, note that. ```julia; julia> using Oceananigans.Units. julia> 0.15hours / 30; 18.0; ```. So you can run for 18 steps instead of 4. (@tomchor why 18?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605:43,integrat,integration,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605,1,['integrat'],['integration']
Integrability,"> So we want to look at model.clock.time and sch.previous_interval_stop_time + sch.interval. It does seem probable the issue is roundoff error. It does seem like a roundoff error, below is the progress message. At iter:64, for example, `model.clock.time` is slightly larger than `sch.previous_interval_stop_time + sch.interval` （which I think they should've been equal):. ```julia; [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds, model clock time:0.0, previous_interval_stop_time + interval:0.1, u-avg: 0.0, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.0, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.0, collecting: true; [ Info: ... simulation initialization complete (231.038 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (546.837 ms).; [ Info: Iter: 11, time: 100 ms, model clock time:0.1, previous_interval_stop_time + interval:0.2, u-avg: 0.1202985845671951, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.1, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.1, collecting: false; [ Info: Iter: 22, time: 200 ms, model clock time:0.2, previous_interval_stop_time + interval:0.30000000000000004, u-avg: 0.8057920910530502, window_start_time: 0.11, window_start_iteration: 12, previous_collection_time:0.2, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.2, collecting: false; [ Info: Iter: 32, time: 300.000 ms, model clock time:0.30000000000000004, previous_interval_stop_time + interval:0.4, u-avg: 2.0225593735128355, window_start_time: 0.21, window_start_iteration: 23, previous_collection_time:0.30000000000000004, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.30000000000000004, collecting: false; [ Info: Iter: 42, time: 400 ms, model clock time:0.4, previous_interval_stop_time + interval:0.5, u-avg: 3.664512241688186, window_start_time: 0.3100000000000001, window_start_iteration: 33,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302:202,message,message,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302,1,['message'],['message']
Integrability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:704,interface,interface,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['interface'],['interface']
Integrability,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1136,depend,depends,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577,3,"['depend', 'integrat']","['depend', 'depends', 'integrated']"
Integrability,"> Some good news is that more tests seem to be passing compared to the prevoius PR.; > ; > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > ; > ```; > Testing Oceananigans; > # Received cancellation signal, interrupting; > ```. I don't know what you saw.; But what I see here: . https://buildkite.com/clima/oceananigans/builds/14750. is that almost all tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960:102,message,messages,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960,1,['message'],['messages']
Integrability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:327,wrap,wrap,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,1,['wrap'],['wrap']
Integrability,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:122,message,message,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,2,['message'],['message']
Integrability,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:444,message,message,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161,6,['message'],"['message', 'messages']"
Integrability,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:501,depend,depend,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329,1,['depend'],['depend']
Integrability,"> Thanks @glwagner . I started but have a few questions.; > ; > * Why didn't the hydrostatic model need a `with_halo` function?; > * I started to write a `new_halo` function in `ImmersedBoundaries.jl` but don't think this is the right spot. Where should it go?; > * Most of the function is pretty easy except for when we define the new_grid. What I have [here](https://github.com/CliMA/Oceananigans.jl/blob/5ea7b9168a40619a17d2c9ab42b65b622a7c9ac1/src/ImmersedBoundaries/ImmersedBoundaries.jl#L86) is wrong but can you help me modify it? It seems like we know infomration about the bump but that is not currently passed in new_halo. Maybe we need to pass more information?. I guess the hydrostatic model doesn't call `with_halo`:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl. I think you need `with_halo` rather than `new_halo`, if I read the error message correctly. In that case I think the needed function is a one-liner:. ```julia; with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. But maybe I am missing something? I don't quite understand what you mean about `new_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667:932,message,message,932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667,1,['message'],['message']
Integrability,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:816,depend,depend,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,2,['depend'],['depend']
Integrability,"> Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?. Yes, that makes sense! I do think we need to have a way to test the different methods... ideally, the tests are non-trivial enough to illustrate that the numerics ""works"" for each ingredient that we implement (either independently or when combined with other ingredients to make a recipe). But the tests don't have to be exhaustive; I imagine it will take some time to develop our best practices.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530,1,['depend'],['dependent']
Integrability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:342,depend,dependence,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['depend'],['dependence']
Integrability,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:761,depend,depending,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,1,['depend'],['depending']
Integrability,"> That's not my intention at all. I have plans to try to implement a dynamic option with or without the above flexibility I proposed. I do think there are legitimate reasons to allow for a user-defined coefficient. Like manually decreasing the coefficient in regions where it's overly diffusive, or when running wall-resolved LES. Basically, since the necessary change is a couple lines of code, I tend to think that flexibility is worth it. That said, the `Array`-based method you proposed can also cover these cases. Ok, but you proposed an interface that would include the velocity field. What are the use cases for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089:543,interface,interface,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089,1,['interface'],['interface']
Integrability,"> The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before. Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783:606,depend,dependent,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783,1,['depend'],['dependent']
Integrability,"> The changes look good to me but I admit that I am a bit confuses as to when we have superscripts a vs c or f. The superscript `a` refers to ""Any"" location. For example, the difference operator `δxᶜᵃᵃ` is _independent_ of the `y` and `z` directions:. https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Operators/difference_operators.jl#L7. Thus this operator is valid if `y` and `z` are respectively `Center` or `Face`. When this is not true (for example, on a horizontally-curvilinear grid, the grid spacing in the x-direction depends on both `x` and `y` location), we need to explicitly specify the location of the operator / object.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548:569,depend,depends,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548,1,['depend'],['depends']
Integrability,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:154,wrap,wrapping,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141,1,['wrap'],['wrapping']
Integrability,"> The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids. Shall we do this? In case we want to do it I have prepared https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/47.; If yes, we can merge that one then this one, then update OrthogonalSphericalShellGrids with the new interface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222:6,depend,dependency,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222,3,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"> The error message we are gettig now does not seem to involve this PR at all.; > ; > If that is the case do we need to reset it?. Yeah, this is an annoying error we get sometimes for reasons unbeknownst to me. I'll restart the build.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164:12,message,message,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164,1,['message'],['message']
Integrability,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197:648,interface,interface,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197,2,['interface'],['interface']
Integrability,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:101,depend,depending,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908,2,['depend'],['depending']
Integrability,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:161,depend,dependence,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['depend'],['dependence']
Integrability,"> The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > ; > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:. First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this. You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface. As I said though, I agree it's a good idea to make this kind of thing easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620:458,interface,interface,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620,2,['interface'],['interface']
Integrability,"> The purpose of this PR was to save mutliple scalars using `NetCDFOutputWriter` and there seemed to be some problems, i.e. some checks fail.; > ; > @glwagner mentioned that maybe `using Statistics: norm` might work without any additional work. Is this the case? If yes then I am happy to close this PR and give it a try on the shallow water Bickley jet example. Ah... the change is fairly innocuous, there's just a few things that make me nervous. 1) It _shouldn't_ fix the problem that it's intended to fix. Unless there's something I am missing... if it fixes the problem that was raised, it's due to some unintended side effect that we don't understand? (Providing some detail and the error message that was received could help, or it could be raised in an issue). A more grave concern is 2) it will slow down the code and cause memory allocation. This is almost always completely negligible since other parts of the code matter more, but it could affect small models, our CI pipeline, etc. It's hard to intentionally throw away type stability :-/ So in a way it's creating technical debt and possibly creating work for us in the future...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415:695,message,message,695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415,1,['message'],['message']
Integrability,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:58,integrat,integrated,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,4,['integrat'],['integrated']
Integrability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:342,rout,routine,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['rout'],['routine']
Integrability,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:247,wrap,wrapped,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,2,['wrap'],['wrapped']
Integrability,"> This function only works if you have a diagnostic though. I prefer to simply output the horizontal averages directly to file. How would I do that with the code in this PR?. If you don't want to use a diagnostic, you'd have to pre-allocate a 1D CuArray of size `1*1*Nz` for `Rxy` and a 2D CuArray of size `1*Ny*Nz` for `Rx`, then call `gpu_accumulate_xy!(Rxy, Rx, data, nothing, +)`, then save `Rxy` to disk. Seems like that would be less efficient as you'd have to pre-allocate memory every time you want to calculate a horizontal average. Which is why having a `VerticalProfile` diagnostic that takes care of this stuff is nice. We could write a wrapper function that allocates the arrays, and returns only the horizontal average.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786:649,wrap,wrapper,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786,1,['wrap'],['wrapper']
Integrability,"> This is good after changes.; > ; > My only question is whether another implementation might be something like; > ; > ```julia; > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > !isa(grid2, typeof(grid1).name.wrapper) && return false; > topology(grid1) == topology(grid2) && return false; > ; > x1, y1, z1 = nodes((Face, Face, Face), grid1); > x2, y2, z2 = nodes((Face, Face, Face), grid2); > ; > return x1 == x2 && y1 == y2 && z1 == z2; > end; > ```; > ; > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > ; > ```julia; > julia> 1.0 == ones(2); > false; > ```; > ; > we may want to identify this case with numeric equality for a grid.; > ; > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes. OK, perhaps then your suggestion is better.; What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368:227,wrap,wrapper,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368,1,['wrap'],['wrapper']
Integrability,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:273,depend,depending,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,2,"['depend', 'synchroniz']","['depending', 'synchronization']"
Integrability,"> This is great, though I'm wondering what it's role in the Oceananigans code base is. Is the intention to remove these bits once WENO is actually implemented in the code?. Yeah so the point of this PR was to test the WENO operators independently of Oceananigans.jl (also to play around with how advection schemes interact with different time steppers). The WENO operators were coded so that we can readily integrate them with the existing operators in `tracer_advection_operators`. So when an advection scheme abstraction is implemented and `weno.jl` is integrated into the main code, `verification/tracer_advection_1d/tracer_advection_1d.jl` can be converted into an Oceananigans.jl verification experiment. Right now it's just a WENO-5 verification experiment. > Why not?. Ah sorry I wasn't clear. I just didn't think running with CFL=4 would be possible in 3D. > I think the first course of action may be to do something similar to what we did for the nonlinear equation of state: implement a simple new advection scheme (even as simple as first order upwind?) for the purpose of designing an `Advection` abstraction. Agreed. First-order upwind is actually included in this PR; ```julia; @inline ∂x_advective_flux(i, Δx, u, ϕ, ::FirstOrderUpwind) =; max(u[i], 0) * (ϕ[i] - ϕ[i-1])/Δx + min(u[i], 0) * (ϕ[i+1] - ϕ[i])/Δx; ```; but it's so diffusive I don't know if we want to include it as an option (although it's up to the users, they may have a good reason to use first-order upwind).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751:407,integrat,integrate,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751,2,['integrat'],"['integrate', 'integrated']"
Integrability,"> This looks super cool: I'll be happy to meet for coffee and chat in person (assuming you're both at MIT) but I am not very familiar with tools in climatology* and think @meggart @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:394,interface,interface,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['interface'],['interface']
Integrability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:694,interface,interface,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['interface'],['interface']
Integrability,"> Those animations look great @tomchor, thanks for working so hard to put this together.; > ; > One observation is that the first plot, the velocity, shows that the initial structures are very small scale in both the horizontal and the vertical. I wonder if increasing \nu would produce an aniamtion that is better resolved?. Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example. . This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. > ; > As for what to do with this, you are the creator, but I would sugget creating a doc. This is a great opportunity to show the nice results and help teach people how to use different features. By creating a doc, do you mean docs example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873:688,depend,depends,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873,1,['depend'],['depends']
Integrability,"> To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on TimeInterval which should, in theory, work perfectly. Wouldn't the MWE I posted above work? Or do you mean a MWE that generates round-off errors at _predictable_ times? (I cannot predict when the errors will occur in the MWE above.). > Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues. I agree with this point, but I feel like I'm also missing something here. Let's say we change the pressure correction so that it works for machine epsilon. Won't the pressure gradient force still depend on `Δt`? That is, won't it be larger for small `Δt`s and vice-versa? If so, this implies the pressure gradient doesn't converge with `Δt` and if so, how do we close a budget where the pressure term is important? (Maybe that's a question for another place also... I don't want to derail the discussion from the specific issue at hand.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427:861,depend,depend,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427,1,['depend'],['depend']
Integrability,"> True.; > ; > @tomchor would you be keen to add drag in the internal tide example? If you just add the code I can deal w the rest. I can, but I don't really see drag there adding value to the example. @navidcy, do you think it would be relevant to the physics? Or do we just want drag to be there as an example of using the interface?. Also, I'm not very familiar with these larger-scale, hydrostatic simulations. What's the physically-preferred way to add drag there? Does something like. ```math; \vec\tau = -C^D \vec u \sqrt{u^2+v^2}; ```; (applied to `bottom`, `west` and `east`, with $C^D \approx$ 1e-3) look reasonable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789:325,interface,interface,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789,1,['interface'],['interface']
Integrability,"> Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`. Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090:138,synchroniz,synchronization,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090,1,['synchroniz'],['synchronization']
Integrability,"> Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > ; > ; > ; > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > ; > ; > ; > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up. . Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though. We can calculate more metrics for sure. I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?. Here are some docs:. https://numba.pydata.org/numba-doc/latest/user/parallel.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990:257,depend,dependent,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990,1,['depend'],['dependent']
Integrability,"> Was it some random one-off stochastic error?. Turns out this happens on a Quadro GP100 GPU, but not on a Tesla V100. I'm using Julia 1.8.3 on NCAR's Casper server using the (current as of this message) main branch. Not sure what to do about this. Does it have to do with the Compute Capability? @navidcy which GPUs does tartarus have again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705:195,message,message,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705,1,['message'],['message']
Integrability,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:279,interface,interfaces,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483,2,['interface'],['interfaces']
Integrability,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287:516,rout,routine,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287,2,['rout'],['routine']
Integrability,"> We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > ; > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector). Okay, so a longer term plan. For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586:118,depend,depends,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586,1,['depend'],['depends']
Integrability,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:225,depend,depends,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568,1,['depend'],['depends']
Integrability,"> We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).; > ; > _Originally posted by @glwagner in [#2050 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805)_. Wouldn't it be better to have something like `Δx = grid_spacing(model.velocities.v, 1)`? Because I'm assuming the `Δx` has to change depending if they want to use it on a quantity that lies on a `Face` or `Center` node in that direction. Maybe just `Δx = grid_spacing(Face, grid, 1)`, or something akin to the already-existing `nodes` function, that returns all 3 at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357:396,depend,depending,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357,1,['depend'],['depending']
Integrability,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:941,interface,interface,941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,2,['interface'],['interface']
Integrability,"> Well, I don't know what is long or short (but I agree, O(10mins) seems bit long). But most importantly, in my benches I find that v0.90.1 is **faster** than 0.89.3, contrary to what you claim. Do you see a difference if you wrap `ζ` in `Field`? I guess that is my major claim.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622:226,wrap,wrap,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622,1,['wrap'],['wrap']
Integrability,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1727,message,messages,1727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267,2,['message'],['messages']
Integrability,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:1001,depend,depend,1001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['depend'],['depend']
Integrability,"> What's the motivation for using a macro rather than multiple dispatch?. The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:591,depend,dependent,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,1,['depend'],['dependent']
Integrability,"> When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?; > ; > ```; > [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; > ```. This is a warning, not an error right?. Yes, I think it'd be good to change the warning (since it's wrong). I would save this for another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244:67,message,message,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244,1,['message'],['message']
Integrability,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938:393,interface,interface,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938,2,['interface'],['interface']
Integrability,"> Would it be in the scope of this PR to add to `regularize_field_boundary_conditions` or similar to automatically add a warning when one tracer is specified as having an open boundary but others are not? Alternativly to set some default alternative but I'm not sure what that would be. We could but it might be good to look at what the code looks like first. Adding a warning makes an assumption about what the user inteface is, but we haven't really discussed exactly what we want the user interface to look like. You can include a script for the visualization above perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004737693:492,interface,interface,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004737693,1,['interface'],['interface']
Integrability,> Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead). The internet says to use `times::Vararg{Number}`. somewhere in . https://discourse.julialang.org/t/deprecation-warnings-from-atom-with-v1-7/72400/3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567728743:2,Wrap,Wrapping,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567728743,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,> Yeah I encountered it when trying to put some interpolations with arrays in a DiscreteForcing. I guess they're not as commonly used as ContinuousForcing. Might be nice to have an interface for that for `ContinuousForcing`!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1642#issuecomment-836949524:181,interface,interface,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1642#issuecomment-836949524,1,['interface'],['interface']
Integrability,"> Yeah, I've done some tests here: [#3646 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101); > The 1D test is consistent with the analytical solution, which works great!. @liuchihl, I think @navidcy is asking about smaller unit tests that could be run in Continuous Integration (CI) to automatically test the package whenever any changes get made. The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of $\text{Flux} = - \kappa \partial_{z} c$ at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950:303,Integrat,Integration,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950,1,['Integrat'],['Integration']
Integrability,"> Yep, I would call it bulk velocity though, instead of phase speed, and change the name from `Orlanski` to something more descriptive like `AdvectiveOutflow`. But these are mathematically identical right? Orlanski called is a ""phase speed"", but ""outflow velocity"" is equally valid and refers to exactly the same mathematical object. The reference you posted says. > The test results also confirm that this type of boundary condition, which was originally designed by Orlanski primarily for equations which are hyperbolic in nature, also performs well for parabolic problems. I think we can keep the name ""Orlanski"" and provide a generic interface for specifying the outflow speed (whatever you want to call it). It can be user-specific, dynamically computed, etc. The code can be extensible, so if users want to experiment with different methods for computing the outflow speed, this is possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832:638,interface,interface,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832,1,['interface'],['interface']
Integrability,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736:849,integrat,integration,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736,2,['integrat'],['integration']
Integrability,"> Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example.; > ; > This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. I think underresolution is ok; many of the examples are underresolved, mostly because we want them to be cheap. The docs examples (in my opinion) are to demonstrate code functionality; eg give users the tools and inspiration they need to set up their own experiments. . A great docs example does go above and beyond and also includes lessons about physics, style and scripting practices, and creative uses of the code. So we could imagine a docs example that illustrates the _concept_ of numerical convergence, and how to build such a test using Oceananigans. But I don't think the mere _realization_ of convergence is that helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791:369,depend,depends,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791,1,['depend'],['depends']
Integrability,"> Yes. Given the derivation I posted, and what @glwagner said, it seems like we want to be using the velocity at an edge not the cell-averaged values, which is what we are storing as fields. But I could be missing something here. I think we are making a particular choice: because we are using a staggered grid, we can reconstruct the velocity field at tracer cell interfaces simply be evaluating the cell-averaged velocity field there. Perhaps this reconstruction has a particular order of accuracy (eg second-order?) I'm not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567:365,interface,interfaces,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567,2,['interface'],['interfaces']
Integrability,> Yes. We essentially want to mapreduce over operations like w / Δz but w and Δz need to have the same size for mapreduce to work on multiple iterators (w and Δz). They have different sizes on all grids right now. Can we wrap the reduced objects somehow so that the iterators for both objects match?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698:221,wrap,wrap,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698,1,['wrap'],['wrap']
Integrability,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:215,message,message,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073,1,['message'],['message']
Integrability,"> You can start by allowing the coefficient to be an array as in AMD:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143; > ; > Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure.; > ; > I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. I see what you mean. That's a good point. I think I'll start with that PR. > A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... That's not my intention at all. I have plans to try to implement a dynamic option with or without the above flexibility I proposed. I do think there are legitimate reasons to allow for a user-defined coefficient. Like manually decreasing the coefficient in regions where it's overly diffusive, or when running wall-resolved LES. Basically, since the necessary change is a couple lines of code, I tend to think that flexibility is worth it. That said, the `Array`-based method you proposed can also cover these cases. > @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187186033:862,interface,interface,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187186033,2,['interface'],['interface']
Integrability,"> You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence.; > ; > Does `AnisotropicMinimumDissipation` work? Or other closures?. Nice catch! It does work for AMD. I hadn't tried that before because I assumed it wasn't gonna work. Unfortunately I can't really use AMD because it produces a lot of noise in the stratified regions of my domain, but hopefully adapting Smag isn't too hard?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249:167,integrat,integrated,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249,1,['integrat'],['integrated']
Integrability,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:423,depend,depends,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461,2,['depend'],['depends']
Integrability,"> `KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown. Thank you. I was about to comment this:; > Another thing with the new kernels. I believe I've now got the particle advection kernels working, but unless some event causes a delay, for example printing some informaiton out, the `advect_lagrangian_particles!` event does not finish before the test tries to test that its been correctly done which causes it to fail. . >If I change it so that `advect_lagrangian_particles!` returns `advect_particles_kernel!(...`, and wrap `advect_particles_kernel!` in wait (i.e. `wait(advect_lagrangian_particles!(particles, model, Δt))`) then it does run correctly. . >This seems like a bigger issue with how kernel events are working? If other events aren't being finished in order this might cause other issues?. But the new alternative should be to call `KernelAbstraction.synchronize(device(arch))` instead then?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017:21,synchroniz,synchronize,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017,3,"['synchroniz', 'wrap']","['synchronize', 'wrap']"
Integrability,"> ```julia; > @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; > condition = arch_array(architecture(operand.grid), condition) ; > return ConditionalOperation(operand; func, condition, mask) ; > end ; > ```. I think there's a typo here that's making it so that the computation doesn't exclude the nodes inside the immersed boundary. I think the correct definition is closer to what I suggested in https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904623674. Specifically `condition` need to be wrapped around `NotImmersed`:. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end; ```; which seems to produce the correct result on the CPU, but I can't get it to work on GPUs. Here's a MWE I cooked up where we can check that the results are correct:; ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch, size = (1, 4, 4), extent = (1,1,1)); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> -1/2)). using Oceananigans.AbstractOperations: ConditionalOperation; using Oceananigans.Fields: AbstractField; import Oceananigans.Fields: condition_operand; IF = AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}; using Oceananigans.ImmersedBoundaries: NotImmersed. using Oceananigans.Architectures: architecture, arch_array; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end. using Oceananigans.Grids: ynode, znode; yᶜᶜᶜ = KernelFunctionOperation{Center, Center, Center}(ynode, grid, Center(), Center(), Center()); zᶜᶜᶜ = KernelFunctionOperation{Center, Center,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213:560,wrap,wrapped,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213,1,['wrap'],['wrapped']
Integrability,"> ```julia; > OpenBoundaryCondition(nothing) # impenetrable; > OpenBoundaryCondition(1) # external state = 1, no matching scheme; > OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; > ```. This does seem like the best user interface for it. Is keeping the external state in the condition and the matching scheme in `Open` okay then?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986472888:256,interface,interface,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986472888,1,['interface'],['interface']
Integrability,"> ```julia; > function fill_west_and_east_halo!(c, west_bc, east_bc, size, offset, loc, arch, grid, args...; kwargs...); > west_bc_args = get_boundary_arguments(west_bc, Val(:west), size, offset, loc, arch, grid, args...; kwargs...); > east_bc_args = get_boundary_arguments(east_bc, Val(:east), size, offset, loc, arch, grid, args...; kwargs...); > ; > return launch!(arch, grid, KernelParameters(size, offset),; > _fill_west_and_east_halo!, c, west_bc, east_bc, loc, grid, west_bc_args, east_bc_args, Tuple(args); kwargs...); > end; > ```; > ; > Where the default behaviour is:; > ; > ```; > get_boundary_arguments(args...; kwargs...) = (); > get_boundary_arguments(bcs::Tuple, args...; kwargs...) = Tuple(get_boundary_arguments(bc, args...; kwargs...) for bc in BCS); > ```; > ; > But we can add methods like this:; > ; > ```; > get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow}, side, size, offset, loc, arch, grid, args...; kwargs...) = (@info typeof(bc); (bc.classification.bulk_speed, )) # fallback; > ; > function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); > u = fields.u; > ; > # THIS WILL NOT BE GPU FRIENDLY; > Uᵇ = sum([u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid) for j=1:grid.Ny, k=1:grid.Nz]) / (grid.Ly * grid.Lz); > ; > return (Uᵇ, ); > end; > ```; > ; > If everyone is happy with this my next issue is working out how to calculate Ub in a way that will work on GPU since boundary conditions are defined before Fields so I can't use `Average`.; > ; > I also made a subdirectory for these boundary conditions but then I realised it would be easiest to not have different classifications depending on where Ub is coming from so I didn't have to make as many different things so I'll move them back at some point. I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977651465:2189,depend,depending,2189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977651465,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:97,depend,dependency,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667,4,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"> afaik the second test filter is only needed when assuming that `β` can vary between scales. I think you're correct here! Sorry for the confusion here, but I suppose by scale-invariance I mean `β` has a power law dependence on the scale size. And since we were trying to implement the scale-dependent version, `β` would vary across different scales? Hence we need the `α=4` filter as well. Am I understanding Equation (26) in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152) correctly here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187284277:214,depend,dependence,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187284277,2,['depend'],"['dependence', 'dependent']"
Integrability,"> any suggestions for tests I might add to get the coverage up?. Hmmm, I think for now it's sufficient that the regression tests pass as this PR should preserve existing functionality. If you're going to implement more rigorous/high-level LES tests in the future then the coverage will go up. And it'll probably become clearer which unit tests are needed. > Lastly, I am thinking that all the doc strings in closure_operators.jl are actually a detriment to readability and understandability. Thoughts?. I kind of agree, but with the docstrings we can integrate them into the documentation, and if the docstrings have LaTeX then we can view the operators alongside the math in the docs. I guess it's readable documentation vs. more readable code? Good practice says we should probably keep them, but maybe we can separate them somehow? I guess right now we only read the code but maybe in the future we'll mainly be reading the docs and not the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848:551,integrat,integrate,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848,1,['integrat'],['integrate']
Integrability,"> as mentioned on slack here's @jlk9 's Enzyme integration test PR #3480; > ; > We should check that the tuple doesn't also break that (or try to find the correct mutually happy solution like maybe vararg type). @jlk9 , the test on #3480 does not pass right now, is that correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1946397811:47,integrat,integration,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1946397811,1,['integrat'],['integration']
Integrability,"> but that would mean passing the simulation to the time step, which is not ideal. We can create a schema where the argument to `Callback.func` depends on ""flavor"" / ""callsite"", etc, similar to how we have different ""forms"" for boundary conditions and forcing functions. > Do we need to support that accurate callback (happening at each RK substep)?. I guess as @jagoosw argues this is an important feature to support for advanced applications. There are a few different ""intra time step"" callsites we might envision (modifications to `calculate_tendencies!` differ from modifications to `update_state!`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832:144,depend,depends,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832,1,['depend'],['depends']
Integrability,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759:104,wrap,wrapper,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759,2,['wrap'],['wrapper']
Integrability,"> it took me a while to understand that I couldn't put abstract operations into the output writers. This makes sense to me --- after all, who cares what a `Field` is? We want to write a computation to disk. Maybe we should support AbstractOperations and Reduction as output directly, to save the boilerplate of always wrapping things in `Field`? It occurs to me that the majority of users don't really need to know what a `Field` is (at least not when they're starting out).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829:318,wrap,wrapping,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829,1,['wrap'],['wrapping']
Integrability,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:80,depend,dependencies,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786,4,['depend'],['dependencies']
Integrability,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:763,integrat,integration,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882,3,"['depend', 'integrat']","['depends', 'integration']"
Integrability,"> oh @francispoulin I now saw your message!. Great minds think alike, and at the same time it seems! ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389:35,message,message,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389,1,['message'],['message']
Integrability,"> oh now I saw that the secondary hidden commit message talks about ""a bug..."" can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:48,message,message,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['message'],['message']
Integrability,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:284,interface,interface,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238,3,['interface'],"['interface', 'interfaces']"
Integrability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:801,interface,interface,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,2,['interface'],['interface']
Integrability,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230:210,wrap,wrapping,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230,4,['wrap'],"['wrap', 'wrapping']"
Integrability,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:53,depend,depend,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287,2,['depend'],"['depend', 'dependent']"
Integrability,"> with bathymetry we would have -g∂ₓ(h + b - H) = -g∂ₓh -g∂ₓb, and in conservative form, -g∂ₓ(h²/2) -gh∂ₓb, right?. Oh, this seems right. Apologies for the confusion. I'm still not sure we want to analytically integrate one of the pressure gradient terms `h dx(h) = dx(h^2/2)` but leave the other unchanged. If we treat them both similarly then we would write the pressure gradient term. ```; -g h * ∂ₓ(h + b); ```. It might be worth testing both possibilities to see if one has favorable numerical properties?. Perhaps this is related to the whole issue re: well-balanced methods, etc... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115162071:210,integrat,integrate,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115162071,1,['integrat'],['integrate']
Integrability,"> yes but it has to be non-linear, advecting w velocity with a spatially constant u and v velocity doesn't cut it. Because that doesn't test a multi-dimensional implementation? That makes sense. I just wanted to clarify what was meant by ""nonlinear"". Some source refer to WENO for tracer advection as ""nonlinear"", because the weights depend on the tracer field itself. The key is to test multi-dimensional momentum advection, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219:334,depend,depend,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219,1,['depend'],['depend']
Integrability,"> ~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~; > ; > ~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~; > ; > ~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~; > ; > This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?. What is the problem you are trying to solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171:257,depend,dependency,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171,1,['depend'],['dependency']
Integrability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:192,integrat,integration,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,2,['integrat'],['integration']
Integrability,"@EavenW here is some code for you:. ```julia; using Oceananigans; using Oceananigans.Fields. f = 1e-4 # [s⁻¹] Coriolis parameter. # Use 'const' so boundary functions work on the GPU.; const ω = 2π/f # [s] Inertial period; const u★ = 0.01 # [m s⁻¹], friction velocity. # fluxes *kinematic* because they are applied to the velocity field. ; x_momentum_flux(x, y, t) = u★^2 * cos(ω * t); y_momentum_flux(x, y, t) = u★^2 * sin(ω * t). τˣ = BoundaryFunction{:z, Face, Cell}(x_momentum_flux); τʸ = BoundaryFunction{:z, Cell, Face}(y_momentum_flux). u_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τˣ)); v_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τʸ)); ```. As @ali-ramadhan we are redesigning this API this week. So expect changes very soon if you keep `Oceananigans` updated. We think the API will become clearer and easier to use. This code is young so we certainly appreciate comments and criticism that will help us make the code easier-to-use. I just noticed that the docstring defined inside the struct does not print at the REPL, so here it is:. ```julia; """"""; BoundaryFunction{B, X1, X2}(func); A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; """"""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856:1158,wrap,wrapper,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856,1,['wrap'],['wrapper']
Integrability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:389,depend,depending,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,1,['depend'],['depending']
Integrability,"@Yixiao-Zhang what is the new user interface? Are you referring to the changes on #3142 ?. Either way, I recommend that you set up your simulation without using `ImmersedBoundaryCondition` at all. `ImmersedBoundaryCondition` is not appropriate for most physical modeling (I am considering whether we should say this more explicitly in the docstring). I suggest trying. ```julia; FieldBoundaryConditions(immersed=the_bottom_heating); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579,1,['interface'],['interface']
Integrability,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024:860,interface,interfaces,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024,2,['interface'],['interfaces']
Integrability,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:99,message,message,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,1,['message'],['message']
Integrability,@ali-ramadhan and I created that warning message. Maybe it's too agressive and we should rethink it as people clearly become concerned by it? Will have to think about that a bit more but glad it's working!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440:41,message,message,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440,2,['message'],['message']
Integrability,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:789,Wrap,Wrap,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['Wrap'],['Wrap']
Integrability,"@ali-ramadhan do you have any thoughts on the design of `x, y, z` `Topology` traits for the grid? I think this is becoming more important, especially because we now have two grids. This may be an essential abstraction, so we may want to make it a ""medium"" priority to implement it (and also eliminate a lot of boiler plate associated with `ChannelModel` constructor. It also will break the user API because it will enable a much simpler and straightforward interface for specifying boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695,1,['interface'],['interface']
Integrability,@ali-ramadhan that sounds neat! Also integrate DimArray with AbstractField so the spatial dimensions can also be named? That might be the first thing to do; then we just have to add Time to DiskTimeSeries. You are a lot more familiar with DimArray so whatever makes sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852:37,integrat,integrate,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852,1,['integrat'],['integrate']
Integrability,@apaloczy just wanted to thank you for raising this issue!. I'm going to take this strategy to fix it:. 1. First merge #2426 (this changes `fill_halo_regions!`); 2. Update the halo filling interface so that field _location_ is passed into the boundary kernels. We can then use field location to infer the correct metrics. It might make sense to include 2. as part of #2437 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727:189,interface,interface,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727,1,['interface'],['interface']
Integrability,"@arcavaliere just to clarify what I think this issue is all about: during a simulation we often would like to print messages that inform us of the simulation's progress. One example of this comes from a `@printf` statement inside a time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting de",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:116,message,messages,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,['message'],['messages']
Integrability,"@fluidnumerics-joe, is the `GPUArrays` a dependency only for the `allowscalar`? If so, I think `GPUArraysCore` is much more lighter and includes `allowscalar`. (saw this from @vchuravy's attempts over at https://github.com/CliMA/Oceananigans.jl/pull/3066)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1943471486:41,depend,dependency,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1943471486,1,['depend'],['dependency']
Integrability,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:726,integrat,integrate,726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['integrat'],['integrate']
Integrability,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:703,message,messages,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,3,"['message', 'wrap']","['messages', 'wraps']"
Integrability,"@francispoulin explained the situation well for `Gradient` and `Value` boundary conditions. I'd like to restate what he said in the context of the finite volume method and clarify the situation for `Flux` boundary conditions because I said something wrong above... Oceananigans uses a weak formulation of PDEs via the finite volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:379,integrat,integrated,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,4,"['integrat', 'interface']","['integrated', 'interfaces']"
Integrability,"@francispoulin is this a better solution?. ```julia; julia> scheme1 = UpwindBiasedThirdOrder(); UpwindBiasedThirdOrder(). julia> scheme2 = WENO5(); ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Research/Oceananigans.jl/src/Advection/weno_fifth_order.jl:145; WENO5 advection scheme with:; ├── X regular; ├── Y regular; └── Z regular. julia> string(typeof(scheme1).name.wrapper); ""UpwindBiasedThirdOrder"". julia> string(typeof(scheme2).name.wrapper); ""WENO5""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458:469,wrap,wrapper,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458,2,['wrap'],['wrapper']
Integrability,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:547,Integrat,Integrated,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['Integrat'],['Integrated']
Integrability,"@glwagner : . I am trying to follow the reasoning as to why the momentum flux does not need the area terms and I have an idea. First, I have tried to follow the dependencies of the flux function and find the following:. `div_hUu` -> `momentum_flux_huu`, -> `_advective_momentum_flux_Uu` -> `advective_momentum_flux_Uu`. The final function is defined for either centered of upwinding schemes. . `centered_advective_fluxes.jl` has a defintion that shows it's proportional to `Ax`, and hence the area: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/centered_advective_fluxes.jl#L15. `upwind_biased_advective_fluxes.jl` has a definition that shows it is proportional to `Ax` as well: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/upwind_biased_advective_fluxes.jl#L24. Something similar is true for `advective_tracer_flux`, and those can be found in the same files. Does this answer the question why there should not be any area terms in the flux?. If this convention is confusing, do we want to do something different?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004:161,depend,dependencies,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004,1,['depend'],['dependencies']
Integrability,"@glwagner @navidcy the biggest blocker here is AMGX. I would propose moving AMGX support to a separate package?. The primary motivation is that ideally `Oceananigans` should not depend directly on CUDA.jl, but ""just"" use KA. The backend packages are large and not necessarily compatible. So all CUDA.jl/AMDGPU.jl/Metal.jl specific code should go into an extension package.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1497609415:178,depend,depend,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1497609415,1,['depend'],['depend']
Integrability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:444,depend,dependent,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,4,['depend'],"['dependent', 'dependent-Lagrangian-dynamic-model-for']"
Integrability,"@glwagner Just FYI, some of the things that did not work for you, actually worked for me. Most notably:. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Center, Center, Center) via identity;    ├── + at (Center, Center, Center);    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Center) via ℑzᵃᵃᶜ;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(tke). julia> ; ```. So it appears to be machine-dependent at least to some extent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354:1306,depend,dependent,1306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354,1,['depend'],['dependent']
Integrability,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:64,message,message,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700,2,['message'],['message']
Integrability,"@glwagner Sorry, I missed these messages and just saw them now. I further inspected the code and it seems that the discrepancy comes from having one of the directions with `size=1`, simulating a `Flat` dimension. I'm not sure how worrisome this issue is given that you have PR https://github.com/CliMA/Oceananigans.jl/pull/1340, which may address this issue? . So, for example, consider the code block below (btw, I'm sorry that my examples are large, but I don't quite know how to create fields with BCs very well without creating a model behind it...):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. # Get simulation parameters; f0 = 1e-4; dudy = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:32,message,messages,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445,1,['message'],['messages']
Integrability,"@glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056:87,message,message,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056,1,['message'],['message']
Integrability,@glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future. . Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109:78,interface,interfaces,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,@glwagner is this PR breaking only because of the deletion of `MEWSVerticalDiffusivity`?. Or is there something else that's breaking in the `Simulation` interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837:153,interface,interface,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837,1,['interface'],['interface']
Integrability,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/737:161,depend,dependence,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737,1,['depend'],['dependence']
Integrability,"@glwagner thanks for clarifying. Coming from an atmospheric sciences background, I'm a bit unclear on the details of TEOS-10 and the nuances associated with it. In particular it seems counter-intuitive to me how an equation of state that depends on depth fits in a Boussinesq fluid (where adiabatic rearrangement of parcels shouldn't change their buoyancy). But this probably isn't the best place to have a long discussion about it. Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109:238,depend,depends,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109,2,['depend'],['depends']
Integrability,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:870,integrat,integrating,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['integrat'],['integrating']
Integrability,"@glwagner this should reproduce the error. The message is thrown when calling `set(model,...)`. ```using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, mask_immersed_field!. using Oceananigans.Architectures: device; using Oceananigans.Grids: xnode, znode; using KernelAbstractions: MultiEvent; using JLD2; using Printf; #using GLMakie; using SpecialFunctions. arch = GPU(); Nx = 256; Nz = 64 # Resolution; #Ny = 64; κ = 1e-6 # Diffusivity and viscosity (Prandtl = 1). underlying_grid = RectilinearGrid(arch,; size = (Nx, Nz),; x = (0, 5),; z = (-0.05, 1.0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). #const gamx = 2.0; #const gamy = 20.0. @inline bottom_topography(x,y) = 0.0;#*exp.(-gamy*y.^2); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom_topography)). no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(bottom=no_slip, immersed=no_slip); w_bcs = FieldBoundaryConditions(immersed=no_slip); boundary_conditions = (; u = u_bcs, w = w_bcs). model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; boundary_conditions = boundary_conditions,; closure = ScalarDiffusivity(ν=κ,κ=κ),; coriolis = nothing,; tracers = :b,; buoyancy = BuoyancyTracer()). b₀(x,y, z) =0.5*(erf.((x.-1.0)*10).-1.0); set!(model, u = 0.0, b = b₀)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087:47,message,message,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087,1,['message'],['message']
Integrability,"@glwagner, I got rid of this ```UnderVarError``` but now I am facing ```domain error``` while applying Chebyshev spacing in z.; But at the same time, when I apply any linear profile, It works. linear function like -``` (2k-1/2Nz)```; . I get the error message after applying the set() function.- . ```. julia> # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ); ERROR: TaskFailedException:; DomainError with -1.1554673348527535e-7:; Exponentiation yielding a complex result requires a complex argument.; Replace x^y with (x+0im)^y, Complex(x)^y, or similar.; ```; If we see the error message, it says to replace x^y, but there is no arithmetic like that in my code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992:252,message,message,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992,2,['message'],['message']
Integrability,"@glwagner:; > I'm still not sure we want to analytically integrate one of the pressure gradient terms `h dx(h) = dx(h^2/2)` but leave the other unchanged. If we treat them both similarly then we would write the pressure gradient term; > ; > ```; > -g h * ∂ₓ(h + b); > ```; > ; > It might be worth testing both possibilities to see if one has favorable numerical properties?; > ; > Perhaps this is related to the whole issue re: well-balanced methods, etc... ?. @francispoulin:; > I agree with @glwagner . Currently, `ShallowWaterModel` separates out the advection terms and the pressure term, which makes sense since they are inherently different.; > ; > One issue is that since we are using a finite volume method, the above term presents a bit of a problem as it's not in divergence form However, even in the other formulation, as you can see from the paper cited above, we still end up getting a term that is not in divergence form, `h dh_B/dx`.; > ; > I support trying @glwagner 's proposal of keeping the pressure term as he wrote it above. So it seems the best way forward for implementing bathymetry is to do it in the non-conservative form of the equations after #2522 is merged. Do we then want to have the conservative form of `ShallowWaterModel` be available only for `bathymetry == nothing`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030:57,integrat,integrate,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030,1,['integrat'],['integrate']
Integrability,"@hdrake can you clarify specifically what is difficult about the calculation? If we know the specific calculations we need to make we might be able to support / facilitate them with abstractions. For example, it may be possible to sort abstract operations --- like the product of a field and a grid metric like cell area or volume, or another multiplicative factor that represents the effect of bathymetry on cell interface area / volume.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260:414,interface,interface,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260,1,['interface'],['interface']
Integrability,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:214,depend,depends,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661,2,['depend'],['depends']
Integrability,@iuryt https://github.com/iuryt/Bioceananigans.jl looks like an awesome start!!! 🚀 . @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ? . Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point? . Note -. 1. in the end both Eulerian and Lagrangian formulations of biogeocheminanigans/biogeochemonanigans/Bioceananigans/Bichemoceananigans style stuff end up as mostly pointwise functions. So a number of bits of an API framework could be common across Eulerian and Lagrangian I think. . 2. On the fluid solver side the API could also support reactive and passive transport in an atmosphere (i.e. work with atmoscheminanigans 😄 ),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522:211,interface,interface,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522,1,['interface'],['interface']
Integrability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:432,interface,interface,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,2,['interface'],['interface']
Integrability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:83,integrat,integration,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['integrat'],['integration']
Integrability,"@jm-c suggested that we want a function that returns the density perturbation associated with scalar values of temperature and salinity. Right now we only have a function that returns the density perturbation for 3D arrays of temperature and salinity, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/d32cf2035184f2320b27f270aee90e4688cf290f/src/buoyancy.jl#L228. @jm-c also recommends calculating the buoyancy frequency directly from the buoyancy distribution. This is different than the recommendation by Roquet et al (Ocean Modelling, 2015) to use the thermal expansion and haline contraction coefficients.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/439:596,contract,contraction,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/439,1,['contract'],['contraction']
Integrability,"@johncmarshall54 has suggested we switch to a full equation of state for seawater for LESbrary simulations as temperature and salinity profiles from state estimates may not be statically stable in Oceananigans when using a linear equation of state. The Roquet et al. (2015a) idealized nonlinear equation of state should be better. Ideally we would use the same equation of state as ECCO/SOSE I think, but TEOS-10 should be what we aim for I suppose. I think we have a couple of options:; 1. There's a Julia wrapper for the TEOS-10 C library but this probably won't work on the GPU: https://github.com/ax1ine/GSW.jl; 2. A 6+52-term polynomial approximation to TEOS-10, accurate to ~0.1% and suitable for Boussinesq models, from Roquet et al. (2015b). We can code up a pure Julia version as there already exist Python, MATLAB, and Fortran implementations here: https://github.com/fabien-roquet/polyTEOS (Thank you @fabien-roquet!). In implementing a pure Julia TEOS-10 equation of state we should make sure it can be shared between Oceananigans and CliMA Ocean (cc @blallen). cc @jm-c @christophernhill @glwagner @rafferrari who might have suggestions or comments. @leios Do you think evaluating a 52-term polynomial at every grid point will be problematic on the GPU? I imagine GPUs should be fast at evaluating polynomials but maybe we have to be smart about storing the coefficients in memory?. References:; 1. Roquet et al. (2015a), ""Defining a Simplified Yet “Realistic” Equation of State for Seawater"", DOI: https://doi.org/10.1175/JPO-D-15-0080.1; 2. Roquet et al. (2015b), ""Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard"", DOI: https://doi.org/10.1016/j.ocemod.2015.04.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692:507,wrap,wrapper,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692,1,['wrap'],['wrapper']
Integrability,@liuchihl Have you tried running on the CPU to see if you get a more useful error message?. I think; ```; Reason: unsupported call to an unknown function (call to jl_f_getfield); ```; could just be the result of a typo in an expression like `a.b`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746,1,['message'],['message']
Integrability,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582:63,depend,depend,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582,2,['depend'],"['depend', 'dependent']"
Integrability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:325,integrat,integration,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['integrat'],['integration']
Integrability,@matinraayai I quickly looked at your work on PencilFFTs and it looks awesome. I'd be happy to merge it in some form. My main reservation is that I'd rather not include CUDA and AMDGPU as hard dependencies. I guess this can be easily corrected using the new package extensions on Julia 1.9. Feel free to open a PR over at PencilFFTs and we can continue the discussion there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982:193,depend,dependencies,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982,1,['depend'],['dependencies']
Integrability,"@navidcy , yes, that looks great. However, when I click on the link I don't think I can execute the commands, but maybe I was too quick to close the page. I created a notebook for the 1D diffusion problem by basically copying and pasting what you have in the example. My markdown is a bit rusty but luckily you had all the right syntax there already. I was going to attach it to this message here but it seems that notebook are unsupported. It is nothing fancy but I do think that if there was an open to open the notebook and run it that would make it a bit easlier than copying and pasting. @glwagner that sounds like a great way to run the script, which is certainly what you want to do. Personally, when learning what a script is doing it's nice to execute it line by line to get to know the process. After you've seen it once then you definitely want to the entire example. Anyhow, my 2 cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454:384,message,message,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454,1,['message'],['message']
Integrability,"@navidcy @glwagner this should superceded all previous enzyme prs (including compatbwlper), which I've gone ahead and closed just now. Some non enzyme tests had a nondeterministic ci failure about a directory not being empty, but otherwise all pass (incl enzyme tests). Once landed we should add a lot more integration test cases like @jlk9 your flux boundary",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317:307,integrat,integration,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317,1,['integrat'],['integration']
Integrability,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:490,message,message,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495,1,['message'],['message']
Integrability,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:215,integrat,integrated,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401,1,['integrat'],['integrated']
Integrability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:857,synchroniz,synchronizes,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['synchroniz'],['synchronizes']
Integrability,"@navidcy may be referring to a couple of places / messages where ""no units"" is assumed to mean ""SI units"". I don't think we support explicit units though. It seems overkill to wrap every float for the purpose of a few messages. We could maybe attach some metadata to `Simulation`. What kind of API would be ""easy"" @navidcy ? Is it `Clock` that needs to know dimensions, or just things that print messages?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354:50,message,messages,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354,4,"['message', 'wrap']","['messages', 'wrap']"
Integrability,"@navidcy thanks, I was able to bring the branch up to date to a more reasonable delta.; @glwagner I think there's no need to separate ROCm support and multi-GPU support, since multi-GPU support was mostly dependent on modifications in PencilFFTs.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937:205,depend,dependent,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937,1,['depend'],['dependent']
Integrability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:422,wrap,wrapped,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['wrap'],['wrapped']
Integrability,@sangeethasankar01 if you post the whole error message that you get with the stack trace we will understand more which line triggered this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356:47,message,message,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356,1,['message'],['message']
Integrability,"@simone-silvestri `DistributedComputations` is imported before models here:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Oceananigans.jl#L221-L224. What was ""enable overlapping communication"" intended to support? Is there something that depends on whether `isnothing(mpi_requests)`? Perhaps more direct specification of this feature would help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750:284,depend,depends,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750,1,['depend'],['depends']
Integrability,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2418:606,interface,interface,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418,2,['interface'],['interface']
Integrability,@simone-silvestri and I think there is a missing synchronization for one of the boundary updates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511:49,synchroniz,synchronization,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511,1,['synchroniz'],['synchronization']
Integrability,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239:356,interface,interface,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239,1,['interface'],['interface']
Integrability,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009,2,['interface'],['interface']
Integrability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:475,depend,dependencies,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,4,['depend'],"['dependencies', 'dependency']"
Integrability,"@simone-silvestri do you have any formula for computing the local energy dissipation rate due to numerical viscosity? For the global dissipation I think evaluating the time evolution of the total KE is a good route, but I'm less sure the best method for obtaining the local dissipation rate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906:209,rout,route,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906,1,['rout'],['route']
Integrability,"@simone-silvestri if we want to unify the user interface across all models, we could introduce the type `AdvectionScheme` (which will be rather trivial now, but we can update it in the future). Then we can have syntax like. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. Or,. ```julia; model = NonhydrostaticModel(; grid, advection=WENO5()); ```. which the model constructor interprets as. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=WENO5(grid)); ```. (this is nice too, because we can build `WENO5` on the grid under the hood). We could also _always_ ""regularize"" the advection scheme with `grid`, so that. ```julia; advection = AdvectionScheme(momentum=WENO5(), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. translates to. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); ```. under the hood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113:47,interface,interface,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113,1,['interface'],['interface']
Integrability,"@simone-silvestri suggests removing `topology` as an argument from the `MultiArch` constructor. `MultiArch` now uses `topology` to construct `RankConnectivity` (ie the mapping between ranks). But in @simone-silvestri's words ""connectivity is a grid thing"". I'm not 100% sure how to solve it though. One possibility is to 1) rebuild `MultiArch` in the grid constructor adding connectivity information. Or we can 2) introduce a wrapper for grids on distributed domains or 3) add `connectivity` to all grids, set to `nothing` when not distributred. I think 1) is easiest but maybe not the cleanest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896:426,wrap,wrapper,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896,1,['wrap'],['wrapper']
Integrability,@simone-silvestri we should probably remove this explicit dependency if it isn't needed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705:58,depend,dependency,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705,1,['depend'],['dependency']
Integrability,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:800,depend,depends,800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,1,['depend'],['depends']
Integrability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:264,depend,depending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['depend'],['depending']
Integrability,"@tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886:103,depend,depend,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886,1,['depend'],['depend']
Integrability,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:336,interface,interface,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998,1,['interface'],['interface']
Integrability,"@tomchor I think your solution might help RK3, but as you noted there is _also_ a problem with AB2:. > In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations. There's an issue somewhere in. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Simulations/run.jl#L41-L56. I'm also wondering if one issue is that we need to change the line. ```julia; aligned_Δt = schedule_aligned_Δt(sim, aligned_Δt); ```. and maybe instead have an interface where callbacks return the next time of actuation. `TimeInterval` may also need to be redesigned... the fact that we compute the next actuation time b. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Utils/schedules.jl#L65. maybe invites round-off error. To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on `TimeInterval` which should, in theory, work perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147:662,interface,interface,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147,1,['interface'],['interface']
Integrability,"@tomchor and I added a `BuoyancyModel` type (can't call it `Buoyancy` since that would conflict with the module name, name is up for debate) to store the gravity unit vector and the buoyancy model. Seems to work with `BuoyancyTracer` from @tomchor's simulations!. I guess what we weren't sure about is the user interface. Right now tilting gravity is done via e.g. ```julia; θ = 45; g = (0, sind(θ), cosd(θ)); model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=BuoyancyTracer(), gravitational_unit_vector=g); ); ```. so now `model.buoyancy` is a `BuoyancyModel`. ---. But what should the user interface look like for not tilting gravity?. We could enforce explicit construction of a `BuoyancyModel` in every script, which may be seen as adding boilerplate, e.g. ```julia; model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=SeawaterBuoyancy()); ); ```. or we could continue allowing. ```julia; model = IncompressibleModel(...; buoyancy = SeawaterBuoyancy(); ); ```. and the model constructor can convert `SeawaterBuoyancy` to a `BuoyancyModel`. This is less boilerplate but maybe somewhat implicit. I'm leaning towards the more implicit second solution of allowing just `buoyancy = SeawaterBuoyancy()`, but might be good to decide on one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664:311,interface,interface,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664,2,['interface'],['interface']
Integrability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:521,depend,dependent,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['depend'],['dependent']
Integrability,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:881,depend,dependent,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['depend'],['dependent']
Integrability,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454,1,['interface'],['interface']
Integrability,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:949,interface,interface,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['interface'],['interface']
Integrability,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57:383,wrap,wrap-around,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57,1,['wrap'],['wrap-around']
Integrability,"@vchuravy thank you that is very helpful! I don't think it will be too difficult to build up a small test suite for AMD. We can start with unit tests and a handful of cheap integration tests. @fluidnumerics-joe we don't have any current plans to get AMD GPU resources, but that could change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799:173,integrat,integration,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799,1,['integrat'],['integration']
Integrability,"@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major versio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8885,depend,dependabot,8885,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['depend'],['dependabot']
Integrability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:181,depend,depends,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['depend'],['depends']
Integrability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:265,interface,interface,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['interface'],['interface']
Integrability,"A 'field-dependent' forcing is a user-specified forcing term that depends on `x, y, z, t, u`, where `u` is the field being forced, and optionally parameters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744:9,depend,dependent,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744,2,['depend'],"['dependent', 'depends']"
Integrability,A NaN checker diagnostic that aborts the simulation when NaN values are detected. We could have some shell script that look for this and sends an email or something. Julia could do this too but then we'd add a big dependency for a small diagnostic. Resolves #38,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/170:214,depend,dependency,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/170,1,['depend'],['dependency']
Integrability,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3510:246,interface,interface,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510,1,['interface'],['interface']
Integrability,"A but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:209 [inlined]; [15] solve!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, solver::Oceananigans.Solvers.HeptadiagonalIterativeSolver{ImmersedBoundaryGrid{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:1213,wrap,wrappers,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['wrap'],['wrappers']
Integrability,"A few ideas:. 1) If we're doing an euler step, zero out the `G⁻` tendencies beforehand. 2) Put an if statement in to take `euler_step!` rather than `ab2_step!`. The problem with 2) is that we haven't figured out how to abstract the stepping interface to handle different models. Basically, we don't really have an generic PDE time-stepper. Instead we have manually implemented time-stepping schemes for the different models; for example:. https://github.com/CliMA/Oceananigans.jl/blob/383e5b60ca8d3bfb3c8497b11b6be30946a25728/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L14-L36. Thus to achieve 2) we'll probably have to write an `euler_step!` for the hydrostatic free surface model. Maybe not a problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764:241,interface,interface,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764,1,['interface'],['interface']
Integrability,"A few more thoughts:. 1) It's probably simplest to use a native time-stepping schemes to advance particle trajectories. The third-order Runge-Kutta scheme seems like a fine choice. 2) I think it makes sense to launch one kernel to compute particle trajectories. ""One kernel per thread"" is a simple paradigm. Up to ""one particle per grid point"", we know this method will work well. 3) A few challenges that I see are: i) writing functions that linearly interpolate the velocity field to the particle location, and ii) dealing with boundaries. Enforcing boundary conditions, presumably, requries launching an additional kernel after a time-step is complete that checks the location of each particle and adjusts it if the particle location lies outside the domain. Enforcing periodic conditions presumably requires a cyclic shift of the particle location. I'm less sure how to deal with solid boundaries: perhaps reflecting the particle position (an elastic collision?) is a good model?. 4) I think tackling the problem of determining particle trajectories is a big enough challenge for now. I think once we have the ability to interpolate fields to the particle location, it may not be difficult to introduce ""auxiliary fields"" for each particle, with user-specified RHS that depend on local tracer and velocity fields at the particle position.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271:1274,depend,depend,1274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271,1,['depend'],['depend']
Integrability,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:1080,interface,interface,1080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638,2,['interface'],['interface']
Integrability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:191,wrap,wrapping,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['wrap'],['wrapping']
Integrability,A new interface for output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793:6,interface,interface,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793,1,['interface'],['interface']
Integrability,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:131,Depend,Dependence-of-Southern-Ocean-Meridional,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['Depend'],['Dependence-of-Southern-Ocean-Meridional']
Integrability,"A possible implementation of `QuadraticallyStretchedFaces` with the ""z faces interface"" might allow syntax like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z_faces = QuadraticallyStretchedFaces()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732,1,['interface'],['interface']
Integrability,"Abstraction for ""equation"" for performance, code clarity, memory footprint reduction, and powerful user interface",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:104,interface,interface,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['interface'],['interface']
Integrability,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:210,synchroniz,synchronize,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,6,['synchroniz'],['synchronize']
Integrability,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:374,integrat,integrated,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145,1,['integrat'],['integrated']
Integrability,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:197,depend,dependency,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,1,['depend'],['dependency']
Integrability,Adds FieldSlicer and integrates with JLD2OutputWriter and WindowedTimeAverage,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932:21,integrat,integrates,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932,1,['integrat'],['integrates']
Integrability,Adds an interface for inserting biogeochemistry models into Oceananigans models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802:8,interface,interface,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802,1,['interface'],['interface']
Integrability,Advection schemes should depend on the `grid` for spacings and float type inference,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857:25,depend,depend,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857,1,['depend'],['depend']
Integrability,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,6,['depend'],"['dependencies', 'dependency']"
Integrability,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:84,message,message,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801,1,['message'],['message']
Integrability,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:713,Depend,Dependency,713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,1,['Depend'],['Dependency']
Integrability,"Agree we need another name, perhaps a variant of shenanigans. On Thu, Jan 30, 2020, 3:31 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I think its a fine idea to merge, though it is interesting that the code; > will still be called Oceananigans :-D; >; > I'm not sure I understand point 4 completely. The ocean model also has the; > concept of a model ""state""; for example, ghost cell values and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:436,depend,depend,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['depend'],['depend']
Integrability,"Ah Julia installed Oceananigans v0.5.1 (an extremely ancient version), probably due to conflicts between dependency versions. The latest release is Oceananigans v0.57.1. To grab the latest version you can try to explicitly update by typing `] add Oceananigans@0.57.1` in the REPL. There may be conflicts with some other packages like CUDA v3.1.0. Oceananigans is still depending on CUDA v2 so you might have to `] rm CUDA` to be able to `] add Oceananigans@0.57.1`. This might also explain the weird error you reported in #1635. PS: You might encounter issues when using Oceananigans.jl with Julia 1.6 right now. It still requires Julia 1.5 for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603:105,depend,dependency,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603,2,['depend'],"['dependency', 'depending']"
Integrability,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494:121,wrap,wrapped,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494,4,['wrap'],['wrapped']
Integrability,"Ah ok I see, you still have to merge main. Then synchronization problems will be fixed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516:48,synchroniz,synchronization,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516,1,['synchroniz'],['synchronization']
Integrability,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:227,message,message,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994,2,['message'],['message']
Integrability,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:40,message,message,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825,1,['message'],['message']
Integrability,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:212,message,messages,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674,1,['message'],['messages']
Integrability,Ah that looks quite nice. Would it make sense to try and integrate `DiskTimeSeries` with a `DimensionalData.DimArray` to get named axis behavior?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801:57,integrat,integrate,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801,1,['integrat'],['integrate']
Integrability,"Ah, I foolishly assumed it was running in CPUs but do see it's running on GPUs. I gather it's slow because the GPU I have on my desktop is poor. Maybe I'll kill it and run it on a CPU as that maybe faster on my local machine. One thing that should be changed, sometime, is the only output I see is a warning message. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735:308,message,message,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735,1,['message'],['message']
Integrability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:257,depend,depends,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['depend'],['depends']
Integrability,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:474,interface,interface,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,2,['interface'],['interface']
Integrability,"Ah, but the ""cape"" is oriented in x --- it sticks out from the southern boundary with unit 1 and tapers to 0 as x -> -infty and +infty. If the flow comes in from the west, it would impinge on the cape. Right?. Note that y < exp(-x^2) is true along the entire southern boundary where `y=0` and `x` varies from `-10` to `+10`. So imposing an inflow along the southern boundary will be masked out, I believe, depending on the order of operations in `update_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265:406,depend,depending,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265,1,['depend'],['depending']
Integrability,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:896,integrat,integrate,896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['integrat'],['integrate']
Integrability,"All that's really needed is to define. https://github.com/CliMA/Oceananigans.jl/blob/0415938fa0fbd9cb581e3301b31083e064519b06/src/Coriolis/hydrostatic_spherical_coriolis.jl#L33-L34. for other `coriolis` schemes. Probably it needs to dispatch on both `FPlane` / `BetaPlane` and `AbstractRectilinearGrid`. The code should be restructured a bit. If we do that, the only that makes coriolis ""spherical"" or not is the dependence of `f` on `i, j`. So we should put the definition of the Sabourny stencils in a new file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159:413,depend,dependence,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159,1,['depend'],['dependence']
Integrability,Allows field-dependent SimpleForcing. Updates plankton growth example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744:13,depend,dependent,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744,1,['depend'],['dependent']
Integrability,Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646:111,depend,dependent,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646,1,['depend'],['dependent']
Integrability,"Also this doesn't blow up, right? I think with increasing energy, eventually nonlinearities and numerical diffusion would kick in. The integrated KE might exhibit oscillatory behavior on long time-scales. (The example in the OP only blows up because the `TimeStepWizard` increases the time step too much.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762:135,integrat,integrated,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762,1,['integrat'],['integrated']
Integrability,"Also we get some deprecation warnings. E.g., for. ```; SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); ```. we get. ```; Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; ```. I don't understand what that means tho.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601:169,Wrap,Wrapping,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,Also wondering why there isn't a test that catches this? Does it depend on the size of the problem?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639,1,['depend'],['depend']
Integrability,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:134,depend,dependencies,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,2,['depend'],['dependencies']
Integrability,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156,3,['interface'],['interface']
Integrability,"An “edge” is the case in which 2 of Lx, Ly, or Lz are “interface”. We just; don’t need special notation. This method of specifying locations in a cube; is simpler, but also more general. On Sat, Mar 9, 2019 at 8:52 AM Ali Ramadhan <notifications@github.com>; wrote:. > Ah yes I remember @jm-c <https://github.com/jm-c>'s concern now! Yes,; > just ""face"" and ""edge"" are ambiguous.; >; > So your proposed solution will make it explicit exactly which interface; > the field is being interpolated from and to, which will be nice.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471178907>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBlzM_EBoVLsfUYqw-V_v_Pe2admmks5vU7yqgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020,2,['interface'],['interface']
Integrability,And all tests pass! Great! Ignore my messages!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383:37,message,messages,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383,1,['message'],['messages']
Integrability,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:71,depend,dependence,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370,2,['depend'],['dependence']
Integrability,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:390,Wrap,Wrapping,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786,2,"['Wrap', 'depend']","['Wrapping', 'dependencies']"
Integrability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,2,['interface'],['interface']
Integrability,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:91,interface,interfaces,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,3,['interface'],"['interface', 'interfaces']"
Integrability,"Another non-function example is this piece of code from the wind mixing case:. ```julia; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m s⁻¹, surface temperature flux. # Finally, we impose a temperature gradient `dTdz` both initially and at the; # bottom of the domain, culminating in the boundary conditions on temperature,. dTdz = 0.01 # K m⁻¹. T_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); ```. This should work on the GPU. The reason is that `Qᵀ` and `dTdz` are not referenced in functions. Instead, they end up inside the data structures `model.tracers.T.boundary_conditions.top.condition` and `model.tracers.T.boundary_conditions.bottom.condition`. Likewise, this code is valid too:. ```julia; @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m s⁻¹; nothing # hide. # where `S` is salinity. We use an evporation rate of 1 millimeter per hour,. evaporation_rate = 1e-3 / hour # m s⁻¹. # We build the `Flux` evaporation `BoundaryCondition` with the function `Qˢ`,; # indicating that `Qˢ` depends on salinity `S` and passing; # the parameter `evaporation_rate`,. evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); ```. because `evaporation_rate` enters into `Qˢ` in its 5th argument. It does not need to be, and should not be, `const`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306:1068,depend,depends,1068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306,1,['depend'],['depends']
Integrability,Another place I think we need to change is particle advection:; https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161. Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094:278,integrat,integrated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094,1,['integrat'],['integrated']
Integrability,"Another possibility is to write some tests using `HydrostaticFreeSurfaceModel` with `ExplicitFreeSurface`, which is entirely explicit and thus requires only halo filling via MPI (with no PencilArrays dependency)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942,1,['depend'],['dependency']
Integrability,Any code using threading is eventually just going to hang on M1. My point is that Oceanigans should not be working around this for the user since it declares an unecessary dependency for everyone else. Users can pin mpich_jll locally if needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087:172,depend,dependency,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087,1,['depend'],['dependency']
Integrability,"Apologies for confusing the nomenclature, I should have said `exterior_cell` (I named it this to contrast with the function `interior`). Though ""exterior"" and ""interior"" strictly aren't mutually exclusive, they are loosely connected... > So external_cell is just a special case external_node, correct?. Correct, `exterior_cell` is identical to `exterior_node` evaluated at tracer cell centers. > It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. No, there is no assumption. The notion of `exterior_cell` is independent of the immersed boundary implementation. There are `exterior_cell`s for any grid `Bounded` in one or more direction. The implementation for underlying grids is here:. https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/src/Grids/exterior_node.jl. Differences between ""full cell"" immersed boundary methods and other types of methods manifest in the way grid metrics are modified (spacing, areas, and vectors normal to cell interfaces). All immersed boundary methods will both define `external_cell` and any boundary-specific modifications to metrics. We'll also need an interface for specifying the face normal vector, since those normals won't lie along the cardinal directions anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563:982,interface,interfaces,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563,2,['interface'],"['interface', 'interfaces']"
Integrability,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:30,interface,interface,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['interface'],['interface']
Integrability,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:26,interface,interface,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,14,['interface'],"['interface', 'interfaces']"
Integrability,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/193:363,message,messages,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193,1,['message'],['messages']
Integrability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:509,interface,interface,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['interface'],['interface']
Integrability,"As discussed elsewhere, it might be most convenient for users if an interface to applying moving averages is provided within the constructor for an output writer, rather than creating a wrapper object like `TimeAveragedOutputWriter`. An example of this would be. ```julia; U = HorizontalAverage(model.velocities.u); V = HorizontalAverage(model.velocities.v). statistics_writer = JLD2OutputWriter(model, (U=U, V=V), time_interval=1hour, time_averaging_window=1minute); ```. The advantage of this syntax is that deciding to time-average output is as simple as adding a keyword argument to an existing output writer. This may be easier to user than previously proposed interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748:68,interface,interface,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748,3,"['interface', 'wrap']","['interface', 'interfaces', 'wrapper']"
Integrability,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:631,depend,dependent,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,1,['depend'],['dependent']
Integrability,"As far as I can tell the main purpose of `CLIMAParameters` is to provide a central / global place to specify common parameters found in different model components. For example, `HydrostaticFreeSurfaceModel` has a `gravitational_acceleration` for both `buoyancy` and `free_surface`. On the other hand, it turns out that it's sometimes convenient for these to be different for testing and experimentation, which may impose additional requirements on `CLIMAParameters` that were not part of the original design. One possible solution might be to build a global `CLIMAParameters` instance in `Oceananigans` that's referenced in model constructors for default parameter values (but we can still let users change parameters when instantiating various model components if they want). A possible goal of CLIMAParameters is to _restrict_ the user interface so that users ""can't mess up""; eg users can't accidentally set `gravitational_acceleration` in `free_surface` and erroneously expect that this also changes `gravitational_acceleration` for buoyancy. Food for thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111,1,['interface'],['interface']
Integrability,"As for a slip velocity that depends on buoyancy, one method uses `Callback`:. ```julia; # Define slip field with impenetrable boundary conditions; w_slip_bcs = FieldBoundaryConditions(grid, top=OpenBoundaryCondition(), bottom=OpenBoundaryCondition()); w_slip = ZFaceField(grid). # Build AdvectiveForcing; slip_forcing = AdvectiveForcing(w = w_slip). # later...; b = BuoyancyField(model) # or just model.tracers.b for BuoyancyTracer(); b_particle = 1e-4 # define particle ""buoyancy"". Requires reference fluid buoyancy / knowledge of initial condition.; particle_radius = 1e-3; molecular_viscosity = 1e-6. # Define an AbstractOperation that computes the slip velocity:; slip_velocity_op = 2/9 * (b_particle - b) / molecular_viscosity * particle_radius^2. function compute_slip_velocity!(sim); compute!(b) # compute buoyancy if it's a function of T, S; w_slip .= slip_velocity_op; Oceananigans.BoundaryConditions.fill_halo_regions!(w_slip); return nothing; end. simulation.callbacks[:compute_slip_velocity] = Callback(compute_slip_velocity!); ```. It's also possible not to use `Callback` if the forcing is written manually with the `discrete_form`. That requires a bit more work and more knowledge of Oceananigans internals though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705,1,['depend'],['depends']
Integrability,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:188,interface,interface,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354,2,['interface'],['interface']
Integrability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:146,depend,depend,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['depend'],['depend']
Integrability,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:585,message,message,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,1,['message'],['message']
Integrability,Automagically wrap `AbstractOperation` and `Reduction` in `Field` inside `OutputWriters`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:14,wrap,wrap,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['wrap'],['wrap']
Integrability,Avoid executing the lines to install dependencies within examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1316:37,depend,dependencies,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316,1,['depend'],['dependencies']
Integrability,"Awesome! Yes unfortunately the code has changed a lot recently and the docs have become stale in many places, we're hoping to revise them soon. > Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Yeah for sure. I think one of our goals with Oceananigans.jl is to eventually make it so users never have to think about the staggered grid. Most examples use functions to initialize fields like. ```julia; random_noise(x, y, z) = rand(); set!(model, u=random_noise, v=random_noise); ```. which will work no matter the size of the field, but in the 2D turbulence example we wanted the noise to have zero mean so we had to use arrays. Perhaps it can be revised to use functions. Either way we can keep this issue open until the docs (or the examples) are revised.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531,1,['interface'],['interface']
Integrability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:224,interface,interface,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['interface'],['interface']
Integrability,Before I updated and induced the problem I was getting O(seconds) initialisation time on M1 Mac so I think you're experiencing the problem with both versions @navidcy . I tried using JLD2 and got the same slow initialisation. Do they have a common dependency that does something to the field?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775:248,depend,dependency,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775,1,['depend'],['dependency']
Integrability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:196,depend,depends,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,1,['depend'],['depends']
Integrability,"Begs the question of whether this code was tested? When users pass a tuple to `forcings`, we wrap it inside `MultipleForcings`. Thus we need this method to unwrap the tuple when adding advective forcings to the total velocity field. @jagoosw @simone-silvestri . Should we add a test?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259:93,wrap,wrap,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259,1,['wrap'],['wrap']
Integrability,Better julia compat version message in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3084:28,message,message,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3084,1,['message'],['message']
Integrability,Better momentum advection message,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2943:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2943,1,['message'],['message']
Integrability,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1310:515,integrat,integrating,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310,1,['integrat'],['integrating']
Integrability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:254,depend,dependencies,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['depend'],['dependencies']
Integrability,"Both `RectilinearGrid` and `LatitudeLongitudeGrid` have the property that the ""extrinsic"" coordinate system --- Cartesian for `RectilinearGrid`, and lat-lon for `LatitudeLongitudeGrid` --- coincide with the ""intrinsic"" coordinate system in which vector fields (like velocities) are expressed. However, for more general grids, like the tripolar grid, the intrinsic coordinate system of the grid differs from the extrinsic coordinate system. The extrinsic coordinate system is prescribed by us. We've decided to use lat-lon on the sphere and Cartesian otherwise. But the intrinsic coordinate system is a property of each grid independently. The main challenge with grids like the tripolar grid is providing an interface to `set!` the velocity fields. I think we should define `set!` so that `u, v, w` are assumed to be provided in the extrinsic coordinate system. This means that the provided velocities need to be rotated under the hood into the intrinsic coordinate system. One of the basic features we need is a function that rotates a vector field:. ```julia; ue, ve, we = extrinsic_vector(i, j, k, grid, ui, vi, wi); ```. and. ```julia; ui, vi, wi = intrinsic_vector(i, j, k, grid, ue, ve, we); ```. We may also want something like `intrinsic_vector_from_centered` and `intrinsic_vector_from_staggered` etc... Let's split the way we add this functionality into a few PRs, eg first develop `extrinsic_vector` and `intrinsic_vector`, and then in a new PR work on `set!`. . cc @simone-silvestri @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625:708,interface,interface,708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625,1,['interface'],['interface']
Integrability,BoundaryFunction wrapper for simple boundary condition functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/513:17,wrap,wrapper,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/513,2,['wrap'],['wrapper']
Integrability,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:746,Depend,Dependencies,746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,3,"['Depend', 'depend']","['Dependencies', 'dependabot']"
Integrability,"But Oceananigans doesn't really output time in ""seconds"", does it? The time unit is arbitrary, or depends on user inputs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380:98,depend,depends,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380,1,['depend'],['depends']
Integrability,But since all tests run on a computer at MIT the time it takes also depends on how many tests are running (eg how many prs were just open) and other random factors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402:68,depend,depends,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402,1,['depend'],['depends']
Integrability,"But still, I think that you first derive the equation for \eta (after the time discretization) and then integrate in volume. In the end it is still a derivative of a derivative (Following the docs from mitgcm https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html). So the \partial x on the LHS should be correct. You 'll see that the term that doesn't cancel (as you derived above) is contained in the integral of the area. On the other hand, I think we should change the batropic pressure gradient correction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966:104,integrat,integrate,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966,1,['integrat'],['integrate']
Integrability,"But the way @tomchor wrote the example, is `outputs_yavg` dependent on `outputs_full`? Seems like it... E.g.,. ```julia; outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full)); ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497:58,depend,dependent,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497,1,['depend'],['dependent']
Integrability,"By the way, an alternative route to getting ""automatic"" dimensioning for `NetCDFOutputWriter` could be to define a `default_dimensions(output::WindowedSpatialAverage, grid, field_slicer)` that does the right thing. You can put the location `X, Y, Z` in `WindowedSpatialAverage` without making the object subtype `AbstractField` (which will cause various issues with time-averaging as noted).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623:27,rout,route,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623,1,['rout'],['route']
Integrability,CATKE closure doesn't work with `NonHydrostaticModel`.; Users who try to add that closure in `NonHydrostaticModel` should be warned with a message.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2229:139,message,message,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2229,1,['message'],['message']
Integrability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['depend'],"['dependencies', 'dependency']"
Integrability,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:367,integrat,integration,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,2,['integrat'],['integration']
Integrability,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753:35,message,message,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753,2,['message'],['message']
Integrability,Can I pin specific versions of dependencies to try out?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120,1,['depend'],['dependencies']
Integrability,Can we keep these features in separate PRs? The output interface really is distinct from the lower-level features needed for the NetCDFOutputWriter.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771,1,['interface'],['interface']
Integrability,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363:29,message,message,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363,2,['message'],['message']
Integrability,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:13,wrap,wrapper,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,1,['wrap'],['wrapper']
Integrability,"Can you print the whole warning message? I can't see what file / function the warning is coming from because it's cut off, I only see `-@-> /home/fpoulin/software/Oceananigans.jl/src/Grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500:32,message,message,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500,1,['message'],['message']
Integrability,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:145,message,message,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,2,['message'],['message']
Integrability,"Can't reproduce that @navidcy . ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 160 already precompiled. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); 2×3×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 6×9×10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c .= rand(size(c)...);. julia> v = view(c, :, 2:3, 1:2); 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 2:3, 1:2); └── data: 6×2×2 OffsetArray(view(::Array{Float64, 3}, :, 5:6, 4:5), -1:4, 2:3, 1:2) with eltype Float64 with indices -1:4×2:3×1:2; └── max=0.943733, min=0.11545, mean=0.571896. julia> size(v); (2, 2, 2). julia> v[2, 2, 2] == c[2, 2, 2]; true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942:98,depend,dependency,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942,1,['depend'],['dependency']
Integrability,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:6516,message,message,6516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['message'],['message']
Integrability,"Change ""field dependencies"" to ""computed_dependencies"" in KernelComputedField?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1369:14,depend,dependencies,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369,1,['depend'],['dependencies']
Integrability,Change Cell to 'Center' and Face to 'Interface' to specify Field locations?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414:37,Interface,Interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414,1,['Interface'],['Interface']
Integrability,Changed units for haline contraction coefficients to match what's listed in table 1.2 of Vallis (from ppt to psu).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1748:25,contract,contraction,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1748,1,['contract'],['contraction']
Integrability,Checkpointer bug fixes and improved interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:36,interface,interface,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,1,['interface'],['interface']
Integrability,Clean up dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/588:9,depend,dependencies,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/588,1,['depend'],['dependencies']
Integrability,Cleans up code comments and fixes a bug in the plotting routine…,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/523:56,rout,routine,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/523,1,['rout'],['routine']
Integrability,Closes https://github.com/CliMA/Oceananigans.jl/issues/3637. This is an implementation of the scale-dependent Lagrangian-averaged dynamic Smagorinsky model as outlined in section C III. in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152). @simone-silvestri @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638:100,depend,dependent,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638,1,['depend'],['dependent']
Integrability,"ComplexF64, CUDA.CUFFT.cCuFFTPlan{ComplexF64, 1, true, 3}, Float64}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Int64, Bounded, Int64, NamedTuple{(:forward, :backward), Tuple{CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}}}, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(:a,), Tuple{Int64}}}; dependencies::CUDAKernels.CudaEvent); @ Oceananigans.Models.NonhydrostaticModels ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:88; [16] calculate_interior_tendency_contributions!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:46 [inlined]; [17] calculate_tendencies!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:27 [inlined]; [18] #apply_regionally!#46; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; [19] apply_regionally!; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:115 [inlined]; [20] macro expansion; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:197 [inlined]; [21] time_step!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:29871,depend,dependencies,29871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"Contributors,. We are planning to re-license Oceananigans under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0), as required by the primary sponsors of the Climate Modeling Alliance, [Schmidt Sciences](https://www.schmidtsciences.org/). Practically speaking, [the two licenses are similarly permissive and open](https://soos.io/apache-vs-mit-license). However, the Apache license adds some additional protection for contributors (like yourselves) by, for example, requiring downstream applications that depend on Oceananigans to disclose major changes. Let us know if there are any concerns. Otherwise, we plan to make the change on August 19. The top 20 outside contributors are tagged here:. @ali-ramadhan ; @tomchor ; @francispoulin ; @hennyg888 ; @elise-palethorpe ; @whitleyv ; @suyashbire1 ; @jagoosw ; @vchuravy ; @xiaozhour ; @maeckha ; @iuryt ; @kburns ; @jbisits ; @maleadt ; @wsmoses ; @Moelf ; @RaphaelRR ; @simonbyrne ; @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708:525,depend,depend,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708,1,['depend'],['depend']
Integrability,"Cool. Getting to the finish line will be a bit of work I guess. I think we usually want to integrate downwards so that's annoying. Not sure if that exists exactly, or we have to implement some lazy version of `reverse` to achieve it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202:91,integrat,integrate,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202,1,['integrat'],['integrate']
Integrability,Correct error message in `validate_lat_lon_grid_args`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3887:14,message,message,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3887,1,['message'],['message']
Integrability,"Correction to my last message, I accidentally included a second prime. The form of the Stokes drift is actually:. $u^s(x,y,z)=f(x)g(y)h′(z)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626:22,message,message,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626,1,['message'],['message']
Integrability,Correction: `InterfaceImmersedCondition` and `CenterImmersedCondition` might still useful during construction because they inform where the bottom height will be.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975:13,Interface,InterfaceImmersedCondition,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975,1,['Interface'],['InterfaceImmersedCondition']
Integrability,Could be convenient to print a message about the expected total size of output files and throw a warning if they're gonna be huge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312:31,message,message,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312,1,['message'],['message']
Integrability,Create dependabot.yml,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3149:7,depend,dependabot,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149,1,['depend'],['dependabot']
Integrability,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971:193,depend,depend,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971,2,['depend'],['depend']
Integrability,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828:785,depend,depend,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828,3,['depend'],"['depend', 'dependence']"
Integrability,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1140:593,interface,interface,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140,1,['interface'],['interface']
Integrability,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/536:82,depend,dependency,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536,1,['depend'],['dependency']
Integrability,"Currently the number of barotropic substeps have to be calculated in advance, and the user must manually calculate the CFL constraint. However, the SplitExplicitFreeSurface _specifies_ gravitational acceleration (and knows the grid); therefore the CFL condition can be calculated internally. Moreover it should be possible to ensure integer substeps on the fly, rather than precalculating. I think a nice user interface would be something like. ```julia; free_surface = SplitExplicitFreeSurface(gravitational_acceleration=9.81, cfl=0.7); ```. (with both defaults). Then the number of barotropic time-steps required to (1) meet the specified CFL constraint and (2) ensure integer number of substeps relative to a baroclinic substep would be calculated on the fly. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2982:410,interface,interface,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2982,1,['interface'],['interface']
Integrability,"Currently, `IncompressibleModel` keeps a reference to `TimeStepper`:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/Models/incompressible_model.jl#L33. This means that every model has one time stepper, and we use `time_step!(model, dt)` to advance a model forward. Yet this is not a necessary entanglement. A perfectly valid time-stepping loop is. ```julia; for i = 1:100; time_step!(model, forward_euler_stepper, dt); time_step!(model, rk3_stepper, dt); end; ```. (obviously we don't have a forward Euler time-stepper, which is a separate issue, but hopefully the point is made.). We can disentangle the timestepper from model by moving the timestepper reference over to `Simulation`. This would also clean up the interface since we wouldn't need to use symbols to specify the time-stepping method (#1119, this might be a hint that we're on the right track...). ```julia; model = IncompressibleModel(...); simulation = Simulation(model, RungeKutta3TimeStepper(model), kwargs...); ```. I think there's a conceptual advantage to this too. `Simulation`s manage the creation of a time-series, while a `Model` is more the idealization of a discrete physical system at a particular moment in time. To make this change, we first have to checkpoint `Simulation`s rather than `Model`s to support time-steppers that require history like AB2. I think this is something we need anyways. This is a major API change, though it could be mitigated if we put a default into the `Simulation` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175:760,interface,interface,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175,1,['interface'],['interface']
Integrability,"Definitely agree the two interfaces should be consistent. I'd be okay with either, although still slightly favor the current interface in case we will want to pass two sets of kwargs in the future. Would you support merging this PR and we can open an issue to discuss the best interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312:25,interface,interfaces,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312,3,['interface'],"['interface', 'interfaces']"
Integrability,"Dependencies between fields are supposed to be accounted for. For example if we write. ```julia; wc = Field(w * c); wc_average = Field(Average(wc, dims=1)); ```. then . ```julia; compute!(wc_average); ```. should first call `compute!(wc)`. For example:. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field_reductions.jl#L72-L77. where `reduction.operand === `wc` in the above example. Thus this calls. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/AbstractOperations/computed_field.jl#L64-L72. Note that `compute_at!` should always compute if needed because. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field.jl#L451-L462",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967:0,Depend,Dependencies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967,1,['Depend'],['Dependencies']
Integrability,Depends on functionality in #744 . Needs:. - [x] tests; - [x] possibly more examples in docstrings. Hopefully `Relaxation` will be helpful.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/745:0,Depend,Depends,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745,1,['Depend'],['Depends']
Integrability,"Did you test it? :). I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!. ```Julia; julia> using Oceananigans, Test; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 129 already precompiled. julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5. julia> closure = ""not a closure""; ""not a closure"". julia> NonhydrostaticModel(; grid, closure); ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String). Closest candidates are:; with_tracers(::Any, ::Nothing, Any...; kwargs...); @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; ... Stacktrace:; [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@Na",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269:99,message,message,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"Distinguish between ""masking"" and ""enforcing impenetrability"" in immersed boundary routines",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249:83,rout,routines,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249,1,['rout'],['routines']
Integrability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:143,rout,route,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['rout'],['route']
Integrability,"Do you have an example? . If you have a grid with `Nx = 10` and `Ny = 10` and set `h = 1.0` (and `fill_halo_regions!`) then the `h.data` will be 1 from `0:11, 0:11` and 0.0 elsewhere. Is this what you are referring to?. If x and y directions are bounded, points at `-2:-1, -2:-1` (and respective points above Nx and Ny) are never touched because both advection and diffusion are second order near the boundary. (You might want to use branch #2603 to make sure this is the case). So, for (2), I don't think we need it because those halo points should not be touched anyways.; For (1): I do not think there is an easy way to do that that does not involve writing some kernels, but you maybe reutilize the previous flux BC implementation and write something like this. ```; @kernel function _fill_height_west_and_east!(h, H, N); j, k = @index(Global, NTuple). @unroll for i in 1:H; @inbounds h[1-i, j, k] = h[i, j, k]; @inbounds h[N+i, j, k] = h[N+1-i, j, k]; end; end. @kernel function _fill_height_south_and_nort!(h, H, N); i, k = @index(Global, NTuple). @unroll for j in 1:H; @inbounds h[i, 1-j, k] = h[i, j, k]; @inbounds h[i, N+j, k] = h[i, N+1-j, k]; end; end. fill_height_west_and_east!(h, arch, dep, grid) = launch!(arch, grid, :yz, _fill_height_west_and_east!, h, grid.Hx, grid.Nx; dependencies=dep); fill_height_south_and_north!(h, arch, dep, grid) = launch!(arch, grid, :xz, _fill_height_south_and_north!, h, grid.Hy, grid.Ny; dependencies=dep); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814:1288,depend,dependencies,1288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814,2,['depend'],['dependencies']
Integrability,Do you know why the manual `synchronize` is needed?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987:28,synchroniz,synchronize,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987,1,['synchroniz'],['synchronize']
Integrability,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:241,depend,dependency,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,1,['depend'],['dependency']
Integrability,"Does it have to do with output? Do you know what the time-step is when this happens? I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649:273,integrat,integrated,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649,1,['integrat'],['integrated']
Integrability,Doesn't `string(typeof(scheme).name.wrapper)` return something similar for all advection schemes? Or am I misunderstanding what you're saying?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987:36,wrap,wrapper,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987,1,['wrap'],['wrapper']
Integrability,Drop MPICH_jll direct dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2496:22,depend,dependency,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2496,1,['depend'],['dependency']
Integrability,Drop SafeTestset from package dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2601:30,depend,dependency,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2601,1,['depend'],['dependency']
Integrability,Drop direct dependency to GPUArrays and BenchmarkTools,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2518:12,depend,dependency,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2518,1,['depend'],['dependency']
Integrability,"EDIT: This has nothing to do with Oceananigans.jl per se. Better pursued on LambertW.jl. I agree with https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904990127 . This part of the stack trace suggests that it is the `@warn` that is causing the problem. It should be possible to remove that somehow. Better would be to remove the `@warn` entirely and instead return the result along with info on the convergence. And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. I don't know anything about running on GPUs. Does `@warn` cause failure if it is anywhere in the package being compiled? or anywhere in the function being called? Or does execution have to hit the `@warn` so that io is attempted at run time?. EDIT: I missed this above:; >> Do you get a warning during CPU execution ?. > Nope. Everything seems to run pretty smoothly:. So it seems that execution does not have to hit the `@warn` for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. EDIT: so the following comment may be relevant, but perhaps not. It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. ```; Reason: unsupported call to an unknown function (call to jl_f__call_latest); Stacktrace:; [1] #invokelatest#2; @ ./essentials.jl:816; [2] invokelatest; @ ./essentials.jl:813; [3] macro expansion; @ ./logging.jl:381; [4] lambertw_root_finding; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:188; [5] lambertw_branch_zero; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:117; [6] _lambertw; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:93; [7] lambertw (repeats 2 times); @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:73; [8] W; @ /glade/derecho/scratch/tomasc/twake4/headland_simulations/mwe.jl:9; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945:452,interface,interface,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945,2,['interface'],['interface']
Integrability,"EDIT: there were a number of mistakes in the original post here. I've updated it. As for the _profiles_, there are some interesting differences between the ""Brevik"" and ""Lenain"" formulations. In particular, the Lenain profile depends on the _air_ friction velocity `u★`, while the Brevik does not. This is because Lenain divide the spectrum into saturation and equilibrium ranges, and the transition wavenumber between the two _depends on the friction velocity_ (it scales with `1 / u★^2`. Lenain also introduce an ""isotropic wavenumber"", which is an upper cutoff above which short waves do not contribute to the net Stokes drift. This isotropic wavenumber also scales with `1 / u★^2`. In all cases the Lenain model has strong shear at the surface. The effect is less pronounced on a (relatively coarse) grid with dz = 1 m, but still significant. The shear is also not monotonic in `u★`, possibly because the lower-frequency components start to contribute more at higher wind speeds, reducing the shear relative to the surface value of the Stokes drift. Check out the results:. ![image](https://user-images.githubusercontent.com/15271942/156649792-02639f67-5d0d-47f3-93f7-e1faa7ad92f9.png). Code:. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; Cᵝ = 0.105 # Toba's constant; Cʳ = 9.7e-3 # Transition wavenumber parameter, Lenain and Pizzo 2020 eq 4; Cⁱ = 0.072 # Cutoff / isotropic wavenumber parameter; # exp(π/2 - θ₀) / γ) from Lenain and Pizzo 2020 Appendix A; Cᴮ = 7e-3 # Saturation constant; g = 9.81 # m s⁻², gravitational acceleration; ρʷ = 1024 # kg m⁻³, water density; ρᵃ = 1.225 # kg m⁻³, air density. #####; ##### Stokes drift profile from Brevik et al 2016; #####. T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))); brevik(k, z) = T₁(k, z) - T₂(k, z). #####; ##### Stokes drift profile from Lenain and Pizzo 2020; #####. kⁿ(u★) = Cʳ * g / u★^2 # Transition wavenumber; kⁱ(u★) = Cⁱ * g / u★^2 # Isotropic wavenumber / upper wav",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264:226,depend,depends,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264,1,['depend'],['depends']
Integrability,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:3775,message,message,3775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['message'],['message']
Integrability,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509:92,message,messages,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509,4,['message'],"['message', 'messages']"
Integrability,Eliminate Plots as dependency in Docs; use Makie,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2562:19,depend,dependency,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2562,1,['depend'],['dependency']
Integrability,Explicitly state interface location instead of using face and edge field locations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/146:17,interface,interface,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/146,1,['interface'],['interface']
Integrability,"Extrinsic is what we decide. When we use the cubed sphere we want to use geographic coordinates. But vector fields on the c-grid have their own coordinate system dictated by the structure of the grid. Except for `LatitudeLongitudeGrid`, the geographic coordinate system does not coincide with the ""other"" coordinate system (I called it intrinsic above, but if this is confusion we need another name) that's associated with the grid. What language would you like to use to describe (1) the coordinate system that we would like to impose on the grid for the user interface and 2) the coordinate system that the raw vector fields use (I'm trying to avoid the language I proposed to ask this question).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309:561,interface,interface,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309,1,['interface'],['interface']
Integrability,Field-dependent boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1093:6,depend,dependent,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093,1,['depend'],['dependent']
Integrability,FieldTimeSeries for time-dependent boundary condition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:25,depend,dependent,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['depend'],['dependent']
Integrability,Fix CUDA dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/197:9,depend,dependencies,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197,1,['depend'],['dependencies']
Integrability,Fix location of Integrated areas derivatives in the PCG solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2710:16,Integrat,Integrated,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710,1,['Integrat'],['Integrated']
Integrability,Fix warning message for halo size,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666:12,message,message,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666,1,['message'],['message']
Integrability,Fixes off-by-one indexing error in hydrostatic pressure integrat…,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:56,integrat,integrat,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['integrat'],['integrat']
Integrability,Fixing `AveragedField` and implementing `IntegratedField` using `GridMetricOperation`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:41,Integrat,IntegratedField,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,1,['Integrat'],['IntegratedField']
Integrability,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:279,integrat,integrated,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168,2,['integrat'],['integrated']
Integrability,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:52,integrat,integrated,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715,1,['integrat'],['integrated']
Integrability,"For completeness I think the same grid could be generated with the current interface using. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; zF = k -> cos(π * (2k - 1) / 2Nz)); ```. I suppose the main difference is that the syntax with `z_stretching` makes the bounds of the domain explicit, whereas when using `zF` a code-reader has to compute the domain bounds by plugging `k = 1` and `k = Nz + 1` into the generating function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232:75,interface,interface,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232,1,['interface'],['interface']
Integrability,"For face indexing convention, 1 is the interface forming left boundary of the domain and N+1 is the interface forming the right boundary. For center indexing, the first cell on the left is 1 and the last cell on the right is N. I'm not 100% sure what you are asking but this is the definition of the indices. I think if you set N+1 for right-sided open boundaries, you should set 1 for left-sided open boundaries. If you set N+2 for the right side, then you would set 0 for the left side. Maybe there is a bug somewhere else?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825,2,['interface'],['interface']
Integrability,"For many purposes, e.g. writing output, calculating statistical diagnostics, etc. that is very inefficient on CuArrays because of scalar operations, it turns out to be faster to just convert the CuArray to an Array and do the operation. I wonder if there's a nicer way of doing this. I guess CUDAnative.jl has a rough list of CuArray-compatible functions that we should refer to more often. We can also just use a wrapper function but this feels a little weird and we'd have to remember where we need to use it; ```julia; wrapper(A::Array) = A; wrapper(A::CuArray) = Array(A); ```; which isn't much better than always using `Array(A)` as we mostly run on the GPU. This feels like a pretty minor issue but thought I'd document it here since I found myself doing this several times today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/171:414,wrap,wrapper,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171,3,['wrap'],['wrapper']
Integrability,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:1410,interface,interface,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,1,['interface'],['interface']
Integrability,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:685,interface,interfaces,685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,2,['interface'],['interfaces']
Integrability,"For small scale testing we could use JuliaGPUs buildkite. On Wed, Sep 4, 2024 at 12:32 PM Simone Silvestri ***@***.***>; wrote:. > Right, I think the problem is the availability of AMD GPUs to run tests.; > If we find one, I can revamp this.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328512985>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XVCEUJNTZHWDD36KDZU3OVLAVCNFSM6AAAAABDHAZB6GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMRYGUYTEOJYGU>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255:620,Message,Message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255,1,['Message'],['Message']
Integrability,"For sure, that is always an option. After a lot of searching it seemed that the problem was indeed the synchronization of the boundary conditions that still was not fixed. . this PR should be ready to merge, I ll do the last check of the comments I maybe missed and then merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231:103,synchroniz,synchronization,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231,1,['synchroniz'],['synchronization']
Integrability,"For the GPU case, again for 128x128 (still rather coarse and results will depend on resolution I suspect). ```; scheme ratio; ====== ===; C2 1.2; U3 1.5; C4 2.4; U5 1.5; W5 7.0. ```. In general the scalings tend to be better on GPUs vs CPUs (on this coarse grid). It does seem that `WENO5` does much worst, relatively speaking. . Benchmarks that I did with @ali-ramadhan found that on GPUs vs CPUs, shallow water model could be faster by a factor of `170`, which was for `U5`. With `WENO5` it was double that. I guess the moral of the story is that `WENO5` is very different and sometimes much better and sometimes much worst. I should say that the difference from the first run to the second sometimes differed by a factor of `10`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677:74,depend,depend,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677,1,['depend'],['depend']
Integrability,Forcing functions that depend on internal model fields besides velocities and tracers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582:23,depend,depend,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582,1,['depend'],['depend']
Integrability,Forward Euler + 3rd order Runge-Kutta time-stepping (or integration with DifferentialEquations.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:56,integrat,integration,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['integrat'],['integration']
Integrability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1679,wrap,wrapper,1679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['wrap'],['wrapper']
Integrability,Function interface for extracting properties from models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156:9,interface,interface,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156,1,['interface'],['interface']
Integrability,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:10,message,messages,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979,3,"['message', 'synchroniz']","['messages', 'synchronized']"
Integrability,Good catch. This should be made very clear as it has confused us in the past... I'll make sure to address this issue on the (increasingly stale =/) `ar/integrate-vs-grid` branch...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523:152,integrat,integrate-vs-grid,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523,1,['integrat'],['integrate-vs-grid']
Integrability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:105,interface,interface,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['interface'],['interface']
Integrability,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1195,Inject,Injection,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Inject'],['Injection']
Integrability,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/404:57,depend,dependencies,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404,1,['depend'],['dependencies']
Integrability,Good! I wonder if we can add a test here too to wrap this up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711:48,wrap,wrap,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711,1,['wrap'],['wrap']
Integrability,"Great job! Though I have not looked at the code, I have two comments:. 1. I am surprised that the choice of `regularization` affects the convergence rate. I will think about it more.; 2. The rate of convergence depends on the distribution of eigenvalues of the preconditioned linear operator. I have a piece code of that outputs the preconditioned linear operator as a dense `Matrix`, which can be useful for testing the convergence rate and new algorithms without invoking `Oceananigans`. It can be helpful for testing why `FlatExtrapolationOpenBoundaryCondition` results in a much slower convergence. Besides, I have found that grids with better symmetry have faster convergence because the resulting Laplacian operators have more repeated eigenvalues. In theory, the number of iterations required for the CG method to get the exact solution is the number of unique eigenvalues. ```Julia; using LinearAlgebra; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver; using Oceananigans.ImmersedBoundaries: active_cells_map, immersed_cell, mask_immersed_field!; using Oceananigans.Solvers: solve!; using Statistics: norm, mean. using Oceananigans.Solvers: precondition!. ENV[""JULIA_DEBUG""] = ""Solvers"". # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(). # Grid; const Nx = 10; const Ny = 10; const Nz = 10; const Lx = 1.0; const Ly = 1.0; const Lz = 1.0. const Δz = Lz / 2 # elevation difference at the top. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; # return Lz - Δz * sin(π/2 * y/Ly) - Δz * 0.2; return Lz - Δz; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611:211,depend,depends,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611,1,['depend'],['depends']
Integrability,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:458,integrat,integrate,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['integrat'],['integrate']
Integrability,HDF5 and plotting utilities are heavy dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284:38,depend,dependencies,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284,1,['depend'],['dependencies']
Integrability,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:294,integrat,integration,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849,1,['integrat'],['integration']
Integrability,"Happy to try these. The first one failed in the same way as before. The second one failed because the syntax does not seem right with clock. I instead tried this. ```; model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0,0,1), grid=grid); ```; and that also had an error, with what seems to be the same message. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388:340,message,message,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388,1,['message'],['message']
Integrability,"Heh, I agree that says nothing!. Do you have any thoughts about a preferred user interface, among the options I give above (or perhaps you have ideas for another design)? That's the first design question to answer before writing any code. Once we settle on an interface I think the code-writing will be fairly straightforward in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247:81,interface,interface,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247,2,['interface'],['interface']
Integrability,"Hello @sam12396 , I am glad you have been able to run Oceananigans on GPUs. That could speed things up a great deal, depending on what you are trying to do. Oceananigans has been written in such a way that the user does not need to do anything different in terms of setting up a problem on CPUs vs GPUs. To illustrate my point, consider the shallow water Bickley jet example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/). The default is set up to run on CPUs but if you want to run it on GPUs, then it's easy. Where you define the model you need to add one line,. ```; model = ShallowWaterModel(; architecture=GPU(),; timestepper=:RungeKutta3,; advection=WENO5(),; grid=grid,; gravitational_acceleration=g,; coriolis=FPlane(f=f),; ); ``` ; When you make that one change (setting the architecture in the second line above), then the code will use GPUs. The producing of the data and reading and writing is then all done with GPUs. There is nothing else for you to do. In particular, if you define your forcing and initial conditions using functions, as the examples tend to do, then nothing needs to change. If you want to use Oceananigans.jl, are you sure you need to program things differently?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777:117,depend,depending,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777,1,['depend'],['depending']
Integrability,"Hello! I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. As a first exercise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=Anisotropi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190:556,interface,interface,556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190,1,['interface'],['interface']
Integrability,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:869,depend,dependencies,869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,2,['depend'],"['dependencies', 'dependency']"
Integrability,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:455,depend,dependencies,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,['depend'],['dependencies']
Integrability,Helpful error message for incorrect usage of `FieldBoundaryConditions`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:14,message,message,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,1,['message'],['message']
Integrability,"Here's a clue: this fixes the issue. ```julia; Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). progress_cb = simulation.callbacks[:progress]; @show actuations = progress_cb.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); progress_cb = simulation.callbacks[:progress]; progress_cb.schedule.actuations = actuations; run!(simulation, pickup=checkpoint); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650:173,message,message,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650,1,['message'],['message']
Integrability,"Here's a couple more thoughts:. * `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires eva",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:855,interface,interfaces,855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,1,['interface'],['interfaces']
Integrability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:41,depend,dependence,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,4,['depend'],"['dependence', 'dependent']"
Integrability,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:105,depend,depends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172,1,['depend'],['depends']
Integrability,"Here's a screenshot of the top row from the final time-step:. ![image](https://user-images.githubusercontent.com/15271942/160630444-6b07529f-cf8b-4d03-8421-a6027153298e.png). showing significantly more small scale features on the left. The difference (the key to this PR) is using the velocity field in the smoothness metric for vorticity reconstruction, rather than the vorticity field. The ordinary WENO algorithm uses the smoothness of the field being reconstructed to produce weights for the candidate stencils. This method is therefore an innovation, since we are using the _velocity_ field to evaluate smoothness for reconstructing _vorticity_. The velocity field is smoother than vorticity, so this generally leads to less-dissipative stencils (but still ""enough"" dissipation to stabilize the simulation). @simone-silvestri definitely has more plots showing differences in spectra and time-series of integrated enstrophy, perhaps he will share!. I'm also going to paste an example of using this scheme in the code once I figure that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042:907,integrat,integrated,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042,1,['integrat'],['integrated']
Integrability,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:725,interface,interface,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['interface'],['interface']
Integrability,"Here's the main differences:. 1. `FunctionOperation` is not backed by data; eg it doesn't allocate memory (its just a wrapper for a function); 2. `KernelComputedField` requires a `KernelAbstractions` `@kernel`. `FunctionOperation` requires a function of `i, j, k, grid, fields..., parameters)`. It's a subtle but real distinction. Sometimes defining `@kernel` may be more convenient / more readable.; 3. The `kernel` in `KernelComputedField` cannot be reduced on the fly (unless this is supported by `KernelAbstractions` someday, somehow, eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/234, but we don't know what this would look like yet). Taking the vertical vorticity for curvilinear / cubed sphere grids as an example, usage is. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᵃ # called with signature ζ₃ᶠᶠᵃ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = FunctionOperation(Face, Face, Center, ζ₃ᶠᶠᵃ, grid, computed_dependencies=(u, v)). ζ = ComputedField(ζ_op) # identical to `VerticalVorticityField`. barotropic_ζ = AveragedField(ζ_op, dims=3); ```. On the CubedSphere, `ζ₃ᶠᶠᵃ` cannot be expressed in terms of `AbstractOperations` due to the need to treat corners in a special manner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910:118,wrap,wrapper,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910,1,['wrap'],['wrapper']
Integrability,"Hi @EavenW hope it wasn't too hard to get started (the documentation needs some more work, sorry about that). Not totally sure what you mean by a flux boundary condition with two components (sounds like the u and v velocity fields might be further coupled via this boundary condition?). Sounds like you're trying to impose a (time-dependent?) surface flux boundary condition which can be done a few different ways.; * If it's independent of time then [imposing a flux BC with a 2D array](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1) is one option.; * If it's time-dependent then [imposing the flux BC as a function](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1) is probably the way to go. The function signature for boundary conditions is `f(i, j, grid, t, U, C, params)` so the boundary condition can depend on time `t`, the velocity fields `U = (u, v, w)` and any tracer quantity in `C`.; * If you can write your surface flux BC as a function of only (x, y, t) then a [`BoundaryFunction`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/boundary_function.jl) can simplify the setup a little. I just realized this isn't showing up in the documentation but the docstring in the file I linked to has an example of how to use it. PS: Not sure which version you're running but we've been making some improvements to the user interface lately which may break certain things if you upgrade to v0.21 or v0.22. Please don't hesitate to ping us if you have any questions or if something isn't working. We're more than happy to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085:331,depend,dependent,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085,4,"['depend', 'interface']","['depend', 'dependent', 'interface']"
Integrability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:350,message,messages,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,3,['message'],['messages']
Integrability,"Hi @jhdong2016, thanks for your interest in Oceananigans! . Personally I find it very difficult to help out without something that I can run and reproduce your results. Could you post your script somewhere also for making the plots. Something I can copy/paste in the REPL or just write `include(""jhdong_script.jl"")`?. It's often useful to post the version of Oceananigans you are using (and the rest of dependencies). E.g., post the output of `using Pkg; Pkg.status()`. Do I understand correctly or is it my impression that you have depth in the horizontal axis?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944:403,depend,dependencies,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944,1,['depend'],['dependencies']
Integrability,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:104,message,messages,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['message'],['messages']
Integrability,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724:425,integrat,integration,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724,3,['integrat'],"['integrate', 'integrated', 'integration']"
Integrability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:471,message,message,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,2,"['depend', 'message']","['dependencies', 'message']"
Integrability,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:366,message,messages,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,3,"['depend', 'message']","['depend', 'message', 'messages']"
Integrability,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657:274,message,message,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657,4,['message'],"['message', 'messages']"
Integrability,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:81,interoperab,interoperability,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134,2,"['interoperab', 'rout']","['interoperability', 'route']"
Integrability,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:156,interface,interface,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,4,"['interface', 'wrap']","['interface', 'wrappers']"
Integrability,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:613,message,message,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812,1,['message'],['message']
Integrability,"Hm... I see both your points. The boundary layer is indeed pronounced in the buoyancy or buoyancy dissipation. But indeed for Ra=1e8 the boundary layer is most probably well-resolved. The boundary layer thickness, however, scales with Ra^{-1/5} or Ra^{-1/4} (depending on the flow regime)... Thus, for the Ra value in the example you are right: no modification is needed. But if one wants to take this up to higher Ra values then higher vertical resolution near the top will help. Perhaps we close this issue (as, I agree, is not really an _issue_ of the code). Or convert to discussion?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629:259,depend,depending,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629,1,['depend'],['depending']
Integrability,"Hm.... what version of Oceananigans did you try the quick_start example with? I'd bet you used a very old version, e.g., a version _before_ the breaking release [v0.90.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.90.0)?. The quick start example works on `main` for me:. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 12 seconds. 160 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z. julia> model = NonhydrostaticModel(; grid, advection=WENO()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: WENO reconstruction order 5; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> ϵ(x, y) = 2rand() - 1; ϵ (generic function with 1 method). julia> set!(model, u=ϵ, v=ϵ). julia> simulation = Simulation(model; Δt=0.01, stop_iteration=100); Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── Next time step: 10 ms; ├── Elapsed wall time: 0 seconds; ├── Wall time per iteration: NaN days; ├── Stop time: Inf days; ├── Stop iteration : 100.0; ├── Wall time limit: Inf; ├── Callbacks: OrderedDict with 4 entries:; │ ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1); │ ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1); │ ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1); │ └─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613:351,depend,dependency,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613,1,['depend'],['dependency']
Integrability,"Hmm yes we might need extensions to provide that functionality. Another possibility is to use plot recipes: https://docs.makie.org/stable/documentation/recipes/. That page says. > If you're a package developer, it's possible to add recipes without adding all of Makie.jl as a dependency. Instead, you can use the MakieCore package, which is a lightweight package which provides all the necessary elements to create a recipe, such as the @recipe macro, convert_arguments and convert_attribute functions, and even some basic plot type definitions. I'm not sure the stuff on `Imaginocean.jl` can be implemented with plot recipes, but if it can then perhaps that is a better approach?. Otherwise I agree that we should investigate extensions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865:276,depend,dependency,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865,1,['depend'],['dependency']
Integrability,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436:194,interface,interface,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436,2,['interface'],['interface']
Integrability,"Hmm, well `ρg` is literally the force density exerted by the weight of the fluid. On Wikipedia, 'buoyancy' is the force induced when you displace fluid; therefore the buoyancy of a solid object is equal to . gravitational acceleration x (volume of object x density of displaced fluid - mass of the object). which gives the forcing acting on the body (positive upwards due to the sign of the terms). Here we deal in densities, so the buoyant forced defined in the same manner would essentially be . gravitational acceleration x ( reference density - density of the buoyant fluid ) . which of course is precisely `-ρ' g`, since `ρ' = ρ - ρ0`. I think that from its usage the meaning of `buoyancy_perturbation` is clear. . Something to keep in mind as we continue to discuss this topic outside this PR is that atmospheric scientists go even a step further and define 'buoyancy' as `-(ρ' - <ρ'>) g / -ρ0`, where `<>` is a horizontal average --- thus omitting the z-dependent, horizontally uniform part of the 'total' buoyancy that does not contribute to dynamics (because it is balanced by a static component of pressure). Thus using `buoyancy_perturbation` to denote a quantity which, for them, comprises even non-dynamic, irrelevant components of `-ρ' g / -ρ0` could seem a bit odd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079:961,depend,dependent,961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079,1,['depend'],['dependent']
Integrability,"Hmm, well it looks like we do compute arguments:. https://github.com/CliMA/Oceananigans.jl/blob/abd447980898bcbfe099d71258d4e52f3cf090f9/src/AbstractOperations/kernel_function_operation.jl#L75. But if the arguments are themselves wrapped inside a `NamedTuple` --- or any other object --- then they won't be computed. In other words `compute!(perturbation_velocities)` does not compute the elements of `perturbation_velocities`. We could add a method `compute!(tup::Tuple) = Tuple(compute!(t) for t in tup)` and also for `NamedTuple`. But I'm not sure this is the best API. Maybe it's better to require that arguments that need to be computed should be included directly as arguments. Seems like its up for debate. PS it does seem to test this correctly then we need to further evaluate . ```julia; f_perturbation = Field(f_perturbation_op); compute!(f_perturbation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508:230,wrap,wrapped,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508,1,['wrap'],['wrapped']
Integrability,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:636,integrat,integrate,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose. I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415:62,depend,depend,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415,1,['depend'],['depend']
Integrability,Hmm... there's a function in `CUDA.jl` called `partial_mapreduce_grid` that might contain logic that depends on the size of the kernel (not sure): https://github.com/JuliaGPU/CUDA.jl/blob/92f1001861641cb173af49454b05c91728cbfc3d/src/mapreduce.jl#L91,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699:101,depend,depends,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699,1,['depend'],['depends']
Integrability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:737,message,message,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['message'],['message']
Integrability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:139,depend,depends,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['depend'],['depends']
Integrability,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,inject,injected,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768,1,['inject'],['injected']
Integrability,"Hmmm, I don't know if many log levels will be that helpful. I guess for debug messages we'll want to have the file name and line number, but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. I think one place that logging can hugely improve user experience is in setting up large models, especially on the GPU, where you could be waiting for several minutes while all of Julia, CUDA, and Oceananigans compiles, model is being set up, memory is allocated, etc. We know it takes time but most users will think that something is wrong if Julia is silent for 5 minutes. In this context info messages can be useful and reassure the user that Oceananigans is working properly. It's well known that progress indicators improve user experience, e.g.: https://www.nngroup.com/articles/progress-indicators/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192:78,message,messages,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192,3,['message'],['messages']
Integrability,"Hmmm, I guess the immediate issue is that `LatitudeLongitudeGrid` doesn't have a 1-location `xnodes` functions:. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/Grids/latitude_longitude_grid.jl#L635-L656. But it shouldn't as x will depend on longitude and latitude. Probably most users will want output in longitude and latitude though. The bigger issue is that the `NetCDFOutputWriter` is not aware of the `LatitudeLongitudeGrid`. As this is covered by issue #2248 I'll close this issue as a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939:275,depend,depend,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939,1,['depend'],['depend']
Integrability,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:190,message,message,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367,3,['message'],"['message', 'messages']"
Integrability,"Homogenize interface for initializing `Simulation`, schedules, etc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015:11,interface,interface,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015,1,['interface'],['interface']
Integrability,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603:588,message,message,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603,2,['message'],['message']
Integrability,"How to create field derived fields? For instance, if I want the model to calculate and save Richardson number fields. Also, I saw that the diffusivity can be a function of x,y,z,t, can I easily give a function that depend on the Richardson number or do I need to implement it as a Turbulence closure?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337:215,depend,depend,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337,1,['depend'],['depend']
Integrability,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:223,integrat,integrating,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1693:55,integrat,integrating,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693,2,"['depend', 'integrat']","['depends', 'integrating']"
Integrability,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3830:348,depend,depend,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830,1,['depend'],['depend']
Integrability,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:241,depend,depends,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,8,"['depend', 'interface']","['depends', 'interface']"
Integrability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:454,interface,interface,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,1,['interface'],['interface']
Integrability,I also don't like `calc_nonlinear_κᶜᶜᶜ`. I hope we can come up with a better interface for defining LES closures in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168,1,['interface'],['interface']
Integrability,"I am a little perplexed, because it seemed that tests on the PR passed (except for documentation, which is mysteriously broken right now due to a dependency that's getting updated during `dev ..` in the docs build). ![image](https://user-images.githubusercontent.com/15271942/114247433-ed6df200-9949-11eb-8649-f270ee7e12c7.png). ![image](https://user-images.githubusercontent.com/15271942/114247449-f5c62d00-9949-11eb-96af-02532bde76ef.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193:146,depend,dependency,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193,1,['depend'],['dependency']
Integrability,"I am also doubting our regression data. For sure it is a synchronization problem, but it is difficult to understand wether it's on the data (generated long time ago) or in the current code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971:57,synchroniz,synchronization,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971,1,['synchroniz'],['synchronization']
Integrability,"I am attempting to use`ConjugateGradientPoissonSolver` in my simulation, but the error specifically occurs when the grids are stretched. The error happens when running either `fft_poisson_solver(grid.underlying_grid)` or `ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20)`. . The error message: ; ```; ERROR: type RectilinearGrid has no field underlying_grid; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] fft_poisson_solver(grid::RectilinearGrid{…}); @ Oceananigans.Solvers ~/code/Oceananigans.jl/src/Solvers/Solvers.jl:55; [3] top-level scope; @ REPL[7]:1. ```; I don't understand why there is no `underlying_grid`, which clearly exists.; Here is the MWE that I slightly modified from https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426, thanks to @ali-ramadhan, @glwagner ; ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2). # Create stretched vertical grid; kwarp(k, N) = (N + 1 - k) / N; # Linear near-surface generator; ζ(k, N, refinement) = 1 + (kwarp(k, N) - 1) / refinement; # Bottom-intensified stretching function; Σ(k, N, stretching) = (1 - exp(-stretching * kwarp(k, N))) / (1 - exp(-stretching)); # Generating function; z_faces(k) = - H * (ζ(k, N, 1.2) * Σ(k, N, 15) - 1); z = z_faces. # uniform vertical grid; # z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:301,message,message,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,1,['message'],['message']
Integrability,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:499,interface,interface,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924,1,['interface'],['interface']
Integrability,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:195,integrat,integrate,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269,3,['integrat'],"['integrate', 'integrating']"
Integrability,I am in the JLD2 camp since it has less dependencies and is easier to get working ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873:40,depend,dependencies,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873,1,['depend'],['dependencies']
Integrability,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:314,wrap,wrap,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906,1,['wrap'],['wrap']
Integrability,"I am open to either option, depending on which is possible at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267:28,depend,depending,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267,1,['depend'],['depending']
Integrability,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:901,Message,Messages,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,1,['Message'],['Messages']
Integrability,"I applaud @vchuravy suggestion. On a different note, @fluidnumerics-joe you need to resolve the dependencies in Manifest; see. https://buildkite.com/clima/oceananigans/builds/14348#018d8bb7-22a8-4a33-9839-626ade95f3c8/18-36. I tried to do it but I don't have push rights on your fork.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967:96,depend,dependencies,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967,1,['depend'],['dependencies']
Integrability,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:232,wrap,wrapper,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"I checked the help and indeed there is!. ```; help?> nameof; search: nameof. nameof(m::Module) -> Symbol. Get the name of a Module as a Symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> nameof(Base.Broadcast); :Broadcast. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(t::DataType) -> Symbol. Get the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> module Foo; struct S{T}; end; end; Foo; ; julia> nameof(Foo.S{T} where T); :S. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(f::Function) -> Symbol. Get the name of a generic Function as a symbol. For anonymous functions, this is a compiler-generated name. For; explicitly-declared subtypes of Function, it is the name of the function's type. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606:404,wrap,wrapped,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606,1,['wrap'],['wrapped']
Integrability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:504,interface,interface,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['interface'],['interface']
Integrability,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:187,depend,dependency,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,1,['depend'],['dependency']
Integrability,I copied the whole line above in the initial message. . But to answer your question it's coming from `automatic_halo_sizing.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768,1,['message'],['message']
Integrability,"I couldn't find any page in docs that explains that the models can take a tuple of closures. I guess it should be [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/turbulent_diffusivity_closures_and_les_models/)?. PS:. - If it's there somewhere and I missed it, please let me know!; - I'm assuming passing a tuple as `closure` is okay, but maybe it's deprecated behavior or something? Possibly depends on https://github.com/CliMA/Oceananigans.jl/issues/1381",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879:420,depend,depends,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879,1,['depend'],['depends']
Integrability,"I didn't make a suggestion except the extremely Holy Principle that the default _absolutely must work_. Otherwise the code is just broken and honestly, when I encounter this in other packages I often decide not to use them. It wouldn't be unreasonable to use VectorInvariant as the default for the hydrostatic model honestly. But if we want to have a flux form default then yes it has to depend on the grid to satisfy Holy Principle 1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091:388,depend,depend,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091,1,['depend'],['depend']
Integrability,"I didn't quite understand what the bug in AMD was. Was it important?. (Asking because one of your commits contained a bugfix for AMD, according to the message)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973:151,message,message,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973,1,['message'],['message']
Integrability,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:176,depend,dependencies,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825,1,['depend'],['dependencies']
Integrability,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:121,message,message,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539,1,['message'],['message']
Integrability,I do! I'll send a message on slack.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696,1,['message'],['message']
Integrability,"I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. If someone else has encountered the same issue then maybe we can make progress?. It'll be nice if upgrading to 1.6 (#1514) solves this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610:169,depend,dependencies,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610,1,['depend'],['dependencies']
Integrability,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:119,interface,interfaces,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,10,['interface'],"['interface', 'interfaces']"
Integrability,"I don't know how relevant these changes are, but I found some more type instabilities in the split explicit free surface model's adams bashforth time integrator. Removing them similar to #3212 . Alternatively we could also hardcode the constants. https://github.com/CliMA/Oceananigans.jl/blob/9140a74536784396d368cf8205432433a9deea3d/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L11-L19. as Float32. ```julia; const β = 0.281105f0; const α = 1.5f0 + β; ```; etc. as this will directly upcast to Float64 if that's used, but not cause a type instability with Float32. But this will again cause problems if we ever want to use something else than Float32/64... Now just the `U★, η★` get a bit lengthier!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3213:150,integrat,integrator,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3213,1,['integrat'],['integrator']
Integrability,"I don't know how the spherical hydrostatic model does this but I agree this would be nice to have for the rectilinear model as well. From what I recall from Sadourny (1975) you can have either energy or enstrophy conserving schemes, depending on how you do the averaging. When I played around with them I found that the enstrophy conserving scheme managed to prevent a numercial instability that can occur, but the energy conserving scheme did not. But getting either one (or both) working would be great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735:233,depend,depending,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735,1,['depend'],['depending']
Integrability,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:380,depend,dependencies,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801,1,['depend'],['dependencies']
Integrability,"I don't think ""child"" is used in standard way here. Usually ""child"" refers to a processes that is dependent on another process. That's not the relationship between `Distributed` and `CPU`... https://www.computerhope.com/jargon/p/parechil.htm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820:98,depend,dependent,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820,1,['depend'],['dependent']
Integrability,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:581,depend,depending,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,2,['depend'],['depending']
Integrability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:412,interface,interface,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,2,['interface'],"['interface', 'interfaces']"
Integrability,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195:24,depend,depend,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195,1,['depend'],['depend']
Integrability,I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806:39,depend,dependency,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806,1,['depend'],['dependency']
Integrability,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:109,rout,routines,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033,3,['rout'],['routines']
Integrability,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:478,message,messages,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918,1,['message'],['messages']
Integrability,"I found a similar problem \(see #3320\), but I am not sure whether it is related or not. I do not know whether `synchronize(device(architecture(model)))` will solve my problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431:112,synchroniz,synchronize,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431,1,['synchroniz'],['synchronize']
Integrability,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:927,integrat,integration,927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317,1,['integrat'],['integration']
Integrability,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:76,depend,dependency,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,1,['depend'],['dependency']
Integrability,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:791,wrap,wrapper,791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724,2,['wrap'],"['wrapper', 'wrapping']"
Integrability,"I guess if you have a (julia) function that takes a particle time-step, given a velocity field (ie 3D array), then you can use PlanktonIndividuals.jl online with Oceananigans now, using the `Callback` Oceananigans feature that's designed for integration with other models. So maybe it already works in fact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871:242,integrat,integration,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871,1,['integrat'],['integration']
Integrability,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108,1,['wrap'],['wrapped']
Integrability,"I guess there are two questions here; one regards user interface and the other regards how we determine defaults internally. It's worth pointing out from the outset that we may have too many defaults right now; we should try to tackle that. On user interfaces, we haven't converged on a way to set parameters like ""radius of the Earth"" and ""gravitational acceleration"". One philosophy could be to never use defaults. Unfortunately that is not very friendly / convenient, but on the upside it would help users ensure that these constants are always consistent. I guess we have to decide on an approach for the user interface first; then the internal code will follow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341,3,['interface'],"['interface', 'interfaces']"
Integrability,"I guess to have a continuous diffusion function that has the same features of the discrete version (with field dependency and parameters), we could implement something very similar to the `ContinuousForcing.` That would require a regularization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624:111,depend,dependency,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624,1,['depend'],['dependency']
Integrability,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:398,contract,contracts,398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,1,['contract'],['contracts']
Integrability,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:57,depend,dependencies,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292,1,['depend'],['dependencies']
Integrability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:54,interface,interface,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['interface'],['interface']
Integrability,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:173,message,message,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['message'],['message']
Integrability,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['depend'],['dependency']
Integrability,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:822,depend,depend,822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,1,['depend'],['depend']
Integrability,"I have found it inconvenient that output is masked to `0`. For most purposes, I'd prefer `NaN`. I'm opening this issue to discuss a user interface that would implement such a feature. My first idea is to add a property / kwarg to output writers called `immersed_values`. Then we might write something like. ```julia; output_writer = JLD2OutputWriter(model, output, immersed_values=NaN, other_kwargs...); ```. The default will be `immersed_values=nothing`. Then `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/OutputWriters/fetch_output.jl#L12-L15. would become something like. ```julia. function fetch_output(field::AbstractField, model, immersed_value) ; compute_at!(field, time(model)); !isnothing(immersed_value) && mask_immersed_field!(field, immersed_value); return parent(field) ; end ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061:137,interface,interface,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061,1,['interface'],['interface']
Integrability,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:99,depend,depend,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['depend'],['depend']
Integrability,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:263,depend,dependence,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559,1,['depend'],['dependence']
Integrability,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:228,depend,dependent,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382,2,['depend'],['dependent']
Integrability,"I just noticed this:. ```julia; julia> x = range(1, stop=10, step=1.0); 1.0:1.0:10.0. julia> y = reshape(x, 10, 1, 1); 10×1×1 reshape(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 10, 1, 1) with eltype Float64:; [:, :, 1] =; 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0. julia> typeof(y); Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}; ```. So the reshaped ranges do not convert to arrays / `collect` elements --- they are still ranges, with a wrapper (which means that we don't have to do anything special for GPU). I don't think there's any downside to reshape the ranges for convenience in this case. This will slightly simplify the `xnodes`, etc functions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364:558,wrap,wrapper,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364,1,['wrap'],['wrapper']
Integrability,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:567,interface,interface,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151,2,['interface'],['interface']
Integrability,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:42,message,message,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,1,['message'],['message']
Integrability,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:905,depend,depend,905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690,1,['depend'],['depend']
Integrability,"I mean the new user interface for `ImmersedBoundaryCondtion`. Previously, I tried to do a simulation with heating distributed on an irregular bottom, and I found that I had to use `ImmersedBoundaryCondition(top = the_bottom_heating)` instead of `ImmersedBoundaryCondition(bottom = the_bottom_heating)` after some testing. I felt this strange and reported this behavior to Simone. Then he opened this issue, because it affects his simulations as well. I am sorry for confusing you, since you did not know Simone and I had some discussion on issue before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782,1,['interface'],['interface']
Integrability,"I moved it to Diagnostics, but it's not compiling yet because it depends on OutputWriters, which is compiled right after Diagnostics. Compiling OutputWriters before Diagnostics doesn't work also because there are some dependencies there too. I think the `define_output_variable!` part could be moved towards `OutputWriters` (since it's only used by the NetCDF writer), but the annoying thing is that I'm also using `slice_parent` in the very definition of the average, which is defined in `field_slicer.jl`. Let me know what you think, but I actually think stuff related to `FieldSlicer` could be moved to outside of `OutputWriters` since it has found other uses outside of the NetCDF output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497:65,depend,depends,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497,2,['depend'],"['dependencies', 'depends']"
Integrability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:119,depend,dependent,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['depend'],['dependent']
Integrability,"I noticed that the example could be improved a bit by using a grid with z-dependence, and omitting the irrelevant x and y dependence. Also, the show method for SeawaterBuoyancy needs improvement (underscores are missing from `equation_of_state`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3398:74,depend,dependence,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3398,2,['depend'],['dependence']
Integrability,"I prefer `HorizontalDirections` to `XYDirections`. ""Horizontal"" is more meaningful when we're on a spherical shell. I understand that gravity can be rotated, but I think ""horizontal directions"" will be primarily used with models that are not rotated. The same issue plagues `XYZDirection` --- its a Cartesian / Rectilinear centric view. The situation makes even less sense on a cubed sphere, where ""x"" and ""y"" are arbitrary and pointed in different directions depending on the location on the sphere. How do others feel?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594:460,depend,depending,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594,1,['depend'],['depending']
Integrability,I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139:78,interface,interface,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139,1,['interface'],['interface']
Integrability,"I ran a few tests using the [Bickley Jet](https://github.com/CliMA/Oceananigans.jl/blob/glw-vw/grid-fitted-incompressible-model/validation/immersed_boundaries/immersed_bickley_jet.jl) with an immersed top wall from the validation script. . ### Surface Normal Velocity; We can easily look at the surface normal velocity of the immersed wall (which should be zero) with increased resolution and see that it is converging nicely, as this method should be exact except for the pressure correction, which will scale. ![Bickley_normal](https://user-images.githubusercontent.com/67593861/122986244-2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:753,integrat,integrated,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,1,['integrat'],['integrated']
Integrability,"I ran this using the latest version and I got no error. @Sumanshekhar17 can you please confirm the version? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:204,message,message,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"I realized I can see from the error message that the grid is `Bounded` in all directions. I've never used this feature but I think you aren't specifying the tracked fields correctly. It needs to be something like. ```julia; # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T); ```. In other words, the values of the NamedTuple are themselves fields. So you have to build `tracers` before constructing the model. Something like this may work:. ```julia; tracers = (T=CenterField(grid), S=CenterField(grid)). # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T). model = NonhydrostaticModel(; grid, tracers, ...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060:36,message,message,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060,1,['message'],['message']
Integrability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:17,interface,interface,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:433,depend,depend,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,1,['depend'],['depend']
Integrability,I see `domain_depth`. What is the proposed interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001,1,['interface'],['interface']
Integrability,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:579,rout,routinely,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,2,['rout'],"['route', 'routinely']"
Integrability,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283:96,wrap,wrapper,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283,4,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:465,depend,dependent,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,2,['depend'],['dependent']
Integrability,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455:484,message,message,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455,1,['message'],['message']
Integrability,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1643:1237,interface,interface,1237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643,1,['interface'],['interface']
Integrability,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:127,message,message,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989,2,['message'],['message']
Integrability,"I think I am encountering a bug using `ValueBoundaryCondition`s with `ImmersedBoundaryGrid`s. `FluxBoundaryCondition`s do not trigger this, and based on the error message it looks like it has to do with how the halos are treated (in `src/BoundaryConditions/fill_halo_regions.jl`)? See a MWE below. I am running the latest version of `Oceananigans` (0.73.8). ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; using Oceananigans.Units; using Printf. Nx = 60; Nz = 18; Lx = 1200kilometers; Lz = 1800meters; Δt = 30minutes; taux = -0.5 # [Pa]; ρ₀ = 1026 # [kg m⁻³]. stop_time = 1years; save_interval = 1days; wind_time_ramp = 5days; lateral_diffusive_time = 1days; αT = 2e-4; taux = taux/ρ₀. buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=αT, haline_contraction=0.0)); momentum_advection = WENO5(); tracer_advection = WENO5(); tracers = (:T, :S). grid = RectilinearGrid(size = (Nx, Nx, Nz),; x = (0, Lx),; y = (0, Lx),; z = (-Lz, 0),; halo = (3, 3, 3),; topology = (Bounded, Bounded, Bounded)). free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver). # Rough topography.; ht = 100meters; Lt = 500kilometers; kt = 2π/Lt; topography(x, y) = ht*cos.(kt*x).*cos.(kt*y) .- Lz; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(topography)). coriolis = BetaPlane(latitude=45); κh = grid.Δxᶜᵃᵃ^2 / lateral_diffusive_time; νh = κh. κz = 0; νz = κz; horizontal_closure = HorizontalScalarDiffusivity(ν=νh, κ=κh); vertical_closure = VerticalScalarDiffusivity(ν=νz, κ=κz); closure = (vertical_closure, horizontal_closure). wind_stress(x, y, t) = - taux * cos(2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2430:163,message,message,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430,1,['message'],['message']
Integrability,"I think I have answered my own question. If you think of the momentum equation in terms fo the stress tensor, then in vector form it is. ``; ∂ₜuᵢ - ∂ⱼ⋅σᵢⱼ= 0,; ``. where the second term is the divergence of the stress tensor. If we integrate this over the volume, and divide by the volume then we get upon using **Gauss' Divergence Theorem**. ``; ∂ₜūᵢ =1/Vfcc∭ ∂ⱼ⋅σᵢⱼ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS; ``. In the case of an idea fluid we have `σᵢⱼ=-pδᵢⱼ` and therefore our equation above becomes. ``; ∂ₜūᵢ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS = - 1/Vfcc ∬ p δᵢⱼ⋅ n̂ⱼ dS = - 1/Vfcc ∬ p n̂ᵢ dS; ``. This shows that the desired result follows from application of Gauss' Divergence Theorem on the stress tensor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916:232,integrat,integrate,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916,1,['integrat'],['integrate']
Integrability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:176,integrat,integrate,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['integrat'],['integrate']
Integrability,"I think `base_grid` is a good name. ""underlying"" is also a little long and ""base"" helps with that. . Note we also should change the name of this abstract type if we use a different name than `underlying`:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/Grids.jl#L86-L92. Another possibility that comes to mind now is `parent_grid`, which is used throughout Julia to indicate a ""wrapped"" object:. ```julia; help?> parent; search: parent parentmodule parentindices. parent(A). Return the underlying ""parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> A = [1 2; 3 4]; 2×2 Matrix{Int64}:; 1 2; 3 4. julia> V = view(A, 1:2, :); 2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:; 1 2; 3 4. julia> parent(V); 2×2 Matrix{Int64}:; 1 2; 3 4; ```. (And there's also `parentmodule`, etc.) Perhaps that docstring is partly inspiration for referring to things as ""underlying"" (elsewhere we also have descriptions of ""underlying data"" for fields. But I like either `parent` or `base` better than `underlying`, with maybe a preference for `parent` now that I see its fairly widespread. As a side note (issue creep...) we also don't need `AbstractRectilinearGrid`, since there's only one:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/rectilinear_grid.jl#L8. eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177:428,wrap,wrapped,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177,2,['wrap'],['wrapped']
Integrability,I think an issue is a good place to discuss interface design. I can open one if you want!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579:44,interface,interface,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579,1,['interface'],['interface']
Integrability,"I think even 1D would be ok. On the question of interpolation of velocities: to compute fluxes we need to _reconstruct_ the fields at the cell interfaces. The velocity field is _staggered_ with respect to the tracer field, such that we can trivially reconstruct the velocity field by using the cell-averaged velocity component that's centered on the location it's needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209:143,interface,interfaces,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209,1,['interface'],['interfaces']
Integrability,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:29,depend,depend,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023,2,['depend'],['depend']
Integrability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:35,depend,dependency,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['depend'],['dependency']
Integrability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:16,depend,depends,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,1,['depend'],['depends']
Integrability,"I think it will be extremely helpful to be able to output boundary conditions and other fields (like fluxes, evaporation, and others) at the ocean interface. Following the discussion from #3081, something on those lines could be implemented, but it ideally it will be nice to have something like `model.boundary_conditions`. ```; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. However it will be great to have something more general to simplify diagnosing simulations, that outputs the relevant boundary condition, in the example will be the `bottom` boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3774:147,interface,interface,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3774,1,['interface'],['interface']
Integrability,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1132:54,interface,interface,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132,5,['interface'],['interface']
Integrability,"I think it'd be cleaner to change `node` so that `Flat` dimensions are omitted. For example, this would mean that on a grid that is flat in `z` (two-dimensional in `x, y`, we would write initial conditions. ```julia; ui(x, y) = # initial u; set!(model, u=ui); ```. Basically, grids that are `Flat` in `z` cannot depend on `z`. So it would be clearer if initial conditions also did not depend on `z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285:312,depend,depend,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285,2,['depend'],['depend']
Integrability,"I think it's good to go. The only thing that doesn't quite make sense to me is why. ```julia; fill_size = fill_halo_size(field, regular_fill_function, indices, boundary_conditions, loc, grid); ```. depends on `regular_fill_function`, since. ```julia; fill_function, regular_fill_function = get_open_halo_filling_functions(loc) ; ```. and `loc` is an argument to both functions. It doesn't seem that from a purely logical point of view we need `regular_fill_function` at all here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293:198,depend,depends,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293,1,['depend'],['depends']
Integrability,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:780,integrat,integrated,780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['integrat'],['integrated']
Integrability,"I think its a fine idea to merge, though it is interesting that the code will still be called `Oceananigans` :-D. I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:276,depend,depend,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['depend'],['depend']
Integrability,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:43,depend,dependency,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426,3,['depend'],['dependency']
Integrability,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:34,Integrat,Integrated,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305,1,['Integrat'],['Integrated']
Integrability,"I think so, either that or we cannot depend on FFTW.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271:37,depend,depend,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271,1,['depend'],['depend']
Integrability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:259,depend,dependency,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,5,"['depend', 'interface']","['dependencies', 'dependency', 'interface']"
Integrability,"I think that name makes sense!. For the light attenuaiton model, I'm not sure how it would work without making it a property of the model? If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up? . I've rewritten it a little bit to make the integration a nothing operation when the user doesn't specify a model but not sure what the best solution might be here. Perhaps we could make it more generic so users can call any kind of update state operation?. But either way, happy for you to fix these issues!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587:319,integrat,integration,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587,1,['integrat'],['integration']
Integrability,"I think the alternative is to build `clock` inside the constructor. In that case users can only change `clock.time` and `clock.iteration` after constructing the model, rather than passing in a custom `Clock` via this kwarg. The choice depends on what features you want to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641:235,depend,depends,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641,1,['depend'],['depends']
Integrability,"I think the difficult part is finding z*; this is what Huang 2005 seems to be discussing. I'm hazy on the details (maybe @hdrake can chime in) but I think the point is that while an adiabatic rearrangement into a stable density profile may exist, it may not be obtainable by a single sorting procedure due to the pressure dependence of the equation of state. Some of the subtleties of the Boussinesq approximation for seawater are discussed in http://pordlabs.ucsd.edu/wryoung/reprintPDFs/SeawaterBoussinesq.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340:322,depend,dependence,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340,1,['depend'],['dependence']
Integrability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:295,interface,interface,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['interface'],['interface']
Integrability,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:83,depend,depends,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,6,['depend'],"['dependencies', 'depends']"
Integrability,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:356,depend,dependencies,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149,2,['depend'],['dependencies']
Integrability,"I think the main issue here is that there is too much code, reflecting the fact that an interface for defining closures has emerged over time rather than being designed from the ground up. It could possibly benefit from a rethink. It's not as much an issue of the names of things in my opinion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507:88,interface,interface,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507,1,['interface'],['interface']
Integrability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:172,depend,depends,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,1,['depend'],['depends']
Integrability,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:27,message,message,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418,1,['message'],['message']
Integrability,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1461,depend,dependencies,1461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['depend'],['dependencies']
Integrability,"I think the size dependence has to do with how `mapreduce` works; it breaks the reduction into chunks and (10, 10, 10) might be just one chunk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482:17,depend,dependence,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482,1,['depend'],['dependence']
Integrability,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:179,depend,dependencies,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['depend'],['dependencies']
Integrability,"I think there's a bit of cleanup to do with the interface to both `Simulation` and `run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1095:48,interface,interface,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095,1,['interface'],['interface']
Integrability,"I think this PR Is becoming too big. I’m thinking to wrap it up here with the ConformalCubedSphere grid plus tracer halo filling, add tests and then open another one to continue on cubed sphere tasks. What do you reckon @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790:53,wrap,wrap,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790,1,['wrap'],['wrap']
Integrability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:385,interface,interfaces,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,1,['interface'],['interfaces']
Integrability,"I think to support inserting `Value` or `Gradient` directly into abstract operations would essentially entail an independent implementation from the current `AbstractOperation`, because while this is certainly feasible on the CPU, I suspect we will run into limitations on the GPU fairly quickly. I think if people are interested in direct numerical simulation in complex domains that would benefit from that kind of thing then this is a worthwhile endeavor and could even be prototyped in an independent repository (magic of Julia). Supporting correct boundary evaluation for non-immersed boundaries is straightforward via rules for filling halo regions. Thus despite the trade-offs, it makes sense to provide such a ""bonus"" feature: it's enabling for quite a few applications without a great cost (at least _yet_, because we don't have a user interface or great support for distributed computations). Support for operations across immersed boundaries is a more complex endeavor. Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Especially due to finite resources for software development, many of our decisions are compromises. We don't aim to be perfect, we aim to be good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897:845,interface,interface,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897,1,['interface'],['interface']
Integrability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:95,rout,route,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,3,"['interface', 'rout']","['interface', 'route']"
Integrability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:182,interface,interface,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['interface'],['interface']
Integrability,"I think we should improve the docstring for `Distributed`:. https://github.com/CliMA/Oceananigans.jl/blob/8f55656812e4ad7968ff37fccdb3bd1974ef393b/src/DistributedComputations/distributed_architectures.jl#L174-L205. A few comments:. * Can we explain ""synchronized communication"" better? This is confusing --- I think it actually has to do with the algorithm a model uses (very far away from building the architecture). We have to explain that this concept is irrelevant unless we are using a model that has an asychronous algorithm. Or otherwise more specifically explain what this means.; * The entry for `devices` is missing a period a the end. In general more explanation of the keyword arguments that is as local to the concept of grids as possible. The docstring makes vague references to ""support for partitioning"". But this refers to models, not grids. It doesn't really make sense in this context. Also we need examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748:250,synchroniz,synchronized,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748,1,['synchroniz'],['synchronized']
Integrability,"I think we want to consider calling `precomputations!(model)` (and perhaps changing its name) _after_ a time-step is complete, rather than before. The reason to do this is that it ensures _all_ fields are _entirely_ up-to-date and synchronized between time-steps. Currently, for example, field halo regions, hydrostatic pressure, and diffusivities are a ""step behind"" model.velocities and model.tracers. This is a problem for some diagnostics; for example, turbulent kinetic energy dissipation cannot be correctly calculated during output. Correct halo regions also cannot be saved. Having the entire model state synced at the end of a time-step is thus important for correct output. There's no extra computational cost to this procedure. However, we will have to execute one special call to `precomputations!(model)` inside `run!(simulation)` to initialize a time-stepping loop. I think this price is worth it. This change will mean that all aspects of the model state are ""untouchable"" between time-steps. In other words, one cannot change halos or the pressure fields at whim. I think this is ok, since this is already true for the majority of the model data (interior parts of the model velocities and tracer fields). This issue is entangled with #1063 since we cannot resolve this issue until we have standard output that does not change a field's halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069:231,synchroniz,synchronized,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069,1,['synchroniz'],['synchronized']
Integrability,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:249,depend,dependencies,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545,1,['depend'],['dependencies']
Integrability,I think wrapping `Base.Broadcast.materialize!` in https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24 around `@apply_regionally` for multi region fields might do the job,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101:8,wrap,wrapping,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101,1,['wrap'],['wrapping']
Integrability,"I think you can define in `ImmerdsedBoundaries`; ```; return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); ```; and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings); ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630:207,depend,depend,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630,1,['depend'],['depend']
Integrability,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:303,Integrat,Integrated,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534,1,['Integrat'],['Integrated']
Integrability,"I thought everything should be synchronized correctly actually. . If you are running on the GPU, the kernels run on a single stream at the moment (we still have to implement asynchronicity), so if you want to synchronize with the CPU you have to call `synchronize(device(arch))`, but that should happen automatically if you have a memory copy from device to host or vice-versa. . On the CPU, the launch is synchronized ; see KernelAbstraction.jl:; (this is the kernel launch wrapped in `@sync`; ``` ; @sync for tid in 1:Nthreads; Threads.@spawn __thread_run(tid, len, rem, obj, ndrange, iterspace, args, dynamic); end; ```; and, therefore `synchronize` does not do much; ```; synchronize(::CPU) = nothing; ```. where do you see this problem? Are you trying to look at GPU quantities from the CPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269:31,synchroniz,synchronized,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269,7,"['synchroniz', 'wrap']","['synchronize', 'synchronized', 'wrapped']"
Integrability,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783,1,['message'],['message']
Integrability,"I tried to run `benchmark_incompressible_model.jl` with advection=WENO5() and the error shown below occurred as it was benchmarking the first GPU case with grid size being 32 x 32 x 32. I'm running all benchmark cases with Float64. Many other error messages of a similar format were also outputted, but this one was the earliest one I can retrieve. My Oceananigans.jl was up to date with the latest merge #1790.; I also tried running it without specifying an advection and it ran fine. @francispoulin is experiencing the same problem. ```; Reason: unsupported use of an undefined name (use of 'pow'); Stacktrace:; [1] overdub; @ C:\Users\henry\.julia\packages\KernelAbstractions\X5hOr\src\backends\cuda.jl:264; [2] right_biased_αz₁(::Int64, ::Int64, ::Int64, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [3] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [4] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:187; [5] right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [6] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [7] _right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\pack",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335:249,message,messages,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335,1,['message'],['messages']
Integrability,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:321,message,message,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,2,"['interface', 'message']","['interface', 'message']"
Integrability,"I tried to update Oceananigans version in ClimaOceanBiogeochemistry as:; ```; Oceananigans v0.92.0 `https://github.com/CliMA/Oceananigans.jl#glw/tuples-with-catke`; ```; Then I ran CATKE together with horizontal closure:; ```; catke = CATKEVerticalDiffusivity(); horizontal_closure = HorizontalScalarDiffusivity(ν=1e3); model = HydrostaticFreeSurfaceModel(; grid,; closure = (catke, horizontal_closure),; ...); ```; It still returns an error message:; `ERROR: type Tuple has no field κe`. Is it indicating the problem is still unresolved, or am I testing in an incorrect way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814:442,message,message,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814,1,['message'],['message']
Integrability,I understand why `FluxBoundaryCondition`s can't be enforced with `closure=nothing` since they depend on a diffusivity. But why can't `Gradient` and `Value` BCs be enforced?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337:94,depend,depend,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337,1,['depend'],['depend']
Integrability,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:224,integrat,integrate,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407,6,['integrat'],"['integrate', 'integration']"
Integrability,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:485,integrat,integrated,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583,2,['integrat'],['integrated']
Integrability,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857,1,['depend'],['depending']
Integrability,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/ep/pcg-with-multigrid/validation/elliptic_solvers/testing_preconditioner.jl)). When the initial guess is all 0s the precondition! method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here ](https://www.netlib.org/templates/templates.pdf)so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2655:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655,1,['depend'],['depending']
Integrability,"I was looking at the errors on `cpu-solver_tests` and found the message below, followed by a bunch of other errors on the lines below. Does someone know why this is failing? I can take a look at it but thought I'd check to see whether this is understood or not. ```; Vertically stretched Poisson solver [FACR, CPU, (Flat, Bounded, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:272;   | Test threw exception;   | Expression: vertically_stretched_poisson_solver_correct_answer(Float64, arch, topo, 8, 8, 1:8);   | ArgumentError: length(size) must be 2.;   | Stacktrace:;   | [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:48;   | [4] VerticallyStretchedRectilinearGrid(::Type{T} where T; architecture::CPU, size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, zF::UnitRange{Int64}, halo::Tuple{Int64,Int64,Int64}, topology::Tuple{DataType,DataType,DataType}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/vertically_stretched_rectilinear_grid.jl:50;   | [5] vertically_stretched_poisson_solver_correct_answer(::Type{T} where T, ::CPU, ::Tuple{DataType,DataType,DataType}, ::Int64, ::Int64, ::UnitRange{Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:140;   | [6] top-level scope at /storage7/buil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114:64,message,message,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114,1,['message'],['message']
Integrability,"I was thinking that it would be a good idea to make an integration with Python's [`xgcm`](https://github.com/xgcm/xgcm) package easier. The project is relatively new but I expect it to grow given that it has [Pangeo](https://pangeo.io/) support. In my mind, this is related to #1313, since the primary (only?) communication with Python is done through NetCDF files. So including some [grid metrics](https://xgcm.readthedocs.io/en/latest/grid_metrics.html) in the NetCDF output would be helpful. For now I'm not exactly sure what needs to be there since their docs [aren't very explanatory in that sense](https://github.com/xgcm/xgcm/issues/291), but it includes distances between `Face`s and `Center`s of the grids and other measures that should be straightforward. Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334:55,integrat,integration,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334,1,['integrat'],['integration']
Integrability,"I went that route before, that would be prohibitive memory-wise also on moderately small grids, especially if you try to do it on 3D settings. You can sparsify the vectors if you want to alleviate it. Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I remember @sandreza had a good trick to calculate a matrix from a linear operation without having to calculate it on all the unit vectors. To sparsify the matrix you can use the utils in matrix_solver_utils.jl because, unfortunately, the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239:12,rout,route,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239,1,['rout'],['route']
Integrability,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:192,depend,depends,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154,2,['depend'],['depends']
Integrability,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1467,interface,interfaces,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708,2,['interface'],['interfaces']
Integrability,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:98,depend,depend,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,2,['depend'],['depend']
Integrability,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:118,Integrat,IntegrateField,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,1,['Integrat'],['IntegrateField']
Integrability,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513:1391,Message,Message,1391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513,1,['Message'],['Message']
Integrability,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:763,interface,interface,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,1,['interface'],['interface']
Integrability,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478:233,message,message,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478,1,['message'],['message']
Integrability,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:673,message,message,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,1,['message'],['message']
Integrability,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:1586,message,message,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971,1,['message'],['message']
Integrability,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:936,depend,dependencies,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['depend'],['dependencies']
Integrability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:114,depend,depend,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['depend'],['depend']
Integrability,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794:1234,depend,depends,1234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794,2,['depend'],"['dependencies', 'depends']"
Integrability,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:453,depend,depending,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947,1,['depend'],['depending']
Integrability,"I'm not sure that this kind of function should be defined for all closures (not all closures even have a diffusivity). If we want to have a more uniform interface, I'd focus on `AbstractScalarDiffusivity` which is specific to closures with a single scalar diffusivity. I think there is already an interface there too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686:153,interface,interface,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686,2,['interface'],['interface']
Integrability,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3825:177,depend,depends,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825,1,['depend'],['depends']
Integrability,I'm okay with the warning message that we have and closing this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436,1,['message'],['message']
Integrability,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:673,interface,interfaces,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,3,['interface'],['interfaces']
Integrability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,2,['interface'],['interface']
Integrability,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:909,interface,interface,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,2,['interface'],['interface']
Integrability,"I'm sort of glad to see @glwagner is verifying the issues we first discussed last year. My 2 cents: . - Small errors in the BC eventually propagating to the whole simulation is unavoidable; this is a well mixed flow. Checking on integrated quantities, such as maintaining conserved properties or matching the expected global dissipation rate, is a more achievable and important goal. ; - Using a test case with some stronger pressure gradients along the boundary would be good as well since this induces much of the error. The circle @wenegrat suggests is the classic, but you might be able to find a more subtle case which is more relevant to your application. Perhaps turbulent flow in a wavy-wall channel? Linking the amplitude of the waves to the change in turbulent statistics seems pretty well aligned with your application (though I could be wrong).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669:229,integrat,integrated,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669,1,['integrat'],['integrated']
Integrability,"I'm still trying to figure out exactly how to go from cell value to cell-averaged value and back again. The forward approach is the quadrature scheme that we use to integrate on our cells. The backwards approach is the reconstructor. The standard choices that I've seen are to assume that the function is constant, linear and parabolic on each cell. If it's constant then the two coincide and there is nothing to worry about, but I presume this yields a lower order of accuracy. ; On top of what , we then have another choice on how to choose the flux based on the advection scheme. . Can you help me figure out what we are using as a reconstruction?. Everything else you suggest sounds good to me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864:165,integrat,integrate,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864,1,['integrat'],['integrate']
Integrability,"I'm thinking maybe that we should not allow `BasicBiogeochemistry` to have an update state or update tracers function. This will help enforce the notion that this object is really for ""truly basic"" situations; for more advanced functioality people need to use the lower level interface (which will produce much more reusable and modular code, so is very much in our interest).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213:276,interface,interface,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213,1,['interface'],['interface']
Integrability,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:19,integrat,integration,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590,1,['integrat'],['integration']
Integrability,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:359,rout,routine,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,5,['rout'],['routine']
Integrability,"I'm trying to integrate a scalar in time (the scalar itself being a volume-integrated `Field`). Pretty much what's being done here: https://github.com/tomchor/Oceanostics.jl/blob/main/test/test_budgets.jl. I can probably come up with a way to do it without auxiliary fields. I just assumed `auxiliary_fields` could also be scalars since fields is written as ""fields"" in the docs, rather than ""`Fields`"". (Although I'm not sure what you mean by a ""parameter"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696:14,integrat,integrate,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696,2,['integrat'],"['integrate', 'integrated']"
Integrability,"I'm trying to understand how advection schemes are constructed, and I see that you can pass a float type `FT` and a `grid` to the constructors. Makes perfect sense that a scheme could depend on `FT` to store any coefficients using the correct data type. It also makes perfect sense for a scheme to depend on `grid` if the coefficients vary spatially. But some constructors take both. For example, `Centered` takes both but doesn't really use the `grid`. It only uses the `grid` , if passed, to overwrite `FT`. Well, looks like `compute_reconstruction_coefficients` is commented out. https://github.com/CliMA/Oceananigans.jl/blob/82099ac50cfd7cd270c2f311b3e9d22c0585735f/src/Advection/centered_reconstruction.jl#L39-L59. Whereas `WENO` uses the `grid` to compute reconstruction coefficients:. https://github.com/CliMA/Oceananigans.jl/blob/82099ac50cfd7cd270c2f311b3e9d22c0585735f/src/Advection/weno_reconstruction.jl#L96-L119. ---. In both cases `grid` is an optional argument. But won't the advection scheme be wrong if `grid` is not passed then? If so, then shouldn't advection schemes just depend on the `grid` (which can be used to infer `FT`)?. I know some interfaces take `FT` while others take `grid` (X-Ref: https://github.com/CliMA/Oceananigans.jl/issues/3800) so I'm not sure of the right approach here, but it seems like some advection schemes actually depend on the grid spacings. X-Ref: https://github.com/CliMA/Oceananigans.jl/issues/3703",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857:184,depend,depend,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857,5,"['depend', 'interface']","['depend', 'interfaces']"
Integrability,"I'm wondering if it might be a bit much to put docstrings on every single `AbstractGridMetric` for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like `IntegratedField` down the line). But I can copy paste the PR comment into the docstring for \Delta z as an example. Note that `GridMetricOperation` is used internally only, it's really the instances `\Delta z`, etc that are meant to be combined in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063:233,Integrat,IntegratedField,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063,1,['Integrat'],['IntegratedField']
Integrability,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:246,depend,depends,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,2,['depend'],['depends']
Integrability,I've added `TracerBasedBiogeochemistry` and an example both using and not using it and they both seem to work now:; ![npd_example](https://user-images.githubusercontent.com/26657828/201384805-32bd6dfe-8838-44c8-a838-e3b841845812.png); I am slightly concerned with how I've setup the forcing for `TracerBasedBiogeochemistry` because I assume the weird stuff going on with the interpolation stuff in `ContinuousForcing` is there for a reason (and we can't use the normal continuous forcing stuff because it relies on the index of the tracer which we don't have as the model isn't finished when we setup the biogeochemical model). I'll have a go at adding an example with PAR integration to check its straightforward to add to a model later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054:673,integrat,integration,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054,1,['integrat'],['integration']
Integrability,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:834,depend,depend,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,1,['depend'],['depend']
Integrability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:106,integrat,integrate,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['integrat'],['integrate']
Integrability,"I've been trying different open boundaries and have found that making $U_b$ the mean cross boundary velocity seems to be more stable in some cases (I think when estimating it can vary rapidly when the flow switches from out to in which causes problems). From this review https://doi.org/10.1002/fld.1650181006 it seems like for the normal velocity component it is actually common to user specify $U_b$ by hand to make it stable for a particular simulation, or to make it the mean boundary velocity which they say is stable until ~30% of the flow is inflow. . The other advantage of these schemes is they don't depend on the tendencies so will be more straight forward to setup. They also suggest that just setting the gradient to zero on the boundary is fine for the other tracers/velocity components which does seem to end up with similar results. Given the illposedness of all of these solutions for the normal velocity component it seems like it might be better if we didn't commit to a particular formulation. I'm not sure what the best user interface for this might be but it might be easiest to just not call any `OpenBoundaryCondition` and instead e.g. `MeanChannelOutflowBoundaryCondition`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795:610,depend,depend,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:194,depend,depending,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,1,['depend'],['depending']
Integrability,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529,6,['interface'],['interface']
Integrability,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:912,depend,dependant,912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,4,['depend'],['dependant']
Integrability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:453,depend,dependence,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,8,"['depend', 'integrat', 'interface']","['dependence', 'integrated', 'integrating', 'interface']"
Integrability,"I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?. For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885:190,depend,dependant,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885,1,['depend'],['dependant']
Integrability,I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C. . Does anyone working on Oceananigans have experience doing that sort of thing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954:30,wrap,wrap,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954,1,['wrap'],['wrap']
Integrability,"I've played more with this now and think the way we can do this with the minimum code changes is as follows. The only other way I can see is for the boundary to store the previous timestep of the boundary adjacent points but since Fields depends on BoundaryConditions that isn't really possible. The key problem really is that previous solutions to this problem have been written in codes that store at least two time levels which we don't have. So, if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a quest",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:238,depend,depends,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['depend'],['depends']
Integrability,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:456,integrat,integrate,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,5,['integrat'],"['integrate', 'integration']"
Integrability,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371:719,depend,depend,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371,2,['depend'],['depend']
Integrability,"Ideally the user would just define an element-wise function `closure(..., i, j, k)` that gets passed to the model and is added to the velocity or tracer source terms, acting as a forcing term in the momentum and tracer advection equations. Defining an element-wise function will allow the function to be injected into CPU and GPU kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73:304,inject,injected,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73,1,['inject'],['injected']
Integrability,"If it's urgent, I suggest creating a new branch that merges master and whatever other branch has an important feature and depending on that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004,1,['depend'],['depending']
Integrability,If this will be important then we should streamline the user interface for changing to Float32. Ideally everything should take `eltype` from the grid I think without requiring tons of manual intervention.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856:61,interface,interface,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856,1,['interface'],['interface']
Integrability,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:913,rout,routines,913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,1,['rout'],['routines']
Integrability,"If we check after the coordinate is created, we may only need to check once (the check is the same for all user input and the message is the same: the coordinate must be increasing)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882:126,message,message,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882,1,['message'],['message']
Integrability,If we use `\nabla \cdot (\nu h \nabla u)` then the dissipation term is ` - \nu h | nabla u |^2`. This is accepted and has the nice property that the dissipation depends on the depth. If we use `\nabla \cdot (\nu \nabla u)` then we don't have the right units as we are evolving `h u`. . `\nabla \cdot (\nu \nabla (h u) )` does not give you a negative definite form as you would get ` - \nu \nabla u \nabla (hu)`.; P.S. How do you include latex here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835:161,depend,depends,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835,1,['depend'],['depends']
Integrability,"If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1744,Depend,Dependent,1744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['Depend'],['Dependent']
Integrability,"If you want to integrate with the Julia ""progress bar"" system, you could put in something like:; ```julia; @debug ""this is a short description of my loop"" progress=iteration/length_of_loop; ```. This works in Juno, and with MicroLogging.jl in the REPL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872:15,integrat,integrate,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872,1,['integrat'],['integrate']
Integrability,Implement interface for `set!` and use it to `set!` distributed fields better,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3817:10,interface,interface,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3817,1,['interface'],['interface']
Integrability,Implementation of the scale-dependent Lagrangian-averaged dynamic Smagorinsky,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638:28,depend,dependent,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638,1,['depend'],['dependent']
Integrability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:515,interface,interface,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,1,['interface'],['interface']
Integrability,"In some way this comes back to the fundamental question of: What is the point of KernelAbstractions CPU support. I originally intended it only for making debugging easier... But folks seem to be depending on it as a performance solution... I think it is feasible to get there, but it would require quite a bit of time and effort",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331:195,depend,depending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331,1,['depend'],['depending']
Integrability,"In the [Bickley jet example](https://clima.github.io/OceananigansDocumentation/dev/generated/Bickley_jet_shallow_water/), where we run the simulation we get the message:; ```julia; [ Info: Simulation is stopping. Model time 2.500 minutes has hit or exceeded simulation stop time 2.500 minutes.; ```; This is because we construct the simulation; ```julia; Simulation(model, Δt = 1e-2, stop_time = 150); ```; it's assumed that 150 is 150 seconds. That could be a bit confusing. Is there is a way to tell the `Simulation` constructor that our units are nondimensional? Should we have such option?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1462:161,message,message,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1462,1,['message'],['message']
Integrability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:567,interface,interface,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"In this PR some structures are refractored such that; - all grids depend on the architecture; - the models takes only the grid as an input. To do so, the architecture is now a positional argument of the grid constructor (so it can be extended by `MultiArch`) as @glwagner suggested. The flow of the script will be something like this now:; ```; arch = ...; grid = Grid(arch, FT; kwargs...); model = NonhydrostaticModel(grid = grid, kwargs...); ```; Some comments on the `MultiArch` architecture...; - `MultiArch` has now a `child_architecture ` field specified on construction; - `MultiArch` still depends on a topology, so, a way to go about it it is to first define a topology and then ; `arch = MultiArch(CPU(), ranks=ranks, topology=topology); grid = (arch, topology=topology, kwargs...)` or to define an architecture without topology and then pass it to the grid. Take care that in this second case it is not guaranteed that `arch == grid.architecture` as the architecture in the grid is constructed from `topology(grid)`; - the grid constructed by `grid(arch::MultiArch; kwargs...)` will be a local grid. To reconstruct the global grid use `reconstruct_global_grid(grid)`. To do; - as of now a field, given `grid(arch::MultiArch; kwargs...)` as an argument, is constructed locally, which is no problem if you `set!` a field from a function but will create problems if you want to `set!` from a global array; - Explore new FFT options to allow more flexibility in the distributed NonhydrostaticModel; - allow GPU halo_passing to support `MultiArch(GPU(); kwargs...)`. Closes #2073 ; Closes #1825",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2078:66,depend,depend,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2078,2,['depend'],"['depend', 'depends']"
Integrability,"In this example the sponge on the inflow probably isn't necessary, but for more complicated inflows, it probably is needed.  Probably not a bad thing to keep it in the example, but I don’t have a strong view either way. On Mar 28, 2024, at 12:01 PM, Jago Strong-Wright ***@***.***> wrote:﻿. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?. You are probably right it shouldn't be necessary here!. —Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925:662,Message,Message,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925,1,['Message'],['Message']
Integrability,Includes at the module level cannot have circular dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/69:50,depend,dependencies,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/69,1,['depend'],['dependencies']
Integrability,Inconsistency in output writers interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884:32,interface,interface,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884,1,['interface'],['interface']
Integrability,"Indeed, I don't think drag is so relevant physically for this problem but it should demonstrate the interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607,1,['interface'],['interface']
Integrability,Informative error message for non-regularly spaced grids in `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2946:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946,1,['message'],['message']
Integrability,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390:205,message,messages,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390,2,['message'],['messages']
Integrability,"Instead of having us manually print a progress statement in a `while` loop, maybe we can pass a `progress_message(model)` function to `time_step!` that does this. This should help clean up the scripts a lot, and we could provide a couple of reasonable defaults instead of setting up this functionality in every script. Eventually the `progress_message(model)` function can be made fancy as we wish with unicode plots, a curses interface for complex progress output, or even email updates.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432:427,interface,interface,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432,1,['interface'],['interface']
Integrability,"Integer, [-1,268]:Integer, [-1,269]:Integer, [-1,270]:Integer, [-1,271]:Integer, [-1,272]:Float@double, [-1,280]:Float@double, [-1,288]:Float@double, [-1,296]:Float@double, [-1,304]:Integer, [-1,305]:Integer, [-1,306]:Integer, [-1,307]:Integer, [-1,308]:Integer, [-1,309]:Integer, [-1,310]:Integer, [-1,311]:Integer, [-1,312]:Integer, [-1,313]:Integer, [-1,314]:Integer, [-1,315]:Integer, [-1,316]:Integer, [-1,317]:Integer, [-1,318]:Integer, [-1,319]:Integer, [-1,320]:Integer, [-1,321]:Integer, [-1,322]:Integer, [-1,323]:Integer, [-1,324]:Integer, [-1,325]:Integer, [-1,326]:Integer, [-1,327]:Integer, [-1,328]:Float@double, [-1,336]:Float@double, [-1,344]:Float@double, [-1,352]:Float@double, [-1,360]:Float@double, [-1,368]:Float@double, [-1,376]:Integer, [-1,377]:Integer, [-1,378]:Integer, [-1,379]:Integer, [-1,380]:Integer, [-1,381]:Integer, [-1,382]:Integer, [-1,383]:Integer, [-1,384]:Integer, [-1,385]:Integer, [-1,386]:Integer, [-1,387]:Integer, [-1,388]:Inte...; ```. Farther down the error message says:. ```; Cannot deduce type of insertvalue ins %138 = insertvalue { { i64, i64, i64, i64, i64, i64, double, double, double, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] } }, { {} addrspace(10)*, [3 x i64] }, {} addrspace(10)* } %134, { {} addrspace(10)*, [3 x i64] } %unbox2.i.unpack286435, 1, !dbg !20 size: 32 TT: {}. Caused by:; Stacktrace:; [1] #60; @ ./tuple.jl:461; [2] afoldl; @ ./operators.jl:545; [3] filter_rec; @ ./tuple.jl:461; [4] filter; @ ./tuple.jl:464; [5] filter; @ ./tuple.jl:0; within MethodInstance for filter(::Oceananigans.Fields.var""#87#91"", ::Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Period",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:10495,message,message,10495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['message'],['message']
Integrability,Integrate LES functionality,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309,1,['Integrat'],['Integrate']
Integrability,Integrate finite volume operators,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['Integrat'],['Integrate']
Integrability,Integrate opening and closing of Netcdf outputwriters in simulation loop,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/650:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/650,1,['Integrat'],['Integrate']
Integrability,Integrating Oceananigans with Python-xgcm,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334:0,Integrat,Integrating,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334,1,['Integrat'],['Integrating']
Integrability,"Interesting that this works. in the `ShallowWaterModel` we define our functions to be `(x,y,z)` because that's what I thought we had to do. But this example above suggests that in the spherical case we can define `(x,y)`. Does this mean we might be able to define functions in `ShallowWaterModel` that don't depend on `z`, or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676:308,depend,depend,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676,1,['depend'],['depend']
Integrability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:128,depend,depend,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['depend'],['depend']
Integrability,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069:332,depend,dependence,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069,2,['depend'],['dependence']
Integrability,Interesting. I noticed that there were some unnecessary test dependencies and removed those. That seems to have helped.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042:61,depend,dependencies,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042,1,['depend'],['dependencies']
Integrability,Interface for allocating the prognostic fields and diagnostic fields at the same time,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509:0,Interface,Interface,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509,1,['Interface'],['Interface']
Integrability,Interface for closures (and other model terms) that introduce auxiliary prognostic variables,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:0,Interface,Interface,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['Interface'],['Interface']
Integrability,Interface to build and output boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3774:0,Interface,Interface,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3774,1,['Interface'],['Interface']
Integrability,Introduce closure_constant interface for AMD and SmagorinskyLilly,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370:27,interface,interface,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370,1,['interface'],['interface']
Integrability,"Is it so hard to update the validation scripts too? Hopefully that should be easy and it doesn't really matter what you do first. We use the validation scripts to test the user interface. You'll be changing them no matter what, in either case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357:177,interface,interface,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357,1,['interface'],['interface']
Integrability,Is that message going to display _every_ time a model is created?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239,1,['message'],['message']
Integrability,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680,2,['interface'],['interface']
Integrability,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343:50,integrat,integration,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343,2,['integrat'],['integration']
Integrability,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447:769,message,messages,769,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447,1,['message'],['messages']
Integrability,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:3,depend,depends,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['depend'],['depends']
Integrability,"It just helps to ensure that the discrete continuity equation (and thus discrete conservation of mass) is handled correctly. It's possible that it's not necessary (but it's the reason that the vertically integrated lateral face areas pop up in the numerics). Here are some notes:. <img width=""955"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165295054-4f3205c2-bf71-46b2-947a-b1c23241328e.png"">. <img width=""954"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165296417-38c25dde-5636-40c0-8ed3-6059f9f95740.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687:204,integrat,integrated,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687,1,['integrat'],['integrated']
Integrability,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:87,message,message,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678,1,['message'],['message']
Integrability,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:456,depend,dependence,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953,1,['depend'],['dependence']
Integrability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:212,wrap,wrapping,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,1,['wrap'],['wrapping']
Integrability,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:34,interface,interface,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775,2,['interface'],"['interface', 'interfaces']"
Integrability,"It might be pretty nice to support syntax like `interior(f::AbstractField, i, j, k)` that returns `view(parent(f), i′, j′, k′)`, where `i′, j′, k′` are offset to account for the halo regions. One reason this is useful is because `view(f.data, i, j, k)` is a _doubly-wrapped_ array (it's a view of an `OffsetArray`, which is wrapped around either `Array` or `CuArray`) and therefore cannot be used in broadcasting, reductions, etc on the GPU. cc @mukund-gupta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1647:324,wrap,wrapped,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1647,1,['wrap'],['wrapped']
Integrability,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:271,interface,interfaces,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071,2,['interface'],['interfaces']
Integrability,"It seems reasonable to add `architecture` to `AbstractField`. I think we actually might need this to make `AbstractOperations` work generically on distributed systems (in particular, `AbstractOperations` that depend on `Field`s or `ComputedField`s).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709:209,depend,depend,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709,1,['depend'],['depend']
Integrability,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366,1,['message'],['message']
Integrability,"It seems we have designed the solver interface (ie, the function signature to `precondition!`) to include the guess / solution at the current iteration. This does seem useful for some preconditioners, right? Eg, if the preconditioner is an asymptotic solution that depends on the current guess, this may be useful. I think. It's not necessary for the _specific_ case of the diagnoally dominant preconditioner though -- I agree with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:499,Depend,Depending,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['Depend'],['Depending']
Integrability,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958:233,wrap,wrapped,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958,1,['wrap'],['wrapped']
Integrability,It'd be easy as an intermediate step to discontinue GPU support only I suppose. Depends how much we want to simplify the code... Also this is a reason not to eliminate `LatitudeLongitudeGrid` because it seems like it will always have fewer parameters than `OrthogonalSphericalShellGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031:80,Depend,Depends,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031,1,['Depend'],['Depends']
Integrability,"It'd be nice to implement the 'Orlanski' boundary condition for open boundaries:. https://www.sciencedirect.com/science/article/pii/0021999183901274. For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. This would allow us to simulate the spatial development of a boundary layer, a la . https://iopscience.iop.org/article/10.1088/1742-6596/318/2/022023/meta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833:232,depend,dependent,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833,1,['depend'],['dependent']
Integrability,"It'll probably need to store N arrays under the hood where N is the number of faces. Right now we use 6 faces but if you're doing cubed sphere + MPI you might end up doing 1 < N < 6 faces on each rank. Otherwise I think the abstraction should enable users to use the cubed sphere grid like they would any other grid. So things like `set!` should just work. Right now it's more about making sure the backend all works with `CubedSphereData` then a nice user interface can be built on top of it. There are some decisions to make like should `interior(::Field{..., <:CubedSphereData})` return a 4D array? But we can decide on those as they come up. It'll be nice if the output writers knew how to write `CubedSphereData` to disk, although this can come later and many users may want the fields interpolated onto a regular lat-lon grid which is a different discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379,1,['interface'],['interface']
Integrability,It's also always preferred to use a function (which represents a user interface) rather than directly referencing a `struct` implementation (eg referencing `.name.wrapper`) that's subject to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790:70,interface,interface,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"It's also worth noting that right now many calculations are done more than once in each timestep. For example for each component of $M_{ij}$ I'm calculating the whole strain rate tensor modulus in addition to the strain rate tensor component needed:. https://github.com/CliMA/Oceananigans.jl/blob/25cc34e6c395e210e0aecf8181919c25435d7919/src/TurbulenceClosures/turbulence_closure_implementations/scale_invariant_smagorinsky.jl#L241-L257. This is done for legibility of the code, but it may be necessary to forfeit that in favor of doing fewer calculations. (Also note that I'm using a weird way to define function names here, so lmk if you guys think I should change it.). Another thing to note that it's common to update dynamic Smagorinsky coefficients once every 5 or so time-steps only, since they can be pretty expensive. afaik this is generally done for the scale-dependent versions, which have two test filters instead of the one needed in this PR, but I wouldn't be surprised if it's occasionally necessary for the scale-invariant versions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403:870,depend,dependent,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403,1,['depend'],['dependent']
Integrability,"It's annoying to constantly write things like `Face` and `Cell` in Oceananigans scripts. I wonder if we can develop some notation that allows this to be avoided in the vast majority of use cases. We can introduce notation `:u`, `:v`, `:w`, and `:c` to indicate the velocities and tracer locations. Thus we could write. ```julia; x = xnodes(:c, grid); ```. to get `x` at tracer points. Or to build a tracer field,. ```julia; c = Field(:c, GPU(), grid); ```. Note that we currently require. ```julia; c = Field(Cell, Cell, Cell, GPU(), grid); ```. (a side note is that the `grid` should probably come before the `arch`, but that's another issue.). An alternate design would use the function `location`. Right now this is defined. ```julia; location(::AbstractField{X, Y, Z}) where {X, Y, Z} = (X, Y, Z) # note no instantiation; ```. We could define a couple new methods that allow something like. ```julia; x = xnodes(location(:c), grid); ```. for example. I suppose this is the quickest route to the functionality I'm proposing, since we'd have to change almost no existing code. I also wonder if this would allow. ```julia; momentum_flux = @at(location(:w), w * c); ```. That doesn't seem very easy to read so maybe we can discuss how to specify the location of abstract operations transparently.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/766:986,rout,route,986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/766,1,['rout'],['route']
Integrability,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075:1298,interface,interfaces,1298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075,2,['interface'],['interfaces']
Integrability,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:66,wrap,wrapped,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,2,['wrap'],['wrapped']
Integrability,"It's because the two fields use the same data:. ```julia; u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); ```. therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269:265,depend,dependent,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269,1,['depend'],['dependent']
Integrability,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:819,wrap,wrappers,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,2,"['Integrat', 'wrap']","['Integrated', 'wrappers']"
Integrability,"It's frustrating to encounter PyCall issues (as @sandreza and @qwert2266 already have) and it puts an extra burden on CI pipelines, so we should remove the SymPy dependency for now while the generated `WENO{N}` schemes are experimental.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/990:162,depend,dependency,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990,1,['depend'],['dependency']
Integrability,"It's not the geometry that allows a two-argument function, it's because the free surface in `HydrostaticFreeSurfaceModel` is a `ReducedField`. `set!` with a function now uses `FunctionField` and then broadcasting:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/set!.jl#L29-L33. and `FunctionField` at reduced locations are now called with reduced arguments:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L60-L62. where `call_func` is invoked in `getindex` for `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L64-L65. which in turn uses `node`. The length of the tuple return by `node` depends on how many locations are `Nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Grids/grid_utils.jl#L158-L168. @francispoulin what is the vertical location of fields in `ShallowWaterModel`? I think if you use `Nothing` for vertical location, you'll obtain this behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622:794,depend,depends,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622,1,['depend'],['depends']
Integrability,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:144,wrap,wrapped,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706,2,['wrap'],['wrapped']
Integrability,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:352,message,message,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017,2,"['depend', 'message']","['depends', 'message']"
Integrability,It's time to update some dependencies :),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2966:25,depend,dependencies,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2966,1,['depend'],['dependencies']
Integrability,It's very little coding work! Most of the work is designing the interface. That's true we don't use `tracer_fields`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978,1,['interface'],['interface']
Integrability,It's very plausible that it depends on CUDA and also Julia version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135,1,['depend'],['depends']
Integrability,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:191,depend,depending,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"Joes PR adding integration tests (which now passes and we should merge, if you can review), I think needs 12 to pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514:15,integrat,integration,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514,1,['integrat'],['integration']
Integrability,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:129,interface,interface,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302,1,['interface'],['interface']
Integrability,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:897,Message,Message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118,1,['Message'],['Message']
Integrability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:709,depend,depends,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,2,['depend'],"['dependent', 'depends']"
Integrability,"Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; ```; Updating `~/git/Oceananigans.jl/Project.toml`; [de688a37] + BitInformation v0.6.1; Updating `~/git/Oceananigans.jl/Manifest.toml`; [66dad0bd] + AliasTables v1.1.2; [de688a37] + BitInformation v0.6.1; [49dc2e85] + Calculus v0.5.1; [31c24e10] + Distributions v0.25.108; [fa6b7ba4] + DualNumbers v0.6.8; [1a297f60] + FillArrays v1.11.0; [34004b35] + HypergeometricFunctions v0.3.23; [77ba4419] + NaNMath v1.0.2; [90014a1f] + PDMats v0.11.31; [1fd47b50] + QuadGK v2.9.4; [79098fc4] + Rmath v0.7.1; [2913bbd2] + StatsBase v0.34.3; [4c63d2b9] + StatsFuns v1.3.1; [f50d1b31] + Rmath_jll v0.4.0+0; ```; also why is the Manifest.toml committed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873:54,depend,dependency,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873,1,['depend'],['dependency']
Integrability,Just bumping version 0.29 that adds the TEOS-10 equation of state so LESbrary.jl can depend on it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/738:85,depend,depend,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/738,1,['depend'],['depend']
Integrability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:621,rout,routinely,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['rout'],['routinely']
Integrability,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:60,message,message,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,"['message', 'rout']","['message', 'routine']"
Integrability,"Just opened a PR with this, we can discuss what's the best approach. > Would users still have to define all three for two-dimensional domains?. Ideally no. I can modify `RegularCartesianGrid` to take this into account. > I understand the benefit in terms of being explicit, but I'm worried there are a lot of use cases in which the origin of the domain is simply unimportant, and the only relevant parameter is the domain extent. The legacy constructor `RegularCartesianGrid(N, L)` can still be used in this case. > Is there any concern about confusion between specifying the domain in terms of bounding cell faces versus cell centers?. I don't think so. When specifying the domain size, you are in effect specifying the location of the first and last face. All cell centers are located strictly between the first and last cell interface. I don't think it makes sense to specify the domain via the cell centers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091:828,interface,interface,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091,1,['interface'],['interface']
Integrability,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:560,wrap,wrapping,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['wrap'],['wrapping']
Integrability,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583,2,['integrat'],['integrate']
Integrability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:217,wrap,wrapper,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,2,['wrap'],"['wrapper', 'wrappers']"
Integrability,Just to clarify that the output was expected (z^aac is an OffsetArray that includes halo points). But I agree a warning would be nice if the length of a coordinate's interfaces does not match the requested cells + 1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496:166,interface,interfaces,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496,1,['interface'],['interfaces']
Integrability,"Just to follow on from what @francispoulin wrote, we normally use MPI_Init() at the start and MPI_Finalize() at the end. All code that calls MPI needs to be between these statements. To your question about whether you can call MPI_Init() within MultiArch (or MultiArchitecture), I think the question is whether it would ever be useful to use an MPI routines before calling MultiArch. For example, you can't find out the local rank until you call MPI_Init(). Also, it is good practice to use both MPI_Init() and MPI_Finalize(), so if MPI_Init() is in MultiArch, it leaves the question of where MPI_Finalize() should be. This might be an argument for having them both outside of MultiArch where they are visible to the user.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676:349,rout,routines,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676,1,['rout'],['routines']
Integrability,"Just want to confirm some final steps with @navidcy and @glwagner here to wrap up this PR. At the moment, I believe we just need to put in a method that throws an error for `validate_free_surface` when the architecture is the AMD GPU and the free surface type is implicit free surface. I'm working on putting this in through the extensions (I believe this is the correct spot) and testing this out. Is there anything else, you want to see to get this merged into main ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656:74,wrap,wrap,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656,1,['wrap'],['wrap']
Integrability,KS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS m,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2490,rout,routine,2490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:65,depend,depends,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,1,['depend'],['depends']
Integrability,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234:375,interface,interface,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234,1,['interface'],['interface']
Integrability,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3755,message,message,3755,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['message'],['message']
Integrability,"L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function names. What do you think of renaming function names like `∇_κ_∇c` to `div_κ_∇c`?. 7. `▶` is used in a lot of places in the `AbstractOperators` module. They should probably be changed to `ℑ` for consistency, but since it's all local to AbstractOperators, I'm leave the decision to @glwagner. Some changes we need to make for vertically stretched grids:; * I initially thought that we might need `apply_z_top_bc!` and `apply_z_bottom_bc!` to use ΔzC or ΔzF based on the field, but this would only apply to `w` for which you cannot use flux boundary conditions for z, so maybe it can always just use ΔzF (spacing between faces) and we can keep the one version.; * Same comment as above for `_fill_top_halo!` and `_fill_bottom_halo!`. I'll release v0.16 once this is merged as JULES.jl depends on these finite volume operators.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:2894,depend,depends,2894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['depend'],['depends']
Integrability,Latitudinal dependence for Coriolis parameter,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/201:12,depend,dependence,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/201,1,['depend'],['dependence']
Integrability,Let's regularize the advection schemes in the model constructor and compute grid-dependent parts there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055:81,depend,dependent,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055,1,['depend'],['dependent']
Integrability,"Let's start here with documentation: a three letter superscript indicates the _location_ at which a function or object is defined. There is one letter for each direction x, y, z, in that order. And there are three locations:. * `ᶠ`: stands for ""face"" or ""interface"" with respect to a tracer cell.; * `ᶜ`: stands for ""center"" with respect to a tracer cell; * `ᵃ`: stands for ""any"", which means the operator / object is valid at either faces or interfaces. For example, the x-velocity `u` is located at `Face, Center, Center`. So the grid area (with `x`-normal) defined at `u` locations is `Axᶠᶜᶜ`. Another example is `Δyᶠᶜᵃ`, which is the _grid spacing in y_ defined at `Face, Center, Any`. Such a grid spacing arises in grids that are vertically rectilinear but horizontally-curvilinear (eg a horizontally-curvilinear that is extruded in the `z` direction). A spacing like `Δyᶠᶜᵃ(i, j, k, grid)` returns the distance from the cell center north of the `y`-node at `Face, Center, Any`, to the cell center south of the `y`-node at `Face, Center, Any`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537:255,interface,interface,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537,2,['interface'],"['interface', 'interfaces']"
Integrability,"Let's try to deal with #3238. There are some glitches with the interface that, e.g., @djlikesdjs and @siddharthabishnu have been stumbling upon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615:63,interface,interface,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615,1,['interface'],['interface']
Integrability,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:1634,depend,depending,1634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,2,"['Bridg', 'depend']","['Bridge', 'depending']"
Integrability,"Looking at the code for `DistributedIncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L8-L36. suggests to me that it's important to include `architecture` when constructing `grid`, even for grids that are _device_ independent. Specifically, our `architecture` object combines information about the memory layout and the device that's used for computation (CPU or GPU). `RegularRectilinearGrid` is _device_ independent, but, apparently, is in practice not `architecture` in dependent (because we need to restrict ourselves to knowledge of just a ""local"" grid for local computations). One complication is that, apparently, the pressure solver requires the global grid:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L40-L41. We'll have to look into that in more detail to understand what needs to be done for that, and for other solvers like the `PreconditionedConjugateGradientSolver`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796:585,depend,dependent,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796,1,['depend'],['dependent']
Integrability,"Looking at this PR, I think we should make a few structural changes:; * Move `AbstractSchedule` to `Simulations`. This is where it belongs? (not `Utils`); * Make schedules a function of `Simulation`, not `model`. I don't think users really care --- it's just more logical I think this way. It's about homogenizing the Simulation/AbstractModel interface I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799:343,interface,interface,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799,1,['interface'],['interface']
Integrability,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:100,integrat,integration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292,1,['integrat'],['integration']
Integrability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:18,interface,interface,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['interface'],['interface']
Integrability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:96,depend,dependency,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,1,['depend'],['dependency']
Integrability,"Main motivation here is to make it possible to move CUDA with Julia 1.9 to a optional dependency,; making loading faster for non GPU workloads as well as making it easier for other GPU backends to be added. Package extensions is a backwards compatible 1.9 feature, in 1.8 and prior we still have to load CUDA.jl by default; but on 1.9 this is no longer required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3066:86,depend,dependency,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3066,1,['depend'],['dependency']
Integrability,Make broadcasting depend on CUDA default stream,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1803:18,depend,depend,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1803,1,['depend'],['depend']
Integrability,Make error messages for grid generation more uniform,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333:11,message,messages,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333,1,['message'],['messages']
Integrability,"Maybe just to help you could explain the reason why `Models` should depend on `Distributed`?. In reality I think models shouldn't know anything about `architecture`. I think ideally we write architecture-agnostic code, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129:68,depend,depend,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129,1,['depend'],['depend']
Integrability,"Maybe the following papers might interest you. We implemented an ALE type of grid but where the regridding is wrapped into the definition of the ""vertical"" velocity (actually velocity relative to the moving grid). In this way it is very ""easy"" to keep conservation valid and if desired be close to isopycnal calculations (keeping w small). https://orbi.uliege.be/handle/2268/4295; https://orbi.uliege.be/handle/2268/8322; https://orbi.uliege.be/handle/2268/92087",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324,1,['wrap'],['wrapped']
Integrability,Mid-Level Enzyme + Oceananigans Integration Test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3346:32,Integrat,Integration,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346,1,['Integrat'],['Integration']
Integrability,Might make sense to include a diffusive term too? The second-order fluxes are crucial and usually mediate how boundary conditions are prescribed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564:98,mediat,mediate,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564,1,['mediat'],['mediate']
Integrability,Mixing data types and instantiated types in the user interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1119:53,interface,interface,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119,1,['interface'],['interface']
Integrability,Modular and unified user interface for advection schemes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454:25,interface,interface,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454,1,['interface'],['interface']
Integrability,More friendly error messages when types are passed to `Model` instead of objects,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:20,message,messages,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,1,['message'],['messages']
Integrability,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:66,interface,interface,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722,1,['interface'],['interface']
Integrability,More informative message when user provides smaller halo size than ImmersedBoundraryGrid requires,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2984:17,message,message,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2984,1,['message'],['message']
Integrability,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1119:819,interface,interface,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119,1,['interface'],['interface']
Integrability,More streamlined interface for boundary functions?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769:17,interface,interface,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769,1,['interface'],['interface']
Integrability,Move CATKE diffusivities to vertical cell interfaces,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449:42,interface,interfaces,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449,1,['interface'],['interfaces']
Integrability,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:487,interface,interface,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028,4,['interface'],['interface']
Integrability,"My mistake, we can remove this dependency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898:31,depend,dependency,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898,1,['depend'],['dependency']
Integrability,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:339,message,message,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645,1,['message'],['message']
Integrability,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:447,integrat,integrating,447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,2,['integrat'],['integrating']
Integrability,"New forcing function interface, defaults, and functionality",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:21,interface,interface,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['interface'],['interface']
Integrability,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:213,integrat,integration,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720,1,['integrat'],['integration']
Integrability,"Nice! We usually use \nu for viscosity and \kappa for diffusivity --- so should we use \kappa here? You can allow it to depend on x, y, z by writing \nabla \cdot (\kappa \nabla c) without loss of generality (it's also nice to see the divergence operator show up twice I think). Thanks for putting this together...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919:120,depend,depend,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919,1,['depend'],['depend']
Integrability,No need for explicit dependence on ArrayInterface.jl anymore,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1674:21,depend,dependence,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1674,1,['depend'],['dependence']
Integrability,"No worries @jagoosw ! This is a neat application!. It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804:355,rout,routine,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804,1,['rout'],['routine']
Integrability,"Normalizing the different grids would definitely be good if we can do it. I would also add the grid properties. Right now there's also e.g. `grid.Δx` and `grid.Δλᶜᶜᵃ`. > After starting to use `RegularLatitudeLongitudeGrid`, I see that the defualts are quite different, you need to specify latitude, longitude, and z. I guess the main limitation is that the different grids use different coordinates (which have different names). Not sure I see a way around this besides calling `longitude` `x` and `latitude` `y` etc. > Also, there is no topology option at all. Yeah for the `RegularLatitudeLongitudeGrid` the topology depends on the `longitude` bounds. I thought it made sense to make y and z `Bounded` and only make x `Periodic` if `longitude = (-180, 180)`. So then not sure what would happen if a user passes an inconsistent `topology`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833:619,depend,depends,619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833,1,['depend'],['depends']
Integrability,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791,1,['interface'],['interface']
Integrability,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:254,wrap,wrap,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623,2,['interface'],['interface']
Integrability,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/916:395,interface,interface,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916,1,['interface'],['interface']
Integrability,"OK, I think we wrap up this PR and merge it. The advection tests and what not can be another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753:15,wrap,wrap,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753,1,['wrap'],['wrap']
Integrability,"OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans... I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033:192,depend,depending,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033,1,['depend'],['depending']
Integrability,OK. How about we close this PR and open another on in which we:; - drop the MPICH_jll direct dependency; - add a remark in the docs for how people need to work around that for julia 1.7 + Mac M1s,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261,1,['depend'],['dependency']
Integrability,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:184,interface,interfaces,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290,4,['interface'],"['interface', 'interfaces']"
Integrability,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:3137,depend,dependent,3137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,2,['depend'],['dependent']
Integrability,"Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressible/incompressible or ocean/atmosphere capabilities within the same package.; 8. Under a shared package and user interface, Oceananigans.jl will allow users to easily switch between simulating compressible and incompressible fluids and might also allow for _fast and friendly_ coupled large-eddy simulation (although the amount of work needed to reach this would be non-trivial). # Mono-repo vs. multiple packages. I think merging this PR puts the Oceananigans.jl repo in danger of becoming a mono-repo so we should be careful. One big reason why we haven't kept the compressible model in a separate repo is because we just don't have a good name for it yet. A potential pathway to multiple packages would be to split out the Oceananigans.jl package into four packages: OceananigansBase.jl, OceananigansIncompressible.jl, Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:4439,interface,interface,4439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['interface'],['interface']
Integrability,"Oceananigans formally uses a finite volume spatial discretization, which means that all boundary conditions amount to a specification (or a model) for the flux of a quantity across the boundary. We use a central approximation to estimate fluxes due to Neumann or Dirichlet boundary conditions. When fluxes are specified directly by the user (via the `Flux` boundary condition type), we take two steps:. 1. Fill halo regions so that the solution is reflected across the boundary. This ensures that boundary fluxes evaluated while the tendency kernel is evaluated in every cell in the domain are zero, due to two assumptions:; - Advective fluxes across the boundary are zero.; - All turbulence closures have the property that the diffusive flux is zero across an interface if odd derivatives of the solution are zero at the interface.; 2. We ""manually"" add user-specified fluxes to each boundary-adjacent cell. Two major limitations of this method are:. 1. We cannot support turbulence closures that do not impose zero boundary diffusive fluxes when the solution is symmetric across the boundary (one example is true biharmonic diffusion, which is why we only support hyper diffusion at the moment, see #1279). ; 2. This algorithm does not easily generalize to irregular coastlines and bathymetry. I think we should come up with an alternative algorithm that better generalizes to biharmonic diffusion and irregular coastlines. If we limit ourselves to impenetrable boundaries (a reasonable limitation I think) then the needed features are all in the `TurbulenceClosures` module. In particular, I think we need to formalize the use of `diffusive_flux_x`, `diffusive_flux_y` and `diffusive_flux_z` for tracers (and corresponding functions for momentum). With these functions in hand for all `TurbulenceClosures`, we can then write an algorithm that. 1. Either does not fill halo regions or fills them in some trivial manner.; 2. Calculates the tendencies at every point, except for fluxes across boundari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1400:761,interface,interface,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1400,2,['interface'],['interface']
Integrability,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:28,interface,interface,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['interface'],['interface']
Integrability,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:287,interface,interface,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519,1,['interface'],['interface']
Integrability,"Ok @hdrake @liuchihl I have added the option to include or not the background field when computing closure fluxes. They are noit included by default. If you want to include them you need to build the `BackgroundFields` explicitly by writing something like. ```julia; background_fields = BackgroundFields(; background_closure_fluxes=true, b=B); ```. where `B` is the background buoyancy field as before. Then pass this to the model constructor instead of passing a `NamedTuple`. Let me know if this seems like a good interface and also if it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954:516,interface,interface,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954,1,['interface'],['interface']
Integrability,"Ok I have a new proposal:. Eliminate the `Buoyancy` wrapper, and instead implement a new ""optional"" wrapper called ""RotatedBuoyancy"" or something like that, which is _only_ used when buoyancy is rotated. I think this is nice because for the majority of users who don't want to rotate buoyancy, they don't have to deal with the extra layer of indirection that `Buoyancy` currently introduces. For those users who want to rotate gravity, well, they know what they are doing. This is a better API because users get out what they put in (ie the keyword `buoyancy = ...` corresponds to `model.buoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982:52,wrap,wrapper,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982,2,['wrap'],['wrapper']
Integrability,"Ok better idea. The _first_ time that time-step wizard is called as a callback, it can call into a function like `validate_CFL(model, cfl)`. . Then model developers can implement that function if they would like to warn users. Since it's called at iteration 0, the warning is prominent. Moreover, the warning can be made specific depending on the type of model and time-stepper being used, so we can be more sure that we are giving accurate and relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830:330,depend,depending,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830,1,['depend'],['depending']
Integrability,Ok two PRs that this depends on now: #3311 and #3314 . I'll mark as draft to indicate that this is on hold for a little,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602:21,depend,depends,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602,1,['depend'],['depends']
Integrability,"Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289:203,wrap,wrapper,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289,1,['wrap'],['wrapper']
Integrability,"Ok, I was a bit unsure which CFL definition is the best, so I checked the 2D stability and I got a slightly better proof. ; Let's start with the discretized version of the 2D advection equation (forward euler and 2nd order centered finite volume on a staggered regular cartesian grid) ; $$\frac{c^{n+1} - c^n}{\Delta t} = u \left( \frac{c^n_i - c^n_{i-1}}{\Delta x}\right) + v \left( \frac{c^n_j - c^n_{j-1}}{\Delta y}\right)$$ ; Let's assume that c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; T",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:476,depend,depending,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,2,['depend'],"['dependent', 'depending']"
Integrability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['interface'],['interface']
Integrability,"Ok, fixed an issue dispatching on a grid with partial cells in the hydrostatic pressure integral (turns out things go very wrong if we naively integrate to find hydrostatic pressure with partial cells!) here: https://github.com/CliMA/Oceananigans.jl/pull/2306/commits/9cc91dafe140ce4d5124a4d80e8a35496e45ad7e. Things look ok now, and a resting ocean remains at rest:. <img width=""598"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/166724316-df8cd89e-aed3-4027-b0fa-60cec7ad44ac.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307:143,integrat,integrate,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307,1,['integrat'],['integrate']
Integrability,"Ok, good to know. But I think the strategy we use to distribute work should depend specifically on how much each example costs. So the optimal strategy for this code might be different than on the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547:76,depend,depend,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547,1,['depend'],['depend']
Integrability,"Ok, let me take a look. That synchronize should not be necessary. Also this seems weird as . https://github.com/JuliaGPU/KernelAbstractions.jl/blob/5a30f7332e5190247742fa671a01724ae2ef254a/src/cpu.jl#L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231:29,synchroniz,synchronize,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231,1,['synchroniz'],['synchronize']
Integrability,"Ok, then we need to think about the user interface. We could add a keyword argument `output_grid` to the output writer, or perhaps a positional argument as in. ```julia; JLD2OutputWriter(model, outputs, grid; kw...); ```. I think a feature that might be useful for implementing this feature is an `InterpolatedField`, which looks something like. ```julia; struct InterpolatedField; grid; data; interpoland; end. function compute!(interp::InterpolatedField); compute!(interp.interpoland); interpolate!(interp, interp.interpoland); return interp; end; ```. Then we could use this feature in `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl. and maybe elsewhere. This is a chunk of work of course. I don't need it right now personally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677,1,['interface'],['interface']
Integrability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:366,depend,depend,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['depend'],['depend']
Integrability,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712:1158,depend,depending,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712,2,['depend'],['depending']
Integrability,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:936,message,message,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,2,['message'],['message']
Integrability,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:507,integrat,integrate,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793,2,['integrat'],['integrate']
Integrability,"On Julia < 1.9 you need requires [which is standard practice by extension packages], if Oceananigans enforces 1.9+, it's not necessary. Wasn't sure so added both here, and you can remove the requires dependency if desired.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748,1,['depend'],['dependency']
Integrability,"On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Would it be of interest to have an option for it to not compute it at every time? I am not suggesting this be done for this problem, but thinking more in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687:52,depend,dependent,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687,1,['depend'],['dependent']
Integrability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:12,interface,interface,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,2,['interface'],['interface']
Integrability,"One remaining question is a user interface for extracting viscosities and diffusivities, especially when we have closure tuples. I think we want a function based interface. Take for example the case. ```julia; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); ```. We could have some API functions that look like. ```julia; viscosity(model) # returns 1.05e-6 + νₑ; diffusivity(model, :b) # returns 1e-7 + κₑ; diffusivities(model) # returns a named tuple with all tracer diffusivities; ```. This could work if _all_ closures are _either_ `AbstractScalarDiffusivity` or `AbstractBiharmonicDiffusivity`. For models with heterogeneous closures we need a bit more. For example with. ```julia; closure = (HorizontalScalarBiharmonicDiffusivity(ν=1e2, κ=1e1), CATKEVerticalDiffusivity()); ```. we might have something like. ```julia; viscosity(closure[1], model); viscosity(closure[2], model); ```. which returns the viscosity associated with `closure[n]` (here, either biharmonic diffusivity or CATKE's nonlinear diffusivity). The issue is that we don't want users picking apart `model.diffusivity_fields` since this will make scripts more fragile, prone to breakage when code changes, and difficult to understand. (I also think we need to change this to `closure_fields` at some point). . Thoughts or other ideas? @navidcy @tomchor @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050:33,interface,interface,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050,2,['interface'],['interface']
Integrability,"Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088:150,message,message,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088,1,['message'],['message']
Integrability,Only perform operations as needed depending on model dimension.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/35:34,depend,depending,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/35,1,['depend'],['depending']
Integrability,"Or perhaps write a separate `euler_step!` that does not depend on special values of `χ`. Not sure if that would have an extra GPU cost. But even if so, it'll only be for one time-step, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516:56,depend,depend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516,1,['depend'],['depend']
Integrability,Or we can rename the grid metric operation to `dx`? Just want to make sure we consider all options. I think in our original discussion we voted for `xspacings` in the user interface for verbosity. If that's priority 1 then I agree it motivates also replacing `Δx` with `xspacing`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924:172,interface,interface,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924,1,['interface'],['interface']
Integrability,"Originally added in PR #592 but removed in #1221, this PR reintroduces the `weno_nth_order.jl` implementation. We should look into making it as fast and efficient as the `weno_fifth_order.jl` before merging. Also this PR adds the cursed SymPy dependency which has caused problems for users in the past (see #990) so would be nice to get rid of it somehow. X-Ref: #995",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1238:243,depend,dependency,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1238,1,['depend'],['dependency']
Integrability,"Ouch! Maybe we should fix the seed. And reduce the time step to 0.1 or something so it doens't fall exactly on the bleeding edge of possibility, depending on the whims of `rand`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846:145,depend,depending,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846,1,['depend'],['depending']
Integrability,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269:1241,message,message,1241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269,1,['message'],['message']
Integrability,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:9,interface,interface,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,3,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,Output error messages to a file?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363:13,message,messages,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363,1,['message'],['messages']
Integrability,"Output writer ""diagnostic dependencies""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/886:26,depend,dependencies,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/886,1,['depend'],['dependencies']
Integrability,"Over at [JULES.jl](https://github.com/thabbott/JULES.jl) @thabbott, @RaphaelRR, and I have been building a compressible non-hydrostatic model on top of Oceananigans.jl for atmospheric simulations. It follows the numerics of the Advanced Research WRF Model as described in Klemp et al. (2007) and Skamarock et al. (2019). With three qualitative verification experiments I think it's ready to be tagged as v0.1. I'm opening this issue to discuss the possibility of merging JULES.jl into Oceananigans.jl which would add a `CompressibleModel` type (discussed a bit in #566). The two models share a lot of the infrastructure we've already built for Oceananigans, and in integrating the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoust",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605:665,integrat,integrating,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605,1,['integrat'],['integrating']
Integrability,"Over in `OceanTurbulenceParameterEstimation` we've developed a utility called `FieldTimeSeriesCollector` that can be used in a callback to ""collect"" field data on the fly while a simulation is running. This is useful for idealized problems and quick experimentation where saving data to disk is unnecessary:. https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/a05d1d8959ef40f0f3e7873b32caf4271f102592/src/Observations.jl#L257-L308. It'd probably be nice to move this feature into `Oceananigans` proper at some point so it's more visible and more people can benefit. And we can tweak the design / interface too. Because ""field_time_serieses"" (a `NamedTuple` collection of `FieldTimeSeries`) doesn't quite roll off the tongue. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2216:613,interface,interface,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2216,1,['interface'],['interface']
Integrability,"PU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1994,depend,depends,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1118:143,message,message,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118,1,['message'],['message']
Integrability,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873:672,depend,dependencies,672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873,3,['depend'],['dependencies']
Integrability,"Pasting the error message would be helpful for debugging this issue. One way around that should work for `VerticallyStretchedRectilinearGrid` and also curvilinear grids is to use `accurate_cell_advection_timescale`. `TimeStepWizard` accepts the `cell_advection_timescale` function as a keyword argument in its constructor. So. ```julia; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. wizard = TimeStepWizard(cell_advection_timescale = accurate_cell_advection_timescale, other_kwargs...); ```. might work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333,1,['message'],['message']
Integrability,"Perhaps I can chime in here to give some context. Something in the Oceananigans/KA/Enzyme/etc setup was breaking our integration test of the advection-diffusion (https://github.com/CliMA/Oceananigans.jl/pull/3480) which was blocking us for making progress for some time. Eventually Joe successfully minimized it down to this point as a minimal error (effectively just testing successful AD of Oceanigans.Utils.launch!, which was failing). We later determined the root cause of the issue to be a problem in KA (https://github.com/JuliaGPU/KernelAbstractions.jl/pull/476). The purpose of this is not to specifically act as a unit test for the individual KA issue, but to be a small unit test for Oceananigans modified launching infrastructure. That way if something else comes up as a bug in a future integration test, we can quickly find the root cause without weeks of debugging from the whole integration test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020:117,integrat,integration,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020,3,['integrat'],['integration']
Integrability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:167,depend,depend,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,2,['depend'],['depend']
Integrability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:300,interface,interface,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,2,['interface'],['interface']
Integrability,"Please could someone rerun the failed tests, I don't think they've actually failed from what I can tell from the error messages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485:119,message,messages,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485,1,['message'],['messages']
Integrability,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802:121,interface,interface,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802,3,['interface'],['interface']
Integrability,"Posted from a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:582,depend,depends,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depends']
Integrability,"Presently, applying differential operators to fields offline (as opposed to using diagnosing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:972,integrat,integrate,972,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['integrat'],['integrate']
Integrability,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:2065,message,message,2065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['message'],['message']
Integrability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:633,depend,depended,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['depend'],['depended']
Integrability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:633,depend,depended,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['depend'],['depended']
Integrability,"Probably the easiest thing to do is to fork `LambertW.jl` and remove that warning. The rest seems ok, though a max iterations of 1000 seems a bit high if you want performance. It depends what you want, but as a hack you can return a NaN upon non-convergence rather than throwing a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244:179,depend,depends,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244,1,['depend'],['depends']
Integrability,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956:65,integrat,integrated,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956,2,['integrat'],['integrated']
Integrability,Proposal to export the entire user interface at the top-level module,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1132:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132,1,['interface'],['interface']
Integrability,"R introduces `AbstractOperation`s for constructing 3D expressions with a friendly syntax (eg, not writing kernels), which can then be evaluated online during a simulation for diagnostics / output purposes. This PR introduces four kinds of `AbstractOperation`s:. 1. `Derivative` (things like `∂x`, `∂y`); 2. `BinaryOperation` (things like `a-b`, `a^b`); 3. `UnaryOperation` (things like `sqrt`, `sin`, `cos`); 4. `PolynaryOperation` (things like `a + b + c + d` or `a * b * c * d`). All of these act on combinations of `Field`, `Function`, and `Number`. `. `AbstractOperation`s arise from what appears to be ordinary arithmetic and calculus performed on `Field`s. Consider this example:. ```julia; julia> using Oceananigans; using Oceananigans: Face, Cell; using Oceananigans.AbstractOperations. grid = RegularCartesianGrid((16, 16, 16), (16, 16, 16));; a = Field(Cell, Cell, Cell, CPU(), grid);; b = Field(Cell, Cell, Cell, CPU(), grid);; a_times_b = a * b;. julia> typeof(a_times_b).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation; ```. Here, the object `a_times_b` is of the type `BinaryOperation`. `a_times_b` can be indexed into like an array or field, however:. ```julia; julia> a_times_b[8, 8, 8]; 0.0. set!(a, rand(size(grid)...)); set!(b, rand(size(grid)...)). julia> a_times_b[8, 8, 8]; 0.5342645056606357; ```. # Staggered grids, interpolation, and operation ""location"". Operations can also be defined between fields at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:1011,wrap,wrapper,1011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability,"Rather than using `α` and `β` to denote the thermal expansion and saline contraction coefficients, we should probably just use `thermal_expansion` and `haline_contraction`. The syntax would then be. ```julia; eos = LinearEquationOfState(thermal_expansion=α, haline_contraction=β); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/453:73,contract,contraction,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/453,1,['contract'],['contraction']
Integrability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['interface'],['interface']
Integrability,Reading through the error message again I'm not sure its what I thought.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853,1,['message'],['message']
Integrability,"Reductions on FieldTimeSeries are performed individually for each element by constructing two Fields and reducing one into another. Probably, the construction of the individual field is what is causing the loss in performance?; We do not necessarily need to do that, we can just wrap the data in a `ConditionalOperation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413:279,wrap,wrap,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413,1,['wrap'],['wrap']
Integrability,Refactors Poisson solver interfaces and new implicit free surface solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:25,interface,interfaces,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['interface'],['interfaces']
Integrability,"Refractors the `IsotropicDiffusivity`, `AnisotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` so that only one `ScalarDiffusivity` is defined. with this PR, the following API changes are implemented; - `closure = IsotropicDiffusivity(ν = 1, κ = 1) -> closure = ScalarDiffusivity(ν = 1, κ = 1, direction=ThreeDimensional()) (default)`; - `closure = HorizontallyCurvilinearAnistropicDiffusivity(νh = 2, κh = 2, νh = 1, κh = 1) -> ; horizontal_closure = ScalarDiffusivity(ν = 2, κ = 2, direction=Horizontal()); ; vertical_closure = ScalarDiffusivity(ν = 1, κ = 1, direction=Vertical())`. For biharmonic diffusivity; - Bug fixes in `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` which is kept as the standard method for biharmonic diffusivity and renamed `ScalarBiharmonicDiffusivity` so now; `closure =HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity(ν = 1, κ = 1) -> closure = ScalarBiharmonicDiffusivity(ν = 1, κ = 1, direction=Horizontal()) (default)`; - Also for biharmonic we have a `ThreeDimensional`, `Horizontal` and `Vertical` mode; - Nuking of `AnisotropicBiharmonicDiffusivity`. Additionally; - Implementation of a `discrete` mode for viscosity and diffusivity functions (with `discrete_diffusivity = true`) to be able to have viscosity and diffusivity depend on grid metrics so that we can have; ```; using Oceananigans.Operators: Δx. νh(lx, ly, lz, i, j, k, grid, clock) = Δx(i, j, k, grid, lx, ly, lz)^4 / (3600*24); closure = ScalarDiffusivity(ν = νh, discrete_diffusivity = true); ```; - Implementation of `solid_node` and `solid_interface` for Bounded grids. Used in `Biharmonic` operators to enforce zero flux and zero laplacian boundary conditions. closes #2239; closes #2113",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247:1301,depend,depend,1301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247,1,['depend'],['depend']
Integrability,"Registration pull request created: [JuliaRegistries/General/32030](https://github.com/JuliaRegistries/General/pull/32030). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if the [Julia TagBot GitHub Action](https://github.com/marketplace/actions/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.53.1 -m ""<description of version>"" 7682a3df3c65a1a7e1df2bb05d86a8ce033a91ff; git push origin v0.53.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332:436,interface,interface,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332,1,['interface'],['interface']
Integrability,Remove Enzyme from core dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3452:24,depend,dependency,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3452,1,['depend'],['dependency']
Integrability,Remove JLD and HDF5 dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/340:20,depend,dependency,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/340,1,['depend'],['dependency']
Integrability,Remove SymPy dependency for now,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/996:13,depend,dependency,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/996,1,['depend'],['dependency']
Integrability,Remove SymPy dependency in next release of Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/990:13,depend,dependency,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990,1,['depend'],['dependency']
Integrability,Remove Tullio dependency; take #2 and implement universally accurate CFL time-scale,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037:14,depend,dependency,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037,1,['depend'],['dependency']
Integrability,Removed tullio dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252:15,depend,dependency,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252,1,['depend'],['dependency']
Integrability,Resolves #1063 (depends on #1081),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1083:16,depend,depends,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1083,1,['depend'],['depends']
Integrability,Resume from checkpoint should be integrated with model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/602:33,integrat,integrated,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/602,1,['integrat'],['integrated']
Integrability,Revisit `SplitExplicitFreeSurface` user-interface and Docs + use `SplitExplicitFreeSurface` as the default when appropriate,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503,1,['interface'],['interface']
Integrability,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/54:686,synchroniz,synchronize,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54,2,"['integrat', 'synchroniz']","['integrating', 'synchronize']"
Integrability,"Right now GitLab CI fails on nightly/dev builds because CUDAapi isn't a package anymore. This PR updates the dependencies/packages in Project.toml to the latest version which should also fix this. There was some mix-up about a month ago that forced us to switch to the master branch of a lot of GPU packages, but things seem fine now. Sticking with GPUifyLoops v0.2.3 because of https://github.com/vchuravy/GPUifyLoops.jl/issues/66. Also removes CUDAapi which isn't a package anymore, and NNlib which was never supposed to be a direct dependency.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/244:109,depend,dependencies,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/244,2,['depend'],"['dependencies', 'dependency']"
Integrability,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:268,integrat,integrate,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,2,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1610:328,wrap,wrapper,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610,3,['wrap'],['wrapper']
Integrability,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:51,integrat,integration,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['integrat'],['integration']
Integrability,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:241,depend,dependencies,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,3,['depend'],['dependencies']
Integrability,"Right now the functions that calculate implicit vertical diffusion coefficients don't know about a field's horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/11727d66587e01067bf1ac24e2655e593e98fe9e/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L41-L44. except implicitly through `κ⁻⁻ᶠ`. However, when using an immersed boundary, we need the _horizontal_ location in order to correctly mask the coefficients of the implicit vertical diffusion tridiagonal matrix. So, rather than passing the function `κ⁻⁻ᶠ`, we should pass the field's location here. This will also mean that we only need one `ivd_upper_diagonal`, and we can dispatch on the special case that a field is located at cell interfaces in the vertical.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2116:720,interface,interfaces,720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2116,1,['interface'],['interfaces']
Integrability,"Right now the the function that calculates whether a face location is a solid interface looks like this:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Grids/grid_solid_nodes.jl#L42-L50. This means that it'll return `true` even if the face location is completely inside the immersed solid (i.e. the two adjacent centers are inside the solid, not just one). Is this by design? In my view it would make more sense to use `xor` there instead of `or`. That way it would return `false` if the `Face` is completely inside the immersed in the solid, and it would only return `true` in the actual edges of the immersed solid. This is relevant when implementing boundary conditions to the immersed solids. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263:78,interface,interface,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263,1,['interface'],['interface']
Integrability,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1586:264,depend,dependency,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586,1,['depend'],['dependency']
Integrability,"Right, we cannot form operations with reductions. To operate on reductions, we have to wrap them in a `Field`, so that they can be computed, stored, and _then_ used via the stored result. You can write. ```julia; U = Field(Average(model.velocities.u)); U / 2; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713:87,wrap,wrap,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713,1,['wrap'],['wrap']
Integrability,"Say if we wanted to further modify the forcing function to have second derivatives so that the forcing function looks something like:. $$; (\mu_{0}\exp(z/\lambda) - m)\partial_x(\frac{\partial_y(P)}{T}); $$. where $T$ is possibly dependent on $x$ and $y$, would the code look something like this?. ```; using Oceananigans.Operators: ℑxᶜᵃᵃ, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ, ∂yᶜᶠᶜ. function growing_and_grazing(i, j, k, grid, clock, fields, params) ; z = znode(Center(), Center(), Center(), i, j, k, grid); return (params.μ₀ * exp(z / params.λ) - params.m) * ℑxᶜᵃᵃ(i, j, k, grid, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ(i, j, k, grid, ∂yᶜᶠᶜ, fields.P)/fields.T); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558:230,depend,dependent,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558,1,['depend'],['dependent']
Integrability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:204,interface,interface,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,2,['interface'],"['interface', 'interfaces']"
Integrability,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:143,integrat,integration,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089,2,['integrat'],['integration']
Integrability,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1604:449,depend,dependent,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604,1,['depend'],['dependent']
Integrability,Should vertical spacings `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ` depend on horizontal location?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049:45,depend,depend,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049,1,['depend'],['depend']
Integrability,Should we move `ShallowWaterModel` to its own package which would depend on Oceananigans?. There is an outstanding issue https://github.com/CliMA/Oceananigans.jl/issues/2922; We'd either need to sort it out. I believe to figure it out we need to plot/print out the tendencies from the first iteration for a version that worked and the first version that it didn't and trace back the issue. . Perhaps it would make sense if this was a different model?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049:66,depend,depend,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049,1,['depend'],['depend']
Integrability,Should we open an issue to discuss interfaces to stretched grids?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312,1,['interface'],['interfaces']
Integrability,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316:93,depend,dependencies,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316,1,['depend'],['dependencies']
Integrability,"Simplifies boundary condition interface, types, and constructors",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:30,interface,interface,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['interface'],['interface']
Integrability,Simplify user interface for `KernelFunctionOperation`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2964:14,interface,interface,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964,1,['interface'],['interface']
Integrability,"Since the code is just a few lines, it's easy to figure out what's going on in the REPL. The top of the error message says:. ```; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; ```. So let's go look at this line. It is:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L35. Ok. Does `background_fields` have the property `u`? At the REPL, using the MWE, I find:. ```julia; julia> background_fields.u; ERROR: type BackgroundFields has no field u; Stacktrace:; [1] getproperty(x::Oceananigans.Models.NonhydrostaticModels.BackgroundFields{true, @NamedTuple{…}, @NamedTuple{…}}, f::Symbol); @ Base ./Base.jl:37; [2] top-level scope; @ REPL[7]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Ok, we found the error. But where is `u`? writing `julia> background_fields.` and pressing TAB yields. ```julia; julia> background_fields.; tracers; velocities; ```. Ok, so maybe we want `background_fields.velocities.u`. Looking into the source code for background fields:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/background_fields.jl#L32-L38. confirms what we found, that `BackgroundFields.u` does not exist. Just to confirm, we go back to the REPL and try:. ```julia; julia> background_fields.velocities.u; ZeroField{Int64}; ```. so yes, using `velocities.u` should fix this particular bug. This is an easy fix. Just to go through the motions and get a hang for how this works, let's add the test first, and then make the fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716:110,message,message,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716,1,['message'],['message']
Integrability,"Since this is such a major change in the interface, I think we should get the docs back up again before registering 0.90 (i.e. fix https://github.com/CliMA/Oceananigans.jl/issues/3191).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373,1,['interface'],['interface']
Integrability,"Since we don't have bitwise reproducibility, each run has random round-off errors that, if integrated into a nonlinear trajectory, can cause two solution to diverge eventually. Possibly this test case is a little too challenging (too long time integration, or too nonlinear), meaning that occasional chaotic divergence of the solution is expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012:91,integrat,integrated,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012,2,['integrat'],"['integrated', 'integration']"
Integrability,"Since we throw away any calculations that are entirely inside a solid, we usually don't care what happens there. I think that's why it's called `solid_interface` rather than `fluid_solid_interface`, but @simone-silvestri can confirm. I think we need a bit more information for boundary conditions right? We have to know the _direction_, eg. ```julia; using Oceananigans.AbstractOperations: flip; east_fluid_solid_interface(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. This returns `true` when our cell is not immersed, but the eastern boundary is a fluid-solid interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497:641,interface,interface,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497,1,['interface'],['interface']
Integrability,Slightly reorganizes dependencies in tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:21,depend,dependencies,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,1,['depend'],['dependencies']
Integrability,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:150,integrat,integration,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531,1,['integrat'],['integration']
Integrability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:359,depend,dependencies,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependencies']
Integrability,"So depending on how we perceive the importance of this issue we could add docs and an example illustrating this workflow to users, as an alternative to changing the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015:3,depend,depending,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015,1,['depend'],['depending']
Integrability,"So far we have a better error message but after trying a few different things I couldn't get `_permute_index(i, N)` to work =/. Gonna keep this open since it's becoming a high priority issue. Resolves #828",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/997:30,message,message,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/997,1,['message'],['message']
Integrability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:717,interface,interface,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,4,['interface'],['interface']
Integrability,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:77,synchroniz,synchronize,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808,3,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:144,depend,depend,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,2,['depend'],['depend']
Integrability,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:353,depend,depending,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912,1,['depend'],['depending']
Integrability,"So, I'm hitting some errors running the `baroclinic_adjustment` example with the ROCBackend. The only modification of this example script is the specification of the architecture as `GPU()`. It seems that this chokes on AMDGPU's `zeros`. I did not encounter this in the other work I was doing on Simone's branch; though the test we were using was not building with a recilinear grid. ```; $ julia --project=. ./bench/baroclinic_adjustment.jl ; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:640,interface,interface,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,1,['interface'],['interface']
Integrability,"Some good news is that more tests seem to be passing compared to the prevoius PR. . One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why. ```; Testing Oceananigans; # Received cancellation signal, interrupting; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877:95,message,messages,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877,1,['message'],['messages']
Integrability,"Some of the examples had typos and incorrect comments. Also, some of the plotting is improved now that we know beautiful plots means `contourf` with `linewidth=0`. I added a few features to some of the examples, most notably `AveragedField`. Finally, we now always visualize in post-process. Depends on #1093, since that PR beautifies a few of the examples as well with field-dependent boundary conditions. Resolves #676",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1099:292,Depend,Depends,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1099,2,"['Depend', 'depend']","['Depends', 'dependent']"
Integrability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:313,wrap,wrap,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,1,['wrap'],['wrap']
Integrability,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749:113,message,message,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749,2,['message'],['message']
Integrability,"Sometimes precompilation and model setup tasks can take a fair amount of time. This can lead to head-scratching and/or boredom while running scripts: what _is_ Oceananigans up to, anyways?. To solve this problem and make Oceananigans more friendly and more chatty, we might add some helpful `@info` messages that print at various stages in the model setup process. Looking at the examples gives a helpful overview of model setup. Here's some things we might consider info statements for:. 1. Grid creation (type, size, topology, domain); 2. Boundary conditions (type and non-default boundary conditions); 3. Model creation (grid info including size and halo regions, and maybe just `display` model properties); 4. `set!(model, ...)`?; 5. `Simulation` construction (stop criteria, time-step...); 6. `run!` initialization (diagnostics, output writers); 7. `run!` completion?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1013:299,message,messages,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1013,1,['message'],['messages']
Integrability,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855:223,message,message,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855,1,['message'],['message']
Integrability,"Sorry I didn't realize I didn't get the full error message:; ```; [52922] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129; Allocations: 618273 (Pool: 617476; Big: 797); GC: 1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:51,message,message,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"Sorry I should have been more verbose. I meant that since the Manifest you pushed doesn't seem to work then I'm not sure I can reproduce the setup you run locally to test things. And that said, I'm not sure whether some errors you point out are because of the code or from a dependency version that is different to what I have on my side etc..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477:275,depend,dependency,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477,1,['depend'],['dependency']
Integrability,Sorry but I don't quite understand the changes. Could you please post explain a little more? Maybe posting a couple of snipets showing how the interface changed is enough!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624:143,interface,interface,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624,1,['interface'],['interface']
Integrability,"Sorry if I jumped the gun on the merge, I thought I saw a message deciding against pseudomomentum but can't find it anymore. To be honest I don't know much about pseudomomentum, so I can't have an informed opinion. I know you can use it when talking about nonbreaking waves, but I, personally, find that nomenclature a little obscure in this context.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270:58,message,message,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270,1,['message'],['message']
Integrability,"Sorry maybe there was a miscommunication. The `output!` interface does not delay creating files until `run!`. . Delaying output initialization to `run!` does not exist. I would like to implement it, however. (In another PR.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882,1,['interface'],['interface']
Integrability,"Sounds great! I've had a discussion with Greg about this before, and which method you need to implement really depends on the application. ; - The ""penalty function"" boundary was the first type proposed historically, but it is completely inappropriate for unsteady flows and will really mess up a turbulent boundary layer evolution.; - Direct forcing methods and other similar approaches go in and set the value of velocity components inside the immersed solid at each time step to satisfy the velocity boundary conditions before or after the projection step. However, you have to choose between enforcing a divergence free velocity and the BC - you can't have both without modifying the pressure Poisson equation. As long as the body isn't moving, the results tend to be fine. The pressure forces will not be time accurate and so dynamic forces will suffer. ; - For fluid structure interaction problems you really need to get those forces right and therefore must modify the pressure equation. . I've attach a write-up one of my students is working on which lays this out with a few simple examples. Section 3 reviews Immersed Boundary methods and 3.1 has a simple 1D FSI example. . [Mr M Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf](https://github.com/CliMA/Oceananigans.jl/files/5370790/Mr.M.Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163:111,depend,depends,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163,1,['depend'],['depends']
Integrability,Split-Explicit free-surface solver interface revisit,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3311:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3311,1,['interface'],['interface']
Integrability,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub(overdub_context::Cassette.Context, overdub_arguments...) in Cassette at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:595); Stacktrace:; [1] getindex at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/Fields/computed_field.jl:114; [3] gpu__compute! at /glade/u/home/tomasc/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [4] overdub at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, int",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:5126,message,message,5126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,2,['message'],['message']
Integrability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:707,depend,dependency-tracking,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['depend'],['dependency-tracking']
Integrability,Supporting non-zero or time-dependent wall-normal velocities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:28,depend,dependent,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,1,['depend'],['dependent']
Integrability,Supressing harmless warning and error messages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366:38,message,messages,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366,1,['message'],['messages']
Integrability,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870:184,message,message,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870,2,['message'],['message']
Integrability,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:233,integrat,integrated,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704,1,['integrat'],['integrated']
Integrability,"Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. ### Local topologies. The local grid topology may need",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:1093,inject,injection,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injection']
Integrability,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:403,integrat,integrating,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,2,['integrat'],['integrating']
Integrability,"Tbh I didn't give it as much thought as you may be implying with your message above :). But I just realized that the ShallowWater example talks about ""equations in conservative form"" and some users may have no idea what we are talking about... Let's see what @glwagner and @ali-ramadhan think on this. Perhaps with the current status of fast development it makes sense to hold on Docs for later..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091:70,message,message,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091,1,['message'],['message']
Integrability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:162,message,message,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,1,['message'],['message']
Integrability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:501,interface,interface,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['interface'],['interface']
Integrability,"Thank you for your response. The question is: what do *you* use to trace MPI; in Julia programs? Do you use `nsys`? If so, how?. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 1:06 AM Simone Silvestri ***@***.***>; wrote:. > Using nsys it is possible to trace MPI with --trace=mpi, see:; > https://docs.nvidia.com/nsight-systems/UserGuide/index.html; > <https://urldefense.com/v3/__https://docs.nvidia.com/nsight-systems/UserGuide/index.html__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvlwu8ongn$>; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396207964__;Iw!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl3gGBEE5$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWH3753SQU2FEFPUVW3Z2I6HXAVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWGIYDOOJWGQ__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl1tQs-Dz$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871:1552,Message,Message,1552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871,1,['Message'],['Message']
Integrability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:1251,depend,depending,1251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,2,['depend'],['depending']
Integrability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:355,depend,depend,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,3,['depend'],"['depend', 'depends']"
Integrability,"Thanks @glwagner for the suggestion. Yes, I agree that would be much easier as there is no need to differentiate or integrate. Will think about that. We are specifying a `BackgroundField`, so given the fact that the buoyancy is calculated at every time step and every grid point, then having it precalculated would make more sense. . It occurs to me that if we solve for the buoyancy using array operators at the beginning, then we can specify the`BackgroundField` using arrays. Should that work? I don't know if I have seen how to specify `BackgroundField` as an array but I presume it's like how the turbulence example specifies the initial conditions in terms of an array?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583:116,integrat,integrate,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583,1,['integrat'],['integrate']
Integrability,"Thanks @glwagner. I certainly don't want to make any changes that would either slow down code or make things harder to maintain. I can't say that I know this is the right direction to go but let me try and articulate what I want to do and maybe you can suggest a direction to proceed?. The basic idea can be found by looking at `shallow_water_Bickley_jet.jl`. In this example we define a `perturbation_norm` in line 134 that computes the norm of `v`. Then in line 158 we define an output_writer to output this norm. There is nothing special about v and I might want to use use `u` as well. To do this requires two steps:. 1. Defining a new analogous function for the perturbation norm of `u`. I'm hoping we can avoid these functions completely with `using Statistics: norm` but I don't know if that's the case.; 2. In line 161 we need to list these two norms. When I tried that there was an error message, and hence what inspired this PR. I don't think this PR needs to happen and there are probably better ways of addressing points 1 and 2. Any advice?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868:897,message,message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868,1,['message'],['message']
Integrability,"Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580:114,depend,dependent,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580,1,['depend'],['dependent']
Integrability,"Thanks @kburns for the suggestion. I will look at Dedalus to see what they do and learn from them. I don't think we would want to find the full spectrum unless the problem is one-dimensional, but I guess it depends on what we want it to do. Lots of potential here I'm sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860:207,depend,depends,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860,1,['depend'],['depends']
Integrability,"Thanks @maleadt, that's very helpful!. In this PR, we haven't directly changed any kernel function signatures. However, this PR does pass more complicated objects into kernels (a wrapper around an `OffsetArray` called a ""`Field`"", rather than simply the `OffsetArray`). The primary changes in this PR are thus 1. _not_ to extract the underlying `OffsetArray` from a `Field`, and 2. writing an `adapt_structure` method for `Field`s. I suppose the translation that's performed by `adapt_structure` increases the number or arguments to the function `ptxcall_calculate_Gu__66`?. The changes made in this PR are not strictly necessary --- they are a convenience. If manually unwrapping `Field`s (the method we previously used) is necessitated by CUDA limitations, I think we can live with that. If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987:179,wrap,wrapper,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987,1,['wrap'],['wrapper']
Integrability,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:270,depend,dependency,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140,1,['depend'],['dependency']
Integrability,"Thanks @navidcy for the reply. This is helpful. This means that when we integrate the zonal momentum equation over a volume (as part of deriving the finite volume method), we get the vertical integral in the `z` derivative and hence why we get the flux at the top minus the flux at the bottom. These should be averages over each horizontal cell and we also divide by a length scale. I presume that's why the MITgcm divides by the depth of the top cell. Interesting that they seem to use a body force but it should result in the same dynamics I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047:72,integrat,integrate,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047,1,['integrat'],['integrate']
Integrability,"Thanks @qingli411. One obvious way to introduce the concept of dynamic dependencies is to break functionality out into multiple small packages (`OceananigansPlotting`, `OceananigansOutput`, etc). @vchuravy argued that this is a good philosophy for packages; perhaps even more so for a complex project like this one: we may want to keep the core as simple as possible. This would also make the tests run faster, and might make development easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624:71,depend,dependencies,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624,1,['depend'],['dependencies']
Integrability,"Thanks @simone-silvestri . I believe we found our bug!. The continuity equation (conservation of mass equation) does not change whether there is topography or not. It should always be, as follows, where `h` is the total depth:. ```; ∂ₜh + ∇⋅(h u⃗) = 0; ```. The pressure gradient, however depends only on the free surface, or if we write it in terms of the total depth we need to include the topography,. ```; ∇ η = ∇(h + b); ```. I am not sure what convention we are following, but there might be a negative in front of the `b`. . Does that make sense?. The equations you shared have some mistakes in them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538:289,depend,depends,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538,1,['depend'],['depends']
Integrability,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:262,message,message,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638,1,['message'],['message']
Integrability,"Thanks @simone-silvestri for the quick reply! I'll work on it this work and message you on slack so we can find a time that is convenient for you for us to chat, and hopefully get this moving again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713,1,['message'],['message']
Integrability,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166,2,['interface'],['interface']
Integrability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:405,depend,dependent,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['depend'],['dependent']
Integrability,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:106,message,messages,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965,2,"['depend', 'message']","['dependencies', 'messages']"
Integrability,"Thanks for creating this @tomchor , I think this is a neat idea. To help me think about how this should look, could you help me find an example you want want to do this? . I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879:283,depend,depends,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879,1,['depend'],['depends']
Integrability,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:517,interface,interface,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151,2,['interface'],['interface']
Integrability,"Thanks for sharing this @tomchor . . Do I take that to mean that if we try and run Oceananigan on an AMD GPU then very likely the code will fail because KerelAbstractions.jl (and possibily others) will fail? . It would be great to be able to run the library on any GPU but I guess a lot of this depends on KerenAbstractions, and other libraries. Do people know what other libraries we depend on that would not necessary run on AMD GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771:295,depend,depends,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771,2,['depend'],"['depend', 'depends']"
Integrability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:250,depend,dependencies,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,4,['depend'],"['dependencies', 'dependency']"
Integrability,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:987,integrat,integration,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255,2,['integrat'],['integration']
Integrability,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/169:1004,synchroniz,synchronize,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169,2,['synchroniz'],['synchronize']
Integrability,Thanks! You're right about the periodic condition and the halo region. Switching to a `8x8x8` did the trick! Although I would have thought that the interpolation routines appropriately calculated the fields at the periodic boundary. Is this expected behavior or a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548:162,rout,routines,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548,1,['rout'],['routines']
Integrability,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:317,rout,routine,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194,3,"['interface', 'rout', 'wrap']","['interface', 'routine', 'wrapper']"
Integrability,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:118,message,message,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710,1,['message'],['message']
Integrability,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:825,Message,Message,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882,1,['Message'],['Message']
Integrability,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:172,message,message,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229,2,['message'],['message']
Integrability,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:228,depend,depends,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326,1,['depend'],['depends']
Integrability,"That's a decent minimal example! Are you sure that the error requires `advection=WENO()` and `timestepper=:RungeKutta3`? The latter cannot be necessary since its the default (so omitting it has the same effect as including it). I find I can reproduce the error without `ImmersedBoundaryGrid` at all. About the error. The top of the message says. ```; ERROR: MethodError: no method matching cpu_fourier_tridiagonal_preconditioner_rhs!; ```. This means that the kernel function `fourier_tridiagonal_preconditioner_rhs!` is being called with the wrong arguments. For example:. ```julia; julia> f(x, y) = x + y; f (generic function with 1 method). julia> f(1); ERROR: MethodError: no method matching f(::Int64). Closest candidates are:; f(::Any, ::Any); @ Main REPL[1]:1. Stacktrace:; [1] top-level scope; @ REPL[2]:1; ```. The stacktrace shows. ```; [8] compute_preconditioner_rhs!(solver::Oceananigans.Solvers.FourierTridiagonalPoissonSolver{…}, rhs::Field{…}); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/HPOLD/src/Solvers/conjugate_gradient_poisson_solver.jl:109; ```. let's look at that line:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L109-L110. This uses the Oceananigans utility `launch!` which launches the kernel `fourier_tridiagonal_preconditioner_rhs!` with the arguments `solver.storage, tridiagonal_dir, rhs`. However, looking at the function `fourier_tridiagonal_preconditioner_rhs` a few lines above. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L93. we see that the function has 4 arguments, not 3. Hence the error. To summarize the analysis method, the key is to find the function that causes the error in the source code (`fourier_tridiagonal_preconditioner_rhs`) and then identify where it is called, and how it should be called. Here's an updated MWE from your nice one @liuchihl :. ```jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576:332,message,message,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576,1,['message'],['message']
Integrability,"That's a neat idea. We also need to checkpoint simulations rather than models, to handle cases where output is time-dependent (windowed time-averages and, in the future, time derivatives).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894,1,['depend'],['dependent']
Integrability,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985:618,integrat,integrate,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985,6,['integrat'],['integrate']
Integrability,"The PR revisits a bit the `SplitExplicitFreeSurface` user-interface and internals and changes the `HydrostaticFreeSurfaceModel` constructor to use the `SplitExplicitFreeSurface` as the default when the grid is appropriate, i.e., all the time except when `grid` is horizontally-regular rectilinear grid. Furthermore, the PR cleans up a bit the free surface constructions. Now all free surfaces have an ""outer constructor"" and then they get materialized via `materialize_free_surface` within the `HydrostaticFreeSurfaceModel` constructor. Closes #3289; Closes #3238",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503:58,interface,interface,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503,1,['interface'],['interface']
Integrability,The `OrthogonalSphericalShellGrid` is more general than the `LatitudeLongitudeGrid`. We should add functionality so that _any_ grid with horizontal coordinates/metrics that depend in both horizontal dimensions can be constructed using the `OrthogonalSphericalShellGrid`. When we do that and when we ensure that we can replicate any `LatitudeLongitudeGrid` using the `OrthogonalSphericalShellGrid` we will be able to eliminate the `LatitudeLongitudeGrid`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3205:173,depend,depend,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3205,1,['depend'],['depend']
Integrability,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:260,depend,depend,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,1,['depend'],['depend']
Integrability,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:120,integrat,integration,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,1,['integrat'],['integration']
Integrability,"The above also explains why synchronizing `mean!` doesn't help. We would need a `synchronize` at some deeper level, apparently. It is interesting that adding `sleep(0.01)` helps. 🤔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690:28,synchroniz,synchronizing,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690,2,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"The answer for this, as per @glwagner's comments, is because that's the syntax for `KernelAbstractions`, which we use to compute GPU kernels:. From @glwagner :. The kernel is created here:; `diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize)`; and launched here:; `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`; the diffiusivity calculations do not depend on one another, so they are all launch simultaneously. At the end, we wait for all of them to finish here:; `wait(device(arch), MultiEvent(Tuple(events)))`. Noticeably apparently we don't use `lauch!` in this case, even though apparently we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426:373,depend,dependencies,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426,2,['depend'],"['depend', 'dependencies']"
Integrability,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:598,depend,dependent,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914,1,['depend'],['dependent']
Integrability,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250:908,interface,interfaces,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250,1,['interface'],['interfaces']
Integrability,"The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to `JLD2OutputWriter` and `NetCDFOutputWriter` in a `WindowedTimeAverage`. It does not involve any averaging. If you can explain why you think it is convoluted, perhaps we can improve it. `WindowedTimeAverage` is defined in this file: https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/windowed_time_average.jl. The key part is `accumulate_result!`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L126-L144. Can you explain why isn't this captured in our tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104:152,wrap,wrapping,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104,1,['wrap'],['wrapping']
Integrability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:193,wrap,wrap,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['wrap'],['wrap']
Integrability,"The constructor for `VerticallyStretchedRectilinearGrid` contains:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/Grids/vertically_stretched_rectilinear_grid.jl#L160-L162. which adjusts the vertical grid spacing at the cell interface just below the top boundary. This adjustment must then render grid calculations inaccurate, because none of the other metrics or node locations are adjusted. What's going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1753:269,interface,interface,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1753,1,['interface'],['interface']
Integrability,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3161:150,depend,depend,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161,2,['depend'],"['depend', 'dependency']"
Integrability,The default depends on whether the file already exists or not? Just above that... https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/netcdf_output_writer.jl#L293-L298,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222:12,depend,depends,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222,1,['depend'],['depends']
Integrability,The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977:4,depend,dependency,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977,2,['depend'],['dependency']
Integrability,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834:559,interface,interfaces,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834,2,['interface'],['interfaces']
Integrability,The difficulties in getting a test to fail on #1784 could mean that the issue this PR resolves is machine dependent. But I'm not sure.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764:106,depend,dependent,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764,1,['depend'],['dependent']
Integrability,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079,4,['depend'],['depend']
Integrability,"The docs have an incorrect description of the `AnisotropicBiharmonicDiffusivity`: . https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity. since the docs claim we use a horizontal biharmonic operator (dx^2 + dy^2)^2 + dz^2, despite that in our implementation:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L64-L68. we actually use dx^4 + dy^4 + dz^4. Our implementation is not truly biharmonic, but is instead might be described as ""fourth-order hyperdiffusion"". A downside of the form we use is that the amount of dissipation it provides depends on the orientation of a feature (""diagonal"" gradients are dissipated less than purely horizontal or vertical gradients). An upside is that we can ensure zero fluxes on solid boundaries more easily. We could solve this by having separate implementation of the true horizontal biharmonic operator for `AnisotropicBiharmonicDiffusivity` (still useful for horizontally-periodic problems), as well as a `FourthOrderHyperDiffusivity` that uses our current implementation. It also might make sense to have `IsotropicBiharmonicDiffusivity` since we can do triply periodic.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1279:753,depend,depends,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279,1,['depend'],['depends']
Integrability,"The error comes from here:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. My guess is that the eigenvalues aren't constructed properly. There's some code in the solver constructor:. https://github.com/CliMA/Oceananigans.jl/blob/aea1e043aa6f965ed599f151b6ace85f25df8cfa/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L44. which (just a guess) looks like we are trying to hack something together rather than properly using an interface defined by `PencilFFTs`. We have to read the `PencilFFTs` documentation and discover how to correctly define these arrays that are meant to be used in the above broadcasting operation. I think there is another issue about this, might be worth searching so we don't have a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630:539,interface,interface,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630,1,['interface'],['interface']
Integrability,The error message we are gettig now does not seem to involve this PR at all. . If that is the case do we need to reset it?. ```. Downloading artifact: OpenSSL; --; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: IntelOpenMP; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: NetCDF; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkit,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['message'],['message']
Integrability,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/603:812,integrat,integrate,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603,2,['integrat'],"['integrate', 'integrated']"
Integrability,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1041,interface,interface,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,2,['interface'],['interface']
Integrability,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:108,depend,dependent,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['depend'],['dependent']
Integrability,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530:540,interface,interface,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530,2,['interface'],['interface']
Integrability,"The issue not only happens after picking up checkpoint, it also occurs before that. For example, with the same MWE, if I set:; ```julia ; Δt = .01 # timestep (s); T1 = 6 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .03 # progress message interval and output saving interval; ```. The issue also occurs in the first run (e.g., 0-6 s):; <img width=""596"" alt=""image"" src=""https://github.com/user-attachments/assets/c4539b8b-b24d-4ba2-8a7e-a99c4d18c9a7"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623:268,message,message,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623,1,['message'],['message']
Integrability,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:360,depend,depends,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025,1,['depend'],['depends']
Integrability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:103,depend,depending,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['depend'],['depending']
Integrability,The main goal of this PR (done jointly with @whitleyv) is to add drag as an option to grid-fitted Immersed boundaries. This is draft for now since first we want to get something that is working properly without worrying to much about user-interface.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275:239,interface,interface,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275,1,['interface'],['interface']
Integrability,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:61,integrat,integrated,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074,4,['integrat'],['integrated']
Integrability,"The pressure correction is done here:. https://github.com/CliMA/Oceananigans.jl/blob/c21d5d6ac95e762cac85154c8f3c4de63631fca7/src/Models/NonhydrostaticModels/pressure_correction.jl#L37-L39. which uses the ""immersed boundary aware"" derivatives `∂xᶠᶜᶜ`, `∂yᶜᶠᶜ`, and `∂zᶜᶜᶠ`. Specifically, these derivatives _always_ return zero across an immersed boundary. (This can be seen from this file: https://github.com/CliMA/Oceananigans.jl/blob/main/src/ImmersedBoundaries/conditional_derivatives.jl, though it is wrapped up in metaprogramming and may be hard to figure out at first glance.). However, the pressure correction for `NonhydrostaticModel` is done in such away that the pressure field does not have zero derivative normal to immersed boundaries. The consequence is that the velocity field in `NonhydrostaticModel` likely has divergence. With an ""immersed boundary unaware"" pressure correction step, we have to make a choice. Either . 1. The velocity field is divergence free, but does not satisfy impenetrability; or; 2. The velocity field satisfies impenetrability, but is not divergence free. We used to make choice 1, but I think we are currently making choice 2. (Note that both are ""wrong"" in that the correct dynamics are _both_ divergence free and satisfy impenetrability.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2891:505,wrap,wrapped,505,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2891,1,['wrap'],['wrapped']
Integrability,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:783,integrat,integrated,783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248,1,['integrat'],['integrated']
Integrability,The reason why this test does not pass on the GPU for periodic boundary conditions in the longitudinal direction might have something to do with the synchronization of the halo filling (PR #1985 which we might want to merge soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060:149,synchroniz,synchronization,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060,1,['synchroniz'],['synchronization']
Integrability,The right boundaries are _misidentified_ as halo regions and zeroed out when the field in question is located at cell interfaces along a `Bounded` direction:. https://github.com/CliMA/Oceananigans.jl/blob/01b248145356586f921239701b14c2f0e2073b27/src/BoundaryConditions/zero_halo_regions.jl#L24-L26,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/919:118,interface,interfaces,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/919,1,['interface'],['interfaces']
Integrability,"The tests in `test_cubed_spheres.jl` were not used (the file was not included). Therefore, the tests on vector rotation were not performed. This PR includes these tests in a new file on a coarse cubed sphere grid. ; @navidcy and @siddharthabishnu are there any tests in `test_cubed_spheres.jl` we want to salvage?. Another problem is the inclusion of `OrthogonalSphericalShellGrids` in the tests. This has caused a bit of problems because of circular dependency. . The inclusion of `OrthogonalSphericalShellGrids` in the tests is to have a non-trivial `OrthogonalSphericalShellGrid` in the tests. For the moment, however, it is used only in the vector rotation test (which was not performed anyways), which is covered by using a conformal cubed sphere. . For this reason thought to remove this dependency here since at the moment does not add anything, and I will open an issue to discuss which non-trivial OrthogonalSphericalShellGrid we want to build to test the OrthogonalSphericalShellGrid capabilities.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3881:451,depend,dependency,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3881,2,['depend'],['dependency']
Integrability,"The top of the error message on #1780 is. ```; Stacktrace:; [1] overdub; @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,2,['message'],['message']
Integrability,"The user API is currently inconsistent: sometimes users identify parameters (and of course model properties) with English names like `thermal_expansion`. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/BuoyancyModels/linear_equation_of_state.jl#L18. or `gravitational acceleration`,. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl#L21. but other times, users identify parameters with mathematical symbols like `ν`,. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L18. or `f₀`:. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/Coriolis/beta_plane.jl#L14-L15. I think we have basically decided that English names are preferred. But the ""legacy API"" is still around. `BetaPlane` is not even internally consistent: it asks for `rotation_rate` and `radius`, as well as `f₀` and `β`. Should we fix the issue? This would of course be a huge breaking change. But in that case, we should do it sooner rather than later. Sometimes this may not make sense --- I think colloquially it is more common to say ""`β`"" than ""planetary vorticity gradient"". Sometimes, the mathematical symbols has _become_ the English name. But many other times it does: we typically say ""viscosity"" rather than ""`ν`"". The ""legacy"" interface will become more and more prominent as we build out the ecosystem into ClimaOcean and ClimaSeaIce, where (hopefully) we will be using English names for everything. (Hopefully also OceanBiome is on the same page here.) Consistency helps us understand each other.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3301:1511,interface,interface,1511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3301,1,['interface'],['interface']
Integrability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:1092,depend,dependent,1092,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['depend'],['dependent']
Integrability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:725,wrap,wrap,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,1,['wrap'],['wrap']
Integrability,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499:864,integrat,integrated,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499,6,['integrat'],['integrated']
Integrability,"There are a few applications that require building fields before `IncompressibleModel`, in order to form `AbstractOperations` and `ComputedFields` that need be computed during a model time step (eg PR #1091). I think this use case will only become more and more important in the future. Currently this functionality is possible but plagued by a huge useability issue: the default `grid` has a halo size of 1, while most applications benefit from higher-order advection schemes. To hide the need to specify halo region sizes from users, we currently ""inflate"" halos inside the constructor for `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/5ddace160c2b8c4469d49f6b35c1c748879a0c17/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. This means that users who want to build fields before `IncompressibleModel` do, in fact, have to know the halo size they need to specify for their chosen advection scheme. This isn't well-documented right now... Somehow, we have to figure out how to smooth this whole process out. One huge help will simply be to choose a default advection scheme that is useful for science: either `UpwindBiasedFifthOrder` or `WENO5`, and to set the default halo size for the grid to 5. Having these default will mitigate the problem greatly I think. But we also probably need utilities (or documentation at the very least) that explains this issue and how to choose the halo size if one needed to build the grid outside the model. Or, perhaps there are even better solutions to this issue. Basically the point is that the grid depends ""circularly"" on aspects of `IncompressibleModel`, which becomes an issue when things like `VelocityFields` (which also depend on the grid) need to be constructed prior to `IncompressibleModel`. We don't want users to have to replicate the `IncompressibleModel` constructor in their scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245:1582,depend,depends,1582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245,2,['depend'],"['depend', 'depends']"
Integrability,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;   | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;   | Stacktrace:;   | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);   | @ Base ./error.jl:168;   | [2] #systemerror#62;   | @ ./error.jl:167 [inlined];   | [3] systemerror;   | @ ./error.jl:167 [inlined];   | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);   | @ Base ./iostream.jl:293;   | [5] open;   | @ ./iostream.jl:282 [inlined];   | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Base ./io.jl:328;   | [7] open;   | @ ./io.jl:328 [inlined];   | [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:182,depend,dependency,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['depend'],['dependency']
Integrability,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323:330,depend,dependant,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323,2,['depend'],"['dependant', 'depends']"
Integrability,"There is a fair amount of scalar iteration right now, largely I think because we have array-like objects (Fields, and friends) that lack fully-featured broadcasting capabilities. This means writing something like `a .== 2` triggers scalar iteration on the GPU because it hits Base broadcasting. We _can_ fix the problem by fleshing out broadcasting a bit so `a .== 2` works ""correctly"" / sensibly, but we haven't prioritized it (we also didn't have broadcasting at all for Field until a month or two ago). Possibly, if changing a global via `allowscalar(true)` were not available we would have been forced to address this deficiency in our Field abstraction sooner. So that could have been a good thing depending on your perspective. It did allow us to sweep some things under the hood. On the other hand I don't think we have any performance issues; scalar iteration is only used on very small arrays for testing where we are completely dominated by compile times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884:703,depend,depending,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884,1,['depend'],['depending']
Integrability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:91,depend,depends,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,1,['depend'],['depends']
Integrability,"There might be an issue with conditional computations but I'm not sure. For example, `ComputedField` has this `compute!` definition:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/computed_field.jl#L61-L62. I think we want something similar; eg we want the `time` argument in `KernelComputedField`:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L76. and we want to use `compute_at!(dependency, time)` here:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L78-L80",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205:512,depend,dependency,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205,1,['depend'],['dependency']
Integrability,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:817,interface,interface,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,['interface'],['interface']
Integrability,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:254,interface,interface,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719,4,"['depend', 'interface']","['depends', 'interface']"
Integrability,"There was a. ```Julia; x, y, z = node(...); ```. but only `z` was needed. And `node` returns a different-size tuple depending on how many dimensions of `grid` are non-flat. Thus there was issues sometimes. Now that part of the code became. ```Julia; z = znode(...); ```. which is much more robust!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3530:116,depend,depending,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530,1,['depend'],['depending']
Integrability,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:449,depend,dependent,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['depend'],['dependent']
Integrability,"There's an intriguing side benefit of this ""unified"" interface for output. It means that it is possible (though we don't have it now) for users to specify an ""output preference"" in a `Preferences.toml`, which would then determine the default behavior of `output!`. I think it also legitimately makes it easier to switching between formats.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948:53,interface,interface,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948,1,['interface'],['interface']
Integrability,"There's another limitation of the current scheme that's worth mentioning. The scheme currently precomputes the 3D diffusivity / viscosity field at cell centers, which means that a cell is ""unstable"" if _either_ vertical interface has a negative buoyancy gradient. But what we really want to do is precompute _stability_ (or the buoyancy gradient), which is more naturally located at vertical cell interfaces. This provides the tracer diffusivity directly; the momentum diffusivity can be calculated by checking the stability of two neighboring regions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746:220,interface,interface,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746,2,['interface'],"['interface', 'interfaces']"
Integrability,"There's been a bunch of interest in using Oceananigans for physical-biogeochemical interaction studies --- problems where systems of reacting tracers that represent either oceanic biological systems, chemical reactions and cycles, or both interact with turbulence and fluid dynamics simulated by Oceananigans. In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we mi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:473,interface,interfaces,473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['interface'],['interfaces']
Integrability,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:213,rout,routines,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,1,['rout'],['routines']
Integrability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:331,integrat,integrate,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['integrat'],['integrate']
Integrability,"These are definitely cool ideas for progress statements!. I see logging as being much more general though. It should also be used when printing progress statements, but I think it's especially useful to have `@debug` messages in certain places to help with debugging. And maybe `@info` messages so the user knows what the model is doing. It could get noisy if we get carried away with them but a user staring at a blank screen for 3 minutes might not know that the GPU stuff is just compiling in the background. More responsive software feels more user-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998:217,message,messages,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998,2,['message'],['messages']
Integrability,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:461,interface,interface,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400,10,['interface'],['interface']
Integrability,"These kernels:. https://github.com/CliMA/Oceananigans.jl/blob/1dbe86c49e1d4e013c5ea595f837b4c226b1561e/src/BoundaryConditions/fill_halo_regions.jl#L51-L66. use broadcasting and are thus executed on the default CUDA stream. We should rewrite these kernels using the `KernelAbstractions.jl` kernel language so that we can control when they are executed. In particular, kernel filling for periodic directions must be filled after non-periodic directions to ensure that corner points are set properly. We can potentially solve this problem by asking *only* the west, east halo-filling routines to fill corner points. This ensures the corner points will be filled if _at least_ one direction is periodic. In the case that no directions are periodic, the corner points do not need to be filled.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/811:581,rout,routines,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811,1,['rout'],['routines']
Integrability,"These lines multiply `h` (a field at ccc) with objects at `fcc` and `cfc` respectively. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L16-L17. This doesn't look correct, but if there is some logic that makes it correct, it should be documented with a comment at least. I think if the bathymetric height is defined at cell centers, then the bathymetric height at a cell interface might need to be defined as the maximum of the height of the adjacent cells.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3051:474,interface,interface,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3051,1,['interface'],['interface']
Integrability,"These lines should not be there and at the least lower the accuracy of calculations on stretched grids. We need tests that the metrics and grid geometry are correct for stretched grids (eg all the cell spacings added up gives the total domain size; cell centers are located halfway between cell interfaces, etc). . Not sure why these lines are there but it may have been necessary due to a serious bug with the vertically stretched Poisson solver that was fixed in https://github.com/CliMA/Oceananigans.jl/pull/1541. I'm not sure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755:295,interface,interfaces,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755,1,['interface'],['interfaces']
Integrability,"These resutls are great @whitleyv , well done! A few thoughts. First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419:565,integrat,integrated,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419,1,['integrat'],['integrated']
Integrability,"These tests aren't passing, and I have no clue why. The error is:. ```; ERROR: `Enzyme=7da242da-08ed-463a-9acd-ee780be4f1d9` depends on `ChainRulesCore=d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4`, but no such entry exists in the manifest.; ```. But I never changed anything related to that. Does anyone know what's going on?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095:125,depend,depends,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095,1,['depend'],['depends']
Integrability,"They don't right now, even though right now the lateral areas `Ax` and `Ay` do depend on horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Operators/spacings_and_areas_and_volumes.jl#L151. Though our underlying grids are ""extruded"" in the vertical (put another way, we make the thin shell approximation for spherical shell grids), vertical spacings may in principle need to depend on horizontal location to accurately represent bathymetry. Another way to see this is that the vertical spacings for `GridFittedBottom` (implemented in #2023) are. https://github.com/CliMA/Oceananigans.jl/blob/8eadc493e04002066448323573edcfde046b9c30/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L56-L62. thus conditioning on the function `is_immersed`. But `is_immersed` is evaluated at `(Center, Center, Center)`. But more general operators such as `Δzᶠᶜᶜ` may be needed for correct bathymetry representation. Note that we might need this note only to compute depths correctly, but also for correct diagnostics. cc @sandreza @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049:79,depend,depend,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049,2,['depend'],['depend']
Integrability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:387,integrat,integrated,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:428,interface,interface,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['interface'],['interface']
Integrability,"This PR adds MPI waits after sending and receiving all the halos and overlaps halo communication (thanks @christophernhill!). I was initially worried that overlapping halo communication would cause the corner halos to become wrong (I'm not even sure if the corner halos should be filled via communication?). But running the MPI example the movie looked fine so I'll keep the overlapping for now. Scaling benchmarks are better now! Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Strong scaling seems noisier/a bit worse for some reason (including a 104% efficiency hit haha) but definitely better than before. # Weak scaling (shallow water). ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┼─────────┤; │ (8192, 256) │ (1, 1) │ 1.188 s │ 1.190 s │ 1.190 s │ 1.193 s │ 416.81 KiB │ 2665 │ 5 │; │ (8192, 512) │ (1, 2) │ 1.187 s │ 1.192 s │ 1.192 s │ 1.200 s │ 408.80 KiB │ 3178 │ 10 │; │ (8192, 1024) │ (1, 4) │ 1.204 s │ 1.206 s │ 1.206 s │ 1.212 s │ 408.80 KiB │ 3178 │ 20 │; │ (8192, 2048) │ (1, 8) │ 1.220 s │ 1.223 s │ 1.223 s │ 1.230 s │ 408.80 KiB │ 3178 │ 40 │; │ (8192, 4096) │ (1, 16) │ 1.281 s │ 1.283 s │ 1.284 s │ 1.291 s │ 408.80 KiB │ 3178 │ 64 │; │ (8192, 8192) │ (1, 32) │ 1.347 s │ 1.417 s │ 1.424 s │ 1.497 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505:458,depend,dependent,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505,1,['depend'],['dependent']
Integrability,This PR adds `Oceananigans.Diagnostics.WindowedTimeAverage` for computing the average of a quantity or 'kernel' over a specified time window. The design of `WindowedTimeAverage` is discussed extensively on #501 . . This PR only implements the basic functionality needed to compute `WindowedTimeAverage`. A streamlined user interface through `JLD2OutputWriter` and `NetCDFOutputWriter` will be implemented in a future PR. Todo:. - [x] tests. Resolves #501,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/856:323,interface,interface,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/856,1,['interface'],['interface']
Integrability,"This PR adds a `BuoyancyField` which is a type of lazily computed field constructed via `b = BuoyancyField(model)`. . `BuoyancyField` represents model buoyancy in abstract operations:. ```julia; b = BuoyancyField(model); wb = ComputedField(w * b); ```. etc. This is important for nonlinear equations of state, where statistics that depend on buoyancy need to be calculated online. cc @BrodiePearson. Side note: we need the same for `PressureField`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/952:332,depend,depend,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/952,1,['depend'],['depend']
Integrability,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932:220,integrat,integration,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932,2,['integrat'],['integration']
Integrability,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:248,integrat,integrating,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['integrat'],['integrating']
Integrability,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970:566,depend,depend,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970,1,['depend'],['depend']
Integrability,"This PR adds a distributed constructor for `ShallowWaterModel`, pair programmed with @francispoulin. End goal might be to add a new example showing the distributed MPI interface! Might also showcase the shallow water model, NetCDF output, and plotting with CairoMakie?. This PR depends on PR #590 (which is why it's 90+ commits long...). Most recent 4 commits are the relevant ones.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430:168,interface,interface,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"This PR adds a docstring for `ImmersedBoundaryGrid` that includes the `active_cells_map` feature. It moves the interface to the top-level, and fixes `with_halo` to work with the new interface. We should add a test for `with_halo` with `ImmersedBoundaryGrid`. resolves #2988",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2989:111,interface,interface,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2989,2,['interface'],['interface']
Integrability,This PR adds a new example . This PR depends on #1091,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1243:37,depend,depends,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1243,1,['depend'],['depends']
Integrability,"This PR adds a new example called ""Microbial rock paper scissors"" in which an idealized diurnal cycle is simulated with an agent-based model of marine microbes as Lagrangian particles playing rock paper scissors. This example is loosely based off of https://github.com/ali-ramadhan/lagrangian-microbes and can be extended to to study competition between marine microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244:976,depend,depends,976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244,1,['depend'],['depends']
Integrability,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090:1209,integrat,integrator,1209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090,1,['integrat'],['integrator']
Integrability,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/731:803,Integrat,Integrate,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731,1,['Integrat'],['Integrate']
Integrability,This PR adds a set of changes so that needed dispatch paths for CubedSphereGrid are followed when CubedSphereFaceGrid tuple is wrapped in an ImmersedBoundary type. . With these changes the https://github.com/CliMA/Oceananigans.jl/blob/cnh-glw/immersed-cubed-sphere/validation/immersed_boundaries/immersed_cubed_sphere_rossby_haurwitz.jl code works identically for non-immersed and immersed cube sphere.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1737:127,wrap,wrapped,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1737,1,['wrap'],['wrapped']
Integrability,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:839,depend,depends,839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['depend'],['depends']
Integrability,"This PR adds a wrapper for boundary-conditions-as-functions called `BoundaryFunction`. From the docstring:. ```julia; """""" ; BoundaryFunction{B, X1, X2}(func). A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/513:15,wrap,wrapper,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/513,2,['wrap'],['wrapper']
Integrability,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602:680,integrat,integrate,680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602,1,['integrat'],['integrate']
Integrability,"This PR adds the capability for treating the ""33"" component of the symmetric isoneutral diffusive flux implicitly. cc @sandreza would be great if you test this. This depends on #2481",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2487:166,depend,depends,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487,1,['depend'],['depends']
Integrability,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753:22,depend,dependencies,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753,1,['depend'],['dependencies']
Integrability,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/936:169,Integrat,Integration,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936,1,['Integrat'],['Integration']
Integrability,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389:683,wrap,wrapped,683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082:261,synchroniz,synchronizes,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082,1,['synchroniz'],['synchronizes']
Integrability,"This PR aims to introduce and integrate Poisson solvers for vertically stretched grids developed by @christophernhill and @maleadt. Once this is merged alongside with PR #283 we should be able to support vertically stretched grid. For PPN boundary conditions, the system is solved for by eigenvalue-eigenvector factorization via FFTs in the horizontal and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reductio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:30,integrat,integrate,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['integrat'],['integrate']
Integrability,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331:57,message,message,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331,3,['message'],"['message', 'messages']"
Integrability,"This PR builds on @navidcy's excellent work to convert all the examples to Makie. I tried to unify the coding style in the examples as best I could. Also, there was a bit too much logging / plotting messages in the examples, which polluted the docs. TODO:. - [x] We should use `Axis3` in the baroclinic adjustment animation.; - [x] The stretched grid is not displayed in the tilted bottom boundary layer (we could also get rid of this, because we already visualize a similar stretched grid in another example); - [x] Remove logging noise from shallow water bickley jet, horizontal convection, and tilted bottom boundary layer examples",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576:199,message,messages,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576,1,['message'],['messages']
Integrability,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757:165,wrap,wrapped,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757,1,['wrap'],['wrapped']
Integrability,"This PR cleans up the `Fields` module: previously, `zeros` was overloaded in a confusing way that would return either `Array` / `CuArray` or an `OffsetArray` depending on the arguments. . This PR introduces a function `new_data` that returns an `OffsetArray`. `new_data` is intended to build `OffsetArrays` that hold the data associated with a field, using the architecture, grid eltype, and the field location to determine array type, size, and indexing. This PR moves the vanilla `zeros` definitions (convenience methods that use `eltype(grid)` to determine floating point type and `arch` to determine whether or not an array is converted to `CuArray`) to `Fields.jl` top-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/914:158,depend,depending,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/914,1,['depend'],['depending']
Integrability,This PR contains a handful of changes made en route to coupled global ocean sea-ice simulations. Right now it just has a tweak to the interface for AbstractModel and also makes LatitudeLongitudeGrid support Flat vertical directions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3351:46,rout,route,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3351,2,"['interface', 'rout']","['interface', 'route']"
Integrability,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1807:90,wrap,wrapping,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807,1,['wrap'],['wrapping']
Integrability,"This PR defines `minimum`, `maximum`, and `mean` for Oceananigans fields (not including halo points)!. I also originally added `extrema` but CUDA.jl actually doesn't support `extrema(::CuArray)` yet. This has been always a source of CUDA scalar operations, especially for new users so I think this PR improves the user interface as it returns the answer users expect (without any CUDA scalar operations). Note: This PR removes the `FieldMaximum` diagnostic and removes the sugary `mean(::Field)` function, so it's a breaking change. Resolves #1117",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1412:319,interface,interface,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1412,1,['interface'],['interface']
Integrability,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128:134,depend,dependent,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128,3,['depend'],"['depend', 'dependent']"
Integrability,"This PR ensures enough things are exported by Oceananigans that all the examples can get by with just `using Oceananigans`. The purpose of this PR is to make the package more user friendly as missing names, e.g. `ComputedField`, have become a large source of errors for new users. As this is a large change to the user interface, I've bumped v0.52.0. Resolves #1075; Resolves #1131; Resolves #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1406:319,interface,interface,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1406,1,['interface'],['interface']
Integrability,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:549,depend,dependencies,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['depend'],['dependencies']
Integrability,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,1,['interface'],['interface']
Integrability,"This PR generalizes `Reduction` to also support accumulating ""scanning"" operations like `cumsum!`. This should not change the existing user interface but instead add the new feature, something like. ```julia; cumulative_u = Accumulation(cumsum!, u, dims=3); ```. and. ```julia; cumint_u = CumulativeIntegral(u, dims=3); ```. ~~Previously I don't think this was possible on GPU because `cumsum!` was not supported for `CuArray` (?) But it is now it seems.~~ To support this feature, we've implemented kernels for forward and reverse accumulation. I also have used the generalization of `Scan` to clean up the internals / user interface for `Average` and `Integral` (now they are proper type aliases). cc @hdrake @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590:140,interface,interface,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590,2,['interface'],['interface']
Integrability,"This PR gets rid of the kwargs `computed_dependencies` and `parameters`. Instead we just have ""arguments"", which are varargs to the constructor:. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v); ```. `compute!` on `KernelFunctionOperation` calls `compute!` on all of the kernel arguments. I think this is a simpler and more intuitive interface leading to more understandable code.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2964:501,interface,interface,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964,1,['interface'],['interface']
Integrability,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015:24,interface,interface,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015,1,['interface'],['interface']
Integrability,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931:761,depend,depend,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1093:27,depend,dependent,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093,1,['depend'],['dependent']
Integrability,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972:390,interface,interfaces,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972,1,['interface'],['interfaces']
Integrability,"This PR implements a primitive immersed boundary scheme that is ""fitted"" to the grid. The scheme is specified with a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we nee",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:987,wrap,wrapper,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,1,['wrap'],['wrapper']
Integrability,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2023:985,integrat,integrated,985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023,1,['integrat'],['integrated']
Integrability,"This PR implements an extension to Oceananigans with `convert_arguments` for Makie plots. For example:. ```julia; julia> using Oceananigans, GLMakie; Precompiling Oceananigans; 7 dependencies successfully precompiled in 18 seconds. 157 already precompiled.; [ Info: Precompiling GLMakie [e9467ef8-e4e7-5192-8a1a-b1aee30e663a]; [ Info: Precompiling OceananigansMakieExt [8b7e02c2-18e1-5ade-af7b-cfb5875075c8]; [ Info: Precompiling ChainRulesCoreExt [eae2faf6-b232-58cb-a410-7764fda2830c]. julia> grid = RectilinearGrid(size=(10, 10, 10), x=(0, 1), y=(0, 1), z=(0, 1)); 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.1; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.1. julia> c = CenterField(grid); 10×10×10 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 16×16×16 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, -2:13) with eltype Float64 with indices -2:13×-2:13×-2:13; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, (x, y, z) -> rand()); 10×10×10 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 16×16×16 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, -2:13) with eltype Float64 with indices -2:13×-2:13×-2:13; └── max=0.998531, min=0.000368158, mean=0.516368. julia> heatmap(view(c, :, 2, :)); ```. <img width=""597"" alt=""image"" src=""https://github.com/user-a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686:179,depend,dependencies,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686,1,['depend'],['dependencies']
Integrability,"This PR implements support for specifying non-zero fluxes across immersed boundaries via `FluxBoundaryCondition`. Currently, immersed boundaries are insulating (no flux / free-slip) via these pieces of code:. ```julia; # Calculate the (1, 1) component of the viscous flux tensor on a grid with an immersed boundary; @inline _viscous_flux_ux(i, j, k, ibg::GFIBG, args...) = conditional_flux_ccc(i, j, k, ibg, viscous_flux_ux, args...). # Return zero if solid or the viscous flux if fluid:; @inline conditional_flux_ccc(i, j, k, ibg::IBG{FT}, flux, args...) where FT = ifelse(solid_node(c, c, c, i, j, k, ibg), zero(FT), flux(i, j, k, ibg, args...)); ```. The implementation in this PR changes this code to:. 1. Calculate the immersed flux; 2. Compute the boundary normal (either +1 or -1 depending on the orientation of the immersed boundary); 3. If on a node that's a boundary between solid and fluid, insert the calculated immersed flux rather than the ""intrinsic"" viscous flux. It's a WIP, but opening now to get CI. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1860:787,depend,depending,787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1860,1,['depend'],['depending']
Integrability,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:618,interface,interface,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['interface'],['interface']
Integrability,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3585:601,depend,depends,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585,2,"['depend', 'rout']","['depends', 'routine']"
Integrability,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:44,integrat,integration,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,2,['integrat'],['integration']
Integrability,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888:553,message,message,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888,1,['message'],['message']
Integrability,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:133,integrat,integrating,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,1,['integrat'],['integrating']
Integrability,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['integrat'],['integrates']
Integrability,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245,1,['integrat'],['integrates']
Integrability,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['integrat'],['integrates']
Integrability,"This PR introduces _halo regions_ instead of using wrap-around `indmod1` and `decmod1` functions to account for horizontally periodic boundary conditions. It will allow us to more easily implement multiple wall-bounded dimensions, e.g. channel models #100. This is also a good first step towards distributed parallelization with MPI. Resolves #45 ; Resolves #104 ; Resolves #122",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/167:51,wrap,wrap-around,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/167,1,['wrap'],['wrap-around']
Integrability,"This PR introduces a `Simulation` type that manages time stepping with a high level interface. I think `diagnostics` and `output_writers` will have to become keyword arguments to `time_step!`. It will be a pretty big breaking change once we move `diagnostics` and `output_writers` outside of `Model` so would be good to agree on the design and API before refactoring. @glwagner Let me know what you think, we can iterate on the design in this PR. Resolves #432 ; Resolves #447",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621:84,interface,interface,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621,1,['interface'],['interface']
Integrability,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290:684,bridg,bridge,684,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290,1,['bridg'],['bridge']
Integrability,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:641,integrat,integrate,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['integrat'],['integrate']
Integrability,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841,3,"['Interface', 'interface']","['InterfaceImmersedCondition', 'interface']"
Integrability,"This PR introduces the concept of an output writer ""diagnostic dependency"": a diagnostic which must be added to `simulation.diagnostics` in order for output to be correct. If a type of output has a ""diagnostic dependency"", it must define the function `add_dependency!(diagnostics, output)`, which will add any appropriate diagnostics to the ordered dictionary `diagnostics`. Currently we only have one type of output that requires a diagnostic, which is the `WindowedTimeAverage`. For `WindowedTimeAverage`, `add_dependency!` is. ```julia; add_dependency!(diags, wta::WindowedTimeAverage) = !(wta ∈ values(diags)) && push!(diags, wta); ```. (As a side note, we could require that all values of `diagnostics` are unique, which would obviate the check above.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/886:63,depend,dependency,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/886,2,['depend'],['dependency']
Integrability,"This PR investigates the possibility of using a convex combination of high-order stencils to calculate horizontal divergence. The goal is to use a stencil for horizontal divergence that tames the omnipresent grid-scale noise in the vertical velocity field in large-scale hydrostatic models. TODO:. - [ ] Add `divergence` property to `HydrostaticFreeSurfaceModel` and pass stencil info into kernels; - [ ] Update implicit free surface to use the vertical integral of horizontal divergence, rather than vertical integrating the velocity fields separately; - [ ] Fuse `Advection` module into `Operators`? The module `Advection` just defines stencils after all...; - [ ] Implement `UpwindWENO4` and `CenteredWENO5` horizontal divergence stencils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388:510,integrat,integrating,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388,1,['integrat'],['integrating']
Integrability,"This PR is an attempt at unifying the directions used by `TurbulenceClosures` a bit, in addition to a few minor things. In summary, this PR. - Nukes the `Vertical` definition at `abstract_scalar_diffusivity_closure.jl` and uses the already-defined `ZDirection` instead. I think this decreases the amount of code but is also more accurate (since for rotated domains the `z` direction of the code isn't necessarily the ""physical"" vertical direction); - Renames `ThreeDimensional`, `Horizontal` to `XYZDirections` and `XYDirections` and moves their definition to `Grids`. This was done for consistency with `ZDirection` and also follows the same argument about rotated domains.; - Exports `XYZDirections`, `XYDirections` and `ZDirection` at the top level; - Makes minor improvements to documentation. I could also change the notation from `isotropy` to `dimensions`, according to https://github.com/CliMA/Oceananigans.jl/issues/2261, depending on how people feel. I haven't done that yet because there doesn't appear to be a consensus on what to do there as of writing this. Closes https://github.com/CliMA/Oceananigans.jl/issues/2254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266:931,depend,depending,931,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266,1,['depend'],['depending']
Integrability,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:293,depend,depending,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,1,['depend'],['depending']
Integrability,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:148,integrat,integration,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,1,['integrat'],['integration']
Integrability,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214:126,depend,depend,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214,1,['depend'],['depend']
Integrability,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253:129,integrat,integrate,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253,1,['integrat'],['integrate']
Integrability,"This PR makes it a bit easier to prescribe `BoundaryFunction`s by providing field-specific constructors. The field-specific constructors ""know"" about the locations of tracers and velocity fields and relieve the user of the (often confusing) task of specifying the `BoundaryFunction` location.; I also added a further wrapper around `BoundaryCondition` to permit patterns like. ```julia; northern_velocity(x, z, t) = cos((x - sin(t))); u_bcs = UVelocityBoundaryConditions(grid, north=UVelocityBoundaryCondition(Value, :y, northern_velocity)); ```. It doesn't look perfect to me, but I do think it's progress over what the user had to do previously. A potential source of confusion (?) is that `UVelocityBoundaryCondition` is only needed for simple boundary functions. We could alleviate this with more verbosity; eg `UVelocityFunctionBoundaryCondition` or something silly like that. But I'm hesitant because we already seem to have a verbosity problem. We need better design, not more words... I've also added a `parameters` field to `BoundaryFunction`. (It only just occurs to me that perhaps what we want are types like `Tracer()`, `U()`, `V()`, and `W()`. We might use these to classify boundary conditions and forcing functions... ?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699:317,wrap,wrapper,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699,1,['wrap'],['wrapper']
Integrability,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:828,depend,depend,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['depend'],['depend']
Integrability,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2320:404,integrat,integration,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320,2,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:174,interface,interface,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1040:924,interface,interface,924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040,1,['interface'],['interface']
Integrability,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:263,interface,interface,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,1,['interface'],['interface']
Integrability,This PR removes any conformal mapping-related properties from the `OrthogonalSphericalShellGrid` and thus now `OrthogonalSphericalShellGrid` is any grid with coordinates and metrics that depend on both horizontal dimensions. The PR also adds a `conformal_cubed_sphere_panel` constructor that returns the grid that corresponds to each panel of a conformal cubed sphere grid. Closes #3200,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3230:187,depend,depend,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230,1,['depend'],['depend']
Integrability,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:492,integrat,integrating,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,1,['integrat'],['integrating']
Integrability,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279:335,rout,routine,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279,1,['rout'],['routine']
Integrability,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/742:68,depend,dependency,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742,2,['depend'],"['depend', 'dependency']"
Integrability,"This PR renames `TKEBasedVerticalDiffusivity` as `CATKEVerticalDiffusivity`, and implements the _triple max_ CATKE formulation that involves a ""convective mixing length"", in addition to the grid-proportional mixing length, and stably stratified mixing length. This formulation is described here (missing some context):. ![image](https://user-images.githubusercontent.com/15271942/128558326-5ee9e1dd-9f0e-4c98-91ee-694b4e9d72c4.png). This requires some minor modifications to the `HydrostaticFreeSurfaceModel` time-stepping algorithm and also refactoring of the `calculate_diffusivities!` interface. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1926:588,interface,interface,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1926,1,['interface'],['interface']
Integrability,"This PR replaces #3509. Also, it builds off #3585 which hopefully we can merge soon so we don't enter merge conflict hell. In short this PR implements k-epsilon. Although, the version that's implemented now is not by-the-book k-epsilon but rather a simplified version. I'd like to merge this PR basically as is and hopefully continue to work on it in the future. There are some numerical considerations which should be reviewed and documented I think. First of all is the challenge of specifying a minimum tke, minimum dissipation rate, and also a maximum dissipation rate. These are useful for producing smooth diffusivities, which note are . $$ \kappa \sim \frac{e^2}{\epsilon} $$. But then there are challenges with implementing the TKE and dissipation equations. Because depending on the term, one may either want to impose or not impose these constraints. It could be useful to try to get some lessons from other codes too. It's not ready for production use, but at least it's doing reasonable things... <img width=""384"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/c7df14e6-8ed2-4c13-b892-99b04e5f8809"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605:775,depend,depending,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605,1,['depend'],['depending']
Integrability,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:967,wrap,wrapped,967,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,3,"['interface', 'wrap']","['interface', 'wrapped']"
Integrability,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412:26,interface,interface,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412,1,['interface'],['interface']
Integrability,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:43,integrat,integrating,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,2,"['integrat', 'wrap']","['integrating', 'wraps']"
Integrability,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:112,integrat,integration,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,1,['integrat'],['integration']
Integrability,This PR splits up the model tests into two and adds explicit dependencies for Buildkite jobs. Both these changes should speed up testing. Resolves #1048 ; Resolves #1056,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1064:61,depend,dependencies,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1064,1,['depend'],['dependencies']
Integrability,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309:32,integrat,integrating,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309,1,['integrat'],['integrating']
Integrability,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:49,interface,interface,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,2,"['inject', 'interface']","['injecting', 'interface']"
Integrability,"This PR tries to improve the GPU efficiency of the WENO algorithm by; - using fast math for smoothness calculation (this should not be a problem since weights are normalized); - resorting the WENO algorithm to enforce register reuse by accumulating the solution instead of computing all the stencils at tge same time. WENO-Z weights are calculated as $$\alpha_s = C_s \left( 1 + \left(\frac{\tau}{\beta_s +\varepsilon}\right)^2 \right)$$; and the interpolation is calculated as $$\psi =\frac{1}{\sum \alpha_s} \sum \psi_s \alpha_s$$; so if we reorder we can calculate $\psi$ as $$\psi = \frac{ \tau^2 \hat{\psi}_1 + \hat{\psi}_2}{ \tau^2 \sum \alpha^{\star}_s + 1}$$; where $$\hat{\psi}_1 = \sum\psi_s \alpha^{\star}_s$$ and $$\hat{\psi}_2 = \sum \psi_s C_s$$ and $\alpha^{\star}_s$ are the WENO-JS coefficients that depend only on the local stencil: $$\alpha^{\star}_s = \frac{C_s}{(\beta_s + \varepsilon)^2}$$; We can then calculate stencils one by one by accumulating the results and ""throwing away"" registers we don't need after the computation. This PR is a draft because, despite it works, everything is written down manually unrolled and maybe there is a way to express the same concept with metaprogramming",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3518:817,depend,depend,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3518,1,['depend'],['depend']
Integrability,This PR tweaks the interface for `Simulation` to make it easier to build new models. These improvements will help [`ClimaSeaIce` ](https://github.com/CliMA/ClimaSeaIce.jl) implement a new sea ice model that can leverage `Oceananigans.Simulation`. I've also included a few minor miscellaneous improvements to kernel launching + documentation. This PR deletes MEWSVerticalDiffusivity (which nobody used and is not planned to be developed anymore).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3282:19,interface,interface,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282,1,['interface'],['interface']
Integrability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:551,depend,depend,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['depend'],['depend']
Integrability,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437:853,interface,interface,853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437,1,['interface'],['interface']
Integrability,"This PR would add a [""Strange splitting""](http://hplgit.github.io/fdm-book/doc/pub/book/sphinx/._book018.html) time stepper where the biogeochemical components of the tendencies are computed more frequently than the transport since biogeochemistry can often be much stiffer and so it is relatively common practice to step the bgc at different frequencies to the physics (e.g. NEMO-PISCES allows multiple euler substeps to be taken between each physics step). Strange splitting assumes the tendency can be written as a stiff and non-stiff part:; $\frac{\partial C}{\partial t} = \mathcal{A} + \mathcal{B}$,; where $\mathcal{A}$ is the advection (less stiff) and $\mathcal{B}$ is the BGC (more stiff) components.; And we basically take half a step with just the stiff component, then a full step with just the non-stiff component, and finally another step with the stiff component.; i.e. we have $C^n$ then:; $C^{n+1/2} = C^n + \int_{t_n}^{t_n+\Delta t/2}\mathcal{B}\left(C^n\right)dt,$; $C^* = C^{n+1/2} + \int_{t_n}^{t_n+\Delta t}\mathcal{A}\left(C^{n+1/2}, \vec{u^n}\right) dt, $; $C^{n+1} = C^* + \int_{t_n +\Delta t / 2}^{t_n+\Delta t}\mathcal{B}\left(C^*\right)dt.$. This is supposedly $\mathcal{O}(\Delta t ^2)$ from the splitting, so you can take the substeps with $\mathcal{O}(\Delta t ^2)$ schemes. To do this I had to implement quite a few changes so that you can optionally turn off bgc transitions in the normal tendency calculation, and then add some new functions to the time steppers to allow them to just compute the tendencies for, and step the bgc. This currently does not work, but I ran out of time to debug it. If there is interest in using this I would be happy to have another look at it. Another thought I had was that we could allow the biogeochemical sub-stepping to be performed by e.g. DifferentialEquations.jl timesteppers, but then I realised it wouldn't be that straight forward to make a wrapper for them to work in oceananigans so decided to leave it for another time.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888:2041,wrap,wrapper,2041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888,1,['wrap'],['wrapper']
Integrability,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:876,rout,routine,876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,1,['rout'],['routine']
Integrability,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664:166,depend,depends,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664,1,['depend'],['depends']
Integrability,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:870,integrat,integrated,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,1,['integrat'],['integrated']
Integrability,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:220,wrap,wrapped,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['wrap'],['wrapped']
Integrability,"This code works:. ```julia; julia> using CUDA.CUSPARSE, SparseArrays, LinearAlgebra. julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0]); 3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B = CuSparseMatrixCSC(A); 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B += 1I; 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 1 ⋅ 1; ⋅ 3 ⋅; ⋅ ⋅ 1; ```. There's some `UniformScaling` stuff here: https://github.com/JuliaGPU/CUDA.jl/blob/06e8a4ccca62567d38a567874f82cb58517d8f01/lib/cusparse/interfaces.jl#L179. These appear to be allocating, so it still might make sense to decompose the matrix into a diagonal and off-diagonal component.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389:578,interface,interfaces,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389,1,['interface'],['interfaces']
Integrability,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/68:372,wrap,wrappers,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68,1,['wrap'],['wrappers']
Integrability,"This has implications in terms of code performance, if we have `set!(field)` somewhere in the code it will trigger automatically a `fill_halo_regions!` which we might not want as we are very careful to where we call `fill_halo_regions!`. There are two options then:; (1) remove all instances of `set!` in the internals and make sure to never use it; (2) implement a different interface that can be user-facing which triggers set! and fill_halo_regions! together. I would vote for (2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115:376,interface,interface,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115,1,['interface'],['interface']
Integrability,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:429,message,message,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614,1,['message'],['message']
Integrability,This is a lot more sustainable than adding new properties to every output writer every time we want to support splitting a file by a different criterion. It's a decent change to the user interface. I can help if you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454:187,interface,interface,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454,1,['interface'],['interface']
Integrability,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360:355,interface,interface,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:155,depend,depends,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893,2,['depend'],['depends']
Integrability,This is another reason why the `Checkpointer` essentially has to depend on the `simulation` rather than just the `model`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055,1,['depend'],['depend']
Integrability,"This is because the right-hand-side of the pressure Poisson equation depends on 1/Δt so Δt=0 leads to an `Inf` source term:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Solvers/solve_for_pressure.jl#L41. This wasn't an issue before since we never `time_step!(model, 0)` but now that the time step is aligned with output writing and simulation stop times, it's possible to end up calling `time_step!(model, 0)`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Simulations/run.jl#L159-L161. Not sure of the best solution to this but one possible solution is if calling `time_step!(model, 0)` causes it to return early without doing anything. I added the ""high priority"" label to this issue since it can cause the output to contain `NaN` at the last time step, very undesirable for users.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1254:69,depend,depends,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254,1,['depend'],['depends']
Integrability,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:901,integrat,integrate,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['integrat'],['integrate']
Integrability,This is helpful - thanks Greg. It's good to have some options when unable to find the error messages during debugging!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162:92,message,messages,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162,1,['message'],['messages']
Integrability,This is mostly to fix the CUDA dependency issues we're currently getting on the CI pipelines. We will live dangerously on four `#master` dependencies!; ```; ] add CuArrays#master CUDAnative#master CUDAdrv#master NNlib#master; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/197:31,depend,dependency,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197,2,['depend'],"['dependencies', 'dependency']"
Integrability,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:600,depend,dependencies,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,2,['depend'],"['dependencies', 'dependency']"
Integrability,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:326,integrat,integrate,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052,1,['integrat'],['integrate']
Integrability,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:23,interface,interface,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592,8,"['depend', 'interface']","['depend', 'interface', 'interfaces']"
Integrability,"This is the bathymetry that the code is currently using. Looks pretty nice. @simone-silvestri I am looking in `shallow_water_advection_operators.jl` and find something odd. Bathymetry only appears in `div_Uh` but not in `div_hUu` and `div_hUv`. I think this is reversed as the evolution equation for height doesn't care about the bathymetry, it's only the pressure term that depends on it. Do you agree?. ; ![topography](https://user-images.githubusercontent.com/8239041/168833014-c399f006-b5cb-4c30-b72c-f4b221b911c0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255:375,depend,depends,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255,1,['depend'],['depends']
Integrability,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107,1,['interface'],['interface']
Integrability,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551,12,['interface'],"['interface', 'interfaces']"
Integrability,"This likely removes some of the single device parallelism,; but decreases the risk for user mistake (everything is stream-ordered). This will cause severe merge conflicts with open PRs and depends on currently unreleased; versions of CUDA & KernelAbstractions. So I might regret doing it now, but I was curious; to see what the damage would be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924:189,depend,depends,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924,1,['depend'],['depends']
Integrability,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:212,message,message,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['message'],['message']
Integrability,This looks great! I think we can re-state light integration as a field reduction with this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281:48,integrat,integration,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281,1,['integrat'],['integration']
Integrability,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:1064,depend,dependency,1064,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,1,['depend'],['dependency']
Integrability,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:118,interface,interface,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999,4,['interface'],['interface']
Integrability,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2738:416,depend,depend,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1673:483,depend,depend,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517:424,depend,depend,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517,2,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3070:414,depend,depend,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1474:459,depend,depend,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1102:445,depend,depend,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2124:424,depend,depend,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2123:428,depend,depend,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2539:425,depend,depend,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1475:455,depend,depend,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:463,depend,depend,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/751:475,depend,depend,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751,2,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3366:420,depend,depend,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366,1,['depend'],['depend']
Integrability,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1563:467,depend,depend,467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563,1,['depend'],['depend']
Integrability,"This really depends where we want to take this abstraction. One possibility is to develop ""four-dimensional fields"". This is sort of what the design reflects now (ie we subtype `AbstractField`, etc). Another possibility is to ditch that and cement `Fields` as 3 dimensional and less, and commit the `FieldTimeSeries` abstraction to look like a 1D vector of 3D fields. It seems like a subtle distinction, but is has some important consequences. For example, what should. ```julia; first(fts::FieldTimeSeries); ```. return? If `FieldTimeSeries` is 4D then this is either `parent(fts)[1, 1, 1, 1]` or `fts.data[1, 1, 1 ,1]`. But if `FieldTimeSeries` is 1D this is `fts[1]` --- the first _Field_. I think it's nice to have `first(fts)` and `last(fts)` return fields --- we use stuff like that _a lot_, but right now we are forced to write stuff like. ```julia; Nt = length(fts.times); fts[Nt]; ```. kind of annoying. Right now the API is hybrid; ie we have `getindex(fts, i)` _and_ `getindex(fts, i, j, k, n)`. But we use the ""vector"" abstraction more than the ""4D field mode"" a lot more I think. One downside is that this might preclude defining a `∂t` abstract operation. I don't think this impacts support for reductions, but I have to think about that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2492:12,depend,depends,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2492,1,['depend'],['depends']
Integrability,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/891:261,message,messages,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891,1,['message'],['messages']
Integrability,"This should be done already (I'm not sure why the tests keep failing, its annoying). I made the change because I seriously could not understand the code. I kept getting confused between ""compute boundary tendencies"" (which adds fluxes to the tendencies, coming in from the boundaries), and ""compute tendencies_boundaries"", which did something completely different (compute the halo dependent tendencies). So I started by changing the names so I could reason about the code without my head spinning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325:382,depend,dependent,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325,1,['depend'],['dependent']
Integrability,"This velocity field:. ```julia; uᵢ(x, y, z) = (1-tanh((x-500)/10)); ```. is compressible, because `uᵢ` depends on `x`. When we project out the compressible component (the part that depends on `x`), we are left with just `u=1`. What do we expect to happen in this case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462:103,depend,depends,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462,2,['depend'],['depends']
Integrability,This was my last attempt to integrate the vertically stretched grid into Oceananigans. This branch is probably too old and stale to be rebased so I'm just opening it so we can see the state of the branch. Will probably start a new branch and copy paste a lot of this stuff into there.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1332:28,integrat,integrate,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332,1,['integrat'],['integrate']
Integrability,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:48,interface,interface,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['interface'],['interface']
Integrability,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:146,message,messages,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,"['Depend', 'message']","['Dependent', 'messages']"
Integrability,Throw helpful message for common `NamedTuple` typo?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269:14,message,message,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269,1,['message'],['message']
Integrability,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073:98,depend,depended,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073,3,['depend'],"['depend', 'depended']"
Integrability,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:662,wrap,wrapping,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599,1,['wrap'],['wrapping']
Integrability,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:394,depend,depends,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543,2,['depend'],['depends']
Integrability,"To asynchronously fill the halos of distributed fields, the code uses an incremental counter to track how many MPI requests are live and update the MPI send and receive tag. The counter is reset when communication is synchronized. As it is defined right now, the counter is always incremented at the end of a `fill_halo_regions!` on a distributed grid, irrespective of what happened in the `fill_halo_regions!`, with the assumption that all cores participate in the `fill_halo_regions!` so the counters are correctly synchronized. ; https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L117-L121. Unfortunately, I experienced a situation where this was not the case. ; In this case, I wanted to do different things on different cores, which is allowed when using the `only_local_halos = true` keyword argument (a very rare occurrence, but a possibility nonetheless). For example, if we execute this code on the main branch; ```julia; arch = Distributed(CPU()); grid = RectilinearGrid(size = (2, 2, 1), extent = (1, 1, 1)); c = Field(grid). if arch.local_rank == 0; fill_halo_regions!(c; only_local_halos = true); end; ```; The mpi_tag will be `1` on rank 0 and `0` on other ranks. This means that in subsequent halo passes, MPI will stall because it cannot match the tag between the send and receive operations of cores that communicate with rank 0. This PR fixes this issue by incrementing the counter _only_ if we have actually launched a mpi send or receive operation, that happens when at least one of the `bcs` is a distributed boundary condition _and_ `only_local_halos == false`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714:217,synchroniz,synchronized,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714,2,['synchroniz'],['synchronized']
Integrability,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1103:417,depend,dependent,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103,2,['depend'],['dependent']
Integrability,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609:202,integrat,integration,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609,2,['integrat'],['integration']
Integrability,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:725,integrat,integrate,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"To compare the numerical solution of the Rossby-Haurwitz wave on the cubed sphere against an established benchmark, I chose the exact solution of the non-linear barotropic vorticity equation on the sphere (not the solution of the non-linear shallow water equations). This was achieved by replacing the initial phase Rλ with the time-dependent phase Rλ−νt in Equations (143)–(146) of [Williamson et al.](https://www.sciencedirect.com/science/article/pii/S0021999105800166), using the angular velocity ν given by Equation (142). The results at a resolution of 128x128 cells per panel are as follows:. - Since we prescribe the initial stream function and numerically take its derivatives to specify the initial velocities on the cubed sphere, numerical errors are present even in the initial velocities and the diagnosed initial vorticity. The vorticity error is significantly pronounced near the cubed sphere corners due to the deviation from orthogonality. For instance, in the domain's interior, the vorticity error norm is three orders of magnitude less than the vorticity norm, whereas at the corners, it is nearly the same order of magnitude.; - As the simulation progresses, the amplified error from the corners propagates into the interior as expected. After 500 time steps, the vorticity error in the interior increases from three orders of magnitude less to one order of magnitude less than the vorticity norm. I have attached panel-wise plots of the exact vorticity and the error of its numerical counterpart on the cubed sphere for the initial condition and after 500 time steps for reference. Given these circumstances, @navidcy and I are contemplating whether we should continue using the exact solution for verification in the test script or consider alternative verification methods, such as ensuring that the norm of the numerical solution of the Rossby-Haurwitz wave remains bounded within a specified range (as mentioned in the introduction to this PR). @glwagner, @simone-silvestri an",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684:333,depend,dependent,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684,1,['depend'],['dependent']
Integrability,"To do:. - Implement `mul!` for the Laplacian operator; - Implement a wrapper type for `Field` that subtypes `AbstractVector`?; - Implement `ldiv!` for the FFT-based preconditioner (after the first two are done), planning to use [`ldiv=true` with `cg`](https://jso.dev/Krylov.jl/dev/preconditioners/#Examples). This example illustrates implementing a custom operator:. https://jso.dev/Krylov.jl/dev/matrix_free/. Here is the documentation for implementing preconditioners in Krylov:. https://jso.dev/Krylov.jl/dev/preconditioners/. In Krylov, we want to remove broadcasting. . To make `Field` look like a vector we just need. ```julia; struct QuasiVector{FT, F} <: AbstractVector{FT}; field :: F; function QuasiVector(field); FT = eltype(field); F = typeof(field); return new{FT, F}(field); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451:69,wrap,wrapper,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451,1,['wrap'],['wrapper']
Integrability,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:921,depend,dependencies,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423,3,['depend'],"['dependencies', 'dependency']"
Integrability,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:441,depend,depend,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652,2,['depend'],['depend']
Integrability,"To use compression in `NCDatasets` , the keyword for `defVar` should be `deflatelevel` instead of `compression`. `defVar` does not show any warning message for unrecognized keywords. **Breaking change**: This PR induces a breaking change in the `NetCDFOutputWriter` constructor since the `compression` kwarg is now renamed to `deflatelevel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153:148,message,message,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153,1,['message'],['message']
Integrability,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284:234,depend,dependency,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284,2,['depend'],"['dependencies', 'dependency']"
Integrability,"Tthe MPI tag must be an integer. The maximum value is vendor dependent but it is quite strict. ; The smaller maximum value is [32767](https://www.intel.com/content/www/us/en/developer/articles/technical/large-mpi-tags-with-the-intel-mpi.html#:~:text=For%20the%20InfiniBand*%20support%20via,be%20queried%20in%20the%20application.). We could probably record the whole location without incurring in integer dimension issue. We cannot do ; `field_id * 100000 + loc_x * 10000 + loc_y * 1000 + loc_z * 100 + from_side * 10 + to_side` because the tag could be larger than 32767. ; However, we could combine the three locations in a dictionary; ```julia; (Center, Center, Center) -> 0; (Center, Center, Face) -> 1; (Center, Face, Center) -> 2; (Face, Center, Center) -> 3; (Face, Face, Center) -> 4; (Center, Face, Face) -> 5; (Face, Center, Face) -> 6; (Center, Center, Nothing) -> 7; (Face, Center, Nothing) -> 8; (Center, Face, Nothing) -> 9; ...; ```; If all the permutations fit into 99 values, we consume only 2 digits which would probably fit within the limits. We can also compress the `from_side` and `to_side` into only one digit because we have; ```julia; west to east -> 0; east to west -> 1; south to north -> 2; north to south -> 3; top to bottom -> 4; bottom to top -> 5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373:61,depend,dependent,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373,1,['depend'],['dependent']
Integrability,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:45,depend,dependent,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585,1,['depend'],['dependent']
Integrability,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:13507,depend,dependency-tracking,13507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['depend'],['dependency-tracking']
Integrability,"Unfortunately it doesn't work for me:. ```julia; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ -e 'using Pkg; Pkg.instantiate()'; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ docs/make.jl; ERROR: LoadError: LoadError: LoadError: ArgumentError: Package SpecialFunctions [276daf66-3868-5448-9aa4-cd146d93841b] is required but does not seem to be installed:; - Run `Pkg.instantiate()` to install all recorded dependencies. Stacktrace:; [1] _require(pkg::Base.PkgId); @ Base ./loading.jl:990; [2] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [3] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [6] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compile",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:453,depend,dependencies,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['depend'],['dependencies']
Integrability,Unified forcing function interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896:25,interface,interface,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896,1,['interface'],['interface']
Integrability,"Unifies interfaces in `NetCDFOutputWriter`, `JLD2OutputWriter` and `Checkpointer`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416:8,interface,interfaces,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416,1,['interface'],['interfaces']
Integrability,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:50,depend,dependency,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['depend'],['dependency']
Integrability,"Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146:136,synchroniz,synchronization,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146,1,['synchroniz'],['synchronization']
Integrability,Update dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860:7,depend,dependencies,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860,10,['depend'],['dependencies']
Integrability,Update dependencies + use Documenter v1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3310:7,depend,dependencies,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3310,1,['depend'],['dependencies']
Integrability,Update dependencies and use Julia 1.9.3 for CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3258:7,depend,dependencies,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3258,1,['depend'],['dependencies']
Integrability,Update dependency packages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2447:7,depend,dependency,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447,1,['depend'],['dependency']
Integrability,Update package's dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1808:17,depend,dependencies,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1808,2,['depend'],['dependencies']
Integrability,Updates dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3101:8,depend,dependencies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3101,1,['depend'],['dependencies']
Integrability,Updates dependencies versions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2489:8,depend,dependencies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2489,1,['depend'],['dependencies']
Integrability,Updates output writers interface to append extension automatically,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435:23,interface,interface,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435,1,['interface'],['interface']
Integrability,Updates package dependencies to latest version,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1745:16,depend,dependencies,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1745,1,['depend'],['dependencies']
Integrability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:172,depend,depending,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['depend'],['depending']
Integrability,User interface for adding topography/boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/694:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/694,1,['interface'],['interface']
Integrability,User interface for masking output on `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061,1,['interface'],['interface']
Integrability,User interface for outputting boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3082:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3082,1,['interface'],['interface']
Integrability,User interface for specifying advection schemes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/695:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/695,1,['interface'],['interface']
Integrability,User interface for specifying stretched coordinates and curvilinear grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551,1,['interface'],['interface']
Integrability,User interface to `ConditionalOperand`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2188:5,interface,interface,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2188,1,['interface'],['interface']
Integrability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:95,depend,depend,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['depend'],['depend']
Integrability,"Using this branch I get. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:245; ERROR: ArgumentError: halo must be ≤ size for coordinate y; Stacktrace:; [1] validate_halo(TX::Type, TY::Type, TZ::Type, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/input_validation.jl:87; [2] validate_rectilinear_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, extent::Nothing, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:292; [3] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{…}, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}, halo::Tuple{…}, extent::Nothing, topology::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:269; [4] with_halo(new_halo::Tuple{…}, old_grid::RectilinearGrid{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:389; [5] inflate_grid_halo_size(::RectilinearGrid{…}, ::WENO{…}, ::Vararg{…}); @ Oceananigans.Models.Nonhyd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352:91,depend,dependency,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352,1,['depend'],['dependency']
Integrability,Vertically stretched grid integration attempt #1 post-mortem,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1332:26,integrat,integration,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332,1,['integrat'],['integration']
Integrability,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:293,interface,interface,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748,6,['interface'],['interface']
Integrability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:809,depend,depend,809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,3,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"Very nice work @glwagner , and thanks for making this. Lots of good stuff here. In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent. Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589:240,depend,dependent,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589,1,['depend'],['dependent']
Integrability,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:520,integrat,integrate,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937,1,['integrat'],['integrate']
Integrability,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:282,depend,dependent,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746,1,['depend'],['dependent']
Integrability,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:27,depend,depend,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,1,['depend'],['depend']
Integrability,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3307:1444,interface,interfaces,1444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307,1,['interface'],['interfaces']
Integrability,"We agreed that stratified plane Couette flow could be a test case against which we can verify the implementation of AMD in PR #309, although the published results [Vreugdenhil & Taylor (2018)] use a slightly modified version of AMD. They report a number of LES runs, and since we don't have a vertically stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129, 256) against which we might be able to compare (might not be possible, depending on vertical grid stretching). Unfortunately, I don't think we can reproduce their results without a vertically stretched grid... If I understand the paper correctly, the grid is stretched according to; ```; y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); ```; so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~ 0.0000035 adjacent to the wall. So a faithful reproduction would need 285,000+ vertical levels lol. I don't fully understand how they got their values for the vertical grid cell size adjacent to the wall `∆y_w^+`, but it seems like if h = 100,000 then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the wall). Either way, the ratio between the thickest and thinnest spacings is ~35,000. Not sure if there's still a way we could compare results in this case without a vertically stretched grid... Absolute worst case scenario, I've been working on an implementation of a vertically stretched grid (see PRs #283 and #306) but it's a work in progress and might not be the best use of our efforts right now. Reference: Catherine A. Vreugdenhil and John R. Taylor, [Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model](https://aip.scitation.org/doi/abs/10.1063/1.5037039), Physics of Fluids 30, 085104 (2018). cc @glwagner @raf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310:669,depend,depending,669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310,1,['depend'],['depending']
Integrability,"We can add a warning message ""note that if you used to use version blah then this now changed... etc"" and keep it there for a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276,1,['message'],['message']
Integrability,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:774,depend,depends,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693,2,['depend'],['depends']
Integrability,"We can use an abstract type to obviate the need for ""zero functions"":. ```julia; abstract type AbstractBiogeochemistry end. struct NutrientsPlanktonDetritus{FT} <: AbstractBiogeochemistry; background_nutrients :: FT; mortality_rate :: FT; nitrification :: FT; end; ```. then with. ```julia; @inline (::AbstractBiogeochemistry)(i, j, k, grid, val_tracer_name, clock, fields) = zero(grid); ```. users don't need to define the ""netural biogeochemical forcing"" themselves. . Very Important: always use verbose names! I don't know how to enforce that within the API 😂 . I like this interface. Let's figure out if `Val{symbol}` is GPU-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081:577,interface,interface,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081,1,['interface'],['interface']
Integrability,"We commonly need to specify criteria that triggers an action; eg saving of data. For example, the `OutputWriter`s have the keyword arguments `time_interval` (for saving after fixed intervals of time) and `iteration_interval` (for saving after a fixed number of iterations). This method is a big clunky and doesn't allow for more general criteria that depend on, for example, flow features, wall clock time, etc. It'd be nice to have a general system for specifying `AbstractCriteria` that must be met for an action to occur. We can have types like `TimeInterval` and `IterationInterval`, or `WallTimeInterval`, for example, which will return true (given some argument like `model`) when saving / action needs to occur. A similar problem exists for the printing of progress statements by `Simulation`, and also for calling ""callback"" functions during the time-stepping loop of `run!(simulation)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/845:351,depend,depend,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/845,1,['depend'],['depend']
Integrability,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:273,wrap,wrapper,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,1,['wrap'],['wrapper']
Integrability,"We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag. . What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321:514,rout,routine,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321,1,['rout'],['routine']
Integrability,"We could implement an interface similar to `Buoyancy`, but I think this may be more easily done with `FPlane`, since `NonTraditionalFPlane` seems to be dedicated not for tilting domains, but for decomposing rotation based on latitude. We'd have something like. ```julia; θ_rad = 0.05 # radians; g̃ = (sin(θ_rad), 0, cos(θ_rad)); buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃); coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃); ```. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205,1,['interface'],['interface']
Integrability,We could to suggest wrapping the `Reduction` in a `Field`. I'm not 100% sure the best way to inject that kind of hint; we don't own operations like `/` so I think to do that we would have to define them (and then throw an error). Hmm.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891,2,"['inject', 'wrap']","['inject', 'wrapping']"
Integrability,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:616,interface,interface,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667,3,['interface'],['interface']
Integrability,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897:81,depend,depend,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897,3,"['depend', 'interface']","['depend', 'depends', 'interface']"
Integrability,"We may able to provide an interface for specifying background tracer distributions and velocity fields (which perform advection only?) using `FunctionField`s and the existing advection operators. I think we would want this functionality to assume that the _linear_ balances between background terms are somehow separately satisfied. With that assumption we can include just the two nonlinear terms associated with 1) advection of the resolved field by the background field and 2) advection of the background field by the resolved fields. For this to be easily implemented we need to change the function signature of the advection operators for momentum from. ```julia; div_ũu(i, j, k, grid, advection, U); ```. to . ```julia; div_ũu(i, j, k, grid, advection, U, u); ```. which then enables us to include background terms via. ```julia; div_ũu(i, j, k, grid, advection, U_background, u) + div_ũu(i, j, k, grid, advection, U, u_background); ```. for example. Tracers are fine, since the current function is. ```julia; div_uc(i, j, k, grid, advection, U, c); ```. which will become. ```julia; div_uc(i, j, k, grid, advection, U_background, c) + div_uc(i, j, k, grid, advection, U, c_background); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/960:26,interface,interface,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960,1,['interface'],['interface']
Integrability,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/428:250,integrat,integrate,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428,1,['integrat'],['integrate']
Integrability,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:165,integrat,integration,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,3,"['integrat', 'wrap']","['integration', 'wrappers']"
Integrability,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896:18,interface,interface,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896,2,['interface'],['interface']
Integrability,"We need a user interface for building `Field` from boundary conditions. Such a utility is model-specific. Right now, users have to do something like this (to get the bottom boundary condition, for example):. ```julia; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. A few observations:. * It's annoying to have to define the wrapper `kernel_getbc`. I don't know if there's a clean way around this. We could update `getbc` to be closer to ""kernel form"", but I'm not sure we want to add the third index when its unused. We could make two-index kernel functions work with `KernelFunctionOperation`, leveraging `Nothing` location --- that might be clean.; * This is model specific because we have to keep track of the arguments passed to `getbc`. Maybe we want to codify that better, ie by using a function `boundary_condition_fields`. I think a user API could look like. ```julia; u_bottom_bc_op = boundary_condition_operation(u, :bottom, model); ```. This came up on #3081",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3082:15,interface,interface,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3082,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"We need a user interface to `ConditionalOperand`, so it can be user-facing. #2185 is related. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2188:15,interface,interface,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2188,1,['interface'],['interface']
Integrability,"We need an abstraction for calculating moving averages. We could call this `TimeAverage`, `MovingTimeAverage`, or maybe `AveragedTimeSeries` --- or something else sensible. (Also, should `Timeseries` actually be `TimeSeries`?). To do this I think we should build something that shares a lot of syntax with `TimeSeries`, which is defined via. ```julia; struct TimeSeries{D, Ω, I, T, TT} <: AbstractDiagnostic; diagnostic :: D; frequency :: Ω; interval :: I; data :: T; time :: Vector{TT}; end; ```. The main challenge is designing syntax that isn't confusing. In `TimeSeries`, the `frequency` field refers to the frequency at which the time series is recorded. However, an `AveragedTimeSeries` diagnostic has two frequencies --- the frequency with which the raw data is acquired, and the frequency / interval at which the time-average is calculated. Thus we want something more like. ```julia; mutable struct AveragedTimeseries{D, Ω, I, X, T, TT} <: AbstractDiagnostic; diagnostic :: D; timeseries_frequency :: Ω # good name?; averaging_interval :: I; # other needed fields; integrand :: X # something to store accumulated timeseries output; data :: T # an ""averaged timeseries"", or a timeseries with moving average applied ; time :: Vector{TT}; end; ```. The reason the user might want to change the `timeseries_frequency` is if the object they are averaging is expensive to compute. . Thoughts?. A related issue is how to output time series that are collected via diagnostics (obviously they can be saved brute force, but it'd be nice to have an interface). I'll open another issue to address this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501:1547,interface,interface,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501,1,['interface'],['interface']
Integrability,We need https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/44 + a new release of OrthogonalSphericalShellGrids.jl otherwise the cyclical dependency blocks Oceananigans from bumping minor version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325:149,depend,dependency,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325,1,['depend'],['dependency']
Integrability,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:289,integrat,integrate,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['integrat'],['integrate']
Integrability,"We need to revise our abstraction for the equation of state. At the same time, considering changes to how we abstract model rotation (see #217), we may want to consider wrapping changes to the equation of state abstraction with changes to how we deal with buoyancy in general. This is important for stabilizing the API, ensuring that our pressure fields have the same dimensionality (important for post-processing and analysis), and for ensuring an extensible design permitting the smooth implementation of future desired features, like arbitrary tracer fields. I propose that we adopt a hierarchical approach to abstracting buoyancy and the equation of state. . Consider first that gravitational acceleration (""`g`"") is solely associated with 'buoyancy', and is only a required parameter when buoyancy is determined via density (gravitational acceleration therefore should not be a parameter of `Model` when running with no tracers, or when running with buoyancy as a tracer itself). Thus I think that we should have a type associated with the model representation of ""buoyancy"" that, in the general case, contains information both about gravitational acceleration and about the equation of state that relates tracer composition (and perhaps the pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEq",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:169,wrap,wrapping,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['wrap'],['wrapping']
Integrability,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794:297,integrat,integrates,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794,2,['integrat'],['integrates']
Integrability,We should figure out an interface to help users access grid metrics. We shouldn't have to write things like `grid.Δxᵃᵃᶜ` in the examples. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/2050#issuecomment-967266791_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:24,interface,interface,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['interface'],['interface']
Integrability,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:451,integrat,integration,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180,1,['integrat'],['integration']
Integrability,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1422:189,Integrat,IntegratedField,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422,1,['Integrat'],['IntegratedField']
Integrability,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:10,wrap,wrap,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232,2,['wrap'],['wrap']
Integrability,"We use `∂xᶠᶜᶜ(i, j, k, grid, η)` to represent the x-component of the barotropic pressure gradient, for example:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/barotropic_pressure_correction.jl#L49-L50. which also appears in the left-side operator for the implicit free surface solver:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L141-L142. But a finite volume discretization of x-component of the barotropic pressure gradient term (ie integrating over cell areas, then using Gauss' theorem to transform the volume integral into a surface integral) would look like. <img width=""308"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165198034-1a4fb702-2abc-4ea8-a028-dae750fdeee3.png"">. where I've canceled some `dz`, but don't seem to be able to cancel `dy`. Are we making some latent approximation here that we may not need to make?. @simone-silvestri @christophernhill ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475:636,integrat,integrating,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475,1,['integrat'],['integrating']
Integrability,"We want to be able to build single column grids with `topology=(Flat, Flat, Bounded)`, but with non-trivial locations (either `x, y` for `RectilinearGrid` or `latitude` and `longitude` for `LatitudeLongitudeGrid`). I think the user interface should be something like. ```julia; grid = LatitudeLongitudeGrid(size=100, latitude=45, longitude=0, z=(-100, 0), topology=(Flat, Flat, Bounded)); ```. This will allow us to write code that automatically interpolates from another grid (say one associated with JRA55) to the location of `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3626:232,interface,interface,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3626,1,['interface'],['interface']
Integrability,"We want to write. ```julia; @inline left_biased_αx₀(i, j, k, grid::AbstractGrid{FT}, ψ) where FT = C3₀ / (left_biased_βx₀(i, j, k, ψ) + FT(ε))^ƞ; ```. this will convert the floating point number `1e-6` to the appropriate precision prior to summing with the result of `left_biased_βx₀`, which in turn will compute the exponential in the appropriate precision. ultimately `left_biased_βx₀` needs to depend on `grid` to resolve #1704 so it might be smart to do that at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896:397,depend,depend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896,1,['depend'],['depend']
Integrability,Well it adds a new feature. I could just bump to 0.91.6 instead but it seems quite a major feature to justify the bump in version.; Also it removes dependencies on quite some packages.; What do people think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534:148,depend,dependencies,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534,1,['depend'],['dependencies']
Integrability,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:808,interface,interface,808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['interface'],['interface']
Integrability,"Well, it depends what definition of `h` you have if you include b in momentum or continuity, I agree with you that if `h` is total depth, b is found in the momentum equations. If not is found in continuity",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553:9,depend,depends,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553,1,['depend'],['depends']
Integrability,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199:761,depend,dependencies,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199,4,"['depend', 'message']","['dependencies', 'message']"
Integrability,"Well, right now, the `Model` includes both discrete and continuous aspects of the PDE. `Model` also stores `architecture`, for example, which is unrelated to the PDE. We did consider an abstraction that represented the equation set independent from discretization. This would not be a replacement for model, but would simply be a way to organize some of the properties of model (eg buoyancy, coriolis, diffusion, etc). Yet this is a challenging abstraction to design. One issue is specification. If we try to separate the terms from their numerical implementation, we have to figure how to distinguish between ""diffusion with second-order differences"" and ""diffusion with fourth-order differences"". It's clearly possible to do this, but it's going to take some time and careful thought to implement. We've taken a more incremental approach to development the model instead, resulting in a fairly ""flat"" interface to `IncompressibleModel` that combines aspects both of the continuous equations, their discretization, and things like `architecture`, the `pressure_solver`, etc. I think flat is simple (think parameter files as the platonic ideal of a flat API); however, we still want to benefit from modularity where it's a simple change that doesn't overcomplicate the interface (hence this issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548:903,interface,interface,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548,2,['interface'],['interface']
Integrability,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:554,depend,dependence,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,2,['depend'],['dependence']
Integrability,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594,4,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:252,interface,interfaces,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829,1,['interface'],['interfaces']
Integrability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:24,interface,interface,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['interface'],['interface']
Integrability,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:23,rout,route,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917,2,['rout'],['route']
Integrability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:1157,wrap,wrapping,1157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['wrap'],['wrapping']
Integrability,"What parallelism strategy makes sense? One particle per thread? Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Presumably `TimeSeries` makes sense for simple diagnosed particle ""properties"" and is the place to start. Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design, especially because our time stepping is not very abstracted yet. If we are integrated with DifferentialEquations this job might get a bit easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123:412,depend,depend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,What was the code? We can improve the error message,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356:44,message,message,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356,1,['message'],['message']
Integrability,"What's the point of wrapping it in `Forcing`?. I think a cleaner syntax is . ```julia; u_forcing = FieldTimeSeries{}(...); model = NonhydrostaticModel(; grid, forcing = (; u = u_forcing)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112,1,['wrap'],['wrapping']
Integrability,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,1,['message'],['message']
Integrability,"When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?. ```; [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614:65,message,message,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614,1,['message'],['message']
Integrability,"When I try to get `DiffusiveCFL` for a simulation with a `VerticallyStretchedGrid` and an LES closure I get the following error message:. ```julia; julia> using Oceananigans. julia> Nx = Ny = Nz = 32; 32. julia> S = 0.8 # Stretching factor; 0.8. julia> hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); hyperbolically_spaced_nodes (generic function with 1 method). julia> Lz = 32; 32. julia> grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz),; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 64.0], y ∈ [0.0, 64.0], z ∈ [-32.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (2.0, 2.0, [min=0.6847479408200634, max=1.2045016342496169]). julia> model = IncompressibleModel(grid=grid, closure=AnisotropicMinimumDissipation()); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Nothing}; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> wizard = TimeStepWizard(cfl=1.0, Δt=10.0, max_change=1.1, max_Δt=1minute, min_Δt=0.1second); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(1.0, Inf, 1.1, 0.5, 60.0, 0.1, 10.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> simulation = Simulation(model, Δt=wizard, stop_time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1749:128,message,message,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749,1,['message'],['message']
Integrability,When the `Oceananigans` github page is opened it might present this helpful message:. ![image](https://user-images.githubusercontent.com/15271942/136055771-2191957e-eced-4696-9362-03aac3e10722.png). Copy/pastable commands:. ```; git branch -m master main; git fetch origin; git branch -u origin/main main; git remote set-head origin -a; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905,1,['message'],['message']
Integrability,"While bathymetry is not a priority at the moment, there may be simple, non-invasive methods (from an algorithms standpoint) like the one described in the slack message pasted by @ali-ramadhan for modeling non-rectangular domains. . Probably the main challenge is not implementing the method (which could take a few days), but verifying and validating the implementation (more likely a few weeks of work at minimum). A collaboration with others who are knowledgeable in Julia and can participate in debugging and validation is probably the best chance for having this feature implemented any time soon, given the time constraints of the main developers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644:160,message,message,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644,1,['message'],['message']
Integrability,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:370,message,message,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,2,"['message', 'synchroniz']","['message', 'synchronize']"
Integrability,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:432,depend,dependencies,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,3,['depend'],"['dependencies', 'dependency']"
Integrability,"Why does `BoundaryConditions` need to depend on `Distributed`? I think `Distributed` needs to _extend_ `fill_halo_regions!`. For this, `Distributed` must come _after_ `BoundaryConditions`. I also think that `Distributed` needs to come after `Field`; and `Field` depends on `BoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489:38,depend,depend,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489,2,['depend'],"['depend', 'depends']"
Integrability,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586:81,depend,depends,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586,2,['depend'],"['depend', 'depends']"
Integrability,"With Julia 1.3 comes Julia library (JLL) packages which packages are starting to depend on, such as FFTW.jl v1.2.0. See this blog post for more info: https://julialang.org/blog/2019/11/artifacts/. But this requires Julia 1.3 so as of right now I've pegged Oceananigans.jl to FFTW.jl v1.1.0, an older version to keep Oceananigans.jl compatible with Julia 1.1+ as our README and docs state. Should we embrace Julia 1.3 so we can keep up to date with all the latest packages?. Note: We already do not support the latest long term support (LTS) release v1.0.5 so we might as well upgrade our requirements to the latest stable release (v.1.3+).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/625:81,depend,depend,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/625,1,['depend'],['depend']
Integrability,"With a student, we are trying to initialize `IncompressibleModel` with a flow that is in thermal wind balance. We specify the velocity and then compute the buoyancy using the package `QuadGK`. The lines that we use are the following:. ```; parms = (f₀ = Coriolis.f, # s⁻¹, Coriolis parameter; N² = 1e-4, # s⁻¹, buoyancy frequency; D = grid.Lz, # m, ocean depth; L_y = Ly/2, # m, jet width scale; L_z = Lz/2, # m, jet depth scale; σz = 2, # jet width parameter; σy = 5, # jet depth parameter; γ = 1/2, # jet skew parameter; U_max = 2) # jet velocity scale. ū(x, y, z, t, p) = p.U_max * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. dudz(x, y, z, t, p) = 2*p.U_max/p.L_z * (2*p.γ*p.σy * (y/p.L_y + p.γ * z/p.L_z) - p.σz) * tanh(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2) * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. b̄(x, y, z, t, p) = quadgk(yp -> p.N² * (z + p.D) - p.f₀*dudz(x, yp, z, t, p), -Ly/2, y)[1]; ```. It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Any idea what the problem is?. There are a bunch of other ways for numerical integration that we can use but this does seem attractive. Any other suggestions would be appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826:1179,integrat,integration,1179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826,1,['integrat'],['integration']
Integrability,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:209,depend,dependencies,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,1,['depend'],['dependencies']
Integrability,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381:1180,wrap,wrapping,1180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381,1,['wrap'],['wrapping']
Integrability,"Wondering if it'd be nicer to write. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, velocities, tracers.b); ```. rather than the current syntax. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); ```. I think we can document the fact that the ""dependencies"" (really, arguments to the kernel function) are computed. I'm actually not sure if it's so common to nest fields that require computation into a `KernelFunctionOperation`. It seems like that's maybe an edge case and most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". @tomchor you have used this the most, what do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340:352,depend,dependencies,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340,3,['depend'],['dependencies']
Integrability,"Working with @arnscheidt to output vorticity to NetCDF the code below is what we came up with but it feels quite cumbersome and required us to define some boilerplate `get_vorticity` function so it can all be accessed on demand by the `NetCDFOutputWriter`. I wonder if we can improve the interface to allow users to easily pipe the output of abstract operations to disk. One approach might be to add explicit support for abstract operations to output writers. `NetCDFOutputWriter` already knows what to do if you give it a field or a function. We can tell it to do all this in the background if given an abstract operation like `vorticity_operation = ∂x(v) - ∂y(u)`. ```julia; u, v, w = model.velocities; vorticity_operation = ∂x(v) - ∂y(u); ω = Field(Face, Face, Cell, model.architecture, model.grid, TracerBoundaryConditions(grid)); vorticity_computation = Computation(vorticity_operation, ω). function get_vorticity(model); compute!(vorticity_computation); return Array(interior(ω)); end. fields = Dict(..., ""vorticity"" => get_vorticity); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/653:288,interface,interface,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653,1,['interface'],['interface']
Integrability,Would be nice to have a Docker image so we have an easy-to-use environment for running Oceananigans. It would also be nice to integrate it into our CI so we know the package build fails. See:; * https://github.com/docker/labs; * https://docs.docker.com/docker-hub/builds/; * https://docs.docker.com/docker-hub/builds/link-source/; * https://repo2docker.readthedocs.io/en/latest/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/151:126,integrat,integrate,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/151,1,['integrat'],['integrate']
Integrability,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:775,interface,interfaces,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['interface'],['interfaces']
Integrability,Wrapping up changes to buoyancy abstraction,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/423:0,Wrap,Wrapping,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/423,1,['Wrap'],['Wrapping']
Integrability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1303,depend,depends,1303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['depend'],['depends']
Integrability,Yeah not the most informative error but it does something! I usually just expect a slower simulation due to float conversions. Checking types would be great! I don't even think there's a test that sets up a `Float32` model and just checks that it's fully `Float32` all the way down. I've also mostly stuck to `Float64` simulations but I am interested in whether `Float32` can work nicely out of the box. Sounds like it'll probably be quite case-dependent...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862:445,depend,dependent,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862,1,['depend'],['dependent']
Integrability,"Yeah the plot is from v0.5.x or something lol. Not sure if CPU -> GPU speedups are as relevant anymore? Well, maybe a lot of people are still on CPUs. The speedup can be much larger with WENO, but it's all very CPU and GPU dependent. I've seen ~8x and ~2000x speedups for the same benchmark. Also not sure if there are any good metrics to quantify performance. But @simone-silvestri's scaling plots would probably be great to include?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495:223,depend,dependent,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495,1,['depend'],['dependent']
Integrability,"Yeah, I guess that would work too!. It does have to just be one kernel per point I think because the modified value depends on all of the other tracer values.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763:116,depend,depends,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763,1,['depend'],['depends']
Integrability,"Yep. the inputs `Ax, Ay, Az, C, D` are used to construct the matrix that solves; ```; Axᵢ₊₁ xᵢ₊₁ + Axᵢ xᵢ₋₁ + Ayⱼ₊₁ xⱼ₊₁ + Ayⱼ xⱼ₋₁ + Azₖ₊₁ xₖ₊₁ + Azₖ xⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) xᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) xᵢⱼₖ = b; ```; with periodic or zero-flux boundary condition depending on the topology of the grid (i.e. bounded topology -> zero flux BC, periodic topology -> periodic BC). If you need a matrix to solve the discretized Poisson equation at `ᶜᶜᶜ`:; ```; Ax = zeros(N...); Ay = zeros(N...); Az = zeros(N...); C = zeros(grid, N...); D = zeros(grid, N...); for i = 1:grid.Nx, j = 1:grid.Ny, k = 1:grid.Nz; Ax[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δyᶠᶜᵃ(i, j, k, grid) / Δxᶠᶜᵃ(i, j, k, grid); Ay[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δxᶜᶠᵃ(i, j, k, grid) / Δyᶜᶠᵃ(i, j, k, grid); Az[i, j, k] = Δxᶜᶜᵃ(i, j, k, grid) * Δyᶜᶜᵃ(i, j, k, grid) / Δzᵃᵃᶠ(i, j, k, grid); end; reduced_dim = (false, false, false); matrix_constructors, diagonal, problem_size = matrix_from_coefficients(arch, grid, (Ax, Ay, Az, C, D), reduced_dim); matrix = arch_sparse_matrix(arch, matrix_constructors); ```; Take care that, with these coefficients, the RHS will have to be multiplied by the volume. (otherwise you can always divide the coefficients by the volume before constructing the matrix)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069:297,depend,depending,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069,1,['depend'],['depending']
Integrability,"Yes !. On Thu, Apr 28, 2022 at 06:33:13AM -0700, Gregory L. Wagner wrote:; > @christophernhill does MITgcm have a divergence viscosity feature?; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112209787; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591:363,Message,Message,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591,1,['Message'],['Message']
Integrability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:563,integrat,integration,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,2,['integrat'],['integration']
Integrability,"Yes, I can use `AbstractArray{FT}`, but it should represent a vector (whatever format he has).; For common array types, it always leads to an `AbstractVector`, so I never found the need to remove it.; I was always hesitant to relax this constraint because the type of `b` is used for allocating the ""vectors"" in the workspace of a Krylov method.; If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444:481,message,message,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444,1,['message'],['message']
Integrability,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:390,interface,interface,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502,1,['interface'],['interface']
Integrability,"Yes, that is the page that I saw.  I got there by searching the docs, not using the index.; On Sep 19, 2023 at 4:41 PM +0100, Gregory L. Wagner ***@***.***>, wrote:; > Hmm, yes I think that is an orphan page in the docs with no link...; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502:362,Message,Message,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502,1,['Message'],['Message']
Integrability,"Yes, this should work.  If it doesn’t work on kelp, you can try it on proteus or oceanus.; On Jun 20, 2024 at 10:41 PM +0100, Jago Strong-Wright ***@***.***>, wrote:; > The distributed regression tests are still failing but I'm not sure how to go about getting them to work because I can't work out how to run mpi locally, is it possible to do e.g. mpiexec -n 4 ... locally just on a single machine?; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099:526,Message,Message,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099,1,['Message'],['Message']
Integrability,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:956,rout,routine,956,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:409,rout,routines,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rout'],['routines']
Integrability,"You are also right, the data was generated on the CPU so it should be synchronized correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649:70,synchroniz,synchronized,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649,1,['synchroniz'],['synchronized']
Integrability,You are saying that you’d expect to have estimates of the velocity values at the interfaces rather than their cell-averaged values (centered around the interfaces)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416:81,interface,interfaces,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416,2,['interface'],['interfaces']
Integrability,"You can start by allowing the coefficient to be an array as in AMD:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143. Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure. I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674:764,interface,interface,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674,2,['interface'],['interface']
Integrability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['integrat'],['integrated']
Integrability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:496,depend,depends,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,2,['depend'],['depends']
Integrability,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:93,interface,interface,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['interface'],['interface']
Integrability,You will need to add `CUDAKernels` as a dependency,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162:40,depend,dependency,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162,1,['depend'],['dependency']
Integrability,"ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to solve this. Ideally we'd calculate the CFL in each point and get the largest values, but that's expensive. Getting the global max of velocity and the global min of Δz also seems like it could be very inaccurate, since the max in velocity could be happening very far from the min in Δz. Maybe a good compromise would be to calculate CFL as a function of `z` and returning the max?. CC: @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:52281,rout,routine,52281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['rout'],['routine']
Integrability,[WIP] Model allocation interface and model-wise buffer communication,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2525:23,interface,interface,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2525,1,['interface'],['interface']
Integrability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:201,wrap,wrapper,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,1,['wrap'],['wrapper']
Integrability,"_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:2243,interface,interface,2243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['interface'],['interface']
Integrability,`@apply_regionally` errors when wrapping a function with a return value and `args...` in the function signature,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2914:32,wrap,wrapping,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2914,1,['wrap'],['wrapping']
Integrability,"`@sprintf` / `@printf` formatters allow right-padding with the syntax `% 123s`, where `123` is the number of spaces. for example:. ```julia; julia> a = ""hi""; ""hi"". julia> b = ""bye""; ""bye"". julia> c = ""yeah sure""; ""yeah sure"". julia> @printf(""a: % 12s\nb: % 12s\nc: % 12s"", a, b, c); a: hi; b: bye; c: yeah sure; ```. Other points:. * The plot looks great!; * I would suggest just merging this plot and working on new advection schemes in another PR.; * You can let a validation script depend on `Polynomials` without adding `Polynomials` to the Oceananigans `Project.toml`. There's a few other validation scripts that depend on random packages that are not a part of Oceananigans.; * This PR also adds a bunch of new examples that are variants on the Bickley jet. Probably not intended?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343:485,depend,depend,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343,2,['depend'],['depend']
Integrability,"`@stdlib/Serialization`; [1a1011a3] SharedArrays `@stdlib/SharedArrays`; [6462fe0b] Sockets `@stdlib/Sockets`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [4607b0f0] SuiteSparse `@stdlib/SuiteSparse`; [fa267f1f] TOML `@stdlib/TOML`; [a4e569a6] Tar `@stdlib/Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing reg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10337,depend,dependencies,10337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['depend'],['dependencies']
Integrability,"`CFL` diagnostic is not very useful, and we don't need to depend on Tullio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037:58,depend,depend,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037,1,['depend'],['depend']
Integrability,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:391,depend,depend,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,1,['depend'],['depend']
Integrability,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720:172,interface,interfaces,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720,1,['interface'],['interfaces']
Integrability,"`IncompleteLU.jl` is unmaintained. I opened a PR a few months ago to add new features (https://github.com/haampie/IncompleteLU.jl/pull/26), but it was never merged. ; I have since included the content of `IncompleteLU.jl` along with my modifications in `KrylovPreconditioners.jl`. Together with @michel2323, we also interfaced **ILU(0)** and **IC(0)** preconditioners for NVIDIA/AMD GPUs, as well as a **block-Jacobi** preconditioner implemented with `KernelAbstractions.jl` for any GPU backend. Related PR: #3778",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3789:316,interface,interfaced,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789,1,['interface'],['interfaced']
Integrability,"`KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771:19,synchroniz,synchronize,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771,1,['synchroniz'],['synchronize']
Integrability,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1369:689,depend,dependencies,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369,4,['depend'],"['depend', 'dependencies', 'depends']"
Integrability,"`NetCDF_jll <400.900` works for me. Adding the following lines to `Project.toml` of `Oceananigans` or the environment for running `Oceananigans` should work, but it seems not the best practice since it adds a stale dependency. . ```toml; [deps]; NetCDF_jll = ""7243133f-43d8-5620-bbf4-c2c921802cf3"". [compat]; NetCDF_jll = ""<400.900""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241:215,depend,dependency,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241,1,['depend'],['dependency']
Integrability,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1002:1362,wrap,wrap,1362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002,1,['wrap'],['wrap']
Integrability,"```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ C:\Users\ADMIN\.julia\packages\OffsetArrays\rMTtC\src\OffsetArrays.jl:422 [inlined]; [10] getindex; @ C:\Users\ADMIN\.julia\packages\Oceananigans\E4XVr\src\Fields\field.jl:540 [inlined]; [11] rescale!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Fl... (repeats 1 time); [12] top-level scope; @ In[10]:9; ```. This is an error message I am getting from my code. Please share your comments on how to resolve this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299:1902,message,message,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299,1,['message'],['message']
Integrability,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); velocities = fake_model.velocities; tracers = fake_model.tracers. # Pacanowski-Philander implementation; #; # The following implements the Packanowski-Philander model for shear-modulated mixing; # with parameters:; ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. # In Packanowski-Philander both the viscosity and diffusivity; # depend on the Richardson number:; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); Ri = Field(Ri_op). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). # For `closure` to work correctly, the Ri must be defined as an ""auxiliary field"" of the model.; # Fields in model.auxiliary_fields are updated every time-stepper stage.; model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer(), auxiliary_fields = (; Ri)); model.velocities = velocities; model.tracers = tracers. # Initial condition with Ri ≈ 0.01; step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. N² = 1e-4; bᵢ(x, y, z) = N² * z. S² = 1e-2; Δu = 4 # m; uᵢ(x, y, z) = Δu * sqrt(S²) * step(z, -grid.Lz/2, Δu). set!(model, u=uᵢ, b=bᵢ). simulation = Simulation(model, Δt=1minute, stop_time=1day). # Alternative to writing output.; fields ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:2375,depend,depend,2375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967,1,['depend'],['depend']
Integrability,`auxiliary_fields` are fields that are meant to be used in forcing functions. That's related to why you're getting the error --- `Forcing.field_dependencies` can include auxiliary fields. A callback is a good way to integrate something and will not change your tendency kernel functions.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692,1,['integrat'],['integrate']
Integrability,"`fill_halo_event!` is now a blocking function, i.e. we fill halos one direction at a time waiting in between. With this PR we try to use dependencies to achieve the same goal. This is an initial step to make `fill_halo_regions!` non-blocking",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2910:137,depend,dependencies,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2910,1,['depend'],['dependencies']
Integrability,`gravitational_acceleration` will always be a Number... We might have to have a derived `g'` for every interface.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338,1,['interface'],['interface']
Integrability,"`on_architecture` for a model seems to be a little complicated because of FFTs that depend on very different plans for GPU and CPU. I am leaning towards leaving `on_architecture` only for some basics building blocks (fields, grids, some solvers) and not allow `on_architecture` for models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577:84,depend,depend,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577,1,['depend'],['depend']
Integrability,"`src/Fields/show_fields.jl` was. ```; import Oceananigans: short_show. location_str(::Type{Face}) = ""Face""; location_str(::Type{Center}) = ""Center""; location_str(::Type{Nothing}) = ""⋅"". function show_size(field); Nx, Ny, Nz = size(field); return ""$Nx×$Ny×$Nz""; end. show_location(X, Y, Z) = ""($(location_str(X)), $(location_str(Y)), $(location_str(Z)))"". show_location(field::AbstractField{X, Y, Z}) where {X, Y, Z} = show_location(X, Y, Z). short_show(m::Missing) = ""$m"". short_show(field::AbstractField) = string(show_size(field), "" "", typeof(field).name.wrapper, "" located at "", show_location(field)); short_show(field::AveragedField) = string(show_size(field), "" "", ""AveragedField over dims=$(field.dims) located at "", show_location(field), "" of "", short_show(field.operand)); short_show(field::ComputedField) = string(show_size(field), "" "", ""ComputedField located at "", show_location(field), "" of "", short_show(field.operand)). Base.show(io::IO, field::AbstractField{X, Y, Z, A}) where {X, Y, Z, A} =; print(io, ""$(short_show(field))\n"",; ""├── architecture: $A\n"",; ""└── grid: $(short_show(field.grid))""). function Base.show(io::IO, field::Field); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""└── boundary conditions: $(short_show(field.boundary_conditions))""). return nothing; end. show_status(::Nothing) = ""nothing""; show_status(status) = ""time=$(status.time)"". function Base.show(io::IO, field::AveragedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── dims: $(field.dims)"", '\n',; ""├── operand: $(short_show(field.operand))"", '\n',; ""└── status: "", show_status(field.status)). return nothing; end. function Base.show(io::IO, field::ComputedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── operand: $(short_show(field.opera",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400:557,wrap,wrapper,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400,1,['wrap'],['wrapper']
Integrability,`static_column_depth` interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841,1,['interface'],['interface']
Integrability,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:95,depend,dependency,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979,2,['depend'],"['dependencies', 'dependency']"
Integrability,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:146,integrat,integrating,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,"`z_viscosity` is supposed to return the vertical diffusivity, or the coefficient `ν` that appears in the term `∂z ν ∂z u` --- _when that term exists for a given closure_. This means that. ```julia; julia> using Oceananigans. julia> using Oceananigans.TurbulenceClosures: z_viscosity. julia> horizontal_diffusivity = HorizontalScalarDiffusivity(ν=1, κ=1); ScalarDiffusivity{ExplicitTimeDiscretization, HorizontalFormulation}(ν=1.0, κ=1.0). julia> z_viscosity(horizontal_diffusivity, nothing); 1.0; ```. is wrong since `z_viscosity(horizontal_diffusivity, nothing) = 0`. I'm not sure if this affects functionality. `z_viscosity` is only used for vertically-implicit time-stepping. Regardless we should do the right thing here. We also need tests (eventually) for this ""internal interface"" for grabbing viscosities and diffusivities. (eg the functions `viscosity`, `diffusivity`, `z_viscosity`, `z_diffusivity`). It's a bit underdeveloped at the moment.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2291:776,interface,interface,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2291,1,['interface'],['interface']
Integrability,a 20-year integration of the quarter degree simulation (in `validation/near_global_lat_lon/near_global_quarter_degree.jl`) using the following as a free surface:. ```; Δt = 10minutes # probably we can go to 10min or 15min?; CFL = 0.7. wave_speed = sqrt(g_Earth * grid.Lz); Δg = 1 / sqrt(1 / min_Δx(grid)^2 + 1 / min_Δy(grid)^2). @show substeps = Int(ceil(2 * Δt / (CFL / wave_speed * Δg))). free_surface = SplitExplicitFreeSurface(; substeps); ```. https://user-images.githubusercontent.com/33547697/217328677-9c737e8d-140b-4a9f-92b9-d42f5d364a3d.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576:10,integrat,integration,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576,1,['integrat'],['integration']
Integrability,"a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:1053,wrap,wrappers,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,1,['wrap'],['wrappers']
Integrability,"a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1051,rout,routine,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"ably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1907,depend,depend,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['depend'],['depend']
Integrability,"ains information both about gravitational acceleration and about the equation of state that relates tracer composition (and perhaps the pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:2134,contract,contraction,2134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['contract'],['contraction']
Integrability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:2334,Message,Message,2334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['Message'],['Message']
Integrability,"ananigans.Fields: _set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl: _set!(ϕ, value); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:import Oceananigans.TimeSteppers: reset!; ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:function reset!(sefs::SplitExplicitFreeSurface); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:using Oceananigans.Fields: _set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:`set!(ϕ::AbstractField, data)` function exists.; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:set!(model, u=u₀, v=v₀, T=T₀); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: @apply_regionally _set!(ϕ, value); ./Models/Models.jl:import Oceananigans.TimeSteppers: reset!; ./Models/Models.jl:function reset!(model::AbstractModel); ./MultiRegion/multi_region_field.jl:im",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:3985,Integrat,Integrate,3985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,any slight dependency update results in most GPU tests failing... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770:11,depend,dependency,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770,1,['depend'],['dependency']
Integrability,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:1975,rout,routine,1975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,1,['rout'],['routine']
Integrability,"arotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Ocean",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:1032,interface,interfaces,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['interface'],['interfaces']
Integrability,"ary conditions (on the domain, not even considering immersed boundary conditions yet). My expectation was that the `GradientBoundaryCondition` would be applied to whichever tracer fields are passed along to the tendency functions:; > ; > ```; > - ∇_dot_qᶜ(i, j, k, grid, closure, diffusivities, val_tracer_index, closure_c, clock, model_fields, buoyancy); > - immersed_∇_dot_qᶜ(i, j, k, grid, closure_c, c_immersed_bc, closure, diffusivities, val_tracer_index, clock, model_fields); > ```; > ; > which in our case should be the sum of the perturbation and background tracer fields. Instead, it seems that our solutions are behaving as though the `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries. Indeed, when we remove the background field from the gradient values passed to `GradientBoundaryCondition`, we get the behavior we are looking for. `GradientBoundaryCondition` isn't applied to the fields at all. The tracer gradient across the boundary is the quantity we need in order to compute fluxes across boundaries. Therefore when the immersed boundary flux is computed, we call. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L100-L101. Contrast this with the routine for `ValueBoundaryCondition` which is a bit more involved:. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L103-L107. These gradients are then used to compute the flux, for example. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L117-L122. > Instead, it seems that our solutions are behaving as though the GradientBoundaryCondition is only being applied to the perturbation fluxes at the boundaries. I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563:1729,rout,routine,1729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563,1,['rout'],['routine']
Integrability,as mentioned on slack here's @jlk9 's Enzyme integration test PR https://github.com/CliMA/Oceananigans.jl/pull/3480. We should check that the tuple doesn't also break that (or try to find the correct mutually happy solution like maybe vararg type),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039:45,integrat,integration,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039,1,['integrat'],['integration']
Integrability,"ase.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:194; [8] calculate_interior_tendency_contributions!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:11315,depend,dependencies,11315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['depend'],['dependencies']
Integrability,"at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:2451,wrap,wrapper,2451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability,"at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the ho",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:5162,wrap,wrapper,5162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability,"ata :: A; grid :: G; u :: U; v :: V; b :: B; dUdz :: Uz_bg; dVdz :: Vz_bg; N2 :: N2_bg; end. """"""; RichardsonNumber(model). Returns an `AbstractField` representing the Richardson number of `model`. Calling `compute!(Rich::RichardsonNumber)` computes the Richardson number; associated with `model` and stores it in `Rich.data`.; """"""; function RichardsonNumber(model; data = nothing,; N²_bg = 0, dUdz_bg = 0, dVdz_bg = 0). if isnothing(data); data = new_data(model.architecture, model.grid, (Cell, Cell, Face)); end. u, v, w = model.velocities; b = model.tracers.b. return RichardsonNumber(data, model.grid, u, v, b, dUdz_bg, dVdz_bg, N²_bg); end. function compute!(Rich::RichardsonNumber). arch = architecture(Rich.data). workgroup, worksize = work_layout(Rich.grid, :xyz, location=(Cell, Cell, Face)). compute_kernel! = compute_richardson_number!(device(arch), workgroup, worksize). event = compute_kernel!(Rich.data, Rich.grid,; Rich.u, Rich.v, Rich.b,; Rich.dUdz, Rich.dVdz, Rich.N2; dependencies=Event(device(arch))). wait(device(arch), event). return nothing; end. @kernel function compute_richardson_number!(Ri, grid, u, v, b, Uz, Vz, N2); i, j, k = @index(Global, NTuple). #dBdz = ∂zᵃᵃᶠ(i, j, k, grid, b) + N2 # dbdz(c, c, f); #dUdz_tot = ℑxᶜᵃᵃ(i, j, k, grid, ∂zᵃᵃᶠ, u) + Uz # dudz(f, c, f) => dudz(c, c, f); #dVdz_tot = ℑyᵃᶜᵃ(i, j, k, grid, ∂zᵃᵃᶠ, v) + Vz # dvdz(c, f, f) => dvdz(c, c, f). #@inbounds Ri[i, j, k] = dBdz / (dUdz_tot^2 + dVdz_tot^2); @inbounds Ri[i, j, k] = N2 / (Uz^2 + Vz^2); end; ```. So, note that, as a test, I'm using using `N2`, `Uz` and `Vz` in the actual calculation at the end. These are all constants (background stratification and shear) and the value of Ri should be exactly `1` at end. However, this is what I'm getting (I'm showing a horizontal average of a time step):. ```python; <xarray.DataArray 'Ri' (zF: 17)>; array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.]); Coordinates:; * zF (zF) float64 -100.0 -87.5 -75.0 -62.5 ... 62.5 75.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1290:1416,depend,dependencies,1416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290,1,['depend'],['dependencies']
Integrability,"atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1395,synchroniz,synchronize,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronize']
Integrability,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1342,integrat,integrated,1342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,4,['integrat'],['integrated']
Integrability,"ation); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:import Oceananigans.Fields: set!; ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl: set!(model; kwargs...); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:function set!(model::NonhydrostaticModel; enforce_incompressibility=true, kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./MultiRegion/multi_region_field.jl:import Oceananigans.Fields: set!, compute!, compute_at!, validate_field_data, validate_boundary_conditions; ./Oceananigans.jl: interior, set!, compute!, regrid!, location,; ./OutputReaders/field_time_series.jl:import Oceananigans.Fields: Field, set!, interior, indices; ./OutputReaders/field_time_series.jl: set!(time_series, path, name); ./OutputReaders/field_time_series.jl:##### set!; ./OutputReaders/field_time_series.jl:function set!(time_series::InMemoryFieldTimeSeries, path::String, name::String); ./OutputReaders/field_time_series.jl: set!(time_series[n], field_n); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:9595,Integrat,Integrate,9595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,"bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute,cell_advection_timescale = accurate_cell_advection_timescale). start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,; progress=progress_message); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:2970,message,message,2970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['message'],['message']
Integrability,"be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:1424,interface,interfaces,1424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['interface'],['interfaces']
Integrability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:78,depend,depending,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['depend'],['depending']
Integrability,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1688,integrat,integrated,1688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,4,['integrat'],['integrated']
Integrability,"but, @tomchor, I'd be definitely more than happy if you'd made these changes since they are trivial and need not be discussed or what not ;). (just saying in response to your protocol concerns..!). thanks for reviewing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988:175,protocol,protocol,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988,1,['protocol'],['protocol']
Integrability,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:1809,depend,depend,1809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,3,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2089,integrat,integration,2089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,6,['integrat'],['integration']
Integrability,"ce, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!)})(::Field{Center, Center, Face, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}}}}}, ::Vararg{Any, N} where N; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/8wtKq/src/CUDAKernels.jl:194; [11] calculate_interior_tendency_contributions!(tendencies::NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:20630,depend,dependencies,20630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['depend'],['dependencies']
Integrability,"cf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl#L92-L96) should return also the barotropic velocities when using a split-explicit free surface. ***(3)***. I would like to flatten out the design of the `SplitExplicitFreeSurface` by; - removing the [`SplitExplicitState`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L136-L161), and have the barotropic velocities and the mean fields part of the main `free_surface` type and all the remaining fields required for specific timesteppers in the [`timestepper`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L259-L260) which at the moment is very simple but can be redesigned to contain all time-stepping specific information; - removing [`SplitExplicitSettings`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L253-L256) (I don't know why there is a `settings_kwargs` there but it looks odd and it's probably a sign that this type is not well designed). This leads to a `SplitExplicitFreeSurface` which will look like; ```julia; struct SplitExplicitFreeSurface{H, U, M, FT, K , S, T} <: AbstractFreeSurface{H, FT}; η :: H; barotropic_velocities :: U # A namedtuple with U, V ; filtered_state :: M # A namedtuple with η, U, V averaged throughout the substepping; gravitational_acceleration :: FT; kernel_parameters :: K; substepping :: S # Either `FixedSubstepNumber` or `FixedTimeStepSize`; timestepper :: T # redesigned to contain all auxiliary field and settings necessary to the particular timestepping; end; ```; These changes will not affect the performance nor the functioning of the algorithm, and (if there are none required) should not even affect the user interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873:3543,interface,interface,3543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873,1,['interface'],['interface']
Integrability,"cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1643,depend,dependency,1643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['depend'],['dependency']
Integrability,"ch aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2Z",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1533,depend,depend,1533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['depend'],['depend']
Integrability,"cision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::Nothing, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:95; [16] launch!; @ /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:79 [inlined]; [17] regrid!(a::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:12303,depend,dependencies,12303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"ck?. Same! Runs again no complaining :). ```julia; julia> using Oceananigans. julia> grid; 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Bounded y ∈ [0.0, 2.0] regularly spaced with Δy=2.0; └── Flat z. julia> model = HydrostaticFreeSurfaceModel(grid=grid, free_surface = ImplicitFreeSurface()); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=1.0, stop_iteration=2); Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (198.852 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.013 minutes).; [ Info: Simulation is stopping. Model iteration 2 has hit or exceeded simulation stop iteration 2.; ```. > Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). yeah!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166:4005,message,message,4005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166,1,['message'],['message']
Integrability,closing this as we are moving fwd with a compat entry that will render this message useless.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967,1,['message'],['message']
Integrability,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:2361,interface,interface,2361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['interface'],['interface']
Integrability,"crete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, field[i, j, k], bc.parameters); end; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897:1560,depend,dependent,1560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897,1,['depend'],['dependent']
Integrability,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3567,interface,interface,3567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['interface'],['interface']
Integrability,"ctive) on stretched grids. I think we can replace this with . ```julia; using Oceananigans.AbstractOperations: Δx, Δy, Δz. function cell_advection_timescale(grid, u, v, w); arch = architecture(u); ; max_u_Δx = maximum(abs, u / Δx); max_v_Δy = maximum(abs, v / Δy); max_w_Δz = maximum(abs, w / Δz). return 1 / max(max_u_Δx, max_v_Δy, max_w_Δz); end; ```. Then we can delete the infamous ""`accurate_cell_advection_timescale`"":. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/Diagnostics/cfl.jl#L83-L102. For reference, the new implementation of `cell_advection_timescale` uses `GridMetricOperation` via. ```julia; julia> using Oceananigans.AbstractOperations: Δx; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (2, 2, 2); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.5, 0.5, 0.5). julia> u = XFaceField(grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 2); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center); ```. @navidcy and @tomchor might have something to add about this change to the user interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037:2615,interface,interface,2615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037,1,['interface'],['interface']
Integrability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1547,depend,depends,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['depend'],['depends']
Integrability,"d complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:2175,interface,interface,2175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['interface'],['interface']
Integrability,"d to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. With the two changes above we might have an API that looks something like. ```julia; c_bcs = TracerBoundaryConditions(grid, top = NormalFluxBoundaryCondition(args...),; boundary_1 = NormalFluxBoundaryCondition(args...), boundary_2 = NormalFluxBoundaryCondition(more_args...)); ```. We also may want to change how boundary conditions are implemented. Currently we launch a bunch of 2D kernels to enforce boundary conditions. But enforcing boundary conditions across immersed boundaries either requires a 3D kernel or a 1D kernel that traverses every fluid-solid interface (probably requiring some tedious bookkeeping to generate the iteration). From the software perspective, it's probably simpler to move the enforcement of flux boundary condition inside the 3D interior tendency kernel and evaluate boundary conditions at the same time that interior tendency contributions are evaluated (in other words, replace diffusive fluxes with the specified boundary normal flux when appropriate). cc @whitleyv this affects your work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720:2562,interface,interface,2562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720,1,['interface'],['interface']
Integrability,"d to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter information from a type's string?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:1936,wrap,wrapper,1936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['wrap'],['wrapper']
Integrability,de/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:/glade/u/apps/casper/23.10/opt/wrappers/bin:/glade/u/apps/casper/23.10/opt/utils/bin:/glade/u/home/knudsenl/.local/bin:/usr/lib/mit/bin:/opt/pbs/bin:/glade/u/apps/casper/23.10/opt/view/bin:/usr/local/bin:/usr/bin:/sbin:/bin:/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin; NCAR_LDFLAGS_INTEL_ONEAPI_COMPILERS = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/lib; MODULESHOME = /glade/u/apps/casper/23.10/spack/opt/spack/lmod/8.7.24/gcc/7.5.0/m4jx/lmod/lmod; PKG_CONFIG_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:14262,wrap,wrappers,14262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['depend'],['dependency']
Integrability,"dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; model.clock.iteration,; prettytime(model.clock.time),; prettytime(wizard.Δt),; umax(), vmax(), wmax(),; prettytime(1e-9 * (time_ns() - wall_clock)); ). @info msg. return nothing; end. # Time step wizard based on CFL condition for AB (CFL<=0.3); wizard = TimeStepWizard(cfl=0.3, Δt=0.01, max_change=1.2, max_Δt=0.1). nothing # hide. simulation = Simulation(model,progress_frequency = 100, Δt = wizard,stop_time = 20,progress = print_progress). nothing # hide. # Output; #; # We set up an output writer for the simulation that saves all velocity fields,; # tracer fields, and the subgrid turbulent diffusivity every 2 minutes. using Oceananigans.OutputWriters. field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs,; interval = 0.1,; prefix = ""continuous_release_3D_background_current"",; force = true). nothing # hide. run!(simulat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:4163,message,message,4163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['message'],['message']
Integrability,"ditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Utils/kernel_launching.jl:95; [7] fill_bottom_and_top_halo!(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::Symbol, ::Tuple{Int64, Int64}, ::Tuple{Face, Center, Center}, ::GPU, ::CUDAKernels.CudaEvent, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:2535,depend,dependencies,2535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['depend'],['dependencies']
Integrability,"drostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1245,depend,depend,1245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depend']
Integrability,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1281,integrat,integrate,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['integrat'],['integrate']
Integrability,"e (the blue line is where the immersed boundary is):. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/8904fd81-70ee-465b-a664-3eb6042f94ca). And here's a plot of the standard deviation of pressure over the whole domain as a function of time where we can visualize when this issue happens:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/86e5687e-0290-45ac-80d9-0cc2552f2b7d). [Here](https://pastebin.com/XArt8Bik) is the code I used to generate these figures in case anyone's interested in playing around with it. A bit of context: I noticed this issue a long time ago, and @whitleyv before me (I believe @amrapallig also mentioned coming across this issue at some point). It hasn't been an issue in the past, but now that I need to close a KE balance in a domain where the pressure contributions don't vanish I find that this issue prevents me from obtaining any sort of reasonable estimate for the pressure contribution. (Which is odd, since it implies that these ""jumps"" have no impact on dynamics...). A few notes:. 1. This only seems to happen when there's a _vertical_ immersed boundary interface and buoyancy isn't `nothing` (or zero). To clarify, this issue does happen in sloping topographies, but it goes away if instead I make the immersed boundary a ""faux"" flat bottom (e.g. if `east_wall(x, y, z) = z < -50`).; 2. I haven't tried branch https://github.com/CliMA/Oceananigans.jl/pull/3188 yet, but it's on my to-do list. I figured even if that branch fixes it, it was worth opening this issue.; 3. In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations.; 4. This example was run with the latest version of Oceananigans `v0.91.0` which doesn't separate the pressure anymore, but it also to happened in older versions with the pressure separation. CC @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593:2391,interface,interface,2391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593,1,['interface'],['interface']
Integrability,"e Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2023,interface,interface,2023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['interface'],['interface']
Integrability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1671,depend,depend,1671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,['depend'],['depend']
Integrability,e either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2014,rout,routine,2014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"e in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1438,rout,routine,1438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"e value anyway). This appears to be occurring in the pressure correction step. For example:; ```julia; julia> using Oceananigans; julia> grid = RectilinearGrid(size = (128, 128, 128), extent = (1000, 1000, 1000));; julia> model = NonhydrostaticModel(; grid);; julia> uᵢ(x, y, z) = (1-tanh((x-500)/10));; julia> set!(model, u = uᵢ). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=1.00781, min=1.00781, mean=1.00781. julia> set!(model, u = uᵢ, enforce_incompressibility=false). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=2.0, min=0.0, mean=1.00781; ```. I initially spotted this issue after time-stepping a model and the same thing occurs, presumably after the pressure correction, so this isn't isolated to `set!`. This is occurring in all of my julia projects where Oceananigans is in various versions and I know Nonhydrostatic models have worked correctly in before, downgrading is also not working so perhaps this is similar to https://github.com/CliMA/Oceananigans.jl/issues/3381 with a broken dependency. I will try updating to 1.10 to see if that fixes the issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3397:2111,depend,dependency,2111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397,1,['depend'],['dependency']
Integrability,"e*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:1431,interface,interface,1431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['interface'],['interface']
Integrability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1523,depend,depend,1523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,10,['depend'],"['depend', 'dependent', 'depends']"
Integrability,e. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. G,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2582,rout,routine,2582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"e.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczyn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1657,Integrat,Integration,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['Integrat'],['Integration']
Integrability,"e.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/OC.jl/src/Utils/kernel_launching.jl:103; [15] calculate_interior_tendency_contributions!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Col",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:14775,depend,dependencies,14775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1526,depend,dependency,1526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,8,['depend'],"['dependencies', 'dependency']"
Integrability,"ecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels ~/.julia/packages/CUDAKernels/3IKLV/src/CUDAKernels.jl:283; [14] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Models.NonhydrostaticModels.calculate_Gu!), ::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:12822,depend,dependencies,12822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"el clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). return simulation; end. function next_actuation_time(sch::AveragedTimeInterval); t₀ = sch.first_actuation_time; N = sch.actuations; T = sch.interval; return t₀ + (N + 1) * T; end. if isfile(""timeavg.nc""); rm(""timeavg.nc""); println(""File 'timeavg.nc' was successfully removed.""); else; println(""File 'timeavg.nc' does not exist.""); end; # run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s). δt = .01 # progress message interval and output saving interval; # Run a simulation that saves data to a checkpoint. simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; # N = iteration(simulation); # checkpoint = ""test_iteration$N.jld2""; # simulation = test_simulation(T2, Δt, δt, false); # run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); # Plots.savefig(""ln.png""); ln; close(ds); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:2947,message,message,2947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['message'],['message']
Integrability,"en though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1630,rout,routine,1630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2101:1633,interface,interface,1633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101,1,['interface'],['interface']
Integrability,"epping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2460,integrat,integrating,2460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['integrat'],['integrating']
Integrability,"ers that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_perturbation(i, j, k, grid, buoyancy, C); return buoyancy.gravitational_acceleration * (; buoyancy.equation_of_state.α * C.T[i, j, k]; - buoyancy.equation_of_state.β * C.S[i, j, k] ); end; ```. for example. @jm-c @christophernhill @johncmarshall54 @rafferrari please advise that this concept will work with our algorithm as it stands, and that it generalizes to nonlinear equations of state (for example, do we need the pressure field as well?). 2) `total_buoyancy(i, j, k, grid, buoyancy, C)`, which returns the total buoyancy, perturbation plus background (is this needed?). 3) `total_buoyancy_gradient` and `perturbation_buoyancy_gradient` which returns the buoyancy gradien",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:2978,depend,dependent,2978,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['depend'],['dependent']
Integrability,"es and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:1437,wrap,wraps,1437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['wrap'],['wraps']
Integrability,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1963,interface,interface,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,4,['interface'],['interface']
Integrability,"ey can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](https://github.com/CliMA/CLIMAParameters.jl) package so we may need to brainstorm about how to use that package in this context...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1625,wrap,wrapper,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['wrap'],['wrapper']
Integrability,"field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to creating the possibility for nice pseudo-animations via `UnicodePlots.jl`). I'm not 100% sure how to do this; one places to start could be https://github.com/ronisbr/TextUserInterfaces.jl. Any work on any of these ideas could be useful! I'd be happy to Skype to talk more and clarify any questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:4000,message,messages,4000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,3,['message'],"['message', 'messages']"
Integrability,"form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3733,depend,dependent,3733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['depend'],['dependent']
Integrability,"g to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper support for systems of coupled nonlinear boundary conditions, etc). It's a good discussion to have regardless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:1051,interface,interface,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,10,['interface'],"['interface', 'interfaces']"
Integrability,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1912,depend,depends,1912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,2,['depend'],['depends']
Integrability,"great Ryan - hope we can collaborate on this. There is a growing group of; people using and developing oceananigans and it would be good to link in; with xgcm. John. On Wed, Feb 10, 2021 at 5:03 PM Ryan Abernathey <notifications@github.com>; wrote:. > Hi folks. I just saw this issue. We are very glad that you're working to; > support interoperability btw oceananigans and xgcm! 🎉 We'd love to help; > however we can.; >; > Ideally you would not have to really do much here other than use CF; > conventions in your netCDF output and things would ""just work."" That's the; > beauty of standards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:336,interoperab,interoperability,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['interoperab'],['interoperability']
Integrability,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:3008,integrat,integrate,3008,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['integrat'],['integrate']
Integrability,"hat `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1447,depend,depends,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"he face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:1237,depend,dependent,1237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['depend'],['dependent']
Integrability,"he line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1246,rout,routine,1246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"hen `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the signature. `func(x, y, z, t, u, S)`. where `u` is assumed to be the `u`-velocity component, and `S` is a tracer. Note that any field; which does not have the name `u`, `v`, or `w` is assumed to be a tracer and must be present; in `model.tracers`. If `discrete_form=false` (the default) and `parameters` are provided, then the _last_ argument; to `func` must be `parameters`. For example, if `func` has no `field_dependencies` but does; depend on `parameters`, then it must be callable with the signature. `func(x, y, z, t, parameters)`. With `field_dependencies=(:u, :v, :w, :c)` and `parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:2433,depend,depend,2433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['depend'],['depend']
Integrability,"https://github.com/CliMA/Oceananigans.jl/blob/5b8813da360921c66c2f3ee77021db91bedda1f7/src/Grids/Grids.jl#L81. Shouldn't the size of the `x`-direction, for example, be `Nx + 2 * Hx`? Perhaps we should simply delete this function if it isn't being used. It doesn't exactly make sense since the size of a _field_ depends on its location, and the topology of the grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/883:311,depend,depends,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/883,1,['depend'],['depends']
Integrability,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:215,wrap,wrapped,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588,2,['wrap'],['wrapped']
Integrability,"https://github.com/MikeInnes/Requires.jl ?. On Fri, Jun 14, 2019 at 10:47 AM Ali Ramadhan <notifications@github.com>; wrote:. > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?; >; > Mainly I think we can get all the same benefits by maintaining a single; > unified and tidy repository with sub-modules. I don't see Oceananigans as a; > complex project yet, we're barely at 2,500 lines of code (minus turbulence; > closure operators which aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:492,integrat,integrated,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['integrat'],['integrated']
Integrability,"icant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1009,wrap,wrapper,1009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['wrap'],['wrapper']
Integrability,"ies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd()). • enable_threaded_blas: if true then BLAS will run on multiple threads in added processes. Default is false. • exename: name of the julia executable. Defaults to ""$(Sys.BINDIR)/julia"" or ""$(Sys.BINDIR)/julia-debug"" as the case may be. It is; recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4065,message,message,4065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['message']
Integrability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2318,interface,interface,2318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['interface'],['interface']
Integrability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:2094,interface,interface,2094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['interface'],['interface']
Integrability,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:3434,rout,routine,3434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,11,['rout'],['routine']
Integrability,"in/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6074,wrap,wrappers,6074,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1052,wrap,wrapped,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,2,['wrap'],['wrapped']
Integrability,"ind the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1226,interface,interface,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['interface'],['interface']
Integrability,"inetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `Bina",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:2883,wrap,wrapper,2883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability,"ing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:1047,integrat,integrated,1047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['integrat'],['integrated']
Integrability,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['wrap'],['wrapper']
Integrability,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:2397,interface,interface,2397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['interface'],['interface']
Integrability,"is would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1014,Depend,Dependent,1014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['Depend'],['Dependent']
Integrability,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:2078,depend,depend,2078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,4,['depend'],"['depend', 'dependency', 'depending']"
Integrability,"ive this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the `IncompressibleModel` is really more of an `OceanModel` as evidence by the `surface_waves` functionality and the `SeawaterBuoyancy` default",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2278,wrap,wraps,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['wrap'],['wraps']
Integrability,"l/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined]; │ [12] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:419 [inlined]; │ [13] macro expansion; │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1615,synchroniz,synchronization,1615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"lDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1509,synchroniz,synchronization,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"larCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: BinaryOperation at (Cell, Cell, Cell); └── status: time=0.0. julia> dz_two_c = ComputedField(∂z(two_c)); ComputedField located at (Cell, Cell, Face) of Derivative at (Cell, Cell, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 5); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: Derivative at (Cell, Cell, Face); └── status: time=0.0. julia> set!(c, (x, y, z) -> rand()); 1×1×2 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:3), 1:1, 1:1, 1:2) with eltype Float64:; [:, :, 1] =; 0.8753467111937931. [:, :, 2] =; 0.649695162761919. julia> compute!(dz_two_c). julia> two_c.data[1, 1, :]; 4-element OffsetArray(::Array{Float64,1}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 1.7506934223875863; 1.299390325523838; 0.0. julia> interior(dz_two_c); 1×1×3 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:4), 1:1, 1:1, 1:3) with eltype Float64:; [:, :, 1] =; 1.7506934223875863. [:, :, 2] =; -0.45130309686374837. [:, :, 3] =; -1.299390325523838; ```. The values of `dz_two_c` at the top and bottom boundary simply reflect the interior values of `two_c`. This is not what's expected: the vertical derivative of `2 * c` across boundaries actually depends on the boundary conditions imposed on `c`. This is a tricky issue to resolve. I'm not sure we can determine correct halo region values for computed fields in general. However, we can allow `ComputedField`s to have boundary conditions, like `Field`s currently do. In this case, users may specify boundary conditions on `ComputedField`s and we can reuse existing defaults if boundary conditions are not specified (or we can use `boundary_conditions = nothing` as a default). At the very least, this will ensure that `ComputedField`s are correct across periodic boundaries and at best users who need correct boundary conditions imposed on `ComputedField`s can provide them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1130:2627,depend,depends,2627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130,1,['depend'],['depends']
Integrability,"las.so: symbol cublasLt_for_cublas_DDD version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1241,wrap,wrappers,1241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
Integrability,"ld not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation.; > ; > For installations and dependency reduction, hopefully the new HDF5 release, which will for the first time support cross compilation, will lead to HDF5.jl switching to BinaryBuilder, which will allow NetCDF.jl to do the same. Also with the Clang.jl improvements we can regenerate the bindings. I still hope that NetCDFand NCDatasets will be able to share more code in the future, and be mainly about exposing different user facing APIs. Thanks for the feedback! My thinking was the same, why use HDF5.jl when NetCDF.jl and NCDatasets.jl exist since we want NetCDF output in the end. Sorry if I misrepresented the two packages, it was just what I gleaned by skimming a few issues and PRs. Will definitely keep a look out for new HDF5 releases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:2875,depend,dependency,2875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['depend'],['dependency']
Integrability,"lem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1031,depend,depend,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,['depend'],['depend']
Integrability,"le{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:291; [13] macro expansion; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:102 [inlined]; [14] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!)})(::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels C:\Users\parfe\.julia\packages\CUDAKernels\4VLF4\src\CUDAKernels.jl:272; [15] launch!(::GPU, ::RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_south_and_north_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; depende",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:14972,depend,dependencies,14972,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['depend'],['dependencies']
Integrability,"libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64, maxiter::Int64, log::Bool, statevars::IterativeSolvers.CGStateVariables{Float64, Cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1326,wrap,wrappers,1326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
Integrability,"lier = 0; else; bias = 0; multiplier = 1; end; ; Q_band1(z) = (params.Ι/params.λ1)*exp(-z/params.λ1) ; Q_band2(z) = (params.Ι/params.λ2)*exp(-z/params.λ2); ; if z >= computational_grid.zᵃᵃᶜ[Nz]; cooling_source = multiplier*Q_cool/(params.ρ*params.Cp*computational_grid.Δzᵃᵃᶜ[Nz]); return Q_sh(t) * (Q_band1(z) + Q_band2(z))/(params.ρ*params.Cp) + (cooling_source*computational_grid.Δzᵃᵃᶜ[Nz]). else ; return Q_sh(t) * (Q_band1(z) + Q_band2(z))/(params.ρ*params.Cp); end. end; ShortWavePenetration_parameters = (ρ = 1000,; Cp = 4182,; λ1 = 0.35,; λ2 = 23.0,; Ι = 0.58; ); heat_source_term = Forcing(ShortWavePenetration,; parameters = ShortWavePenetration_parameters). #Velocity Boundary conditions ; const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). #Buoyancy that depends on temperature and salinity ; buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). #Model instantiation ; using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; forcing = (T=heat_source_term,),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). #Setting Initial Conditions ; using CSV; using DataFrames; initial_temperature = Matrix(CSV.read(""initial_temperature.csv"", DataFrame)); itemp = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; itemp[x,y,:] = initial_temperature; end; end. initial_salinity = Matrix(CSV.read(""initial_salinity.csv"", DataFrame)); isal = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; isal[x,y,:] = initial_salinity; end; end. # `set!` the `model` fields using functions or constants:; set!(model, T = itemp, S ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:3396,depend,depends,3396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['depend'],['depends']
Integrability,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:402,Message,Message,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684,1,['Message'],['Message']
Integrability,"lots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:2418,wrap,wrappers,2418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,['wrap'],['wrappers']
Integrability,"low. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1150,rout,routine,1150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"lux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-4 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=0.3, Δt=0.10, max_change=1.1, max_Δt=0.1minute). wmax = FieldMaximum(abs, model.velocities.w); umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, umax = %.1e ms⁻¹, vmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),umax(sim.model), vmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=10minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289:2738,message,message,2738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289,1,['message'],['message']
Integrability,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:1607,integrat,integrate,1607,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,1,['integrat'],['integrate']
Integrability,"m 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a hr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:3897,depend,dependabot,3897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"m this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1342,rout,routine,1342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"m::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 903 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 903 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 31 overdub; 911 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _left_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31932,contract,contract,31932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"mage"" src=""https://user-images.githubusercontent.com/15271942/163682350-9c0e83e4-48c2-488d-8a2a-67c1c896faf8.png"">. Since I had to dig deep into the immersed boundary implementation, I made a few more long-needed changes:. * Finally, we directly serialize `ImmersedBoundaryGrid`; * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid""; * I cleaned up the output writers utilities a bit as well.; * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1145,interface,interfaces,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['interface'],['interfaces']
Integrability,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2772,protocol,protocols,2772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932,1,['protocol'],['protocols']
Integrability,"maximum iterations for this test are 20 with a 128 grid size, so I think we need to exclude the boundary condition possibility and look at other synchronization issues (maybe particular to the shallow water model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998:145,synchroniz,synchronization,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998,1,['synchroniz'],['synchronization']
Integrability,"mmit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8739,Depend,Dependabot,8739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['Depend'],['Dependabot']
Integrability,"model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1233,wrap,wraps,1233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['wrap'],['wraps']
Integrability,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:9071,Depend,Dependabot,9071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,9,"['Depend', 'depend']","['Dependabot', 'dependabot']"
Integrability,"mplement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [umax]) . xu2 = reshape(xu, grid.Nx, 1); zu2 = reshape(zu, 1, grid.Nz); u[bump.(xu2, 0, zu2)] .= NaN . u_plot = heatmap(xu, zu, u'; title = ""x velocity"", color = :balance, clims = (-ulim, ulim)). display(u_plot); ```. Note that the small time-step is near the gravity wave CFL for an explicit free surface on the specified grid. Somewhat larger time-steps are possible with an `ImplicitFreeSurface` but it seems the overall integration is slower that way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2423,integrat,integration,2423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,1,['integrat'],['integration']
Integrability,"mplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:1279,depend,depend,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938,1,['depend'],['depend']
Integrability,"n?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:3260,wrap,wrapper,3260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['wrap'],['wrapper']
Integrability,"n_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\Utils\pretty_time.jl:18; ```; I am attaching the file of Initial data whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:5474,message,message,5474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['message'],['message']
Integrability,"ncountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{V",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1080,synchroniz,synchronize,1080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['synchroniz'],['synchronize']
Integrability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:2502,depend,depends,2502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['depend'],['depends']
Integrability,"nditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); cfl=AdvectiveCFL(0.1); start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, cfl: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; cfl(model), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=0.1, stop_time=40minutes, iteration_interval=10,; progress=progress_message,parameters=(;cfl)); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:2601,message,message,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"nelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, typeof(Oceananigans.Fields.gpu__regrid!)})(::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::Nothing, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/YWLqR/src/CUDAKernels.jl:273; [15] launch!(::GPU, ::RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:10915,depend,dependencies,10915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"nged</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependencies &amp; build</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/b96a5725f5a28e33e247b8ebedb77663a8b9f960""><code>b96a572</code></a> Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> ...</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/437a175294dd49c0c379f79067d8ba50c3f0f31b""><code>437a175</code></a> update to node20 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/209"">#209</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:6918,depend,dependencies,6918,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['depend'],['dependencies']
Integrability,"ngs.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ptuckman/.julia/packages/KernelAbstractions/rFWPd/src/backends/cuda.jl:172; [21] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Oceananigans.Advection.CenteredSecondOrder, ::NonTraditionalFPlane{Float64}, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:18511,depend,dependencies,18511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['depend'],['dependencies']
Integrability,"nhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(f3); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Are KFOs meant to be used only with `Field`s? Or is this a bug?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455:1602,wrap,wrapping,1602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455,1,['wrap'],['wrapping']
Integrability,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9579,depend,dependencies,9579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,2,['depend'],['dependencies']
Integrability,"ns/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contribut",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:4076,Depend,Dependabot,4076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['Depend'],['Dependabot']
Integrability,"nst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1994,wrap,wrap,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['wrap'],['wrap']
Integrability,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1257,synchroniz,synchronize,1257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,4,['synchroniz'],['synchronize']
Integrability,ocket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1918,rout,routine,1918,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"ocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1006,message,messages,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['messages']
Integrability,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:2423,message,message,2423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['message'],['message']
Integrability,oh @francispoulin I now saw your message!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592:33,message,message,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592,1,['message'],['message']
Integrability,"oh now I saw that the secondary hidden commit message talks about ""a bug...""; can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about... (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504:46,message,message,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504,1,['message'],['message']
Integrability,"oh sorry, I just saw your reply... ; indeed the problem was with CUDA... I fixed it!. (I removed my question though... just putting this here in case the messages seem strange for the git-archaeologists of the next century.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992:154,message,messages,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992,1,['message'],['messages']
Integrability,"omputation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, th",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:6426,depend,depends,6426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['depend'],['depends']
Integrability,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1529,interface,interface,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,4,['interface'],['interface']
Integrability,or at least we could try following that route (it seems like there were some problems also with that implementation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834:40,rout,route,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834,1,['rout'],['route']
Integrability,"or example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common and useful development paradigm). What do others think about this? @iuryt @johnryantaylor @rafferrari @simone-silvestri @christophernhill @jm-c @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:2818,interface,interface,2818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['interface'],['interface']
Integrability,"ordering requirements are necessary for filling corner halos. ; This is done by `Periodic` boundary conditions in non-distributed simulations.; Additionally, since communication boundary conditions can be asynchronous, distributed (and multi-region) BCS need to be filled last. To remove order requirements we would need to fill the halo for flux, value, and gradient also in the corners.; I thought that might be a good idea but we hit a problem when having an `AbstractArray` boundary condition because we would need to construct the associated `OffsetArray`. . This can be prevented by wrapping the array in a `Field` and filling the halo regions but it seems like a heavy requirement to do it, and generally, a large API change that we might want to think about a little more. In #3338 I fixed the problem by separating out communicating boundary conditions which wasn't that complicated and maintained the current logic. . Maybe in the future, we might want to eliminate the order requirement though. So we can keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174:589,wrap,wrapping,589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174,1,['wrap'],['wrapping']
Integrability,"ore generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, filename) ; update_schedule!(schedule, filepath); ```. Make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1518,interface,interface,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['interface'],['interface']
Integrability,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2718,protocol,protocols,2718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326,1,['protocol'],['protocols']
Integrability,"partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:2132,integrat,integration,2132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['integrat'],['integration']
Integrability,per state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2766,rout,routine,2766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"r constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5259,message,message,5259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['message'],['message']
Integrability,"r for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good to discuss. I also did a little clean up and changed the internal function `TurbulenceClosures.DiffusivityFields` to `TurbulenceClosures.diffusivity_fields`. The code is inconsistent about the use of TitleCase (is it a constructor / struct? is it a function?) and there's a bit of clean up to do... Resolves #2422",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:1744,interface,interface,1744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['interface'],['interface']
Integrability,"r, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressible/incompressible or ocean/atmosphere capabilities within the same package.; 8. Under a shared package and user interface, Oceananigans.jl will allow users to easily switch between simulating compressible and incompressible fluids and might also allow for _fast and friendly_ coupled large-eddy simulation (although the amount of work needed to reach this would be non-trivial). # Mono-repo vs. multiple packages. I think merging this PR puts the Oceananigans.jl repo in danger of becoming a mono-repo so we should be careful. One big reason why we haven't kept the compressible model in a separate repo is because we just don't have a good name for it yet. A potential pathway to multiple packages would be to split out the Oceananigans.jl package into four packages: OceananigansBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:4705,interface,interface,4705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['interface'],['interface']
Integrability,r/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:15985,message,message,15985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"rdinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2731,depend,depending,2731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['depend'],['depending']
Integrability,"rection to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1485,depend,depend,1485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,2,['depend'],['depend']
Integrability,"red buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buoyancy-related parameters. Because of that we may want to stick with `buoyancy_perturbation`. Any ideas / alternative suggestions? An alternative is to perform a translation in the kernel functions; aka use `buoyancy_params` in the function signature of kernel(s) that call the function `buoyancy`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:1786,depend,dependent,1786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['depend'],['dependent']
Integrability,"rences in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which is quite nice, but you have to modify the original LaTeX and avoid using fancy packages. But it has `\bm` which is awesome!; 2. I'm depending on `Documenter#master` as the upcoming v0.24 has an awesome new layout and dark mode.; 3. Documentation building on Travis is failing so gotta figure this out as well. Resolves #102; Resolves #222; Resolves #240; Resolves #327; Resolves #332; Resolves #353; Resolves #354",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:3235,depend,depending,3235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['depend'],['depending']
Integrability,"riodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:3220,depend,depend,3220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['depend'],['depend']
Integrability,"rom a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR perhaps…",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:1270,depend,depend,1270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depend']
Integrability,"rom: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3022,wrap,wrappers,3022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['wrap'],['wrappers']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2858,rout,routine,2858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper st,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2954,rout,routine,2954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:3050,rout,routine,3050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:3146,rout,routine,3146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS mus,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:3242,rout,routine,3242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,roper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:3338,rout,routine,3338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see with the current design of `Simulation` here. PS do we need `Simulation.parameters`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1095:1844,interface,interface,1844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095,1,['interface'],['interface']
Integrability,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:2321,interface,interface,2321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['interface'],['interface']
Integrability,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1794,integrat,integrate,1794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['integrat'],['integrate']
Integrability,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:2490,message,message,2490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,1,['message'],['message']
Integrability,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2975,message,message,2975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,2,['message'],['message']
Integrability,"s</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://githu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:1093,depend,dependabot,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"se $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:1610,depend,dependent,1610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['depend'],['dependent']
Integrability,"set!(u::Field{G}, f::Function) should use xC, yC, zC (or xF, yF, zF) depending on Field.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/23:69,depend,depending,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/23,1,['depend'],['depending']
Integrability,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8682,depend,dependabot-security-updates,8682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['depend'],['dependabot-security-updates']
Integrability,"so catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would at least produce correct results in a straightforward way. I won't be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:979,interface,interface,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166,1,['interface'],['interface']
Integrability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2362,integrat,integrate,2362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['integrat'],['integrate']
Integrability,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,2,['wrap'],['wrapper']
Integrability,spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:1;/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:1;/glade/u/apps/casper/23.10/opt/wrappers/bin:1;/glade/u/apps/casper/23.10/opt/utils/bin:1;/glade/u/home/knudsenl/.local/bin:1;/usr/lib/mit/bin:1;/opt/pbs/bin:1;/glade/u/apps/casper/23.10/opt/view/bin:1;/usr/local/bin:3;/usr/bin:3;/sbin:2;/bin:3;/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin:1; __LMOD_REF_COUNT_NCAR_LDFLAGS_CUDA64 = /glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:1; NCAR_LDFLAGS_UCX = /glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib; __LMOD_REF_COUNT_ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards:1; ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards; __LMOD_REF_COUNT_NLSPATH = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin/locale/%l_%t/%N:1; JAVA_HOME = /usr/lib64/jvm/java-11-openjdk-11; INSTALLPATH_ROOT = /glade/u/apps/casper/default/spack/opt/spack; __LMOD_REF_COUNT_LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:3850,wrap,wrappers,3850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper stat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2674,rout,routine,2674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:6215,depend,depend,6215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['depend'],['depend']
Integrability,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1192,depend,depend,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,3,['depend'],"['depend', 'dependent']"
Integrability,"sumed to be a tracer and must be present; in `model.tracers`. If `discrete_form=false` (the default) and `parameters` are provided, then the _last_ argument; to `func` must be `parameters`. For example, if `func` has no `field_dependencies` but does; depend on `parameters`, then it must be callable with the signature. `func(x, y, z, t, parameters)`. With `field_dependencies=(:u, :v, :w, :c)` and `parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3201,depend,depending,3201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['depend'],['depending']
Integrability,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:365,synchroniz,synchronize,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600,1,['synchroniz'],['synchronize']
Integrability,"sure with viscosity ν and tracer diffusivities κ for each tracer field in tracers. If a single κ is provided, it is applied to all tracers. Otherwise κ; must be a NamedTuple with values for every tracer individually. Arguments; ≡≡≡≡≡≡≡≡≡. • time_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization(). • formulation:; • HorizontalFormulation() for diffusivity applied in the horizontal direction(s); • VerticalFormulation() for diffusivity applied in the vertical direction,; • ThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions. • FT: the float datatype (default: Float64). Keyword arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • ν: Viscosity. Number, AbstractArray, Field, or Function. • κ: Diffusivity. Number, AbstractArray, Field, Function, or NamedTuple of diffusivities with entries for each tracer. • discrete_form: Boolean; default: false. When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:. • discrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (λ, φ, z, t) for a LatitudeLongitudeGrid. • discrete_form = true:; • with loc = (nothing, nothing, nothing) (default): functions of (i, j, k, grid, ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center().; • with loc = (ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center(): functions of (i, j, k, grid). • parameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing. julia> using Oceananigans. julia> ScalarDiffusivity(ν=1000, κ=2000); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0). julia> const depth_scale = 100;. julia> @inline ν(x, y, z) = 1000 * exp(z / depth_scale); ν (generic function with 1 method). julia> ScalarDiffusivity(ν=ν); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498:1551,depend,depending,1551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498,1,['depend'],['depending']
Integrability,"t /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:67; [22] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3,Nothing}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing}}},CUDA.CuArray{Complex{Float64},3,Nothing},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3,Nothing},CUDA.CuArray{C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:12433,depend,dependencies,12433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['depend'],['dependencies']
Integrability,t be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2110,rout,routine,2110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,t be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2206,rout,routine,2206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,t be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2302,rout,routine,2302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1076,depend,depend,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,4,"['depend', 'inject']","['depend', 'injected']"
Integrability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2067,message,messages,2067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['message'],['messages']
Integrability,"tagging the wrong Navid…. ___________________________________________; Multidisciplinary Composer | Media Alchemist | Artist-Researcher; Associate Director, Topological Media Lab; Research Associate: Matralab, Milieux, HEXAGRAM, LASG; navidnavab.com <http://navidnavab.com> | 514.432.6633; ----------------------------------------------------------------------------. On Wed, Feb 14, 2024 at 12:47 AM Navid C. Constantinou <; ***@***.***> wrote:. > Thanks @navid <https://github.com/navid> for your suggestions above. I; > will incorporate them in subsequent commits.; >; > You can just click the button next to them and they are committed!; > Screenshot.2024-02-14.at.07.46.47.png (view on web); > <https://github.com/CliMA/Oceananigans.jl/assets/7112768/34363045-e8b1-4776-8436-a551babaa02e>; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1943122887>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDTZNCXD3DWZHODH2M3JLYTRFXFAVCNFSM6AAAAAA5S3QE4CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSNBTGEZDEOBYG4>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984:1172,Message,Message,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984,1,['Message'],['Message']
Integrability,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1982,rout,route,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['rout'],['route']
Integrability,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:119; [18] launch!; @ ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:90 [inlined]; [19] #compute_interior_tendency_contributions!#17; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:122 [inlined]; [20] compute_interior_tendency_contributions!; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:53 [inlined]; ```; Sorry for the length, I also had to remove some of the error message so GitHub would let me post it so feel free to let me know if you need to see more. I was able to fix the code by updating the function formatting from ; ``` @inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]) ```; to; ``` @inline constant_stratification(x, y, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])```; after consulting colleagues and was told this was due to a Julia update. I just wanted to inform y'all of this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3412:32219,message,message,32219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412,1,['message'],['message']
Integrability,thanks. And presumably a similar change needs to be done in the original script to include `IncompressibleModel`. That I think I can find and do. The last thing I can think of is where to define the function before there is a dispatch that occurs depending on the model.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343:247,depend,depending,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343,1,['depend'],['depending']
Integrability,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1985,depend,depend,1985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861,2,['depend'],['depend']
Integrability,"the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity an",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:5045,message,message,5045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['message'],['message']
Integrability,"the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@Kwargs{Nz::MultiRegionObject{…}, z::Tuple{…}, panel::Oceananigans.Utils.Iterate{…}, topology::Tuple{…}, halo::Tuple{…}, radius::Float64}); @ Oceananigans",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:1246,message,message,1246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['message'],['message']
Integrability,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063:197,wrap,wrapping,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063,4,['wrap'],"['wrap', 'wrapping']"
Integrability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:51,depend,depend,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,2,['depend'],"['depend', 'dependent']"
Integrability,"this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2377,integrat,integration,2377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['integrat'],['integration']
Integrability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2804,depend,depend,2804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['depend'],['depend']
Integrability,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:504,message,message,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,1,['message'],['message']
Integrability,"this was the innovation that Alistair had when he was sorting out the; numerics of the cubed sphere out. One needs the vorticity at the corner. He; expressed it as a circulation integral snaking across three surfaces of the; cube, rather than differencing. I'm in full support. On Sun, Apr 30, 2023 at 11:25 AM Gregory L. Wagner ***@***.***>; wrote:. > Does it make sense to try to reconstruct vorticity in the same way? Ie; > have we tried reconstructing the circulation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/98bcdde7ae679583ea88474ec0909469abccfc90/src/Operators/vorticity_operators.jl#L9; >; > and then computing vorticity by dividing by Azᶠᶜᶜ and Azᶜᶠᶜ?; >; > It makes a lot of sense to me that δx(Δy * u) + δy(Δx * v) is smoother; > than δx(Δy * u) + δy(Δx * v) / Azᶜᶜᶜ when the grid is strongly stretched.; >; > Maybe we should come up with test cases that have even more extreme; > stretching? It will be very very nice to have good properties on stretched; > grids for the cubed sphere.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529053452>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRBF7RYUYWS3KH4NGDXDZ75XANCNFSM6AAAAAAXQNM76E>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646:1350,Message,Message,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646,1,['Message'],['Message']
Integrability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2583,wrap,wrapper,2583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['wrap'],['wrapper']
Integrability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1346,message,messages,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['message'],['messages']
Integrability,"time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions and forcing functions. Previously, discrete-form boundary condition functions and forcing functions contained an object called `state`: `state.velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3894,depend,dependent,3894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['depend'],['dependent']
Integrability,"ting the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoustic time stepper (nothing, fully explicit for regular grids, vertically implicit for stretched grids); 4. Setting fields and initial conditions is more complicated because the density needs to be adjusted when setting the potential temperature. Also because the prognostic variables are ρ, ρu, ρv, ρw, ρθ, etc.; 5. Other atmospheric things like cloud microphysics and radiation but for this there are packages that can be relied on, e.g. [RRTMGP.jl](https://github.com/climate-machine/RRTMGP.jl) and [Cloudy.jl](https://github.com/climate-machine/Cloudy.jl). It would be ideal if we have a single `Model` type and just change the equation between the `CompressibleModel` an",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605:1636,interface,interface,1636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605,1,['interface'],['interface']
Integrability,"tively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter when lossless compression is on); - a default `bitrounder` that rounds to the keepbits as suggested above that can be used instead of `bitrounder=nothing` (default). We can then independently tweak the precision (how many keepbits, ideally as a function of the vertical, see salinity) and the lossless compressor (Zlib -> Zstandard)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:2208,interface,interface,2208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['interface'],['interface']
Integrability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:528,wrap,wrapping,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['wrap'],['wrapping']
Integrability,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4256,depend,depend,4256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,2,['depend'],['depend']
Integrability,"ually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:5077,interface,interface,5077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['interface'],['interface']
Integrability,"ue to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could dive much deeper into that example and test a wide variety of wave numbers. It depends whether you are interested in the grid-scale noise system, or whether you are interested in verifying that smooth resolved dynamics are correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423:2077,depend,depends,2077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423,2,['depend'],['depends']
Integrability,"uld not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:1534,rout,routine,1534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"up-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:2970,depend,dependabot,2970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:4812,depend,dependency,4812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['depend'],['dependency']
Integrability,ust be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:2398,rout,routine,2398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['rout'],['routine']
Integrability,"utterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:3672,depend,dependabot,3672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"vection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:1120,message,message,1120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,2,['message'],['message']
Integrability,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1039,protocol,protocol,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,6,"['depend', 'protocol']","['dependencies', 'dependency', 'protocol']"
Integrability,"we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1201,interface,interface,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['interface'],['interface']
Integrability,"whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:2023,interface,interface,2023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['interface'],['interface']
Integrability,"wicePrecision{Float64}, Base.Twice...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 _advective_momentum_flux_Uu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 overdub; 1363 0 @Oceananigans/src/Operators/difference_operators.jl 21 δxᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1372 0 @Oceananigans/src/Operators/difference_operators.jl 21 overdub; 1602 0 @Oceananigans/src/Operators/difference_operators.jl 20 δxᶜᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1681 1681 @KernelAbstractions/src/compiler/contract.jl 18 mul_float_contract; 1681 0 @KernelAbstractions/src/compiler.jl 47 overdub; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 _advective_momentum_flux_Vu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 overdub; 1714 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1781 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 13 _advective_momentum_flux_Vv(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1781 0 @Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:38491,contract,contract,38491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"yeah, if they are slow, the horizontal BCs for the barotropic velocities are included in the vertically integrated tendencies.; Not sure about eta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886:104,integrat,integrated,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886,1,['integrat'],['integrated']
Integrability,"yeah, that interpolation operator is defined as ; ```; @inline ℑxᶜᵃᵃ(i, j, k, grid::AG{FT}, u) where FT = @inbounds FT(0.5) * (u[i, j, k] + u[i+1, j, k]); ```. so it assumes that the field to be interpolated is located at `Faces`. It should not be used on Centered fields.; I do not think we need fallbacks, the operators are not part of the public API and I am not sure we want them to be as they have to be wrapped around kernels",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362:409,wrap,wrapped,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362,1,['wrap'],['wrapped']
Integrability,"yep, makes sense and works. ; Suggestion: add some comments/explanations in https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/. Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Anyway thanks for the quick and useful reply !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236:206,interface,interface,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236,1,['interface'],['interface']
Integrability,"yes please!. On Mon, Mar 28, 2022 at 8:04 PM Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** approved this pull request.; >; > Bump minor version. Would also be sweet to see some of the global; > solutions!; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2317#pullrequestreview-923878927>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXBJN3S56JM4PSIOITVCJCIPANCNFSM5QCCJFGA>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485:549,Message,Message,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485,1,['Message'],['Message']
Integrability,"you cannot use `WENO(; order =5)` in the y-direction if you have only one grid point. ; In this case the script would have to change to ; ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> advection = FluxFormAdvection(WENO(order=5), nothing, WENO(order=5)). julia> model = NonhydrostaticModel(; grid, advection); ```; I think spitting out the error should be the correct behavior because we want to make sure that people know what scheme is begin used in the different directions, and correct the advection scheme accordingly. We can probably change the error message to be a bit more descriptive",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348:204,depend,dependency,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"y}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels C:\Users\parfe\.julia\packages\CUDAKernels\4VLF4\src\CUDAKernels.jl:272; [15] launch!(::GPU, ::RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_south_and_north_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils C:\Users\parfe\.julia\packages\Oceananigans\B958I\src\Utils\kernel_launching.jl:95; [16] fill_south_and_north_halo!(::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:15953,depend,dependencies,15953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['depend'],['dependencies']
Integrability,"z""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:3447,depend,dependabot,3447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['depend'],['dependabot']
Integrability,"{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:11969,depend,dependencies,11969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['depend'],['dependencies']
Integrability,"~~I would try `u` because the behavior of eta could depend on whether you use explicit or implicit time-stepping.~~. Okay, I realized that you're using `ExplicitFreeSurface`. I think the comparison you want to make is to take an `euler` step with a NaN in `G-`, and check whether the NaN appears in the field where the NaN was inserted. You're checking `G-`, rather than the field itself. Since you're checking `G-` for NaNs, it doesn't appear for a couple more time-steps because the NaNs first appear in eta, and then get transferred to `Gn`, and _then_ get transferred to `G-` when `store_tendencies!` is called using `Gn` that has a NaN.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381,1,['depend'],['depend']
Integrability,"~~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~~. ~~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~~. ~~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~~. This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779:256,depend,dependency,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779,1,['depend'],['dependency']
Integrability,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:696,depend,depends,696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['depend'],['depends']
Integrability,"────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; ## Possible future improvements. In this PR I also attempted to explore an alternative formulation of the FFT-based preconditioner:. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H Δt) - ∇ʰ H ⋅ ∇ʰ η★ / H,; ```. where `η★` is the current solution in the conjugate gradient iteration. However, this caused the iteration to diverge. Perhaps it would be better to use `ηⁿ`, but I'm not sure. On the right side, `H` is no longer constant but instead is the actual depth `H(x, y)`. I also tried using `H̄` in the denominators above, but this apparently made no difference. # Other changes / improvements. To support this development, this PR implements some improvements to `PreconditionedConjugateGradientSolver`. Previously we would specify the argument `precondition!`, which was supposed to be a function that computed `P * r`, where `P` is often called the ""preconditioner"". Now we specify `preconditioner`, which must define a method. ```julia; precondition!(z, preconditioner, r, args...); ```. This API is more convenient for preconditioners that require some data storage or precomputation and thus must be objects of their own (rather than functions). - In the conjugate gradient loop, we launch broadcasts with `parent(a) .= parent(b)` rather than using Oceananigans internal broadcasting `a .= b`. This is a bit faster and saves some memory allocation.; - The default preconditioner for `PCGImplicitFreeSurface` is now `nothing`.; - We now always precompute and store `GridFittedBottom`, since it's rarely / never desired to compute on the fly and ""only supporting arrays"" simplifies our code.; - The interface for `PreconditionedConjugateGradientSolver` now resembles the interface to `cg` with properties `maxiter`, `abstol`, and `reltol`; - The default `reltol` for the `PCGImplicitFreeSurfaceSolver` is `max(1e-7, 10 * eps(eltype(grid)))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:7019,interface,interface,7019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,2,['interface'],['interface']
Integrability,"✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4478,depend,dependency,4478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependency']
Modifiability," 2, 2020, 5:41 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR adds experimental support for rotating/tilting the gravity vector.; >; > I'm not even sure if it works properly but I'm opening a draft PR as it; > might be ready to be experimented with? I don't think we can have a; > non-zero gravity component along a periodic direction as the fluid just; > free falls along that dimension and the model blows up.; >; > But here's a plume rising with gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b5",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1089,refactor,refactor,1089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,1,['refactor'],['refactor']
Modifiability," A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functionality into FourierFlows (which is generally more flexible than Oceananigans, but has fewer features for the specific problem of the nonhydrostatic Boussinesq equations), but that's not a small piece of work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:1672,flexible,flexible,1672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,2,['flexible'],['flexible']
Modifiability," I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:1429,variab,variable,1429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['variab'],['variable']
Modifiability," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1174,config,config,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['config'],['config']
Modifiability," c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; The worst-case scenario occurs when both cosines evaluate to -1, to hit this condition it is enough to have grid-scale noise, which has the maximum expressible wavenumber of $\kappa = \pi / \Delta x$. In this case we have; $$\Delta t \cdot \left( \frac{u}{\Delta x} + \frac{v}{\Delta y} \right)< 1$$; Since the direction is arbitrary you can substitute $u$ and $v$ with their absolute values and you get; $$\Delta t < \left( \frac{|u|}{\Delta x} + ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:1139,rewrite,rewrite,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,1,['rewrite'],['rewrite']
Modifiability," domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2992,variab,variables,2992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['variab'],['variables']
Modifiability," easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1313,Adapt,Adapt,1313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,2,['Adapt'],['Adapt']
Modifiability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1950,extend,extend,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['extend'],['extend']
Modifiability," if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it. Does this make sense to everyone? I also can't see an obvious way to get $\Delta t$ to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. Update:. I'm not sure if",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:2112,extend,extend,2112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['extend'],['extend']
Modifiability," is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of gr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:982,Extend,Extend,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['Extend'],['Extend']
Modifiability," push!(Rit, deepcopy(interior(Ri, 1, 1, :))); push!(bt, deepcopy(interior(b, 1, 1, :))); push!(ut, deepcopy(interior(u, 1, 1, :))); push!(et, deepcopy(interior(e, 1, 1, :))); push!(κct, deepcopy(interior(κc, 1, 1, :))); push!(κut, deepcopy(interior(κu, 1, 1, :))). return nothing; end. t = 0:10minutes:simulation.stop_time; Nt = length(t). simulation.callbacks[:dc] = Callback(collect_data, SpecifiedTimes(t)). run!(simulation). fig = Figure(resolution=(800, 600)). axR0 = Axis(fig[1, 1], xlabel=""Ri⁻¹"", ylabel=""z (m)""); axe0 = Axis(fig[2, 1], xlabel=""e"", ylabel=""z (m)"", xticks=[1e-6, 2e-5]); axκ0 = Axis(fig[3, 1], xlabel=""κ"", ylabel=""z (m)"", xticks=[0.0, 2e-3, 4e-3]). axR = Axis(fig[1, 2], xlabel=""Time (hr)"", ylabel=""z (m)"", xaxisposition=:top); axe = Axis(fig[2, 2], ylabel=""z (m)""); axκ = Axis(fig[3, 2], xlabel=""Time (hr)"", ylabel=""z (m)""). hidexdecorations!(axe). hidespines!(axR0, :r, :t); hidespines!(axe0, :r, :t); hidespines!(axκ0, :r, :t). Prt = map((κu, κc) -> κu ./ κc, κut, κct). bzt = hcat(bt...)'; Rzt = hcat(Rit...)'; ezt = hcat(et...)'; κzt = hcat(κct...)'; Pzt = hcat(Prt...)'. zc = znodes(grid, Center()); zf = znodes(grid, Face()). for n = (7, 49, 24*4+1); @show tn = t[n] / hour; label = @sprintf(""t = %d hr"", tn); lines!(axR0, 1 ./ Rit[n], zf; label); ln = lines!(axe0, et[n], zc); lines!(axκ0, κct[n], zf, color = ln.color.val, label=""κᶜ""); lines!(axκ0, κut[n], zf, linestyle=:dash, color=ln.color.val, label=""κᵘ""); end. Legend(fig[2, 0], axR0); Legend(fig[3, 0], axκ0, merge=true). vlines!(axR0, 4, color=(:gray, 0.5), linewidth=4). cr = contourf!(axR, t ./ hour, zf, 1 ./ Rzt, levels = 0:10, colormap=:viridis)#, extendhigh=true, extendlow=true); Colorbar(fig[1, 3], cr, label=""Ri⁻¹""). cr = contourf!(axe, t ./ hour, zc, ezt, levels=10, colormap=:heat); Colorbar(fig[2, 3], cr, label=""E (m² s⁻²)""). cr = contourf!(axκ, t ./ hour, zf, κzt, levels=10, colormap=:solar); Colorbar(fig[3, 3], cr, label=""κᶜ (m² s⁻¹)""). colsize!(fig.layout, 1, Relative(0.2)). display(fig); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970:2692,extend,extendhigh,2692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability," significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:1087,refactor,refactored,1087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,1,['refactor'],['refactored']
Modifiability," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:3117,refactor,refactoring,3117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['refactor'],['refactoring']
Modifiability," that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:1298,variab,variable,1298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['variab'],['variable']
Modifiability," the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1452,Adapt,Adapt,1452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Modifiability," well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a preconditioner for a fixed point iteration. We could do the same thing except with a conjugate gradient iteration (possibly slightly better than a fixed point iteration). It's possibly a nice project for someone interested in LES above or below weakly distorted boundaries. Note that this method probably won't work when the bathymetry is ""too big"", because the iterative solve may converge too slowly. cc @whitleyv .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514:1616,refactor,refactor,1616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514,2,['refactor'],['refactor']
Modifiability," … 0.00%; Time (median): 9.717 ms ┊ GC (median): 0.00%; Time (mean ± σ): 9.797 ms ± 271.120 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ █ █ █ █; █▁█▁▁▁▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 9.61 ms Histogram: frequency by time 10.3 ms <. Memory estimate: 89.45 KiB, allocs estimate: 320. ```. on this branch:; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(momentum_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(13.991 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 13.991 ms … 22.167 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.057 ms ┊ GC (median): 0.00%; Time (mean ± σ): 15.676 ms ± 3.629 ms ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁; 14 ms Histogram: frequency by time 22.2 ms <. Memory estimate: 487.70 KiB, allocs estimate: 766. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(tracer_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(4.807 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 4.807 ms … 5.457 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 4.819 ms ┊ GC (median): 0.00%; Time (mean ± σ): 4.958 ms ± 281.609 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █▁ ▁ ▁; ██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 4.81 ms Histogram: frequency by time 5.46 ms <. Memory estimate: 88.53 KiB, allocs estimate: 261. ```; A test on the global ocean configuration (found in [prototype_omip_simulation.jl](https://github.com/CliMA/ClimaOcean.jl/blob/aacd2e19b81e35a3b220bd45aa6b5bcb98dc876d/prototype_omip_simulation/prototype_omip_simulation.jl) ) is incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643:2789,config,configuration,2789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643,1,['config'],['configuration']
Modifiability,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:5684,Adapt,Adapt,5684,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['Adapt'],['Adapt']
Modifiability,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6210,inherit,inherit,6210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,3,['inherit'],"['inherit', 'inherited', 'inheriting']"
Modifiability,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1307,parameteriz,parameterizations,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['parameteriz'],['parameterizations']
Modifiability,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:291,refactor,refactoring,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['refactor'],['refactoring']
Modifiability,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:366,polymorphi,polymorphism,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['polymorphi'],['polymorphism']
Modifiability,## try. Configuration problem:; bors.toml: not found,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702:8,Config,Configuration,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702,1,['Config'],['Configuration']
Modifiability,(0.90.3) Fix bug in adapting `ScalarDiffusivity` and `ScalarBiharmonicDiffusivity`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413:20,adapt,adapting,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413,1,['adapt'],['adapting']
Modifiability,(0.91.14) Extend Lagrangian advection to immersed grids and add tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3765:10,Extend,Extend,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3765,1,['Extend'],['Extend']
Modifiability,(0.92.2) Add more advection scheme tests; fix order adapting with tracer-specific schemes; fix WENOVectorInvariant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3864:52,adapt,adapting,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3864,1,['adapt'],['adapting']
Modifiability,(0.93.2) Update Adapt.jl compat and fix `Float32` CATKE on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876:16,Adapt,Adapt,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876,1,['Adapt'],['Adapt']
Modifiability,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:47429,Parameteriz,ParameterizedForcing,47429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45289,Parameteriz,ParameterizedForcing,45289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:41318,Parameteriz,ParameterizedForcing,41318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:49313,Parameteriz,ParameterizedForcing,49313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [15] macro expansion at ./lock.jl:183 [inlined]; [16] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:43437,Parameteriz,ParameterizedForcing,43437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(@simone-silvestri, until we implement the refactor and/or changes, what's the best way forward using v0.87.1?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026:43,refactor,refactor,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026,1,['refactor'],['refactor']
Modifiability,"(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, ::Clock{Float64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/time_stepping_kernels.jl:18; [27] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:51383,Parameteriz,ParameterizedForcing,51383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:70,sandbox,sandbox,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['sandbox'],['sandbox']
Modifiability,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:6463,coupling,coupling,6463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['coupling'],['coupling']
Modifiability,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:2185,adapt,adapting,2185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,1,['adapt'],['adapting']
Modifiability,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:1172,variab,variable,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924,2,['variab'],['variable']
Modifiability,*Enhance* simulation `Callback` and model `StateModifier` utilities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895:1,Enhance,Enhance,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895,1,['Enhance'],['Enhance']
Modifiability,", 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:1369,adapt,adapted,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,2,['adapt'],['adapted']
Modifiability,", :, 8] =; -0.0260201 -0.0147839 -0.00890929 -0.00551279 -0.00345117 -0.00217171 -0.00136973 … -0.00250611 -0.00396347 -0.00628301 -0.0100122 -0.0161434 -0.0267292 -0.0469493. julia> interior(dwpdz); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), 1:1, 1:512, 1:8) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 5] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 6] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 7] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 8] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. Am I missing something here? Is computation for pressure somehow different from other variables?. Notes:. - If I replace `p = sum(model.pressures)` for `p = model.pressures.pNHS` the result is the same.; - If I calculate instead just the `w * p` term in the kernel the result is correct! So apparently it has to do with the derivative of the pressure, not just the pressure itself.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401:4874,variab,variables,4874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401,1,['variab'],['variables']
Modifiability,",Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(circular_salinity_flux),NamedTuple{(:melt_rate, :xb, :yb, :Rb),NTuple{4,Float64}}}}}}}}}},NamedTuple{(:pHY′, :pNHS),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:11798,Parameteriz,ParameterizedDiscreteBoundaryFunction,11798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,2,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,- Uses NCDatasets.jl; - Allows slicing; - Should be fast because a new file is not created for every output time-step (I guess the previous netcdf writer was slow because it created a new file for every output time-step which added a lot of overhead); - See example for usage (it works on CPU!). TODO:; - Global and per variable attributes. Edit:; - Needs to be tested; - We need to discuss halo regions (the dimension lengths are not consistent with the array sizes thanks to halo regions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433:320,variab,variable,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433,1,['variab'],['variable']
Modifiability,"-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1817,extend,extended,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['extend'],['extended']
Modifiability,"-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off about this approach. I think `stretching` should somehow depend on `refinement`; eg when `refinement = 1` then no stretching is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1810:1534,parameteriz,parameterization,1534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810,2,['parameteriz'],['parameterization']
Modifiability,".julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:112; [10] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:97; [11] run!(sim::Simulation{NonhydrostaticModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:85; [12] top-level scope; @ ~/repos/Oceananigans.jl/sandbox/mwe.jl:31; [13] include(fname::String); @ Base.MainInclude ./client.jl:489; ```. So it's not as trivial as the single change I just made. From glancing at the code we at least have to modify `initialize_nc_file!()` to take a `grid` option as well:. https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/OutputWriters/netcdf_output_writer.jl#L625-L636. plus a couple of other things. Still pretty easy, but more work/time that I have right now. @iuryt feel free to jump in here and make these changes if you feel it's necessary, since creating a whole separate model can be a bit onerous and wastes precious GPU memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:3084,sandbox,sandbox,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['sandbox'],['sandbox']
Modifiability,"/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essenti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7133,adapt,adapt,7133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,1,['adapt'],['adapt']
Modifiability,/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `79.76% <100.00%> (+3.85%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2348,parameteriz,parameterized,2348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1953,config,configurable,1953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['config'],['configurable']
Modifiability,"19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version = ""0.5.3+4"". [[OrderedCollections]]; git-tree-sha1 = ""4fa2ba51070ec13fcc7517db714445b4ab986bdf""; uuid = ""bac558e1-5e72-5ebc-8fee-abe8a469f55d""; version = ""1.4.0"". [[Parsers]]; deps = [""Dates""]; git-tree-sha1 = ""c8abc88faa3f7a3950832ac5d6e690881590d6dc""; uuid = ""69de0a69-1ddd-5017-9359-2bf0b02dc9f0""; version = ""1.1.0"". [[Penci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11562,Adapt,Adapt,11562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"1f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 = ""ddec5466a1d2d7e58adf9a427ba69763661aacf6""; uuid = ""aedffcd0-7271-4cad-89d0-dc628f76c6d3""; version = ""0.2.4"". [[StaticArrays]]; deps = [""LinearAlgebra"", ""Random"", ""Statistics""]; git-tree-sha1 = ""e8cd1b100d37f5b4cfd2c83f45becf61c762eaf7""; uuid = ""90137ffa-7385-5640-81b9-e52037218182""; version = ""1.1.1"". [[StaticPermutations]]; git-tree-sha1 = ""193c3daa18ff3e55c1dae66acb6a762c4a3bdb0b""; uuid = ""15972242-4b8f-49a0-b8a1-9ac0e7a1a45d""; version = ""0.3.0"". [[Statistics]]; deps = [""LinearAlgebra"", ""SparseArrays""]; uuid = ""10745b16-79ce-11e8-11f9-7d13ad32a3b2"". [[StructArrays]]; deps = [""Adapt"", ""DataAPI"", ""Tables""]; git-tree-sha1 = ""44b3afd37b17422a62aea25f04c1f7e09ce6b07f""; uuid = ""09ab397b-f2b6-538f-b94a-2f83cf4a842a""; version = ""0.5.1"". [[StructTypes]]; deps = [""Dates"", ""UUIDs""]; git-tree-sha1 = ""e36adc471280e8b346ea24c5c87ba0571204be7a""; uuid = ""856f2bd8-1eba-4b0a-8007-ebc267875bd4""; version = ""1.7.2"". [[TOML]]; deps = [""Dates""]; git-tree-sha1 = ""44aaac2d2aec4a850302f9aa69127c74f0c3787e""; uuid = ""fa267f1f-6049-4f14-aa54-33bafae1ed76""; version = ""1.0.3"". [[TableTraits]]; deps = [""IteratorInterfaceExtensions""]; git-tree-sha1 = ""c06b2f539df1c6efa794486abfb6ed2022561a39""; uuid = ""3783bdb8-4a98-5b6b-af9a-565f29a5fe9c""; version = ""1.0.1"". [[Tables]]; deps = [""DataAPI"", ""DataValueInterfaces"", ""IteratorInterfaceExtensions"", ""LinearAlgebra"", ""TableTraits"", ""Test""]; git-tree-sha1 = ""c9d2d262e9a327be1f35844df25fe4561d258dc9""; uuid = ""bd369af6-aec1-5ad0-b16a-f7cc5008161c""; version = ""1.4.2"". [[TaylorSeries]]; deps = [""InteractiveUtils"", ""LinearAlgebra"", ""Markdown"", ""Requires"", ""SparseArrays""]; git-tree-sha1 = ""66f4d1993bae49eeba21a1634",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:15966,Adapt,Adapt,15966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"2 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stoppi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2473,variab,variably,2473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stoppin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4269,variab,variably,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendencies to checkpoint. Also of course RK3 is actually 3rd order whereas QAB2 is first order. Note that the advantages of RK3 have historically not been useful for ocean simulations because at coarse (non-eddy-resolving) resolutions the momentum time-step is limited by Coriolis, not by CFL / advection. In that case a one-stage time-stepper might be preferred. > Out of curiousity, how much work is it to implement RK3 for HydrostaticFreeSurfaceModel?. It may be a research project to adapt the split-explicit free surface. It's little unclear because naively, we may be able to advance the split-explicit free surface each stage and therefore use the same algorithm we use for AB2. But there has been some work to implement an algorithm that resembles Le and Moin 1991 where the free surface is advanced to the end of the time-step, while baroclinic variables are advanced in stages. That would yield even more speed up. @simone-silvestri has thought about this a bit and might have more to add...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394:2482,adapt,adapt,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394,4,"['adapt', 'variab']","['adapt', 'variables']"
Modifiability,"4,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16437,sandbox,sandbox,16437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Modifiability,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7160,Adapt,Adapt,7160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,"64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51446,sandbox,sandbox,51446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Modifiability,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3036,Adapt,Adapt,3036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Adapt'],['Adapt']
Modifiability,"76d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-5462-911a-8362d720325c""; version = ""0.3.5"". [[ChainRulesCore]]; deps = [""Compat"", ""LinearAlgebra"", ""SparseArrays""]; git-tree-sha1 = ""5402b5674b3068ca570771c11da9a57bfa70acd4""; uuid = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; version = ""0.9.39"". [[Compat]]; deps = [""Base64"", ""Dates"", ""DelimitedFiles"", ""Distributed"", ""InteractiveUtils"", ""LibGit2"", ""Libdl"", ""LinearAlgebra"", ""Markdown"", ""Mmap"", ""Pkg"", ""Printf"", ""REPL"", ""Random"", ""SHA"", ""Serialization"", ""SharedArrays"", ""Sockets"", ""SparseArrays"", ""Statistics"", ""Test"", ""UUIDs"", ""Unicode""]; git-tree-sha1 = ""ac4132ad78082518ec2037ae5770b6e796f7f956""; uuid = ""34da2185-b29b-5c13-b0c7-acf172513d20""; version = ""3.27.0"". [[CompilerSup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:1532,Adapt,Adapt,1532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:12316,config,configure,12316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['config'],['configure']
Modifiability,": Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4973,variab,variable,4973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,": ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:2826,Adapt,Adapt,2826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['Adapt'],['Adapt']
Modifiability,":CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstractions\MAxUm\src\extras\loopinfo.jl:26 [inlined]; [13] iterate_split_explicit!(free_surface::SplitExplici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1862,Adapt,Adapt,1862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,2,['Adapt'],['Adapt']
Modifiability,"; Installed Missings ──────────────────── v1.2.0; Installed StringManipulation ────────── v0.3.4; Installed UnsafeAtomics ─────────────── v0.2.1; Installed SortingAlgorithms ─────────── v1.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Precompiling project...; ✓ LLVMLoopInfo; ✓ DataValueInterfaces; ✓ Reexport; ✓ IteratorInterfaceExtensions; ✓ LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:3638,Adapt,Adapt,3638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,3,['Adapt'],"['Adapt', 'AdaptStaticArraysExt']"
Modifiability,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:1751,config,configuration,1751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,2,['config'],['configuration']
Modifiability,"=======================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in y. At this point the three in-place forward transforms are complete, and we; solve the Poisson equation by updating `last(storage)`.; Then the process is reversed to obtain `first(storage)` in physical; space and with the layout (z, x, y). Restrictions; ============. The algorithm for two-dimensional decompositions requires that `Nz = size(global_grid, 3)` is larger; than either `Rx = ranks[1]` or `Ry = ranks[2]`, where `ranks` are configured when building `MultiArch`.; If `Nz` does not satisfy this condition, we can only support a one-dimensional decomposition. Algorithm for one-dimensional decompositions; ============================================. This algorithm requires a one-dimensional decomposition with _either_ `Rx = 1`; _or_ `Ry = 1`, and is important to support two-dimensional transforms. For one-dimensional decompositions, we place the decomposed direction _last_.; If the number of ranks is `Rh = max(Rx, Ry)`, this algorithm requires that; _both_ `Nx > Rh` _and_ `Ny > Rh`. It remains somewhat of a mystery why this; succeeds (ie, why the last transform is correctly decomposed).; """"""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:2477,config,configured,2477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['config'],['configured']
Modifiability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:1053,sandbox,sandbox,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,2,['sandbox'],['sandbox']
Modifiability,"> 2\. Climate Machine also has a shallow water [model](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl). I don't know the details of what this does but I should probably learn how the two models will differ. I'm not 100% sure how its implemented but I think at the end it'd be great if both ClimateMachine and Oceananigans shallow water models used the same equation set, since we can then compare the numerics. We don't have the bandwidth to develop the ClimateMachine shallow water model, but possibly at the time the Oceananigans has a nice one we'll be motivated to flesh out ClimateMachine's model. I'm not sure about immersed boundaries --- does the method generalize in a simple way? I'm not sure whether a special treatment is required for the height field, compared to an ordinary velocity variable, or tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787:850,variab,variable,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787,1,['variab'],['variable']
Modifiability,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:47,evolve,evolve,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866,1,['evolve'],['evolve']
Modifiability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:1318,config,configuration,1318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,2,['config'],['configuration']
Modifiability,"> > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.; > ; > True true.; > ; > Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?. Because of the no-flux boundary condition? I think that's correct, ok to have. You could have a mixed layer at the top too!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063:390,parameteriz,parameterizations,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063,1,['parameteriz'],['parameterizations']
Modifiability,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:397,flexible,flexible,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399,2,['flexible'],['flexible']
Modifiability,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:45,evolve,evolve,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919,1,['evolve'],['evolve']
Modifiability,"> > > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > > ; > > ; > > But I thought the whole idea is to be able to provide an `Array` for forcing.; > . `Field` is an abstract array. You should think of `Field` as a kind of `Array`. (We also want `CuArray` of course, and `SubArray`, `OffsetArray`, etc...). This code should work with anything for which `array[i, j, k]` is meaningful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941:123,adapt,adapts,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941,1,['adapt'],['adapts']
Modifiability,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:655,config,configuration,655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['config'],['configuration']
Modifiability,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:375,flexible,flexible,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,2,['flexible'],['flexible']
Modifiability,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:90,variab,variables,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613,2,['variab'],['variables']
Modifiability,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,1,['refactor'],['refactor']
Modifiability,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:454,layers,layers,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['layers'],['layers']
Modifiability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:749,extend,extends,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,1,['extend'],['extends']
Modifiability,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122:509,refactor,refactoring,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122,2,['refactor'],['refactoring']
Modifiability,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:935,refactor,refactor,935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['refactor'],['refactor']
Modifiability,"> > Doesn't that already exist?; > > We just have to adapt the test; > ; > Yes, the test I think only tests the `NetCDFOutputWriter`. There is already a test for the `JLD2OutputWriter`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160:53,adapt,adapt,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160,1,['adapt'],['adapt']
Modifiability,"> > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > ; > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically. True true. Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817:368,parameteriz,parameterizations,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817,1,['parameteriz'],['parameterizations']
Modifiability,"> > Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.; > ; > I think so. Let's definitely try!; > ; > Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?. We have `FluxBoundaryCondition` already which is the same. The difference in terms of user input is that an immersed boundary condition _function_ has to be called with three indices `i, j, k` rather than two like all the other boundary conditions. I don't think we need any new types in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738:21,adapt,adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738,1,['adapt'],['adapt']
Modifiability,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027:385,flexible,flexible,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027,2,['flexible'],['flexible']
Modifiability,"> > I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...; > ; > What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help. ```bash; $ which mpiexec; /opt/homebrew/bin/mpiexec; ```. I don't have a `LocalPreferences.toml`, I never did anything with MPIPreferences. Do I need to? I just did what the tutorial was suggesting and that wasn't part of the instructions -- that's why I didn't do anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128:169,config,configuration,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> > I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that.; > ; > What I mean is that it's makes it easier for a user to write something like:; > ; > ```julia; > u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); > ```; > ; > and have it (correctly) return 0 when `closure=nothing`.; > ; > I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances.; > ; > Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition. In the future instead of using an if-statement, you can extend `viscosity` and `diffusivity` in your own code (temporarily, until a PR like this one is merged)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192:1146,extend,extend,1146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192,2,['extend'],['extend']
Modifiability,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954:83,evolve,evolves,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954,2,['evolve'],['evolves']
Modifiability,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:415,config,configured,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570,2,['config'],['configured']
Modifiability,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399:206,variab,variable,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399,2,['variab'],['variable']
Modifiability,"> > I now recall the reason for the discrepancy. It was due to an index shift, which made filling the extra layer of halos quite straightforward, so I proceeded with it. For example, field_1[2:Nc+1, Nc+1:Nc+Hc] from an odd panel corresponds to field_2[1:Hc, 1:Nc] from the panel to the north. I can modify this expression to field_1[2:Nc, Nc+1:Nc+Hc] aligning with field_2[1:Hc, 2:Nc] and make similar adjustments for other halo fillings to minimize confusion. Please let me know your thoughts.; > ; > My thoughts are two:; > ; > * how will we know that while doing that change you won't break anything since there is no test for any of these things; > * I understand that you are telling me is merely an indexing reordering, that is instead of doing; > ```julia; > for j in 1:10; a[j] = 10; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > you do; > ```julia; > for j in 2:11; a[j-1] = j-1; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > right? But these two will result to the same array. So I'm confused. I understand that there is no test for these things, but the chances of breaking the code is nil because the same logic applies to the remaining halo points. Regarding the index shifting, your example is not quite analogous to our case. Just consider my example above, where field_1[2:Nc+1, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 1:Nc] of panel 3. That is for sure, right? If, instead, I specified field_1[2:Nc, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 2:Nc] of panel 3, that would have removed the additional row/column of halo fills and made it look cleaner. I thought if the additional row/column were filled incorrectly, it would have been reflected in the remaining rows/columns as well, since the halos were filled in the same way. But, yes, I agree with your other comment that cleaning up the code would enhance its clarity and enable future recollection of our work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530:1854,enhance,enhance,1854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530,1,['enhance'],['enhance']
Modifiability,"> > I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation.; > ; > I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":; > ; > Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems.; > ; > We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:608,adapt,adapt,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['adapt'],['adapt']
Modifiability,"> > I suggest we remove the parameter for `gravitational_acceleration`.; > > @francispoulin any objection to that?; > ; > Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations. I only meant removing the explicit type declaration of the parameter. Sorry, should have been clearer. :); But we decided not to. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182:209,evolve,evolve,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182,2,['evolve'],['evolve']
Modifiability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:717,extend,extend,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,4,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:244,adapt,adapt,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['adapt'],['adapt']
Modifiability,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:641,extend,extended,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['extend'],['extended']
Modifiability,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230:846,parameteriz,parameterization,846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230,2,['parameteriz'],['parameterization']
Modifiability,"> > I will add a docstring with some explanation, and replace some of the if-statements with multiple dispatch.; > ; > What will you dispatch on though? A docstring is for sure needed. Thanks!. I see your point. For dispatch, the argument types need to be different, which is not the case here. I used so many if statements to minimize the number of functions. I think I will just rewrite them in more readable way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932:381,rewrite,rewrite,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932,1,['rewrite'],['rewrite']
Modifiability,"> > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?. Mainly I think we can get all the same benefits by maintaining a single unified and tidy repository with sub-modules. I don't see Oceananigans as a complex project yet, we're barely at 2,500 lines of code (minus turbulence closure operators which aren't integrated yet). I can see reasons for having a separate repository for examples and tutorials if there are enough of them, but I don't see e.g. the output writers as being logically separate from the main code. As a stand alone package, OceananigansOutput.jl doesn't do anything useful. Something like TurbulenceClosures.jl could though. Keeping things in tidy submodules within a single repository increases code visibility, which I think is important. When I see a package or framework spread across multiply small packages I find it hard to get an idea about what it can do. Another nice thing is we currently have ""unified versioning"" so when releases occur we know everything works together. We don't have to worry about running with Oceananigans v0.x with OceananigansPlotting v0.y and OceananigansOutput#master to fix some issue. From a development perspective, issues and pull requests are now spread across multiple repositories and we can end up with pull requests that depend on other pull requests in other repositories, e.g. when adding in halo regions the main code got refactored but so did the output writers and plotting code would change as well. We can also end up with multiple test suites that need to pass, plus possibly multiple CI pipelines to manage. So right now it's easy to make atomic changes that touch upon multiple pieces of code (and we'll probably be in this stage where we need to refactor frequently for a while). I also don't have to git clone a bunch of repositories just to work on a simple example. But this is getting off-topic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749:1439,refactor,refactored,1439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749,2,['refactor'],"['refactor', 'refactored']"
Modifiability,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:43,evolve,evolve,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652,1,['evolve'],['evolve']
Modifiability,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:124,variab,variably,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['variab'],['variably']
Modifiability,> > Likely this function is the problem:; > > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/BoundaryConditions/update_boundary_conditions.jl#L15-L16; > ; > Yeah I saw that this was where some of the errors were coming from but I don't really understand what is going on with Enzyme that this causes problems?. It could be that this function is recursive coupled with the fact that `boundary_conditions` is not type-inferrable. So we may want to rewrite both of those functions. Luckily typically the changes we make to improve type inferrence (making it easier for the compiler to understand) also make it easier for humans to understand. As a starting point I don't think we can use the `Tuple` generator...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349:490,rewrite,rewrite,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349,1,['rewrite'],['rewrite']
Modifiability,"> > Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines.; > ; > Can you elaborate for the benefit of future generations?. For sure, the problems were:. - to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to `biogeochemical_transitions` - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable; - I then needed to be able to compute the bgc tendencies only so I added a function to the bgc file to launch a kernel that just computes `biogeochemical_transitions`; - Then I made the new time stepper which is just a container for two different timesteppers called `physics` and `biogeochemistry` (which are normal timesteppers so each have a set of tendencies etc.); - this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at `timestepper.G` / `$G^-$`, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned `timestepper.physics.G` etc.; - Then I had to add `time_step_biogeochemistry!` functions which do the same as `time_step!` but only comput the bgc tendencies. So to summarise: 1) separating the bgc tendency calculations from the rest, 2) make somewhere for the bgc tendencies to live and return the physics tendencies when expected, 3) step the bgc on its own",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735:572,maintainab,maintainable,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735,1,['maintainab'],['maintainable']
Modifiability,"> > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > ; > But I thought the whole idea is to be able to provide an `Array` for forcing. `Field` is an abstract array. You should think of `Field` as a kind of `Array`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257:121,adapt,adapts,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257,1,['adapt'],['adapts']
Modifiability,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:528,extend,extend,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128,2,['extend'],['extend']
Modifiability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:994,sandbox,sandbox,994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509,2,['sandbox'],['sandbox']
Modifiability,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:363,flexible,flexible,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,2,['flexible'],['flexible']
Modifiability,"> > This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage; > ; > So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way? We should definitely add a link to that docs page then. No the best thing to do is to call `mpiexecjl`, which is installed when you install `MPI.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680:39,config,configure,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680,2,['config'],"['configuration', 'configure']"
Modifiability,"> > We should also add a test similar to the one that was added in #3512.; > ; > Doesn't that already exist?; > ; > We just have to adapt the test. Yes, the test I think only tests the `NetCDFOutputWriter`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688:132,adapt,adapt,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688,1,['adapt'],['adapt']
Modifiability,"> > Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > > ```julia; > > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which will become a number for single layers?; > ; > Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both. Ok! This type field will be pf different type for single and multilayer models then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372:328,layers,layers,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372,1,['layers'],['layers']
Modifiability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:940,variab,variables,940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['variab'],['variables']
Modifiability,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:233,adapt,adapted,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['adapt'],['adapted']
Modifiability,"> > but I guess you are telling me that it defaults to the position of the first variable?; > ; > Correct.; > ; > > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something; > ; > My apologies for being unclear! I would write; > ; > ```julia; > uh, vh, h = model.solution; > u = ComputedField(uh / h); > ```. Great to know, thanks!. Actually, the fact that I have uh, vh and h already defined causes some problems. Rather than introducing more variables I will probably just use the long name. I will try and not forget this in the future though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723:81,variab,variable,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723,2,['variab'],"['variable', 'variables']"
Modifiability,"> > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > The other option to not use MPI variables is to hardcode the number of processors; > ; > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > ; > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do. Just to clarify, this is already possible, just by doing; ```julia; arch = Distributed(); rank = arch.local_rank; ```; The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065:88,variab,variables,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065,2,['variab'],['variables']
Modifiability,"> > potentially with a default value of overwrite_existing = false.; > ; > Do you run with `overwrite_existing=false`? (Outside the context of restoring from a checkpoint.). I agree, that is not a common use case scenario. I have only used `overwrite_existing=false` without a checkpoint for short tests within the same Julia instance to extend the model output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045,1,['extend'],['extend']
Modifiability,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,2,['variab'],['variable']
Modifiability,"> @Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the momentum equations.; > ; > If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue. @francispoulin I am interested deriving/testing closures in the 2D Adv-Diff equation in the (general) case of periodic shear flows. A constant shear flow won't do it. More like a velocity field that can be decomposed into a shear flow u(y) (e.g. a cosine in y or sum of cosines) plus a cellular flow (square waves). I am still a newbie over here, so I am open to trying different models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388:207,evolve,evolve,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388,1,['evolve'],['evolve']
Modifiability,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:126,adapt,adapted,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['adapt'],['adapted']
Modifiability,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:694,layers,layers,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,2,['layers'],['layers']
Modifiability,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:263,variab,variables,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511,1,['variab'],['variables']
Modifiability,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988,1,['adapt'],['adapt']
Modifiability,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,1,['refactor'],['refactor']
Modifiability,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:427,config,configuration,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,2,['config'],['configuration']
Modifiability,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:56,config,config,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873,1,['config'],['config']
Modifiability,"> @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?. Yes. Consider the following sources for the grid metrics:. 1. the `cs32` grid with one halo layer, used by:; - Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; - yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; 3. the `cc32` grid created by Oceananigans. In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018:430,layers,layers,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018,1,['layers'],['layers']
Modifiability,"> @siddharthabishnu, what capability does this PR add?. @glwagner, this PR uses the new halo-filling functions to update halos for prognostic variables and refines the vorticity computation function on the cubed sphere. Additional features introduced in this PR are detailed in the description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213:142,variab,variables,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213,1,['variab'],['variables']
Modifiability,> @simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ). @christophernhill don't we need to implement thickness weighting as part of a general overhaul to generic vertical coordinates? Or can we implement thickness weighting even in a fixed Z coordinate system?. @glwagner and @simone-silvestri I think you could explore thickness weighting in the non-linear shallow water. @francispoulin does that make sense? Might be a way to more quickly pilot some API and numerics aspects?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693:172,flexible,flexible,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693,1,['flexible'],['flexible']
Modifiability,> @tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?; > ; > Looks like `ScalarBiharmonicDiffusivity` needed it here:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113; > ; > Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?. I tried that and got a different error. But now looking at `ScalarBiharmonicDiffusivity` I think I probably did something wrong. I'll try again soon!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686:60,adapt,adapting,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686,2,['adapt'],['adapting']
Modifiability,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1000,adapt,adapt,1000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695,2,['variab'],['variable']
Modifiability,"> @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel. Sure, you could e.g. have an adapt rule return a named tuple so that you can still do `.time` etc, as long as you don't have any signatures relying on `::Clock`. Getting mutables to work is much tougher, but not impossible either, especially if the object doesn't contain pointers (as Clock here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181:45,adapt,adapt,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181,2,['adapt'],['adapt']
Modifiability,"> Actually I think you want `u` at the same location as `uh`, so you should write; > ; > ```julia; > u = ComputedField(uh / h); > ```. Agreed. What I did was `u = ComputedField( @at (Face,Cell,Cell) uh/h )` but I guess you are telling me that it defaults to the position of the first variable?. Actually, I needed to use `model.solution.uh` instead of `uh` and it seems to be working better (but I'm not done). Does that make sense or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876:284,variab,variable,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876,1,['variab'],['variable']
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146,7,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted', 'adapting']"
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171,21,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146:296,variab,variables,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146,4,['variab'],"['variable', 'variables']"
Modifiability,"> Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model. Even more than details associated with particular challenging ODEs is the more fundamental software challenge of designing a flexible and useful system for user-specification of ODEs (special fields defined on sets of particles, each associated with an independent ODE that is coupled to the model solution) to be solved on particle trajectories. If we were integrated with DifferentialEquations.jl, this might not be all that hard, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256:435,flexible,flexible,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256,1,['flexible'],['flexible']
Modifiability,> Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged. I was also puzzled why that happened. I just pulled master and then `git merge master`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083:24,sandbox,sandbox,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083,1,['sandbox'],['sandbox']
Modifiability,"> Ah sorry I really do think it would be confusing to users that one has to use HydrostaticSphericalCoriolis on grids that have spherical coordinate systems; and that the ""constant Coriolis"" type only applies to Cartesian coordinate systems :-( don't others agree?. I do agree it's a bit confusing, but IMO it's also obscure to name it `ConstantCartesianCoriolis`. As a user I'm thinking what's a cartesian Coriolis? And I definitely wouldn't make the leap in reasoning that `ConstantCartesianCoriolis` is meant to be used with _rectilinear grids_ (none of those two words appears in the name). Which is I suggested a few posts back to use the (very verbose) `ConstantRectlinearGridCoriolis` or something to that effect. > Sorry this is becoming laborious... if the name is changed to include Cartesian then we can merge this and discuss further in an issue. I'm okay with this. It seems like the background rotation implementation could use a big refactoring, which is kind of outside the scope of this PR anyway.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511:948,refactor,refactoring,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511,1,['refactor'],['refactoring']
Modifiability,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:220,extend,extended,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171,1,['extend'],['extended']
Modifiability,"> Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think. @glwagner we can merge this in at some point. I didn't want to lose it meantime. Looks like #1575 needs other bits doing too, since #1522 did its stuff!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246:84,refactor,refactor,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246,1,['refactor'],['refactor']
Modifiability,"> Also just to clarify, the problem is not `SeawaterBuoyancy` but rather any buoyancy model at all. When I tested with `BuoyancyTracer` the issue doesn't come up. I suppose you mean any buoyancy model that doesn't have buoyancy as an explicit prognostic variable right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697:254,variab,variable,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697,1,['variab'],['variable']
Modifiability,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1007,layers,layers,1007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257,1,['layers'],['layers']
Modifiability,"> Also this works:; > ; > ```julia; > julia> import Base: minimum; > ; > julia> using OffsetArrays; > ; > julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); > minimum (generic function with 21 methods); > ; > julia> minimum(zspacings(grid, Center())); > 1.0; > ; > julia> grid; > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; > └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; > ```; > ; > so it might have something to do with the `KernelFunctionOperation` that's used here?:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413. We use the `KernelFunctionOperation` because this generalizes to any grid, including immersed boundary grids that may modify the spacings of the underlying grid (for example with `PartialCellBottom`). It's possible to implement shortcuts like calculating a minimum directly over a `view`, but I'd hesitate to put this in the source code. Maybe we can make some improvements to `KernelFunctionOperation` that allow it to be reduced more easily. That would benefit everyone.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276:573,variab,variably,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276,1,['variab'],['variably']
Modifiability,"> Also, you don't need the `field_dependencies` argument with `discrete_form=true` (but I think that has no effect, so just a side comment, maybe we should throw an error for that). Ah yeah, I forgot to change that when I adapted it to discrete form. Thanks for catching that and for the other tips!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397:222,adapt,adapted,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397,1,['adapt'],['adapted']
Modifiability,"> And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that _dispatch_ on the number or arguments and argument types. That makes sense and it should be easy enough to define `ShallowWaterModel` versions of these. I will work on the advection case and let you know what I come up with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109:35,extend,extend,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109,1,['extend'],['extend']
Modifiability,"> Another possibility is that we figure out how to translate `x^2` to `x*x` (eg hook into `Base.literal_pow`). Exponentiation by literals is covered by that, just not when using constants as in #1770 . ```julia; julia> f(x) = x^2; f (generic function with 1 method). julia> code_warntype(f, Tuple{Float64}); Variables; #self#::Core.Const(f); x::Float64. Body::Float64; 1 ─ %1 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2}); │ %2 = (%1)()::Core.Const(Val{2}()); │ %3 = Base.literal_pow(Main.:^, x, %2)::Float64; └── return %3; ```; ```julia; julia> const factor = 2; 2. julia> g(x) = x^factor; f (generic function with 1 method). julia> code_warntype(g, Tuple{Float64}); Variables; #self#::Core.Const(g); x::Float64. Body::Float64; 1 ─ %1 = (x ^ Main.factor)::Float64; └── return %1; ```. HOWEVER, on the CPU both result in good code:. ```julia; julia> code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1923(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_342(double %0) {; top:; ; ┌ @ math.jl:918 within `^'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }; ```. Whereas with CUDA, the non-literal version leads to expensive code:. ```; julia> CUDA.code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1908(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> CUDA.code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_1282(double %0) {; top:; ; ┌ @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:223 within `^' @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:218; %1 = call i32 @llvm.nvvm.d2i.hi(double %0) #4; %2 = call i32 @llvm.nvvm.d2i.hi(double 2.000000e",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587:308,Variab,Variables,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587,2,['Variab'],['Variables']
Modifiability,"> Are you envisioning that we need something additional to simply dispatching on the boundary condition types (which is already implemented?). Good point, we should just dispatch on the boundary conditions. Might get messy if we're passing the boundary conditions through multiple layers of operators so maybe there's a way to include them in the grid? The grid is already passed in. > I vote for using the halo regions to satisfy boundary conditions rather than writing if-statements into the operators. Don't think I'll use an `if` statement, maybe we can use a 1D array like `Ay[0] = Ay[Ny+1] = 0` and `Ay[j] = Δx*Δz`. Reason being is that apparently there are issues or reasons why it's better to enforce the wall by setting the area to zero at the wall, rather than using the halo regions to enforce things. I still need to discuss this with @jm-c and @christophernhill.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322:281,layers,layers,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322,1,['layers'],['layers']
Modifiability,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:707,config,configuration,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274,2,['config'],['configuration']
Modifiability,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:280,variab,variable,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309,2,['variab'],['variable']
Modifiability,"> As discussed with @jm-c, I think another feature we will need is the ability to design closure-specific temporary variables.; > ; > For example, the implementation of Constant Smagorinsky or Anisotropic Minimum Dissipation will benefit from the ability to compute the eddy viscosity (at 4 locations in a cell --- 3 `FaceField`s and 1 `CellField`) and re-use it in calculating the contribution of the subgrid closure to the momentum 'source terms'.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/73#issuecomment-467660286_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/94:116,variab,variables,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/94,1,['variab'],['variables']
Modifiability,"> As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in xz space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. References would help! We are currently curvilinear only in xy... so 2D curvilinearity in xz is the same thing as 3D curvilinearity. But maybe I am misunderstanding what you're saying. > Create a dispatch between ConservationForm and VectorInvariantForm (similar to HydrostaticModel I presume). Alternatively, you can adapt the existing ""flux form"" momentum advection operators to work on curvilinear grids. This is something we plan to do eventually (so we can use WENO advection schemes on a lat-lon grid, for example), but haven't gotten to it yet. There is already a `VectorInvariant` type. You just need to move around some of the code and ensure that the vector invariant advection scheme generalizes / can be generalized to a shallow water system. > Define a new grid, maybe called BoundaryFollowingGrid. I think you could build something more generic like `HorizontallyWarpedGrid` with a warping function that maps from the rectangle / square to whatever geometry you're trying to use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781:884,adapt,adapt,884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781,1,['adapt'],['adapt']
Modifiability,> As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?. I agree Makie is way better. Can we do animations too though? I'll explore. Sadly tartarus is not open CL enabled.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750:26,refactor,refactor,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750,1,['refactor'],['refactor']
Modifiability,"> As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`. So what we did here was; https://github.com/CliMA/Oceananigans.jl/blob/5d9836398cb49cf2eea38ec6da505b03d9a94a66/docs/make.jl#L46-L53; which is equivalent to `pmap`, right?. But now I see. I thought the `run('...')` was only if I wanted to carry out global variables from one example to the other.; So you are saying that . ```Julia; asyncmap(1:length(example_scripts)) do n ; example = example_scripts[n] ; example_filepath = joinpath(EXAMPLES_DIR, example) ; withenv(""JULIA_DEBUG"" => ""Literate"") do ; run(`julia --project=docs -e'Literate.markdown(example_filepath, OUTPUT_DIR; flavor = Literate.DocumenterFlavor(), execute = true)'`; end ; end; ```; right? I'll try that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246:115,variab,variable,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246,2,['variab'],"['variable', 'variables']"
Modifiability,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:413,extend,extend,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063,1,['extend'],['extend']
Modifiability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:56,extend,extend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['extend'],['extend']
Modifiability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:772,layers,layers,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,3,['layers'],['layers']
Modifiability,"> Blast. How about `x′`, `y′`?; >; > Can also change the vorticity notation in field_metric_products to something else. I'm okay with `x′`, `y′` but I'll leave it for now since it's localized to the grid constructor so it hopefully shouldn't cause any confusion (and there's a comment). Could be cool if we had like a notation list/glossary so every variable had one meaning like some books have, but we'd probably run out of letters very quickly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016:350,variab,variable,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016,1,['variab'],['variable']
Modifiability,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1404,variab,variable,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,"> But question: floats need adaptation?. The answer is no. For any object that doesn't have an explicitly defined `adapt` method, then `adapt(to, x) = x`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846:28,adapt,adaptation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> Can any of you take a look to see if I'm doing anything that's wrong or ill-advised in any way? (I solved it in a pretty pythonic way...). I think your solution is fine. In more complicated scenarios it's sometimes better to use dispatch rather than if statements because the code is then more extensible (by defining new functions, which can go anywhere, rather than adding conditions to a chain of if statements in some central location). Here it's not so crucial and we can refactor later if we need to. We certainly _can_ use if statements in julia (and dispatch in python!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053:479,refactor,refactor,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053,1,['refactor'],['refactor']
Modifiability,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:212,variab,variable,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,3,"['Variab', 'variab']","['Variable', 'variable']"
Modifiability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:1455,coupling,coupling,1455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,1,['coupling'],['coupling']
Modifiability,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:304,refactor,refactor,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191,1,['refactor'],['refactor']
Modifiability,"> Did you want me to give this a try? It does not seem like a lots needs to change and I will certainly learn a lot in the process. That's fine with me (and I am very happy to help, or pair program over zoom). I think resolving this issue (moving files around) should happen in a separate PR from implementing `ShallowWaterModel`. Imports and exports will also change, for example `IncompressibleModels` will become a submodule of `Models`, and we'll have to pull the name `IncompressibleModel` into `Models`:. ```julia; # in Models.jl. include(""IncompressibleModels/IncompressibleModels.jl""). using IncompressibleModels.IncompressibleModel; ```. Hopefully we can reuse as much code as possible. If your prognostic variables are `hu,`, `hv`, `h`, you may benefit from some fancy julia abstraction that will let you reuse momentum advection and tracer advection operators like `div_Uu` and `div_Uc`. I'm happy to help with that. Your fields will all have to be three-dimensional (with a single grid point in the vertical direction). Also until #1024 is fixed we will unfortunately also need halo regions in the vertical direction. Hopefully this won't matter too much and eventually we will be able to use `Flat` vertical directions. As for the file structure, I think some functions can be generalized to work for any model rather than split, like `store_tendencies!` (it perhaps makes sense that `store_tendencies!` is independent of the model type). I think it's nice that the physics-specific functions will now be in `Models/IncompressibleModels`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396:715,variab,variables,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396,1,['variab'],['variables']
Modifiability,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:73,refactor,refactor,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['refactor'],['refactor']
Modifiability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:989,evolve,evolved,989,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['evolve'],['evolved']
Modifiability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1136,extend,extend,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,2,['extend'],['extend']
Modifiability,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167:705,variab,variables,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167,4,"['portab', 'variab']","['portability', 'variables']"
Modifiability,> Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?; > ; > . I haven't run that case on GPU but would have thought it will run if you change the grid architecture and adapt the initial particle positions (which is described in the simulation tips part of the docs). I can have a look later to see if I can run it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430:333,adapt,adapt,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430,1,['adapt'],['adapt']
Modifiability,"> Greg, Doesn't Ali have a version of immersed boundary layers going?. @johncmarshall54, Ali experimented with a simple immersed boundary implemented via Oceananigans's user-defined forcing functions. The code is these 9 lines:. https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. This implementation damps the velocity field to zero on a very fast time-scale (specified by the parameter `K`) within the immersed boundary. This is certainly a nice, simple immersed boundary implementation for Dirichlet / Value boundary conditions and could be a good starting point. However, I also think there's some good reasons to pursue an alternate immersed boundary implementation to what @ali-ramadhan has done:. 1. @ali-ramadhan's implementation doesn't obviously extend to other boundary conditions, like prescribed gradients or fluxes (the latter being crucial for the geophysical problems we're interested in). So, even if we use a continuous forcing method similar to @ali-ramadhan's implementation, we need to figure out how to enforce boundary conditions other than Dirichlet boundary conditions.; 2. @ali-ramadhan's implementation conforms exactly to the grid; however we would like to be able to model smoothly-varying boundaries.; 3. As noted by @whitleyv, @ali-ramadhan's ""continuous forcing method"" implementation introduces a time-step restriction due to the need to explicitly resolve the damping time-scale in the forcing function. It seems that a discrete forcing method overcomes this restriction and could prove crucial for geophysical problems that involve otherwise long time-steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244:56,layers,layers,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:1459,refactor,refactoring,1459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,1,['refactor'],['refactoring']
Modifiability,"> Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`.... Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures). I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020:273,parameteriz,parameterizations,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020,1,['parameteriz'],['parameterizations']
Modifiability,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:229,variab,variable,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270,1,['variab'],['variable']
Modifiability,"> Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions. I think so. Let's definitely try!. Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921:19,adapt,adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921,1,['adapt'],['adapt']
Modifiability,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:197,layers,layers,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364,1,['layers'],['layers']
Modifiability,"> I agree that the PoissonSolver struct is a better place to store the pressure boundary conditions, but what do you think of just storing them in model.boundary_conditions?. I don't like this idea, because I would like the tuple of boundary conditions to have the same length as the number of solution variables to permit easy and simple looping / code reduction / arbitrary tracer stuff in the future. . While not crucial, I think it makes sense (though of course we don't currently have a `solution` tuple, though that would be easy to add). Edit: we could achieve both aims by adding a level of hierarchy to `boundary_conditions`, so that it has fields `solution, tendencies, pressure`, (each of them a tuple), or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861:303,variab,variables,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861,1,['variab'],['variables']
Modifiability,"> I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos. On the contrary with this approach you should be able to use the existing `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/OutputWriters/output_construction.jl#L44-L46. which is designed for `Field` / `AbstractOperation` already. So I think again with this approach the kwarg `with_halo` is irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823:133,config,configured,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823,1,['config'],['configured']
Modifiability,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:651,sandbox,sandbox,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154,1,['sandbox'],['sandbox']
Modifiability,"> I am not sure that I am following everything there. Is it for flux-form of vector-invariant ? otherwise, I don't recognize the energy-conserving discretization (thought it would have been nice to have). I didn't realize the the Coriolis implementation is different for the ""flux-form"" momentum equations than for vector-invariant momentum equations --- thanks for pointing that out @jm-c. I don't quite understand why this is the case. However, it is not that difficult to extend our Coriolis implementation to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.gith",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:475,extend,extend,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799,1,['extend'],['extend']
Modifiability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:561,variab,variables,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['variab'],['variables']
Modifiability,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:376,flexible,flexible,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311,2,['flexible'],['flexible']
Modifiability,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373:280,layers,layers,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373,2,['layers'],['layers']
Modifiability,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:8,adapt,adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,2,['adapt'],['adapt']
Modifiability,"> I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine... What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? ; Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458:167,config,configuration,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1035,adapt,adapt,1035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000,2,['adapt'],['adapt']
Modifiability,"> I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > although I imagine that could use a lot more memory if there were a large grid and small amount of particles. It seems the memory requirement of the forcing function approach is proportional to the number of _tracers_, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125:1226,flexible,flexible,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125,1,['flexible'],['flexible']
Modifiability,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:305,maintainab,maintainable,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029,1,['maintainab'],['maintainable']
Modifiability,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:235,flexible,flexible,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241,1,['flexible'],['flexible']
Modifiability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:564,extend,extend,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['extend'],['extend']
Modifiability,> I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. I don't see it; did you push?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077:81,evolve,evolves,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077,1,['evolve'],['evolves']
Modifiability,"> I have only used overwrite_existing=false without a checkpoint for short tests within the same Julia instance to extend the model output. Thank you for pointing out this use case. I think this is another situation that could be solved by waiting until `run!` for initialization. We can analyze an existing file and determine whether or not any data within the file will be overwritten based on the simulation parameters (current time, stop time). Another idea by the way would be to move the concept of ""overwriting"" to `run!`, as well. Then the single keyword can apply to all output, or not, which presumably more aligned with what a user would want (rather than toggling `overwrite_existing` for each writer individually).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348:115,extend,extend,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348,1,['extend'],['extend']
Modifiability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:409,config,configured,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918,2,['config'],['configured']
Modifiability,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:645,rewrite,rewrites,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,2,['rewrite'],['rewrites']
Modifiability,"> I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > ; > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?. I don't quite understand the question --- what would you like a reference for?. It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know. We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372:204,variab,variable,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372,1,['variab'],['variable']
Modifiability,"> I mostly do it to keep a consistent size and chunks across files for post-processing. Ok! Curious how this will evolve, we eventually hope to support FieldTimeSeries for NetCDF which will give us some options to design various productivity features...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831:114,evolve,evolve,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831,1,['evolve'],['evolve']
Modifiability,"> I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation. I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":. Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems. We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms. It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701:593,adapt,adapt,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701,1,['adapt'],['adapt']
Modifiability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1589,evolve,evolved,1589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['evolve'],['evolved']
Modifiability,"> I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`. sounds good",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030:129,refactor,refactor,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030,1,['refactor'],['refactor']
Modifiability,> I suggest we remove the parameter for `gravitational_acceleration`.; > ; > @francispoulin any objection to that?. Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047:203,evolve,evolve,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047,1,['evolve'],['evolve']
Modifiability,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720:365,parameteriz,parameterization,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720,2,['parameteriz'],['parameterization']
Modifiability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:235,adapt,adapt,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,1,['adapt'],['adapt']
Modifiability,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635:1013,refactor,refactor,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635,2,['refactor'],['refactor']
Modifiability,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582:616,rewrite,rewrite,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582,2,['rewrite'],['rewrite']
Modifiability,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:901,variab,variable,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731,2,['variab'],['variable']
Modifiability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:279,extend,extend,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['extend'],['extend']
Modifiability,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:614,parameteriz,parameterizations,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266,2,['parameteriz'],['parameterizations']
Modifiability,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:234,refactor,refactor,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,6,"['extend', 'refactor']","['extending', 'refactor', 'refactoring']"
Modifiability,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:550,extend,extend,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036,1,['extend'],['extend']
Modifiability,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:409,flexible,flexible,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,2,['flexible'],['flexible']
Modifiability,"> I'm assuming this is a relatively simple issue to resolve?. Unfortunately not due to our current algorithm that we inherited from MITgcm, but which we hope to change pretty soon. Right now Oceananigans splits up the pressure into the hydrostatic pressure anomaly and the non-hydrostatic pressure (see https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/pressure_decomposition/). MITgcm did this to facilitate easy switching between a hydrostatic mode and a non-hydrostatic mode: to turn a non-hydrostatic model into a hydrostatic one, just don't compute the non-hydrostatic pressure and recompute w from the continuity equation. But we feel we can use multiple dispatch to implement a hydrostatic model in Julia. This algorithm also requires extra memory (2 pressure fields instead of just 1). So we're hoping to change the algorithm to only use 1 pressure field and get rid of this pressure decomposition. The algorithm also makes it difficult to implement tilted gravity because the hydrostatic pressure anomaly is computed as. ```; pHY′ = ∫ buoyancy_perturbation dz from z=0 down to z=-Lz; ```. where `buoyancy_perturbation = g * (αT - βS)` if you're using a linear equation of state. So now if gravity is tilted it's not just a vertical integral. I'm actually not sure how to modify the vertical integral if gravity is tilted... Seemed easier to move away from this vertical integral by not decomposing pressure then we should be able to easily add in support for tilted gravity via a `bg⃗` term in the momentum equation where `g⃗ = g⃗(x, y, z)` can be whatever the user wants. Not sure if we have an issue discussing this change to the pressure decomposition, but if it doesn't exist then I can open one to track progress on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605:117,inherit,inherited,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605,1,['inherit'],['inherited']
Modifiability,"> I'm confused as to what T would be here. It feels like it should be simulation.Δt, but that wouldn't work for variable Δt. The time interval that user specifies, `TimeInterval(T)`. > We probably would need to discuss how that would interact with min_Δt from the TimeStepWizard, no?. I hadn't thought of that. But `min_Δt` is not a global constraint, it's only the `min_Δt` that the TimeStepWizard specifies. The simulation `Δt` can still be smaller.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707:112,variab,variable,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707,1,['variab'],['variable']
Modifiability,"> I'm not sure I exactly understand whats changed here because of all the renaming. The important changes are here right?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Utils/kernel_launching.jl#L120-L158; > ; > And this makes it so that instead of being able to optionally fill the right boundary point, you can set it to `true` and it will instead compute 2:N for face fields (and presumably still 1:N for center fields)?. Heh, I'd argue that without the renaming it would also be hard (harder) to understand! Especially for me... The outcome of this PR is a key change to the computation of nonhydrostatic tendencies, here:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl#L104-L115. In addition to that, we do not update the periphery regardless:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/TimeSteppers/runge_kutta_3.jl#L172. The keyword `exclude_periphery` propagates into `work_layout` as noticed. When we use the `:xyz` specification, ask for `exclude_periphery`, and the location is `Face` and the topology is `Bounded`, then the kernel is configured to loop from 2:N. Otherwise, it loops from 1:N as usual. Hope that helps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646:1256,config,configured,1256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646,1,['config'],['configured']
Modifiability,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:524,Adapt,Adapt,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502,1,['Adapt'],['Adapt']
Modifiability,"> I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. `ShallowWaterModel` is totally independent from the other models --- so this is up to how `ShallowWaterModel` is written. But in a shallow water system it seems (based on the discussion on this thread) that bathymetry is treated via pressure gradients (and also vanishing layers or other techniques to handle outcropping). So we won't use `ImmersedBoundaryGrid`, which is how complex domains are handled elsewhere in Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977:465,layers,layers,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977,1,['layers'],['layers']
Modifiability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:514,flexible,flexible,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['flexible'],['flexible']
Modifiability,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:141,refactor,refactored,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532,3,['refactor'],"['refactored', 'refactoring']"
Modifiability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:28,config,configure,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['config'],['configure']
Modifiability,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:178,layers,layers,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,2,['layers'],['layers']
Modifiability,"> If we take a look at those other kernels, maybe we can get to the bottom of it?. Actually now that I'm checking my scripts, I have always differentiated arguments passed as a `computed_dependency`. I hadn't paid attention to this before but I've never differentiated a variable that I created _inside_ the kernel, as is the case with `wp`. Apparently this is yet another limitation of GPU computing that I wasn't aware of. For my application this already solves the issue, as I can just define a vertical derivative kernel and pass the abstract operation `w*p`. But for the sake of the general user: is there any way around this limitation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346:271,variab,variable,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346,1,['variab'],['variable']
Modifiability,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:857,extend,extending,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,1,['extend'],['extending']
Modifiability,"> In line 39, where I define the background buoyancy of the jet, I can't use coriolis.f because CUDA seems to need a global variable and this doesn't cut it. This isn't a GPU issue I don't think because initialization is done on the CPU. I don't see a `coriolis` object defined in your script. You may need to write `model.coriolis.f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759:124,variab,variable,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759,1,['variab'],['variable']
Modifiability,"> In python the convention is to put import statements at the top of a file? So the python convention is not to have local import statements. Since every file is a module, this means that in python import statements are at the top of modules by convention.; > ; > In julia modules can be split among many files. Thus if imports are at the top of a file, they are scattered within the module. I meant ""more local"" so putting `import` and `using` statements at the top of each file. I think putting them at the module level makes module files messy/cluttered and actually makes it harder to see where and how imported functions are used and overloaded. > One reason to put things at the top level is so that its easy to see at a glance what a package imports. It's also nice to see what methods are being extended via implication; for example if one sees `import Base: +` we can expect that `+` is redefined. If I want to check what a package imports, I will check the `Project.toml`. I think it's very rare for me to check ""what a module imports"". The much more common case in my experience is I'm looking at a file and see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:803,extend,extended,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['extend'],['extended']
Modifiability,"> In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345:41,evolve,evolve,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345,1,['evolve'],['evolve']
Modifiability,"> In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?. That's right. The ""nonlinear Coriolis term"" in the vector invariant advection scheme requires reconstructing the vorticity at the locations of the x- and y-momentum. This PR implements WENO reconstruction of this term with two possibilities for the smoothness calculation: `VorticityStencil()` ([Roullet and Gaillard](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2021MS002663)) and `VelocityStencil()` (uses velocity rather than vorticity to calculate smoothness coefficients, implemented in this PR). The API is probably WIP; hopefully we will smooth this out. Anyways, this scheme can be used by writing. ```julia; using Oceananigans.Advection: VelocityStencil, VorticityStencil. # and then. momentum_advection = WENO5(vector_invariant=VelocityStencil()); ```. for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086:130,rewrite,rewrite,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086,1,['rewrite'],['rewrite']
Modifiability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:559,variab,variable,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['variab'],['variable']
Modifiability,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:583,refactor,refactor,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655,1,['refactor'],['refactor']
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. Sorry, I misunderstood. Yeah, it would be indeed a bit of refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008,2,['refactor'],['refactoring']
Modifiability,"> Is the vertical velocity generated over the piecewise constant topogrpahy something that is of a concern? When I increased the resolution I believe I saw the vertical velocity generated increased as well. I agree with @glwagner that it's concerning at least for your current configuration. My guess is that with bottom drag and a more turbulent simulation that might not be a huge problem. But as it stands it's definitely affecting the dynamics. (Btw, I say that because I've run a fair amount of turbulent simulations with immersed boundaries at this point and I've never seen this being an issue in my simulations. But they are always turbulent.). > I think so! Is this with GridFittedBottom or PartialCellBottom? I feel like this motivated cut / shaved cells. @glwagner reading the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl) it seems that it's a `GridFittedBottom`. @francispoulin Like Greg mentioned, shaved cells would be ideal here, but since we don't have that yet, I'd suggest trying out the `PartialCellBottom`. I expect some improvement there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617:277,config,configuration,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617,1,['config'],['configuration']
Modifiability,> Is there any other model that may be impacted from this?. As mentioned in a DM I don't think `HydrostaticFreeSurfaceModel` supports vertically-flat configurations; even with one grid point in the vertical we may need vertically `Bounded`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014:150,config,configurations,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014,1,['config'],['configurations']
Modifiability,"> Is this still an issue?. Apparently not anymore. I just tested @navidcy 's MWE are everything seems to work fine (on a Quadro GPU and CUDA 3.12 on `main`):. ```julia; julia> grid; 150×150×12 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=5.00e+01, max(h)=5.00e+01); ├── underlying_grid: 150×150×12 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-200.0, 200.0) regularly spaced with Δx=2.66667; ├── Periodic y ∈ [-200.0, 200.0) regularly spaced with Δy=2.66667; └── Bounded z ∈ [0.0, 100.0] variably spaced with min(Δz)=8.33333, max(Δz)=8.33333. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807:625,variab,variably,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807,1,['variab'],['variably']
Modifiability,"> It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether. Don't know if it's always possible but if we can avoid temporary variables by aggressively inlining all calculations, that would be cool. Every temporary field saved means being able to run a larger model on GPUs. We will always need a couple of temporary arrays so if we can't inline we can just try to share and reuse the temporary arrays as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396:227,variab,variables,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396,1,['variab'],['variables']
Modifiability,"> It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Just to make sure I understand correctly: you're talking about expanding the use of the already-existing keyword argument `field_dependencies` to include not only prognostic fields (which apparently is the current status), but all fields. If that's correct, I don't see why not. It'd make the code more flexible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785:500,flexible,flexible,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785,1,['flexible'],['flexible']
Modifiability,"> It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs. Agreed. https://github.com/CliMA/Oceananigans.jl/pull/3080 is for now just a start to see if anything significant breaks. So far everything looks OK there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862:21,refactor,refactor,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862,1,['refactor'],['refactor']
Modifiability,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:122,variab,variably,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['variab'],['variably']
Modifiability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:1032,rewrite,rewrite,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,1,['rewrite'],['rewrite']
Modifiability,"> Just to clarify a point here. The background field here does not participate in the hydrostatic pressure, it only adds an advective term to the tracer equation which reads ∇⋅(uB). So in practice, you are solving; > ; > ∂tu+(u⋅∇)u=−∇p+g^b+Di(u) ∂tb+∇⋅(ub)+∇⋅(uB)=Di(b)+Di(B) where Di is the implicit diffusion coming from 5th order upwind. Yup, and just to clarify the physics behind this set-up, it is necessary when simulating things like doubly-periodic tilted boundary layers in a stratified environment (such as our [tilted bottom example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/)). @simone-silvestri not to sidetrack from the issue but isn't $\mathcal D_i(B)$ ignored in the evolution equation? I got that impression from reading the docs [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/) and [here](https://clima.github.io/OceananigansDocumentation/stable/physics/nonhydrostatic_model/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866:474,layers,layers,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866,1,['layers'],['layers']
Modifiability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:227,config,configurations,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['config'],['configurations']
Modifiability,"> Looks like me, @glwagner or @charleskawczynski have the right privileges to create an agent token. I'm happy to help, but @glwagner is probably more familiar with the Oceananigans configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644,1,['config'],['configuration']
Modifiability,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:545,config,configuration,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['config'],['configuration']
Modifiability,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:794,parameteriz,parameterization,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650,2,['parameteriz'],['parameterization']
Modifiability,> Maybe compute_w_from_continuity! is missing a datatuple or something is missing from an adapted struct?. But it's only with the `RegularLatitudeLongitudeGrid` -- a model with `RegularRectilinearGrid` passes. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534:90,adapt,adapted,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534,1,['adapt'],['adapted']
Modifiability,> Maybe it did need some of the overwrite existing because it writes different configurations to the same file; > ; > Update: passes locally if I add them back. hmm ok that's ok. Could also just manually delete the existing files which might save future pain / confusion,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051:79,config,configurations,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051,1,['config'],['configurations']
Modifiability,"> More out of interest, is there a benefit to passing variables explicitly?. Is this question about CUDA.jl behavior? I'm afraid I don't know, but this comment might help:. https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852. It could be worth asking on #gpu slack, or on https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107:54,variab,variables,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107,1,['variab'],['variables']
Modifiability,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:429,extend,extend,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234,1,['extend'],['extend']
Modifiability,"> My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. If you're mostly interested in the oceanic boundary layer and don't need topography or a free surface, then Oceananigans probably has most of what you need. (See #443 if you're interested in surface physics.). 8192×3072×256 ~ 10¹⁰ grid points is out of our reach for the moment although our plan is to be able to run these super large simulations one day!. We're still limited to 1 GPU (with 16 or 32GB RAM) which lets us go up to ~5×10⁷ grid point. We could probably extend that to ~10⁸ grid points if we implement #98 but even then it would take 50-100 GPUs to reach 10¹⁰ grid points. We've mostly been running oceanic mixed layer simulations with a focus on vertical mixing so no need for a ton of horizontal resolution, but we do have horizontal mixing problems in mind at which point we'll need to start running on multiple GPUs with MPI. This is something we're starting to get serious about as we do need it ourselves. Not sure how coarse you can go but if you can go down to ~10⁸ grid points then maybe Oceananigans can be useful. If the factor of ~2 reduction in memory usage from #98 would be useful for you, let us know and we can look into implementing it. In general, I think we're happy to work together on features that you might need. I still need to work on some documentation to showcase all the model creation options, etc. so let us know if you're not sure how to impose a certain boundary condition or forcing, etc. Out of curiosity, what LES model are you currently using?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886:933,extend,extend,933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886,1,['extend'],['extend']
Modifiability,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631,4,['variab'],"['variable', 'variables']"
Modifiability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['variab'],['variable']
Modifiability,"> OK! I'll review this!; > ; > so in Oceananigans terms is the `e-ϵ` parameterization, right?. I think we should call it ""TKE dissipation vertical diffusivity"", or k-epsilon in a nod to the literature. I don't think we shoudl call it ""e-epsilon"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889:69,parameteriz,parameterization,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889,1,['parameteriz'],['parameterization']
Modifiability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:910,config,configurable,910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['config'],['configurable']
Modifiability,"> Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better. But I thought the whole idea is to be able to provide an `Array` for forcing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274:119,adapt,adapts,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274,1,['adapt'],['adapts']
Modifiability,"> Ok I think I figured it out. The `Float64` values are coming in from functions like `depthᶜᶜᶠ` and `height_above_bottomᶜᶜᶠ`. The main issue is actually the grid coordinates not being fully `Float32`.; > ; > In particular, when coordinates like `grid.zᵃᵃᶜ` are ranges the reference and step size are `Float64`:; > ; > ```julia; > julia> r = range(0.0f0, 1.0f0, 16); > 0.0f0:0.06666667f0:1.0f0; > ; > julia> typeof(r); > StepRangeLen{Float32, Float64, Float64, Int64}; > ```. Can you clarify? You're showing the type of `r`, but not the type of the coordinate that would be produced by indexing into the range, which is what we care about. The docstring specifically says . ```julia; help?> StepRangeLen; search: StepRangeLen StepRange. StepRangeLen( ref::R, step::S, len, [offset=1]) where { R,S}; StepRangeLen{T,R,S}( ref::R, step::S, len, [offset=1]) where {T,R,S}; StepRangeLen{T,R,S,L}(ref::R, step::S, len, [offset=1]) where {T,R,S,L}. A range r where r[i] produces values of type T (in the first form, T is deduced automatically), parameterized by a reference; value, a step, and the length.; ```. Therefore `StepRangeLen{Float32, Float64, Float64}` should produce values of `Float32`. Is this not happening?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713:1038,parameteriz,parameterized,1038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713,1,['parameteriz'],['parameterized']
