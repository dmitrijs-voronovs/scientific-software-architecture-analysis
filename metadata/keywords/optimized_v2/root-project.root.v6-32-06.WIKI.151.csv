quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,". TPMERegexp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPMERegexp. class TPMERegexp: protected TPRegexp. Wrapper for PCRE library (Perl Compatible Regular Expressions).; Based on PME - PCRE Made Easy by Zachary Hansen. Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. See $ROOTSYS/tutorials/regexp_pme.C for examples. Function Members (Methods); public:. TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10); virtual~TPMERegexp(); voidAssignGlobalState(const TPMERegexp& re); static TClass*Class(); Int_tGetGlobalPosition() const; Int_tGetNMaxMatches() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp); Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); TObjArray*TPRegexp::MatchS(const TString& s, const TString& mods = """", Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPMERegexp.html:529,simpl,simply,529,root/html528/TPMERegexp.html,https://root.cern,https://root.cern/root/html528/TPMERegexp.html,4,['simpl'],['simply']
Usability,". TPMERegexp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPMERegexp. class TPMERegexp: protected TPRegexp. Wrapper for PCRE library (Perl Compatible Regular Expressions).; Based on PME - PCRE Made Easy by Zachary Hansen. Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. See $ROOTSYS/tutorials/regexp_pme.C for examples. Function Members (Methods); public:. TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10); virtual~TPMERegexp(); voidAssignGlobalState(const TPMERegexp& re); static TClass*Class(); Int_tGetGlobalPosition() const; Int_tGetNMaxMatches() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector&); Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; static Bool_tTPRegexp::GetThrowAtCompileError(); Bool_tTPRegexp::IsValid() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPMERegexp.html:529,simpl,simply,529,root/html534/TPMERegexp.html,https://root.cern,https://root.cern/root/html534/TPMERegexp.html,2,['simpl'],['simply']
Usability,". TPMERegexp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPMERegexp. class TPMERegexp: protected TPRegexp. Wrapper for PCRE library (Perl Compatible Regular Expressions).; Based on PME - PCRE Made Easy by Zachary Hansen. Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. See $ROOTSYS/tutorials/regexp_pme.C for examples. Function Members (Methods); public:. virtual~TPMERegexp(); voidAssignGlobalState(const TPMERegexp& re); static TClass*Class(); Int_tGetGlobalPosition() const; Int_tGetNMaxMatches() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE); TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; static Bool_tTPRegexp::GetThrowAtCompileError(); Bool_tTPRegexp::IsValid() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPMERegexp.html:529,simpl,simply,529,root/html602/TPMERegexp.html,https://root.cern,https://root.cern/root/html602/TPMERegexp.html,4,['simpl'],['simply']
Usability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. TParallelCoordVar(); TParallelCoordVar(const TParallelCoordVar&); TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoordVar.html:580,simpl,simply,580,root/html530/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html530/TParallelCoordVar.html,5,['simpl'],['simply']
Usability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoordVar.html:580,simpl,simply,580,root/html602/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html602/TParallelCoordVar.html,4,['simpl'],['simply']
Usability,". TPointSet3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPointSet3D. class TPointSet3D: public TPolyMarker3D, public TAttBBox. TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering.; Supports only elementary marker types:; 4, 20, 24 : round points, size in pixels;; 2, 3, 5 : crosses, size in scene units;; 28 : as above, line width 2 pixels;; all other : square points, size in pixels. Marker-size (from TAttMarker) is multiplied by 5!. An identification of type TObject* can be assigned to each point; via SetPointId() method. Set the fOwnIds flag if the ids are owned; by the point-set and should be deleted when pointset is cleared or; destructed. Copy-constructor and assignment operator COPIES the ids if the are; not owned and CLONES them if they are owned. The ids are not streamed. Function Members (Methods); public:. TPointSet3D(); TPointSet3D(const TPointSet3D& t); TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); virtual~TPointSet3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPointSet3D.html:827,clear,cleared,827,root/html528/TPointSet3D.html,https://root.cern,https://root.cern/root/html528/TPointSet3D.html,6,['clear'],['cleared']
Usability,". TPointSet3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPointSet3D. class TPointSet3D: public TPolyMarker3D, public TAttBBox. TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering.; Supports only elementary marker types:; 4, 20, 24 : round points, size in pixels;; 2, 3, 5 : crosses, size in scene units;; 28 : as above, line width 2 pixels;; all other : square points, size in pixels. Marker-size (from TAttMarker) is multiplied by 5!. An identification of type TObject* can be assigned to each point; via SetPointId() method. Set the fOwnIds flag if the ids are owned; by the point-set and should be deleted when pointset is cleared or; destructed. Copy-constructor and assignment operator COPIES the ids if the are; not owned and CLONES them if they are owned. The ids are not streamed. Function Members (Methods); public:. virtual~TPointSet3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyMarker3D::DrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPointSet3D.html:827,clear,cleared,827,root/html602/TPointSet3D.html,https://root.cern,https://root.cern/root/html602/TPointSet3D.html,4,['clear'],['cleared']
Usability,". TProcessEventTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TProcessEventTimer. class TProcessEventTimer: public TTimer. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TProcessEventTimer(Long_t delay); ~TProcessEventTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidTTimer::Add(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tTTimer::CheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProcessEventTimer.html:676,simpl,simple,676,root/html528/TProcessEventTimer.html,https://root.cern,https://root.cern/root/html528/TProcessEventTimer.html,6,['simpl'],['simple']
Usability,". TProcessEventTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TProcessEventTimer. class TProcessEventTimer: public TTimer. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~TProcessEventTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidTTimer::Add(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tTTimer::CheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProcessEventTimer.html:676,simpl,simple,676,root/html602/TProcessEventTimer.html,https://root.cern,https://root.cern/root/html602/TProcessEventTimer.html,4,['simpl'],['simple']
Usability,". TProofProgressDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:363,progress bar,progress bar,363,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,". TProofProgressDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient fram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressDialog.html:363,progress bar,progress bar,363,root/html534/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html534/TProofProgressDialog.html,2,['progress bar'],['progress bar']
Usability,". TProofProgressDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidToggleOdometerInfos(); voidToggleThreshold(); TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:363,progress bar,progress bar,363,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:595,undo,undo,595,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,12,['undo'],['undo']
Usability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:571,undo,undo,571,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,18,['undo'],['undo']
Usability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:594,undo,undo,594,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,12,['undo'],['undo']
Usability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:570,undo,undo,570,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,18,['undo'],['undo']
Usability,". TRadialGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRadialGradient. class TRadialGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TRadialGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRadialGradient.html:415,simpl,simple,415,root/html602/TRadialGradient.html,https://root.cern,https://root.cern/root/html602/TRadialGradient.html,4,['simpl'],['simple']
Usability,". TRadialGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRadialGradient. class TRadialGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TRadialGradient(); TRadialGradient(const TRadialGradient&); TRadialGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); TRadialGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); ~TRadialGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRadialGradient.html:391,simpl,simple,391,root/html534/TRadialGradient.html,https://root.cern,https://root.cern/root/html534/TRadialGradient.html,2,['simpl'],['simple']
Usability,". TRandom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom. class TRandom: public TNamed. TRandom. basic Random number generator class (periodicity = 10**9).; Note that this is a very simple generator (linear congruential); which is known to have defects (the lower random bits are correlated); and therefore should NOT be used in any statistical study.; One should use instead TRandom1, TRandom2 or TRandom3.; TRandom3, is based on the ""Mersenne Twister generator"", and is the recommended one,; since it has good random proprieties (period of about 10**6000 ) and it is fast.; TRandom1, based on the RANLUX algorithm, has mathematically proven random proprieties; and a period of about 10**171. It is however slower than the others.; TRandom2, is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; of being fast and using only 3 words (of 32 bits) for the state. The period is 10**26. The following table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRandom.html:403,simpl,simple,403,root/html602/TRandom.html,https://root.cern,https://root.cern/root/html602/TRandom.html,4,['simpl'],['simple']
Usability,". TRandom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom. class TRandom: public TNamed. TRandom. basic Random number generator class (periodicity = 10**9).; Note that this is a very simple generator (linear congruential); which is known to have defects (the lower random bits are correlated); and therefore should NOT be used in any statistical study.; One should use instead TRandom1, TRandom2 or TRandom3.; TRandom3, is based on the ""Mersenne Twister generator"", and is the recommended one,; since it has good random proprieties (period of about 10**6000 ) and it is fast.; TRandom1, based on the RANLUX algorithm, has mathematically proven random proprieties; and a period of about 10**171. It is however slower than the others.; TRandom2, is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; of being fast and using only 3 words (of 32 bits) for the state. The period is 10**26. The following table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom.html:379,simpl,simple,379,root/html528/TRandom.html,https://root.cern,https://root.cern/root/html528/TRandom.html,6,['simpl'],['simple']
Usability,". TRecorderInactive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderInactive. class TRecorderInactive: public TRecorderState. Represents state of TRecorder after its creation. Function Members (Methods); public:. virtual~TRecorderInactive(); static TClass*Class(); static longDisplayValid(Long_t n); static voidDumpRootEvent(TRecGuiEvent* e, Int_t n); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char* filename); virtual voidListGui(const char* filename); TRecorderInactive&operator=(const TRecorderInactive&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidPrevCanvases(const char* filename, Option_t* option); virtual Bool_tReplay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::EReplayModes mode); virtual voidTRecorderState::ReplayStop(TRecorder*); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStart(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderInactive(); TRecorderInactive(const TRecorderInactive&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Data Members; private:. TSeqCollection*fCollect. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderInactive. Function documentation; void Start(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); Switches from INACTIVE state to RECORDING and starts recording. Bool_t Replay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::ERep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderInactive.html:820,Pause,Pause,820,root/html602/TRecorderInactive.html,https://root.cern,https://root.cern/root/html602/TRecorderInactive.html,4,"['Pause', 'Resume']","['Pause', 'Resume']"
Usability,". TRecorderInactive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderInactive. class TRecorderInactive: public TRecorderState. Represents state of TRecorder after its creation. Function Members (Methods); public:. TRecorderInactive(); TRecorderInactive(const TRecorderInactive&); virtual~TRecorderInactive(); static TClass*Class(); static longDisplayValid(Long_t n); static voidDumpRootEvent(TRecGuiEvent* e, Int_t n); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char* filename); virtual voidListGui(const char* filename); TRecorderInactive&operator=(const TRecorderInactive&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidPrevCanvases(const char* filename, Option_t* option); virtual Bool_tReplay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::EReplayModes mode); virtual voidTRecorderState::ReplayStop(TRecorder*); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Data Members; private:. TSeqCollection*fCollect. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Start(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); Switches from INACTIVE state to RECORDING and starts recording. Bool_t Replay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Switches from INACTIVE state of recorder to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorderInactive.html:862,Pause,Pause,862,root/html532/TRecorderInactive.html,https://root.cern,https://root.cern/root/html532/TRecorderInactive.html,2,"['Pause', 'Resume']","['Pause', 'Resume']"
Usability,". TRecorderInactive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderInactive. class TRecorderInactive: public TRecorderState. Represents state of TRecorder after its creation. Function Members (Methods); public:. TRecorderInactive(); TRecorderInactive(const TRecorderInactive&); virtual~TRecorderInactive(); static TClass*Class(); static longDisplayValid(Long_t n); static voidDumpRootEvent(TRecGuiEvent* e, Int_t n); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char* filename); virtual voidListGui(const char* filename); TRecorderInactive&operator=(const TRecorderInactive&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidPrevCanvases(const char* filename, Option_t* option); virtual Bool_tReplay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::EReplayModes mode); virtual voidTRecorderState::ReplayStop(TRecorder*); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector&); virtual voidStart(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Data Members; private:. TSeqCollection*fCollect. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Start(TRecorder* r, const char* filename, Option_t* option, Window_t* w = 0, Int_t winCount = 0); Switches from INACTIVE state to RECORDING and starts recording. Bool_t Replay(TRecorder* r, const char* filename, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Switches from INACTIVE s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderInactive.html:862,Pause,Pause,862,root/html534/TRecorderInactive.html,https://root.cern,https://root.cern/root/html534/TRecorderInactive.html,2,"['Pause', 'Resume']","['Pause', 'Resume']"
Usability,". TRecorderPaused. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderPaused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderPaused(const TRecorderPaused&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); TRecorderPaused(TRecorderReplaying* state). private:. virtual~TRecorderPaused(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderPaused. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder & operator=(const TRecorderPaused& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. virtual ~TRecorderPaused(); {}. TRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderPaused.html:375,pause,paused,375,root/html602/TRecorderPaused.html,https://root.cern,https://root.cern/root/html602/TRecorderPaused.html,6,"['Pause', 'pause']","['Pause', 'paused']"
Usability,". TRecorderPaused. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderPaused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderPaused.html:351,pause,paused,351,root/html528/TRecorderPaused.html,https://root.cern,https://root.cern/root/html528/TRecorderPaused.html,5,"['Pause', 'pause']","['Pause', 'paused']"
Usability,". TRecorderPaused. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderPaused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector&); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder & operator=(const TRecorderPaused& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderPaused.html:351,pause,paused,351,root/html534/TRecorderPaused.html,https://root.cern,https://root.cern/root/html534/TRecorderPaused.html,3,"['Pause', 'pause']","['Pause', 'paused']"
Usability,". TRecorderReplaying. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderReplaying. class TRecorderReplaying: public TRecorderState. Represents state of TRecorder when replaying. Function Members (Methods); public:. static TClass*Class(); virtual voidContinue(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderReplaying&operator=(const TRecorderReplaying&); virtual voidPause(TRecorder* r); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); voidRegisterWindow(Window_t w); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); voidReplayRealtime(); virtual voidReplayStop(TRecorder* r); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderReplaying(const TRecorderReplaying&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); Bool_tInitialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); TRecorderReplaying(const char* filename). private:. virtual~TRecorderReplaying(); Bool_tCanOverlap(); Bool_tFilterEvent(TRecGuiEvent* e); Bool_tPrepareNextEvent(); Bool_tRemapWindowReferences(). Data Members; private:. TCanvas*fCanvUsed to record the previous canvases; TRecCmdEvent*fCmdEventCommandline event being currently replayed; TTree*fCmdTreeTTree with recorded commandline events; Int_tfCmdTreeCounterCounter of c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderReplaying.html:1030,Resume,Resume,1030,root/html602/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html602/TRecorderReplaying.html,2,['Resume'],['Resume']
Usability,". TRecorderReplaying. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderReplaying. class TRecorderReplaying: public TRecorderState. Represents state of TRecorder when replaying. Function Members (Methods); public:. TRecorderReplaying(const TRecorderReplaying&); static TClass*Class(); virtual voidContinue(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderReplaying&operator=(const TRecorderReplaying&); virtual voidPause(TRecorder* r); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); voidRegisterWindow(Window_t w); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); voidReplayRealtime(); virtual voidReplayStop(TRecorder* r); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderReplaying(const char* filename); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); Bool_tInitialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode). private:. (unknown)(); Bool_tCanOverlap(); Bool_tFilterEvent(TRecGuiEvent* e); Bool_tPrepareNextEvent(); Bool_tRemapWindowReferences(). Data Members; private:. TCanvas*fCanvUsed to record the previous canvases; TRecCmdEvent*fCmdEventCommandline event being currently replayed; TTree*fCmdTreeTTree with recorded commandline events; Int_tfCmdTreeCounterCounter of commandline events that have been replayed; Bool_tfEventReplayedSignaliz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorderReplaying.html:1053,Resume,Resume,1053,root/html532/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html532/TRecorderReplaying.html,1,['Resume'],['Resume']
Usability,". TRecorderReplaying. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderReplaying. class TRecorderReplaying: public TRecorderState. Represents state of TRecorder when replaying. Function Members (Methods); public:. TRecorderReplaying(const TRecorderReplaying&); static TClass*Class(); virtual voidContinue(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderReplaying&operator=(const TRecorderReplaying&); virtual voidPause(TRecorder* r); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); voidRegisterWindow(Window_t w); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); voidReplayRealtime(); virtual voidReplayStop(TRecorder* r); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector&); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TRecorderReplaying(const char* filename); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); Bool_tInitialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode). private:. (unknown)(); Bool_tCanOverlap(); Bool_tFilterEvent(TRecGuiEvent* e); Bool_tPrepareNextEvent(); Bool_tRemapWindowReferences(). Data Members; private:. TCanvas*fCanvUsed to record the previous canvases; TRecCmdEvent*fCmdEventCommandline event being currently replayed; TTree*fCmdTreeTTree with recorded commandline events; Int_tfCmdTreeCounterCounter of commandline events that have been replayed; Bool_tfEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderReplaying.html:1053,Resume,Resume,1053,root/html534/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html534/TRecorderReplaying.html,1,['Resume'],['Resume']
Usability,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSAXParser.html:419,Simpl,Simple,419,root/html602/TSAXParser.html,https://root.cern,https://root.cern/root/html602/TSAXParser.html,2,['Simpl'],['Simple']
Usability,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSAXParser.html:395,Simpl,Simple,395,root/html532/TSAXParser.html,https://root.cern,https://root.cern/root/html532/TSAXParser.html,2,['Simpl'],['Simple']
Usability,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVG.html:537,simpl,simply,537,root/html602/TSVG.html,https://root.cern,https://root.cern/root/html602/TSVG.html,4,['simpl'],['simply']
Usability,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. TSVG(); TSVG(const char* filename, Int_t type = -113); virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVG.html:513,simpl,simply,513,root/html528/TSVG.html,https://root.cern,https://root.cern/root/html528/TSVG.html,6,['simpl'],['simply']
Usability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selectStr = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selectStr.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpider.html:897,simpl,simply,897,root/html602/TSpider.html,https://root.cern,https://root.cern/root/html602/TSpider.html,4,['simpl'],['simply']
Usability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString select = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),select.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. TSpider(); TSpider(const TSpider&); TSpider(TTree* tree, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 0, Long64_t firstentry = 0); virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpider.html:873,simpl,simply,873,root/html530/TSpider.html,https://root.cern,https://root.cern/root/html530/TSpider.html,5,['simpl'],['simply']
Usability,". TStatsFeedback. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatsFeedback. class TStatsFeedback: public TObject, public TQObject. TStatsFeedback. Utility class to display PROOF stats feedback histos during queries. Function Members (Methods); public:. virtual~TStatsFeedback(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatsFeedback.html:405,feedback,feedback,405,root/html602/TStatsFeedback.html,https://root.cern,https://root.cern/root/html602/TStatsFeedback.html,4,['feedback'],['feedback']
Usability,". TStatsFeedback. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatsFeedback. class TStatsFeedback: public TObject, public TQObject. TStatsFeedback. Utility class to display PROOF stats feedback histos during queries. Function Members (Methods); public:. TStatsFeedback(TProof* proof = 0); virtual~TStatsFeedback(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatsFeedback.html:381,feedback,feedback,381,root/html534/TStatsFeedback.html,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html,2,['feedback'],['feedback']
Usability,". TStructNodeProperty* FindNodeProperty(TStructNode* node); Returns pointer to property associated with node ""node"". If property is not found; then it returns default property. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. Int_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructViewerGUI.html:27566,Undo,Undo,27566,root/html532/TStructViewerGUI.html,https://root.cern,https://root.cern/root/html532/TStructViewerGUI.html,4,['Undo'],['Undo']
Usability,". TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TSynapse. class TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSynapse.html:328,simpl,simple,328,root/html602/TSynapse.html,https://root.cern,https://root.cern/root/html602/TSynapse.html,4,['simpl'],['simple']
Usability,". TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TSynapse. class TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. TSynapse(); TSynapse(const TSynapse&); TSynapse(TNeuron*, TNeuron*, Double_t w = 1); virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSynapse.html:304,simpl,simple,304,root/html528/TSynapse.html,https://root.cern,https://root.cern/root/html528/TSynapse.html,6,['simpl'],['simple']
Usability,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:667,simpl,simple,667,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['simpl'],['simple']
Usability,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSystem.html:643,simpl,simple,643,root/html532/TSystem.html,https://root.cern,https://root.cern/root/html532/TSystem.html,4,['simpl'],['simple']
Usability,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:643,simpl,simple,643,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,2,['simpl'],['simple']
Usability,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSystem.html:643,simpl,simple,643,root/html604/TSystem.html,https://root.cern,https://root.cern/root/html604/TSystem.html,2,['simpl'],['simple']
Usability,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTeXDump.html:670,user-friendly,user-friendly,670,root/html602/TTeXDump.html,https://root.cern,https://root.cern/root/html602/TTeXDump.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTeXDump.html:646,user-friendly,user-friendly,646,root/html534/TTeXDump.html,https://root.cern,https://root.cern/root/html534/TTeXDump.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTeXDump.html:646,user-friendly,user-friendly,646,root/html604/TTeXDump.html,https://root.cern,https://root.cern/root/html604/TTeXDump.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(const Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfWeek(Int_t day, Int_t month, Int_t year); Int_tGetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfYear(Int_t day, Int_t month, Int_t year); Int_tGetMonth(Bool_t in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimeStamp.html:752,simpl,simply,752,root/html604/TTimeStamp.html,https://root.cern,https://root.cern/root/html604/TTimeStamp.html,2,['simpl'],['simply']
Usability,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsJulianDate() const; const char*AsString(const Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfWeek(Int_t day, Int_t month, Int_t year); Int_tGetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfYear(Int_t day, Int_t month, Int_t year); Int_tGetMonth(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Int_tGetNanoSec() const; time_tGetSec() const; UInt_tGetTime(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* hour = 0, UInt_t* min = 0, UInt_t* sec = 0) const; timespec_tGetTimeSpe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimeStamp.html:752,simpl,simply,752,root/html602/TTimeStamp.html,https://root.cern,https://root.cern/root/html602/TTimeStamp.html,2,['simpl'],['simply']
Usability,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimeStamp.html:728,simpl,simply,728,root/html534/TTimeStamp.html,https://root.cern,https://root.cern/root/html534/TTimeStamp.html,2,['simpl'],['simply']
Usability,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsJulianDate() const; const char*AsString(Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:728,simpl,simply,728,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,4,['simpl'],['simply']
Usability,". TTree and Its Data | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials TTree and Its Data. TTree; A TTree is a large, structured chunk of data on disk. The trick is tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:288,guid,guidelines,288,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['guid'],['guidelines']
Usability,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:549,learn,learning,549,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['learn'],['learning']
Usability,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:549,learn,learning,549,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,4,['learn'],['learning']
Usability,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:525,learn,learning,525,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['learn'],['learning']
Usability,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:525,learn,learning,525,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,8,['learn'],['learning']
Usability,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:341,simpl,simple,341,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,12,['simpl'],"['simple', 'simpler']"
Usability,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUUID.html:365,GUID,GUIDs,365,root/html602/TUUID.html,https://root.cern,https://root.cern/root/html602/TUUID.html,4,['GUID'],['GUIDs']
Usability,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUUID.html:341,GUID,GUIDs,341,root/html532/TUUID.html,https://root.cern,https://root.cern/root/html532/TUUID.html,4,['GUID'],['GUIDs']
Usability,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TView3D.html:955,simpl,simple,955,root/html602/TView3D.html,https://root.cern,https://root.cern/root/html602/TView3D.html,8,['simpl'],['simple']
Usability,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView3D.html:931,simpl,simple,931,root/html528/TView3D.html,https://root.cern,https://root.cern/root/html528/TView3D.html,12,['simpl'],['simple']
Usability,". TXMLFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TXMLFile. class TXMLFile: public TFile, public TXMLSetup. The main motivation for the XML format is to facilitate the; communication with other non ROOT applications. Currently; writing and reading XML files is limited to ROOT applications.; It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for; real applications. One of possible approach with code generation; is implemented in TXMLPlayer class. The XML format should be used only for small data volumes,; typically histogram files, pictures, geometries, calibrations.; The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism; exploiting the ROOT/CINT dictionary. Any class having a dictionary; can be saved in XML format. This first implementation does not support subdirectories; or Trees. The shared library libRXML.so may be loaded dynamically; via gSystem->Load(""libRXML""). This library is automatically; loaded by the plugin manager as soon as a XML file is created; via, eg; TFile::Open(""file.xml"",""recreate"");; TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; one can use the normal TObject::Write to write an object in the file.; Alternatively one can use the new functions TDirectoryFile::WriteObject and; TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; from TObject. example of a session saving a histogram to a XML file. TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; h->FillRandom(""gaus"");; h->Write();; delete f;. example of a session reading the histogram from the file. TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLFile.html:539,simpl,simple,539,root/html602/TXMLFile.html,https://root.cern,https://root.cern/root/html602/TXMLFile.html,4,['simpl'],['simple']
Usability,". TXMLFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TXMLFile. class TXMLFile: public TFile, public TXMLSetup. The main motivation for the XML format is to facilitate the; communication with other non ROOT applications. Currently; writing and reading XML files is limited to ROOT applications.; It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for; real applications. One of possible approach with code generation; is implemented in TXMLPlayer class. The XML format should be used only for small data volumes,; typically histogram files, pictures, geometries, calibrations.; The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism; exploiting the ROOT/CINT dictionary. Any class having a dictionary; can be saved in XML format. This first implementation does not support subdirectories; or Trees. The shared library libRXML.so may be loaded dynamically; via gSystem->Load(""libRXML""). This library is automatically; loaded by the plugin manager as soon as a XML file is created; via, eg; TFile::Open(""file.xml"",""recreate"");; TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; one can use the normal TObject::Write to write an object in the file.; Alternatively one can use the new functions TDirectoryFile::WriteObject and; TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; from TObject. example of a session saving a histogram to a XML file. TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; h->FillRandom(""gaus"");; h->Write();; delete f;. example of a session reading the histogram from the file. TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:515,simpl,simple,515,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,6,['simpl'],['simple']
Usability,". Taligent's Guide to Designing Programs - Name conventions. Name conventions; Select C++ identifiers (including types, functions, and classes) carefully. When a programmer sees a name, it might be out of context; choose names to enhance readability and comprehension. A name that seems cute or easy to type can cause trouble to someone trying to decipher code. Remember, code is read many more times than it is written; err on the side of long, readable names. Internal code names should not appear anywhere in the interfaces to the system. Even inside your implementation, it's better to use the prosaic form if there is one.; To make the scope of names explicit, Taligent uses the following conventions. Name conventions. Identifier. Convention. Example. Types. Begin with a capital letter. Boolean. Base classes. Begin with T. TContainerView. Mixin classes. Begin with M; ; see ""Multiple inheritance"" on page 44. MPrintable. Enumeration types. Begin with E. EFreezeLevel. Raw C types. Avoid using C types; see ""Avoid raw C types with dimensions"" on page 66. Virtual base classes. Begin with V, rather than T or M. VBaseClass. Members. Begin with f for field1; ; functions begin with a capital letter. fViewList, DrawSelf(). Static variables. Begin with g; applies to static variables in functions and global variables (excluding static data members of a class). gDeviceList. Static data members. Begin with fg; includes class globals. TView::fgTokenClient. Locals and parameters. Begin with a word whose initial letter is lowercase; local automatic variables only, treat statics like globals. seed, port, ; theCurrentArea. Constants. Begin with k; including names of enumeration constants and constant statics. kMenuCommand. Acronyms. All uppercase. TNBPName, not TNbpName. Template arguments. Begin with A. AType. Getters and setters. Begin with Set..., Get..., or Is... (Boolean); use sparingly (see ""Structification"" on page 50). SetLast(), GetNext(), IsDone(). Allocator and adopters. Begin wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_63.html:13,Guid,Guide,13,TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_63.html,https://root.cern,https://root.cern/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_63.html,1,['Guid'],['Guide']
Usability,". Team | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Team. . Axel Naumann ; ; Starting off as a physicist, Axel studied physics and math in Muenster, Germany. In 2000, he got a Ph.D. position for high energy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:274,guid,guidelines,274,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['guid'],['guidelines']
Usability,". The End | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials The End. You are done - that was the introductory tutorial!. Image by Tangopaso; If you want to go on, have ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/end.html:277,guid,guidelines,277,d/end.html,https://root.cern,https://root.cern/d/end.html,1,['guid'],['guidelines']
Usability,". The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then:; MASTER = T * LOCAL; Therefore a local-to-master conversion will be performed by using T, while a master-to-local by using its inverse. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', this global transformation represent the pile-up of all local transformations in the corresponding branch. The conversion from the global reference frame and the given object is also called master-to-local, but it is handled by the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1; Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1; Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1; where:; rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on each axis,. The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translation would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMatrix.html:1748,simpl,simple,1748,doc/master/classTGeoMatrix.html,https://root.cern,https://root.cern/doc/master/classTGeoMatrix.html,1,['simpl'],['simple']
Usability,. Track. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TEST; » Track. class Track: public TObject. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of th,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Track.html:320,simpl,simple,320,root/html528/Track.html,https://root.cern,https://root.cern/root/html528/Track.html,1,['simpl'],['simple']
Usability,". TutorialSelector.C | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop TutorialSelector.C. // This class is derived from the ROOT class TSelector to demonstrate; // the use of PROOF with the R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:288,guid,guidelines,288,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['guid'],['guidelines']
Usability,". Tutorials | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Tutorials. ROOT offers a rich set of code examples that allow you to see ROOT's building blocks ""in action"", as part of more complex programs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorials.html:279,guid,guidelines,279,d/tutorials.html,https://root.cern,https://root.cern/d/tutorials.html,1,['guid'],['guidelines']
Usability,". UserGroup_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » UserGroup_t. class UserGroup_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. ~UserGroup_t(); UserGroup_t&operator=(UserGroup_t&&); UserGroup_t&operator=(const UserGroup_t&); UserGroup_t(); UserGroup_t(UserGroup_t&&); UserGroup_t(const UserGroup_t&). Data Members; public:. Int_tfGidgroup id; TStringfGroupgroup name; TStringfPasswdpassword; TStringfRealNameuser full name; TStringfShelluser preferred shell; Int_tfUiduser id; TStringfUseruser name. Class Charts. Inheritance Chart:. UserGroup_t. Function documentation; UserGroup_t(); { }. TSystem& operator=(const TSystem&). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/UserGroup_t.html:664,simpl,simple,664,root/html602/UserGroup_t.html,https://root.cern,https://root.cern/root/html602/UserGroup_t.html,2,['simpl'],['simple']
Usability,". UserGroup_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » UserGroup_t. class UserGroup_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. ~UserGroup_t(); UserGroup_t&operator=(UserGroup_t&&); UserGroup_t&operator=(const UserGroup_t&); UserGroup_t(); UserGroup_t(UserGroup_t&&); UserGroup_t(const UserGroup_t&). Data Members; public:. Int_tfGidgroup id; TStringfGroupgroup name; TStringfPasswdpassword; TStringfRealNameuser full name; TStringfShelluser preferred shell; Int_tfUiduser id; TStringfUseruser name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UserGroup_t(); { }. TSystem& operator=(const TSystem&). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/UserGroup_t.html:640,simpl,simple,640,root/html604/UserGroup_t.html,https://root.cern,https://root.cern/root/html604/UserGroup_t.html,2,['simpl'],['simple']
Usability,". Using TTree::Draw() to access a TTree | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using TTree::Draw() to access a TTree. Now close the browser, quit and restart",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-ttreedraw-access-ttree.html:307,guid,guidelines,307,d/using-ttreedraw-access-ttree.html,https://root.cern,https://root.cern/d/using-ttreedraw-access-ttree.html,1,['guid'],['guidelines']
Usability,". Using a Macro to Read a TTree | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a Macro to Read a TTree. Why using a macro?; As real analyses don't fit into sim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:299,guid,guidelines,299,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['guid'],['guidelines']
Usability,". Using a TSelector with PROOF | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using a TSelector with PROOF. For people having a multi (e.g. dual) core computer, it i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-tselector-proof.html:298,guid,guidelines,298,d/using-tselector-proof.html,https://root.cern,https://root.cern/d/using-tselector-proof.html,1,['guid'],['guidelines']
Usability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4254 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 548 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3542 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 2997 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:78040,clear,clearEvalErrorLog,78040,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 3082 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:79308,clear,clearEvalErrorLog,79308,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearEvalErrorLog']
Usability,". Workshops | ROOT a Data analysis Framework. Menu. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » News Workshops. Here the list with ROOT workshops:. ROOT 2018 ; ROOT 2015 ; ROOT 2013 (slides); ROOT 2007 (slides); ROOT 2005 (slides); ROOT 2007; ROOT 200",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/workshops.html:279,guid,guidelines,279,d/workshops.html,https://root.cern,https://root.cern/d/workshops.html,1,['guid'],['guidelines']
Usability,". [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column x; ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWigner(fPx,3,2); event.GetHistogram()->GetXaxis()->GetXmax(); TTree::GetHistogramTH1 * GetHistogram()Definition TTree.h:479; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:112058,simpl,simplest,112058,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['simpl'],['simplest']
Usability,". [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column x; ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWigner(fPx,3,2); event.GetHistogram()->GetXaxis()->GetXmax(); TTree::GetHistogramTH1 * GetHistogram()Definition TTree.h:519; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:112231,simpl,simplest,112231,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['simpl'],['simplest']
Usability,". enum TProof::ESubMerger. EnumeratorkOutputSize ; kSendOutput ; kBeMerger ; kMergerDown ; kStopMerging ; kOutputSent . Definition at line 376 of file TProof.h. ◆ EUploadOpt. enum TProof::EUploadOpt. EnumeratorkAppend ; kOverwriteDataSet ; kNoOverwriteDataSet ; kOverwriteAllFiles ; kOverwriteNoFiles ; kAskUser . Definition at line 353 of file TProof.h. ◆ EUploadPackageOpt. enum TProof::EUploadPackageOpt. EnumeratorkUntar ; kRemoveOld . Definition at line 366 of file TProof.h. ◆ EUrgent. enum TProof::EUrgent. private . EnumeratorkLocalInterrupt ; kPing ; kHardInterrupt ; kSoftInterrupt ; kShutdownInterrupt . Definition at line 393 of file TProof.h. Constructor & Destructor Documentation. ◆ TProof() [1/3]. TProof::TProof ; (; const TProof & ; ). private . ◆ TProof() [2/3]. TProof::TProof ; (; ). protected . Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; This constructor simply closes any previous gProof and sets gProof to this instance. ; Definition at line 513 of file TProof.cxx. ◆ TProof() [3/3]. TProof::TProof ; (; const char * ; masterurl, . const char * ; conffile = kPROOF_ConfFile, . const char * ; confdir = kPROOF_ConfDir, . Int_t ; loglevel = 0, . const char * ; alias = 0, . TProofMgr * ; mgr = 0 . ). Create a PROOF environment. ; Starting PROOF involves either connecting to a master server, which in turn will start a set of slave servers, or directly starting as master server (if master = """"). Masterurl is of the form: [proof[s]://]host[:port]. Conffile is the name of the config file describing the remote PROOF cluster (this argument alows you to describe different cluster configurations). The default is proof.conf. Confdir is the directory where the config file and other PROOF related files are (like motd and noproof files). Loglevel is the log level (default = 1). User specified custom config files will be first looked for in $HOME/.conffile. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:60294,simpl,simply,60294,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['simpl'],['simply']
Usability,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TTimeStamp.h 32404 2010-02-25 12:06:10Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/timespec.html:696,simpl,simply,696,root/html528/timespec.html,https://root.cern,https://root.cern/root/html528/timespec.html,1,['simpl'],['simply']
Usability,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/timespec.html:698,simpl,simply,698,root/html534/timespec.html,https://root.cern,https://root.cern/root/html534/timespec.html,2,['simpl'],['simply']
Usability,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TTimeStamp.h 32404 2010-02-25 12:06:10Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/timespec.html:698,simpl,simply,698,root/html530/timespec.html,https://root.cern,https://root.cern/root/html530/timespec.html,1,['simpl'],['simply']
Usability,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TTimeStamp.h 32404 2010-02-25 12:06:10Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/timespec.html:698,simpl,simply,698,root/html532/timespec.html,https://root.cern,https://root.cern/root/html532/timespec.html,2,['simpl'],['simply']
Usability,". virtual TArrayD * TProfile2D::GetBinSumw2 ; (; ). inlinevirtual . Definition at line 121 of file TProfile2D.h. ◆ GetBinSumw2() [2/2]. virtual const TArrayD * TProfile2D::GetBinSumw2 ; (; ); const. inlinevirtual . Definition at line 122 of file TProfile2D.h. ◆ GetErrorOption(). Option_t * TProfile2D::GetErrorOption ; (; ); const. Return option to compute profile2D errors. ; Definition at line 889 of file TProfile2D.cxx. ◆ GetNumberOfBins(). Double_t TProfile2D::GetNumberOfBins ; (; ). inline . Definition at line 151 of file TProfile2D.h. ◆ GetStats(). void TProfile2D::GetStats ; (; Double_t * ; stats); const. overridevirtual . Fill the array stats from the contents of this profile. ; The array stats must be correctly dimensioned in the calling program. stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range. ; Reimplemented from TH2.; Definition at line 916 of file TProfile2D.cxx. ◆ GetW(). Double_t * TProfile2D::GetW ; (; ). inlineprivate . Definition at line 65 of file TProfile2D.h. ◆ GetW2(). Double_t * TProfile2D::GetW2 ; (; ). inlineprivate . Definition at line 66 of file TProfile2D.h. ◆ GetZmax(). virtual Double_t TProfile2D::GetZmax ; (; ); const. inlinevirtual . Definition at line 126 of file TProfile2D.h. ◆ GetZmin(). virtual Double_t TProfile2D::GetZmin ; (; ); const. inlinevirtual . Definition at line 125 of file TProfile2D.h. ◆ IsA(). TClass * TProfile2D::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TH2D.; Definition at line 153 of file TProfile2D.h. ◆ LabelsDeflate(). void TProfile2D::LabelsDeflate ; (; Option_t * ; axis = ""X""). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:90601,simpl,simply,90601,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['simpl'],['simply']
Usability,". void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearFitter.html:23079,Clear,Clear,23079,root/html602/TLinearFitter.html,https://root.cern,https://root.cern/root/html602/TLinearFitter.html,4,['Clear'],"['Clear', 'Clears']"
Usability,". void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLinearFitter.html:22511,Clear,Clear,22511,root/html532/TLinearFitter.html,https://root.cern,https://root.cern/root/html532/TLinearFitter.html,4,['Clear'],"['Clear', 'Clears']"
Usability,". void DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); Draw a line.; x1,y1 : begin of line; x2,y2 : end of line. void DrawPolyLine(Int_t n, TPoint* xy); Draw a line through all points.; n : number of points; xy : list of points. void DrawPolyMarker(Int_t n, TPoint* xy); Draw n markers with the current attributes at position x, y.; n : number of markers to draw; xy : x,y coordinates of markers. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw a text string using current font.; mode : drawing mode; mode=0 : the background is not drawn (kClear); mode=1 : the background is drawn (kOpaque); x,y : text position; angle : text angle; mgn : magnification factor; text : text string. void FindBestVisual(); Find best visual, i.e. the one with the most planes and TrueColor or; DirectColor. Sets fVisual, fDepth, fRootWin, fColormap, fBlackPixel; and fWhitePixel. void FindUsableVisual(RXVisualInfo* vlist, Int_t nitems); Check if visual is usable, if so set fVisual, fDepth, fColormap,; fBlackPixel and fWhitePixel. void GetCharacterUp(Float_t& chupx, Float_t& chupy); Return character up vector. XColor_t & GetColor(Int_t cid); Return reference to internal color structure associated; to color index cid. Window_t GetCurrentWindow() const; Return current window pointer. Protected method used by TGX11TTF. void * GetGC(Int_t which) const; Return desired Graphics Context (""which"" maps directly on gGCList[]).; Protected method used by TGX11TTF. Int_t GetDoubleBuffer(Int_t wid); Query the double buffer value for the window wid. void GetGeometry(Int_t wid, Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Return position and size of window wid.; wid : window identifier; x,y : window position (output); w,h : window size (output); if wid < 0 the size of the display is returned. const char * DisplayName(const char* dpyName = 0); Return hostname on which the display is opened. ULong_t GetPixel(Color_t cindex); Return pixel value associated t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:29639,usab,usable,29639,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,4,['usab'],['usable']
Usability,". void DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); Draw a line.; x1,y1 : begin of line; x2,y2 : end of line. void DrawPolyLine(Int_t n, TPoint* xy); Draw a line through all points.; n : number of points; xy : list of points. void DrawPolyMarker(Int_t n, TPoint* xy); Draw n markers with the current attributes at position x, y.; n : number of markers to draw; xy : x,y coordinates of markers. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw a text string using current font.; mode : drawing mode; mode=0 : the background is not drawn (kClear); mode=1 : the background is drawn (kOpaque); x,y : text position; angle : text angle; mgn : magnification factor; text : text string. void FindBestVisual(); Find best visual, i.e. the one with the most planes and TrueColor or; DirectColor. Sets fVisual, fDepth, fRootWin, fColormap, fBlackPixel; and fWhitePixel. void FindUsableVisual(XVisualInfo* vlist, Int_t nitems); Check if visual is usable, if so set fVisual, fDepth, fColormap,; fBlackPixel and fWhitePixel. void GetCharacterUp(Float_t& chupx, Float_t& chupy); Return character up vector. XColor_t & GetColor(Int_t cid); Return reference to internal color structure associated; to color index cid. Window_t GetCurrentWindow() const; Return current window pointer. Protected method used by TGX11TTF. GC * GetGC(Int_t which) const; Return desired Graphics Context (""which"" maps directly on gGCList[]).; Protected method used by TGX11TTF. Int_t GetDoubleBuffer(Int_t wid); Query the double buffer value for the window wid. void GetGeometry(Int_t wid, Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Return position and size of window wid.; wid : window identifier; x,y : window position (output); w,h : window size (output); if wid < 0 the size of the display is returned. const char * DisplayName(const char* dpyName = 0); Return hostname on which the display is opened. ULong_t GetPixel(Color_t cindex); Return pixel value associated to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11.html:27753,usab,usable,27753,root/html528/TGX11.html,https://root.cern,https://root.cern/root/html528/TGX11.html,6,['usab'],['usable']
Usability,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 14:10:12 2015 » Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:21240,clear,clearEmat,21240,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,8,['clear'],['clearEmat']
Usability,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnfoldSys.html:21240,clear,clearEmat,21240,root/html604/TUnfoldSys.html,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html,8,['clear'],['clearEmat']
Usability,". void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFilePrefetch.html:7984,clear,clear,7984,root/html534/TFilePrefetch.html,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html,2,['clear'],['clear']
Usability,". void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFilePrefetch.html:8445,clear,clear,8445,root/html604/TFilePrefetch.html,https://root.cern,https://root.cern/root/html604/TFilePrefetch.html,2,['clear'],['clear']
Usability,". void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFilePrefetch.html:8445,clear,clear,8445,root/html602/TFilePrefetch.html,https://root.cern,https://root.cern/root/html602/TFilePrefetch.html,2,['clear'],['clear']
Usability,".  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py.html:1114,learn,learning,1114,doc/master/tmva101__Training_8py.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html,1,['learn'],['learning']
Usability,".  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree1_8C.html:1058,simpl,simple,1058,doc/master/tree1_8C.html,https://root.cern,https://root.cern/doc/master/tree1_8C.html,2,['simpl'],['simple']
Usability,". ◆ EvaluateLogLGradient(). void ROOT::Fit::FitUtil::EvaluateLogLGradient ; (; const IModelFunction & ; func, . const UnBinData & ; data, . const double * ; p, . double * ; grad, . unsigned int & ; nPoints, . ::ROOT::EExecutionPolicy ; executionPolicy = ::ROOT::EExecutionPolicy::kSequential, . unsigned ; nChunks = 0 . ). evaluate the LogL gradient given a model function and the data at the point p. ; return also nPoints as the effective number of used points in the LogL evaluation . ◆ EvaluatePdf(). double ROOT::Fit::FitUtil::EvaluatePdf ; (; const IModelFunction & ; func, . const UnBinData & ; data, . const double * ; p, . unsigned int ; ipoint, . double * ; g = nullptr, . double * ; h = nullptr, . bool ; hasGrad = false, . bool ; fullHessian = false . ). evaluate the pdf contribution to the LogL given a model function and the BinPoint data. ; If the pointer g is not null evaluate also the gradient of the pdf. If the function provides parameter derivatives they are used otherwise a simple derivative calculation is used ; Definition at line 891 of file FitUtil.cxx. ◆ EvaluatePoissonBinPdf(). double ROOT::Fit::FitUtil::EvaluatePoissonBinPdf ; (; const IModelFunction & ; func, . const BinData & ; data, . const double * ; x, . unsigned int ; ipoint, . double * ; g = nullptr, . double * ; h = nullptr, . bool ; hasGrad = false, . bool ; fullHessian = false . ). evaluate the pdf contribution to the Poisson LogL given a model function and the BinPoint data. ; evaluate the pdf (Poisson) contribution to the logl (return actually log of pdf) and its gradient (gradient of log(pdf)); If the pointer g is not null evaluate also the gradient of the Poisson pdf. If the function provides parameter derivatives they are used otherwise a simple derivative calculation is used ; Definition at line 1297 of file FitUtil.cxx. ◆ EvaluatePoissonLogL(). double ROOT::Fit::FitUtil::EvaluatePoissonLogL ; (; const IModelFunction & ; func, . const BinData & ; data, . const double * ; p, . int ; iWei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Fit_1_1FitUtil.html:9488,simpl,simple,9488,doc/master/namespaceROOT_1_1Fit_1_1FitUtil.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Fit_1_1FitUtil.html,1,['simpl'],['simple']
Usability,. ◆ SetSilent(). void TMVA::Config::SetSilent ; (; Bool_t ; s). inline . Definition at line 63 of file Config.h. ◆ SetUseColor(). void TMVA::Config::SetUseColor ; (; Bool_t ; uc). inline . Definition at line 60 of file Config.h. ◆ SetWriteOptionsReference(). void TMVA::Config::SetWriteOptionsReference ; (; Bool_t ; w). inline . Definition at line 66 of file Config.h. ◆ Streamer(). virtual void TMVA::Config::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TMVA::Config::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 148 of file Config.h. ◆ UseColor(). Bool_t TMVA::Config::UseColor ; (; ); const. inline . Definition at line 59 of file Config.h. ◆ WriteOptionsReference(). Bool_t TMVA::Config::WriteOptionsReference ; (; ); const. inline . Definition at line 65 of file Config.h. Member Data Documentation. ◆ fDrawProgressBar. std::atomic<Bool_t> TMVA::Config::fDrawProgressBar. private . draw progress bar to indicate training evolution ; Definition at line 140 of file Config.h. ◆ fExecutor. Executor TMVA::Config::fExecutor. protected . Definition at line 52 of file Config.h. ◆ fgConfigPtr. std::atomic< TMVA::Config * > TMVA::Config::fgConfigPtr { 0 }. staticprivate . Definition at line 137 of file Config.h. ◆ fIONames. class TMVA::Config::IONames TMVA::Config::fIONames. ◆ fLogger. MsgLogger* TMVA::Config::fLogger. mutableprivate . ! message logger ; Definition at line 145 of file Config.h. ◆ fNWorkers. std::atomic<UInt_t> TMVA::Config::fNWorkers. private . Default number of workers for multi-process jobs. ; Definition at line 141 of file Config.h. ◆ fSilent. std::atomic<Bool_t> TMVA::Config::fSilent. private . no output at all ; Definition at line 143 of file Config.h. ◆ fUseColoredConsole. std::atomic<Bool_t> TMVA::Config::fUseColoredConsole. private . coloured standard output ; Definition at line 142 of file Config.h. ◆ fVariablePlotting. class TMVA::Config::VariablePlotting TMVA::Config::fVariablePlotting. ◆ ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Config.html:7386,progress bar,progress bar,7386,doc/master/classTMVA_1_1Config.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Config.html,1,['progress bar'],['progress bar']
Usability,"................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 34935 2010-08-23 09:13:3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:20303,learn,learning,20303,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['learn'],['learning']
Usability,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24779,simpl,simply,24779,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22888,simpl,simply,22888,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"...; Searching...; No Matches. df025_RNode.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Manipulate RDF objects in functions, loops and conditional branches. ; Each RDataFrame object has its own type. It helps with performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df025__RNode_8C.html:1080,simpl,simple,1080,doc/master/df025__RNode_8C.html,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html,1,['simpl'],['simple']
Usability,".7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063748,simpl,simple,1063748,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,".; 5788 if (fBranchRef && fBranchRef != fSeqBranches[0]) {; 5789 fSeqBranches.push_back(fBranchRef);; 5790 }; 5791 ; 5792 // The branches to be processed sequentially are those that are the leaf count of another branch; 5793 if (checkLeafCount) {; 5794 for (Int_t i = 0; i < nbranches; i++) {; 5795 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5796 auto leafCount = ((TLeaf*)branch->GetListOfLeaves()->At(0))->GetLeafCount();; 5797 if (leafCount) {; 5798 auto countBranch = leafCount->GetBranch();; 5799 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), countBranch) == fSeqBranches.end()) {; 5800 fSeqBranches.push_back(countBranch);; 5801 }; 5802 }; 5803 }; 5804 }; 5805 ; 5806 // Any branch that is not a leaf count can be safely processed in parallel when reading; 5807 // We need to reset the vector to make sure we do not re-add several times the same branch.; 5808 if (!checkLeafCount) {; 5809 fSortedBranches.clear();; 5810 }; 5811 for (Int_t i = 0; i < nbranches; i++) {; 5812 Long64_t bbytes = 0;; 5813 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5814 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), branch) == fSeqBranches.end()) {; 5815 bbytes = branch->GetTotBytes(""*"");; 5816 fSortedBranches.emplace_back(bbytes, branch);; 5817 }; 5818 }; 5819 ; 5820 // Initially sort parallel branches by size; 5821 std::sort(fSortedBranches.begin(),; 5822 fSortedBranches.end(),; 5823 [](std::pair<Long64_t,TBranch*> a, std::pair<Long64_t,TBranch*> b) {; 5824 return a.first > b.first;; 5825 });; 5826 ; 5827 for (size_t i = 0; i < fSortedBranches.size(); i++) {; 5828 fSortedBranches[i].first = 0LL;; 5829 }; 5830}; 5831 ; 5832////////////////////////////////////////////////////////////////////////////////; 5833/// Sorts top-level branches by the last average task time recorded per branch.; 5834 ; 5835void TTree::SortBranchesByTime(); 5836{; 5837 for (size_t i = 0; i < fSortedBranches.size(); i++) {; 5838 fSortedBranches[i].first *= kNEntriesResortInv;; 5839",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:229388,clear,clear,229388,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['clear'],['clear']
Usability,".; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:54645,simpl,simple,54645,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simple']
Usability,".; Bool_tfWrapTwoPi; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloData(const char* n = ""TEveCalData"", const char* t = """"); Constructor. void UnSelected(); Virtual method TEveElement::UnSelect.; Clear selected towers when deselected. void UnHighlighted(); Virtual method TEveElement::UnHighlighted. TString GetHighlightTooltip(). void FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); Populate set impSelSet with derived / dependant elements. void PrintCellsSelected(); Print selected cells info. void ProcessSelection(TEveCaloData::vCellId_t& sel_cells, TGLSelectRecord& rec); Process newly selected cells with given select-record.; Secondary-select status is set.; CellSelectionChanged() is called if needed. void SetSliceThreshold(Int_t slice, Float_t threshold); Set threshold for given slice. Float_t GetSliceThreshold(Int_t slice) const; Get threshold for given slice. void SetSliceColor(Int_t slice, Color_t col); Set color for given slice. Color_t GetSliceColor(Int_t slice) const; Get color for given slice. void SetSliceTransparency(Int_t slice, Char_t t); Set transparency for given slice. Char_t GetSliceTransparency(Int_t slice) const; Get transparency for given slice. void InvalidateUsersCellI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloData.html:21271,Clear,Clear,21271,root/html602/TEveCaloData.html,https://root.cern,https://root.cern/root/html602/TEveCaloData.html,2,['Clear'],['Clear']
Usability,".; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 446 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [3/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 524 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [4/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:30506,simpl,simple,30506,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,".; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector.; Definition at line 48 of file TSelHandleDataSet.h. ◆ Process(). Bool_t TSelHandleDataSet::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 165 of file TSelHandleDataSet.cxx. ◆ ReleaseCache(). void TSelHandleDataSet::ReleaseCache ; (; const char * ; fn). private . Release the memory cache associated with file 'fn'. ; Definition at line 74 of file TSelHandleDataSet.cxx. ◆ RemoveFile(). void TSelHandleDataSet::RemoveFile ; (; const char * ; fn). private . Physically remove the file 'fn'. ; Definition at line 109 of file TSelHandleDataSet.cxx. ◆ SetInputList(). void TSelHandleDataSet::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 52 of file TSelHandleDataSet.h. ◆ SetObject(). void TSelHandleDataSet::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 51 of file TSelHandleDataSet.h. ◆ SetOption(). void TSelHandleDataSet::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHandleDataSet.html:16426,simpl,simple,16426,doc/master/classTSelHandleDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelHandleDataSet.html,1,['simpl'],['simple']
Usability,".; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation.; ; 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:25203,guid,guided,25203,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['guid'],['guided']
Usability,".; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). TObject * GetUserFunc(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFitter.html:13050,Clear,Clear,13050,root/html602/TVirtualFitter.html,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html,2,['Clear'],['Clear']
Usability,".; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""gROOT.Reset(\""a\"")"",; ""Close ControlBar"");; bar.Show();; gROOT.SaveContext();; }. /*. */. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TControlBar.html:1582,Simpl,Simple,1582,root/html532/TControlBar.html,https://root.cern,https://root.cern/root/html532/TControlBar.html,4,['Simpl'],['Simple']
Usability,".; void Delete(const char *namecycle); The namecycle string has the format name;cycle. The next are some rules to remember:. name = * means all, but don’t remove the subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465529,simpl,simple,465529,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,".Definition TQObject.h:48; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TViewSee TView3D.Definition TView.h:25; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPad::TContext::fInteractiveBool_t fInteractiveDefinition TVirtualPad.h:62; TVirtualPad::TContext::~TContext~TContext()Destructor Restores previous value of gPad.Definition TVirtualPad.cxx:61; TVirtualPad::TContext::IsInteractiveauto IsInteractive() constDefinition TVirtualPad.h:68; TVirtualPad::TContext::fSavedTVirtualPad * fSavedDefinition TVirtualPad.h:63; TVirtualPad::TContext::PadDeletedvoid PadDeleted(TVirtualPad *pad)Inform context that pad deleted or will be deleted soon Reference on that pad should be cleared.Definition TVirtualPad.cxx:73; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::PaintFillAreaNDCvirtual void PaintFillAreaNDC(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")=0; TVirtualPad::Modifiedvirtual void Modified(Bool_t flag=1)=0; TVirtualPad::PadInHighlightModevirtual Bool_t PadInHighlightMode() constShould always return false, unless you can highlight selected object in pad.Definition TVirtualPad.cxx:156; TVirtualPad::SetTickxvirtual void SetTickx(Int_t value=1)=0; TVirtualPad::SetAttMarkerPSvirtual void SetAttMarkerPS(Color_t color, Style_t style, Size_t msize)=0; TVirtualPad::Clipvirtual Int_t Clip(Double_t *x, Double_t *y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt)=0; TVirtualPad::SetGridvirtual void SetGrid(Int_t valuex=1, Int_t valuey=1)=0; TVirtualPad::CloseToolTipvirtual void CloseTo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualPad_8h_source.html:21592,clear,cleared,21592,doc/master/TVirtualPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualPad_8h_source.html,1,['clear'],['cleared']
Usability,".Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterpreter.Declare('#include ""myLibrary.h""') # Header with the declaration of the myFilter function; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); A more thorough explanation of how to use C++ code from Python can be found in the PyROOT manual.; Python code",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:80335,simpl,simple,80335,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,".cxx. ◆ UpdateBackgroundStart(). void TGHtml::UpdateBackgroundStart ; (; ). overrideprotectedvirtual . Start background update. ; Reimplemented from TGView.; Definition at line 250 of file TGHtml.cxx. ◆ UpdateInsert(). void TGHtml::UpdateInsert ; (; ). protected . Recompute the position of the insertion cursor based on the position in fIns. ; Definition at line 2084 of file TGHtml.cxx. ◆ UpdateSelection(). void TGHtml::UpdateSelection ; (; int ; forceUpdate). protected . Given the selection end-points in fSelBegin and fSelEnd, recompute pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay() to update the display. ; This routine should be called whenever the selection changes or whenever the set of TGHtmlBlock structures change. ; Definition at line 1928 of file TGHtml.cxx. ◆ UpdateSelectionDisplay(). void TGHtml::UpdateSelectionDisplay ; (; ). protected . The fPSelStartBlock and fPSelEndBlock values have been changed. ; This routine's job is to loop over all TGHtmlBlocks and either set or clear the HTML_Selected bits in the .fFlags field as appropriate. For every TGHtmlBlock where the bit changes, mark that block for redrawing. ; Definition at line 1981 of file TGHtml.cxx. Member Data Documentation. ◆ fAddEndTags. int TGHtml::fAddEndTags. protected . Definition at line 1254 of file TGHtml.h. ◆ fAFont. TGFont* TGHtml::fAFont[71]. protected . Definition at line 1228 of file TGHtml.h. ◆ fAGcCache. GcCache_t TGHtml::fAGcCache[32]. protected . Definition at line 1242 of file TGHtml.h. ◆ fAnchorFlags. int TGHtml::fAnchorFlags. protected . Definition at line 1200 of file TGHtml.h. ◆ fAnchorStart. TGHtmlAnchor* TGHtml::fAnchorStart. protected . Definition at line 1204 of file TGHtml.h. ◆ fApColor. ColorStruct_t* TGHtml::fApColor[32]. protected . Definition at line 1232 of file TGHtml.h. ◆ fBgColor. ColorStruct_t* TGHtml::fBgColor. protected . Definition at line 1237 of file TGHtml.h. ◆ fBgImage. TImage* TGHtml::fBgImage. protected . Definition at line 1246 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:92184,clear,clear,92184,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['clear'],['clear']
Usability,".cxx. ◆ begin() [1/4]. TIterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:36716,clear,clear,36716,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['clear'],['clear']
Usability,".dat; // this file has 3 columns of float data; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/"");; dir.ReplaceAll(""/./"",""/"");; ifstream in;; in.open(Form(""%sbasic.dat"",dir.Data()));; ; Float_t x,y,z;; Int_t nlines = 0;; auto f = TFile::Open(""basic.root"",""RECREATE"");; TH1F h1(""h1"",""x distribution"",100,-4,4);; TNtuple ntuple(""ntuple"",""data from ascii file"",""x:y:z"");; ; while (1) {; in >> x >> y >> z;; if (!in.good()) break;; if (nlines < 5) printf(""x=%8f, y=%8f, z=%8f\n"",x,y,z);; h1.Fill(x);; ntuple.Fill(x,y,z);; nlines++;; }; printf("" found %d points\n"",nlines);; ; in.close();; ; f->Write();; }; f#define f(i)Definition RSha256.hxx:104; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AppendTString & Append(const char *cs)Definition TString.h:572; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file basic.C. tutorialstreebasic.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/basic_8C.html:1753,simpl,simple,1753,doc/master/basic_8C.html,https://root.cern,https://root.cern/doc/master/basic_8C.html,1,['simpl'],['simple']
Usability,".h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < 25000; i++) {; ; Long64_t tentry = t->LoadTree(i);; bvpx->GetEntry(tentry);; ; for (UInt_t j = 0; j < vpx->size(); ++j) {; ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1215,clear,clear,1215,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,".pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStructViewer.html:1137,simpl,simple,1137,root/html602/TStructViewer.html,https://root.cern,https://root.cern/root/html602/TStructViewer.html,4,['simpl'],['simple']
Usability,".py;   Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ;  ;  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ;  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ;  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ;  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ;  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ;  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ;  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ;  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ;  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ;  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1586,learn,learning,1586,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['learn'],['learning']
Usability,"/ When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $ROOTSYS/js/files/draw.htm page is used; 385/// When empty filename is specified, default page will be used; 386 ; 387void THttpServer::SetDrawPage(const std::string &filename); 388{; 389 if (!filename.empty()); 390 fDrawPage = filename;; 391 else; 392 fDrawPage = fJSROOTSYS + ""/files/draw.htm"";; 393 ; 394 // force to read page content next time again; 395 fDrawPageCont.clear();; 396}; 397 ; 398////////////////////////////////////////////////////////////////////////////////; 399/// Factory method to create different http engines; 400///; 401/// At the moment two engine kinds are supported:; 402///; 403/// * civetweb or http (default); 404/// * fastcgi; 405///; 406/// Examples:; 407///; 408/// // creates civetweb web server with http port 8080; 409/// serv->CreateEngine(""http:8080"");; 410/// serv->CreateEngine(""civetweb:8080"");; 411/// serv->CreateEngine("":",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:12447,clear,clear,12447,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['clear'],['clear']
Usability,"/ use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:28537,clear,clear,28537,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"/**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;; 239 fpTmpBinEdgeVector= nullptr;; 240 }; 241 ; 242 if ( fpTmpCoordErrorVector ); 243 {; 244 delete[] fpTmpCoordErrorVector;; 245 fpTmpCoordErrorVector = nullptr;; 246 }; 247 ; 248 fDataPtr = nullptr;; 249 fDataErrorPtr= fDataErrorHighPtr= fDataErrorLowPtr= nullptr;; 250 ; 251 fErrorType = rhs.fErrorType;; 252 fRefVolume = rhs.fRefVolume;; 253 fBinEdge = rhs.fBinEdge;; 254 ; 255 if ( fWrapped ); 256 {; 257 fData.clear();; 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:7157,clear,clear,7157,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:251663,simpl,simply,251663,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['simpl'],['simply']
Usability,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6602/// - kWithTypeDef: use the sugared type name in the calculation.; 6603///; 6604/// This is needed for backward compatibility.; 6605///; 6606/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6607/// They are both used to handle backward compatibility and should both return the same values.; 6608/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6609/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6610 ; 6611UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6612{; 6613 // fCheckSum is an atomic variable. Also once it has; 6614 // transition from a zero Value it never changes. If two; 6615 // thread reach past this if statement and calculated the; 6616 // 'kLastestCheckSum', they will by definition obtain the; 6617 // same value, so technically we could simply have:; 6618 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6619 // However save a little bit of barrier time by calling load(); 6620 // only once.; 6621 ; 6622 isvalid = kTRUE;; 6623 ; 6624 UInt_t currentChecksum = fCheckSum.load();; 6625 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6626 ; 6627 R__LOCKGUARD(gInterpreterMutex);; 6628 ; 6629 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6630 // for backward compatibility, too be able to use the inequality checks,; 6631 // we need to set the code to the largest value.; 6632 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6633 ; 6634 UInt_t id = 0;; 6635 ; 6636 int il;; 6637 TString name = GetName();; 6638 TString type;; 6639 il = name.Length();; 6640 for (int i=0; i<il; i++) id = id*3+name[i];; 6641 ; 6642 // Here we skip he base classes in case this is a pair or STL collection,; 6643 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:254414,simpl,simply,254414,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['simpl'],['simply']
Usability,"// entry is always the local entry number in the current tree.; 327/// Assuming that fChain is the pointer to the TChain being processed,; 328/// use fChain->GetTree()->GetEntry(entry);; 329 ; 330void TSelector::ProcessFill(Long64_t /*entry*/); 331{; 332 ; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// The Process() function is called for each entry in the tree (or possibly; 337/// keyed object in the case of PROOF) to be processed. The entry argument; 338/// specifies which entry in the currently loaded tree is to be processed.; 339/// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); 340/// to read either all or the required parts of the data. When processing; 341/// keyed objects with PROOF, the object is already loaded and is available; 342/// via the fObject pointer.; 343///; 344/// This function should contain the ""body"" of the analysis. It can contain; 345/// simple or elaborate selection criteria, run algorithms on the data; 346/// of the event and typically fill histograms.; 347///; 348/// The processing can be stopped by calling Abort().; 349///; 350/// Use fStatus to set the return value of TTree::Process().; 351///; 352/// The return value is currently not used.; 353///; 354/// WARNING when a selector is used with a TChain, you must use; 355/// the pointer to the current TTree to call GetEntry(entry).; 356/// The entry is always the local entry number in the current tree.; 357/// Assuming that fChain is the pointer to the TChain being processed,; 358/// use: `fChain->GetTree()->GetEntry(entry)`.; 359 ; 360bool TSelector::Process(Long64_t /*entry*/) {; 361 ; 362 return false;; 363}; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:13626,simpl,simple,13626,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['simpl'],['simple']
Usability,"// internally) for 2-fold cross validation.; //; // The split type can be ""Random"", ""RandomStratified"" or ""Deterministic"".; // For the last option, check the comment below. Random splitting randomises; // the order of events and distributes events as evenly as possible.; // RandomStratified applies the same logic but distributes events within a; // class as evenly as possible over the folds.; //; UInt_t numFolds = 2;; TString analysisType = ""Classification"";; ; TString splitType = (useRandomSplitting) ? ""Random"" : ""Deterministic"";; ; //; // One can also use a custom splitting function for producing the folds.; // The example uses a dataset spectator `eventID`.; //; // The idea here is that eventID should be an event number that is integral,; // random and independent of the data, generated only once. This last; // property ensures that if a calibration is changed the same event will; // still be assigned the same fold.; //; // This can be used to use the cross validated classifiers in application,; // a technique that can simplify statistical analysis.; //; // If you want to run TMVACrossValidationApplication, make sure you have; // run this tutorial with Deterministic splitting type, i.e.; // with the option useRandomSPlitting = false; //; ; TString splitExpr = (!useRandomSplitting) ? ""int(fabs([eventID]))%int([NumFolds])"" : """";; ; TString cvOptions = Form(""!V""; "":!Silent""; "":ModelPersistence""; "":AnalysisType=%s""; "":SplitType=%s""; "":NumFolds=%i""; "":SplitExpr=%s"",; analysisType.Data(), splitType.Data(), numFolds,; splitExpr.Data());; ; TMVA::CrossValidation cv{""TMVACrossValidation"", dataloader, outputFile, cvOptions};; ; // --------------------------------------------------------------------------; ; //; // Books a method to use for evaluation; //; cv.BookMethod(TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=100:MinNodeSize=2.5%:BoostType=Grad""; "":NegWeightTreatment=Pray:Shrinkage=0.10:nCuts=20""; "":MaxDepth=2"");; ; cv.BookMethod(TMVA::Types::kFisher, ""Fisher"",; ""!H:!V:Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:23117,simpl,simplify,23117,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['simpl'],['simplify']
Usability,"/// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 72",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:24480,clear,clear,24480,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,6,['clear'],['clear']
Usability,"/// ~~~; 1194 ///; 1195 /// \sa This Vary() overload for more information.; 1196 RInterface<Proxied, DS_t> Vary(const std::vector<std::string> &colNames, std::string_view expression,; 1197 const std::vector<std::string> &variationTags, std::string_view variationName); 1198 {; 1199 return JittedVaryImpl(colNames, expression, variationTags, variationName, /*isSingleColumn=*/false);; 1200 }; 1201 ; 1202 ////////////////////////////////////////////////////////////////////////////; 1203 /// \brief Allow to refer to a column with a different name.; 1204 /// \param[in] alias name of the column alias; 1205 /// \param[in] columnName of the column to be aliased; 1206 /// \return the first node of the computation graph for which the alias is available.; 1207 ///; 1208 /// Aliasing an alias is supported.; 1209 ///; 1210 /// ### Example usage:; 1211 /// ~~~{.cpp}; 1212 /// auto df_with_alias = df.Alias(""simple_name"", ""very_long&complex_name!!!"");; 1213 /// ~~~; 1214 RInterface<Proxied, DS_t> Alias(std::string_view alias, std::string_view columnName); 1215 {; 1216 // The symmetry with Define is clear. We want to:; 1217 // - Create globally the alias and return this very node, unchanged; 1218 // - Make aliases accessible based on chains and not globally; 1219 ; 1220 // Helper to find out if a name is a column; 1221 auto &dsColumnNames = fDataSource ? fDataSource->GetColumnNames() : ColumnNames_t{};; 1222 ; 1223 constexpr auto where = ""Alias"";; 1224 RDFInternal::CheckValidCppVarName(alias, where);; 1225 // If the alias name is a column name, there is a problem; 1226 RDFInternal::CheckForRedefinition(where, alias, fColRegister, fLoopManager->GetBranchNames(), dsColumnNames);; 1227 ; 1228 const auto validColumnName = GetValidatedColumnNames(1, {std::string(columnName)})[0];; 1229 ; 1230 RDFInternal::RColumnRegister newCols(fColRegister);; 1231 newCols.AddAlias(alias, validColumnName);; 1232 ; 1233 RInterface<Proxied, DS_t> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:66462,clear,clear,66462,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['clear'],['clear']
Usability,///////////////////////////////////////////////////////////////////////////; 2870/// Destructor.; 2871 ; 2872TGeoVolumeAssembly::ThreadData_t::~ThreadData_t() {}; 2873 ; 2874////////////////////////////////////////////////////////////////////////////////; 2875 ; 2876TGeoVolumeAssembly::ThreadData_t &TGeoVolumeAssembly::GetThreadData() const; 2877{; 2878 Int_t tid = TGeoManager::ThreadId();; 2879 return *fThreadData[tid];; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883 ; 2884void TGeoVolumeAssembly::ClearThreadData() const; 2885{; 2886 std::lock_guard<std::mutex> guard(fMutex);; 2887 TGeoVolume::ClearThreadData();; 2888 std::vector<ThreadData_t *>::iterator i = fThreadData.begin();; 2889 while (i != fThreadData.end()) {; 2890 delete *i;; 2891 ++i;; 2892 }; 2893 fThreadData.clear();; 2894 fThreadSize = 0;; 2895}; 2896 ; 2897////////////////////////////////////////////////////////////////////////////////; 2898 ; 2899void TGeoVolumeAssembly::CreateThreadData(Int_t nthreads); 2900{; 2901 std::lock_guard<std::mutex> guard(fMutex);; 2902 // Create assembly thread data here; 2903 fThreadData.resize(nthreads);; 2904 fThreadSize = nthreads;; 2905 for (Int_t tid = 0; tid < nthreads; tid++) {; 2906 if (fThreadData[tid] == nullptr) {; 2907 fThreadData[tid] = new ThreadData_t;; 2908 }; 2909 }; 2910 TGeoVolume::CreateThreadData(nthreads);; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914 ; 2915Int_t TGeoVolumeAssembly::GetCurrentNodeIndex() const; 2916{; 2917 return fThreadData[TGeoManager::ThreadId()]->fCurrent;; 2918}; 2919 ; 2920////////////////////////////////////////////////////////////////////////////////; 2921 ; 2922Int_t TGeoVolumeAssembly::GetNextNodeIndex() const; 2923{; 2924 return fThreadData[TGeoManager::ThreadId()]->fNext;; 2925}; 2926 ; 2927////////////////////////////////////////////////////////////////////////////////; 2928 ; 2929void TGeoVolumeAssembl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:104681,clear,clear,104681,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['clear'],['clear']
Usability,"////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11377,clear,clearValueAndShapeDirty,11377,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:33605,simpl,simply,33605,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['simpl'],['simply']
Usability,"////////////////////////////////////////////////////////////////; 1355/// Collect all information required to draw geometry on the client; 1356/// This includes list of each visible nodes, meshes and matrixes; 1357 ; 1358void RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41946,clear,clear,41946,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"///////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else {; 1053 Warning(""OpenForumTopic"", ""cannot find \""%s\"" as type for a Forum topic\n""; 1054 ""Available types are 'bug'."", type.Data());; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:39223,clear,clear,39223,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['clear'],['clear']
Usability,"////////////////////////////////////////////////////////////; 23 ; 24#ifndef TMVA_NEURAL_NET; 25#define TMVA_NEURAL_NET; 26#pragma once; 27 ; 28#include <vector>; 29#include <iostream>; 30#include <algorithm>; 31#include <iterator>; 32#include <functional>; 33#include <tuple>; 34#include <cmath>; 35#include <cassert>; 36#include <random>; 37#include <thread>; 38#include <future>; 39#include <type_traits>; 40#include <string>; 41#include <utility>; 42 ; 43#include ""Pattern.h""; 44#include ""Monitoring.h""; 45 ; 46#include ""TApplication.h""; 47#include ""Timer.h""; 48 ; 49#include ""TH1F.h""; 50#include ""TH2F.h""; 51 ; 52#include <fenv.h> // turn on or off exceptions for NaN and other numeric exceptions; 53 ; 54 ; 55namespace TMVA; 56{; 57 ; 58 class IPythonInteractive;; 59 ; 60 namespace DNN; 61 {; 62 ; 63 // double gaussDoubl (edouble mean, double sigma);; 64 ; 65 ; 66 ; 67 double gaussDouble (double mean, double sigma);; 68 double uniformDouble (double minValue, double maxValue);; 69 int randomInt (int maxValue);; 70 ; 71 ; 72 ; 73 ; 74 class MeanVariance; 75 {; 76 public:; 77 MeanVariance(); 78 : m_n(0); 79 , m_sumWeights(0); 80 , m_mean(0); 81 , m_squared(0); 82 {}; 83 ; 84 inline void clear(); 85 {; 86 m_n = 0;; 87 m_sumWeights = 0;; 88 m_mean = 0;; 89 m_squared = 0;; 90 }; 91 ; 92 template <typename T>; 93 inline void add(T value, double weight = 1.0); 94 {; 95 ++m_n; // a value has been added; 96 ; 97 if (m_n == 1) // initialization; 98 {; 99 m_mean = value;; 100 m_squared = 0.0;; 101 m_sumWeights = weight;; 102 return;; 103 }; 104 ; 105 double tmpWeight = m_sumWeights+weight;; 106 double Q = value - m_mean;; 107 ; 108 double R = Q*weight/tmpWeight;; 109 m_mean += R;; 110 m_squared += m_sumWeights*R*Q;; 111 ; 112 m_sumWeights = tmpWeight;; 113 }; 114 ; 115 template <typename ITERATOR>; 116 inline void add (ITERATOR itBegin, ITERATOR itEnd); 117 {; 118 for (ITERATOR it = itBegin; it != itEnd; ++it); 119 add (*it);; 120 }; 121 ; 122 ; 123 ; 124 inline int count() const {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:1834,clear,clear,1834,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"/////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json); 1412{; 1413 TLockGuard lock(fMutex);; 1414 ; 1415 hjson.clear();; 1416 json.clear();; 1417 ; 1418 if (find.empty()) {; 1419 hjson = ""FOUND:RESET"";; 1420 return 0;; 1421 }; 1422 ; 1423 std::vector<int> nodescnt(fDesc.size(), 0), viscnt(fDesc.size(), 0);; 1424 ; 1425 int nmatches = 0;; 1426 std::string test = find;; 1427 int kind = 0;; 1428 if (test.compare(0, 2, ""c:"") == 0) {; 1429 test.erase(0, 2);; 1430 kind = 1;; 1431 } else if (test.compare(0, 2, ""m:"") == 0) {; 1432 test.erase(0, 2);; 1433 kind = 2;; 1434 }; 1435 ; 1436 TRegexp regexp(test.c_str());; 1437 ; 1438 auto match_func = [&regexp, kind](RGeomNode &node) {; 1439 return (node.vol > 0) && (TString(node.GetArg(kind)).Index(regexp) >= 0);; 1440 };; 1441 ; 1442 // first count how many times each individual node appears; 1443 ScanNodes(false, 0,; 1444 [&nodescnt, &viscnt, &match_func, &nmatches](RGeomNode &node, std::vector<int> &, bool is_vis, int) {; 1445 if (match_func(node)) {; 1446 nmatches++;; 1447 nodescnt[node.id]++;; 1448 if (is_vis); 1449 viscnt[node.id]++;; 1450 };; 1451 return true;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:43015,clear,clear,43015,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"////////////////////////////////////////; 885/// Check if specified checksum string is correct and build checksum vector.; 886 ; 887Bool_t TSchemaRule::ProcessChecksum( const TString& checksum ) const; 888{; 889 //---------------------------------------------------------------------------; 890 // Check if we have valid list; 891 /////////////////////////////////////////////////////////////////////////////; 892 ; 893 if (!checksum[0]); 894 return kFALSE;; 895 std::string chk = (const char*)checksum;; 896 if( chk[0] != '[' || chk[chk.size()-1] != ']' ); 897 return kFALSE;; 898 ; 899 std::list<std::string> checksums;; 900 Internal::TSchemaRuleProcessor::SplitList( chk.substr( 1, chk.size()-2), checksums );; 901 ; 902 if( checksums.empty() ) {; 903 delete fChecksumVect;; 904 fChecksumVect = nullptr;; 905 return kFALSE;; 906 }; 907 ; 908 if( !fChecksumVect ); 909 fChecksumVect = new std::vector<UInt_t>;; 910 fChecksumVect->clear();; 911 ; 912 //---------------------------------------------------------------------------; 913 // Check the validity of each list element; 914 /////////////////////////////////////////////////////////////////////////////; 915 ; 916 for( const auto& checksumStr : checksums ) {; 917 auto chksum = ParseChecksum( checksumStr.c_str() );; 918 if (chksum == 0u) {; 919 delete fChecksumVect;; 920 fChecksumVect = nullptr;; 921 return kFALSE;; 922 }; 923 ; 924 fChecksumVect->push_back( chksum );; 925 }; 926 return kTRUE;; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Parse the checksum in the given string. Returns either the checksum or zero; 931/// if the string is not a hex or decimal number.; 932 ; 933UInt_t TSchemaRule::ParseChecksum(const char* checksum) const {; 934 std::istringstream converter(checksum);; 935 UInt_t chksum;; 936 converter >> std::hex >> chksum;; 937 if (converter.fail()) {; 938 converter.clear();; 939 converter.seekg(0);; 940 converter >> std::dec >> chksum;; 941 }; 942 ; 943",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:29653,clear,clear,29653,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['clear'],['clear']
Usability,"//////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105557,clear,clear,105557,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"////////////////////////////////////; 1619/// Creates stack for given array of ids, first element always should be 0; 1620 ; 1621std::vector<int> RGeomDescription::MakeStackByIds(const std::vector<int> &ids); 1622{; 1623 TLockGuard lock(fMutex);; 1624 ; 1625 std::vector<int> stack;; 1626 ; 1627 if (ids.empty()); 1628 return stack;; 1629 ; 1630 if (ids[0] != 0) {; 1631 printf(""Wrong first id\n"");; 1632 return stack;; 1633 }; 1634 ; 1635 int nodeid = 0;; 1636 ; 1637 for (unsigned k = 1; k < ids.size(); ++k) {; 1638 ; 1639 int prntid = nodeid;; 1640 nodeid = ids[k];; 1641 ; 1642 if (nodeid >= (int)fDesc.size()) {; 1643 printf(""Wrong node id %d\n"", nodeid);; 1644 stack.clear();; 1645 return stack;; 1646 }; 1647 auto &chlds = fDesc[prntid].chlds;; 1648 auto pos = std::find(chlds.begin(), chlds.end(), nodeid);; 1649 if (pos == chlds.end()) {; 1650 printf(""Wrong id %d not a child of %d - fail to find stack num %d\n"", nodeid, prntid, (int)chlds.size());; 1651 stack.clear();; 1652 return stack;; 1653 }; 1654 ; 1655 stack.emplace_back(std::distance(chlds.begin(), pos));; 1656 }; 1657 ; 1658 return stack;; 1659}; 1660 ; 1661/////////////////////////////////////////////////////////////////////////////////; 1662/// Produce stack based on string path; 1663/// Used to highlight geo volumes by browser hover event; 1664 ; 1665std::vector<int> RGeomDescription::MakeStackByPath(const std::vector<std::string> &path); 1666{; 1667 TLockGuard lock(fMutex);; 1668 ; 1669 std::vector<int> res;; 1670 ; 1671 RGeomBrowserIter iter(*this);; 1672 ; 1673 if (iter.Navigate(path)); 1674 res = MakeStackByIds(iter.CurrentIds());; 1675 ; 1676 return res;; 1677}; 1678 ; 1679/////////////////////////////////////////////////////////////////////////////////; 1680/// Produce list of node ids for given stack; 1681/// If found nodes preselected - use their ids; 1682 ; 1683std::vector<int> RGeomDescription::MakeIdsByStack(const std::vector<int> &stack); 1684{; 1685 TLockGuard lock(fMutex);; 1686 ; 1687 std::ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:50227,clear,clear,50227,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"//////////////////////////////////; 472/// Set the target class of this rule (i.e. the in memory class).; 473 ; 474void TSchemaRule::SetTargetClass( const TString& classname ); 475{; 476 std::string normalizedName;; 477 TClassEdit::GetNormalizedName(normalizedName, classname);; 478 fTargetClass = normalizedName;; 479}; 480 ; 481////////////////////////////////////////////////////////////////////////////////; 482/// Get the targte class of this rule (i.e. the in memory class).; 483 ; 484const char *TSchemaRule::GetTargetClass() const; 485{; 486 return fTargetClass;; 487}; 488 ; 489////////////////////////////////////////////////////////////////////////////////; 490/// Set the target member of this rule (i.e. the in memory data member).; 491 ; 492void TSchemaRule::SetTarget( const TString& target ); 493{; 494 fTarget = target;; 495 ; 496 if( target == """" ) {; 497 delete fTargetVect;; 498 fTargetVect = nullptr;; 499 return;; 500 }; 501 ; 502 if( !fTargetVect ) {; 503 fTargetVect = new TObjArray();; 504 fTargetVect->SetOwner();; 505 }; 506 ProcessList( fTargetVect, target );; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Get the target data members of this rule as a simple string (i.e. the in memory data member).; 511 ; 512const char *TSchemaRule::GetTargetString() const; 513{; 514 return fTarget;; 515}; 516 ; 517////////////////////////////////////////////////////////////////////////////////; 518/// Get the target data members of this rule (i.e. the in memory data member).; 519 ; 520const TObjArray* TSchemaRule::GetTarget() const; 521{; 522 if( fTarget == """" ); 523 return nullptr;; 524 ; 525 if( !fTargetVect ) {; 526 fTargetVect = new TObjArray();; 527 fTargetVect->SetOwner();; 528 ProcessList( fTargetVect, fTarget );; 529 }; 530 ; 531 return fTargetVect;; 532}; 533 ; 534////////////////////////////////////////////////////////////////////////////////; 535/// Set the list of source members. This should be in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:16560,simpl,simple,16560,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['simpl'],['simple']
Usability,"////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histogram is drawn in a pad, then filled again, the new status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; 3059/// TH1::UseCurrentStyle can be used to change all histogram graphics; 3060/// attributes to correspond to the current selected style.; 3061/// This function must be called for each histogram.; 3062/// In case one reads and draws many histograms from a file, one can force; 3063/// the histograms to inherit automatically the current graphics style; 3064/// by calling before gROOT->ForceStyle();; 3065///; 3066/// See the THistPainter class for a description of all the drawing options.; 3067 ; 3068void TH1::Draw(Option_t *option); 3069{; 3070 TString opt1 = option; opt1.ToLower();; 3071 TString opt2 = option;; 3072 Int_t index = opt1.Index(""same"");; 3073 ; 3074 // Check if the string ""same"" is part of a TCutg name.; 3075 if (index>=0) {; 3076 Int_t indb = opt1.Index(""["");; 3077 if (indb>=0) {; 307",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:121554,clear,clears,121554,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['clear'],['clears']
Usability,"////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^= ctxt[i] << (i * 8);; 875 }; 876 }; 877 }; 878 return ret;; 879 }; 880}; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Returns false if strings are not equal.; 884 ; 885static int MemIsEqual(const char *p, const char *q, Ssiz_t n); 886{; 887 while (n--); 888 {; 889 if (tolower((unsigned char)*p) != tolower((unsigned char)*q)); 890 return kFALSE;; 891 p++; q++;; 892 }; 893 return kTRUE;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Search for a string in the TString. Plen is the length of pattern,; 898/// startIndex is the index from which to start and cmp selects the type; 899/// of case-comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:25941,simpl,simple,25941,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['simpl'],['simple']
Usability,"//////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below at each point:; 2090///; 2091/// (y - f(x))**2; 2092/// -----------------------------------; 2093/// ey**2 + (0.5*(exl + exh)*f'(x))**2; 2094///; 2095/// where x and y are the point coordinates and f'(x) is the derivative of function f(x).; 2096/// This method to approximate the uncertainty in y because of the errors in x, is called; 2097/// ""effective variance"" method.; 2098/// The improvement, compared to the previously used method (f(x+ exhigh) - f(x-exlow))/2; 2099/// is of (error of x)**2 order.; 2100///; 2101/// NOTE:; 2102///; 2103/// 1. By using the ""effective variance"" method a simple linear regression; 2104/// becomes a non-linear case , which takes several iterations; 2105/// instead of 0 as in the linear case .; 2106///; 2107/// 2. The effective variance technique assumes that there is no correlation; 2108/// between the x and y coordinate .; 2109///; 2110/// In case the function lies below (above) the data point, ey is ey_low (ey_high).; 2111 ; 2112void GraphFitChisquareFumili(Int_t &npar, Double_t * gin, Double_t &f,; 2113 Double_t *u, Int_t flag); 2114{; 2115 Double_t cu,eu,exl,exh,ey,eux,fu,fsum;; 2116 Double_t x[1];; 2117 Int_t i, bin, npfits=0;; 2118 ; 2119 TFumili *grFitter = (TFumili*)TVirtualFitter::GetFitter();; 2120 TGraph *gr = (TGraph*)grFitter->GetObjectFit();; 2121 TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 2122 Foption_t fitOption = grFitter->GetFitOption();; 2123 ; 2124 Int_t n = gr->GetN();; 2125 Double_t *gx = gr->GetX();; 2126 Double_t *gy = gr->GetY();; 2127 npar = f1->GetNpar();; 2128 ; 2129 grFitter->SetParNumber(npar);; 2130 ; 2131 if(flag == 9) return;; 2132 Double_t *zik = grFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:62080,simpl,simple,62080,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['simpl'],['simple']
Usability,"///////////////////////////; 5575/// Translate the arguments of genreflex into rootcling ones and forward them; 5576/// to the RootCling function.; 5577/// These are two typical genreflex and rootcling commandlines; 5578/// 1) genreflex header1.h [header2.h ...] [options] [preprocessor options]; 5579/// 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename]; 5580/// header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}]; 5581/// The rules with which the arguments are translated are (1st column genreflex):; 5582/// --debug -v4; 5583/// --quiet -v0; 5584/// -o ofile positional arg after -f; 5585/// -s selection file Last argument of the call; 5586/// --fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; 5587///; 5588/// New arguments:; 5589/// -l --library targetLib name (new) -s targetLib name; 5590/// -m pcmname (can be many -m) (new) -m pcmname (can be many -m); 5591/// --rootmap -rmf (new); 5592/// --rootmap-lib -rml (new); 5593///; 5594/// genreflex options which rise warnings (feedback is desirable); 5595/// --no_membertypedefs (it should be irrelevant); 5596/// --no_templatetypedefs (it should be irrelevant); 5597///; 5598/// genreflex options which are ignored (know for sure they are not needed); 5599/// --pool, --dataonly; 5600/// --interpreteronly; 5601/// --gccxml{path,opt,post}; 5602///; 5603///; 5604/// Exceptions; 5605/// The --deep option of genreflex is passed as function parameter to rootcling; 5606/// since it's not needed at the moment there.; 5607 ; 5608int GenReflexMain(int argc, char **argv); 5609{; 5610 using namespace genreflex;; 5611 ; 5612 // Setup the options parser; 5613 enum optionIndex { UNKNOWN,; 5614 PRINTROOTCLINGINVOCATION,; 5615 OFILENAME,; 5616 TARGETLIB,; 5617 MULTIDICT,; 5618 NOGLOBALUSINGSTD,; 5619 SELECTIONFILENAME,; 5620 ROOTMAP,; 5621 ROOTMAPLIB,; 5622 PCMFILENAME,; 5623 DEEP,; 5624 DEBUG,; 5625 VERBOSE,; 5626 QUIET,; 5627 SILENT,; 5628 CXXMODULE,; 5629 WRITEEMPTYROOTPC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:224098,feedback,feedback,224098,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['feedback'],['feedback']
Usability,"//////////////////////////; 1035/// Stream an object of class TQObject.; 1036 ; 1037void TQObject::Streamer(TBuffer &R__b); 1038{; 1039 if (R__b.IsReading()) {; 1040 // nothing to read; 1041 } else {; 1042 // nothing to write; 1043 }; 1044}; 1045 ; 1046////////////////////////////////////////////////////////////////////////////////; 1047/// Returns true if all signals are blocked.; 1048 ; 1049Bool_t TQObject::AreAllSignalsBlocked(); 1050{; 1051 return fgAllSignalsBlocked;; 1052}; 1053 ; 1054////////////////////////////////////////////////////////////////////////////////; 1055/// Block or unblock all signals. Returns the previous block status.; 1056 ; 1057Bool_t TQObject::BlockAllSignals(Bool_t b); 1058{; 1059 Bool_t ret = fgAllSignalsBlocked;; 1060 fgAllSignalsBlocked = b;; 1061 return ret;; 1062}; 1063 ; 1064////////////////////////////////////////////////////////////////////////////////; 1065/// Global function which simplifies making connection in interpreted ROOT session; 1066///; 1067/// ConnectCINT - connects to interpreter(CINT) command; 1068 ; 1069Bool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot); 1070{; 1071 TString str = ""ProcessLine(="";; 1072 str += '""';; 1073 str += slot;; 1074 str += '""';; 1075 str += "")"";; 1076 return TQObject::Connect(sender, signal, ""TInterpreter"",; 1077 gInterpreter, str.Data());; 1078}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; RQ_OBJECT.h; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBaseClass.h; TBuffer.h; TClass.h; TDataType.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:34942,simpl,simplifies,34942,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['simpl'],['simplifies']
Usability,"/////////////////////////; 744/// Return a new TObjOptLink (a TObjLink that also stores the option).; 745 ; 746TList::TObjLinkPtr_t TList::NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:23787,clear,cleared,23787,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['clear'],['cleared']
Usability,"///////////////////////; 18// //; 19// TTreeReader //; 20// //; 21// A simple interface for reading trees or chains. //; 22// //; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TTree.h""; 27#include ""TTreeReaderUtils.h""; 28#include ""TNotifyLink.h""; 29 ; 30#include <deque>; 31#include <iterator>; 32#include <unordered_map>; 33#include <string>; 34 ; 35class TDictionary;; 36class TDirectory;; 37class TFileCollection;; 38 ; 39namespace ROOT {; 40namespace Internal {; 41 class TBranchProxyDirector;; 42 class TFriendProxy;; 43}; 44}; 45 ; 46class TTreeReader: public TObject {; 47public:; 48 ; 49 ///\class TTreeReader::Iterator_t; 50 /// Iterate through the entries of a TTree.; 51 ///; 52 /// This iterator drives the associated TTreeReader; its; 53 /// dereferencing (and actually even the iteration) will; 54 /// set the entry number represented by this iterator.; 55 /// It does not really represent a data element; it simply; 56 /// returns the entry number (or -1 once the end of the tree; 57 /// is reached).; 58 class Iterator_t {; 59 private:; 60 Long64_t fEntry; ///< Entry number of the tree referenced by this iterator; -1 is invalid.; 61 TTreeReader* fReader; ///< The reader we select the entries on.; 62 ; 63 /// Whether the iterator points to a valid entry.; 64 bool IsValid() const { return fEntry >= 0; }; 65 ; 66 public:; 67 using iterator_category = std::input_iterator_tag;; 68 using value_type = const Long64_t;; 69 using difference_type = Long64_t;; 70 using pointer = const Long64_t *;; 71 using const_pointer = const Long64_t *;; 72 using reference = const Long64_t &;; 73 ; 74 /// Default-initialize the iterator as ""past the end"".; 75 Iterator_t(): fEntry(-1), fReader(nullptr) {}; 76 ; 77 /// Initialize the iterator with the reader it steers and a; 78 /// tree entry number; -1 is invalid.; 79 Iterator_t(TTreeReader& reader, Long64_t entry):; 80 fEntry(entry), fReader(&reader) {}; 81 ; 82 /// Compare two itera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:1789,simpl,simply,1789,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['simpl'],['simply']
Usability,"///////////////////; 3218 ; 3219void ExtractHeadersForDecls(const RScanner::ClassColl_t &annotatedRcds,; 3220 const RScanner::TypedefColl_t tDefDecls,; 3221 const RScanner::FunctionColl_t funcDecls,; 3222 const RScanner::VariableColl_t varDecls,; 3223 const RScanner::EnumColl_t enumDecls,; 3224 HeadersDeclsMap_t &headersClassesMap,; 3225 HeadersDeclsMap_t &headersDeclsMap,; 3226 const cling::Interpreter &interp); 3227{; 3228 std::set<const clang::CXXRecordDecl *> visitedDecls;; 3229 std::unordered_set<std::string> buffer;; 3230 std::string autoParseKey;; 3231 ; 3232 // Add some manip of headers; 3233 for (auto & annotatedRcd : annotatedRcds) {; 3234 if (const clang::CXXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:128705,clear,clear,128705,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"////////////////; 1157/// Copy material properties; 1158 ; 1159void RGeomDescription::CopyMaterialProperties(TGeoVolume *volume, RGeomNode &node); 1160{; 1161 if (!volume); 1162 return;; 1163 ; 1164 TColor *col = nullptr;; 1165 ; 1166 if ((volume->GetFillColor() > 1) && (volume->GetLineColor() == 1)); 1167 col = gROOT->GetColor(volume->GetFillColor());; 1168 else if (volume->GetLineColor() >= 0); 1169 col = gROOT->GetColor(volume->GetLineColor());; 1170 ; 1171 if (volume->GetMedium() && (volume->GetMedium() != TGeoVolume::DummyMedium()) &&; 1172 volume->GetMedium()->GetMaterial()) {; 1173 auto material = volume->GetMedium()->GetMaterial();; 1174 ; 1175 node.material = material->GetName();; 1176 ; 1177 auto fillstyle = material->GetFillStyle();; 1178 if ((fillstyle >= 3000) && (fillstyle <= 3100)); 1179 node.opacity = (3100 - fillstyle) / 100.;; 1180 if (!col); 1181 col = gROOT->GetColor(material->GetFillColor());; 1182 } else {; 1183 node.material.clear();; 1184 }; 1185 ; 1186 if (col) {; 1187 TString colbuf;; 1188 colbuf.Form(""#%02x%02x%02x"", (int)(col->GetRed() * 255), (int)(col->GetGreen() * 255),; 1189 (int)(col->GetBlue() * 255));; 1190 node.color = colbuf.Data();; 1191 if (node.opacity == 1.); 1192 node.opacity = col->GetAlpha();; 1193 } else {; 1194 node.color.clear();; 1195 }; 1196}; 1197 ; 1198/////////////////////////////////////////////////////////////////////; 1199/// Reset shape info, which used to pack binary data; 1200 ; 1201void RGeomDescription::ResetRndrInfos(); 1202{; 1203 for (auto &s : fShapes); 1204 s.reset();; 1205}; 1206 ; 1207/////////////////////////////////////////////////////////////////////; 1208/// Produce JSON string which can be directly used with `build`; 1209/// function from JSROOT to create three.js model of configured geometry; 1210///; 1211/// Collect all information required to draw geometry on the client; 1212/// This includes list of each visible nodes, meshes and matrixes; 1213/// If @param all_nodes is true, all existing no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:35653,clear,clear,35653,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json); 1412{; 1413 TLockGuard lock(fMutex);; 1414 ; 1415 hjson.clear();; 1416 json.clear();; 1417 ; 1418 if (find.empty()) {; 1419 hjson = ""FOUND:RESET"";; 1420 return 0;; 1421 }; 1422 ; 1423 std::vector<int> nodescnt(fDesc.size(), 0), viscnt(fDesc.size(), 0);; 1424 ; 1425 int nmatches = 0;; 1426 std::string test = find;; 1427 int kind = 0;; 1428 if (test.compare(0, 2, ""c:"") == 0) {; 1429 test.erase(0, 2);; 1430 kind = 1;; 1431 } else if (test.compare(0, 2, ""m:"") == 0) {; 1432 test.erase(0, 2);; 1433 kind = 2;; 1434 }; 1435 ; 1436 TRegexp regexp(test.c_str());; 1437 ; 1438 auto match_func = [&regexp, kind](RGeomNode &node) {; 1439 return (node.vol > 0) && (TString(node.GetArg(kind)).Index(regexp) >= 0);; 1440 };; 1441 ; 1442 // first count how many times each individual node appears; 1443 ScanNodes(false, 0,; 1444 [&nodescnt, &viscnt, &match_func, &nmatches](RGeomNode &node, std::vector<int> &, bool is_vis, int) {; 1445 if (match_func(node)) {; 1446 nmatches++;; 1447 nodescnt[node.id]++;; 1448 if (is_vis); 1449 viscnt[node.id]++;; 1450 };; 1451 return true;; 1452 });; 1453 ; 1454 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:43035,clear,clear,43035,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"///; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 }; 515 } while ((snode = iter()) != nullptr);; 516 ; 517 fDesc.reserve(fNodes.size());; 518 fSortMap.reserve(fNodes.size());; 519 ; 520 // array for sorting; 521 std::vector<RGeomNode *> sortarr;; 522 sortarr.reserve(fNodes.size());; 523 ; 524 // create vector of desc and childs; 525 int cnt = 0;; 526 for (auto node : fNodes) {; 527 ; 528 fDesc.emplace_back(node ? node->GetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12642,clear,clear,12642,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"/EventSelector.C; Preparation; Now quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. Processing a Selector on a Tree; To apply this selector on the tree you do not call the selector directly; instead, the selector is passed to the tree which then runs it (see the documentation of TTree::Process()):; root[1] EventTree->Process(""EventSelector.C""). As you can see, nothing happens because our selector is empty. So lets see what we can do with this selector.; Editing the Selector Skeleton; Open the downloaded selector file (EventSelector.C) in a text editor, e.g. with vi, emacs, wordpad, Eclipse... At the beginning of the file is the EventSelector class definition with the data members declaration etc. This is the place where to add new member definitions, e.g. TH1 *fMyHist;. Then come the function implementations.; Creating a Data Member; Lets start with something simple: count the number of events in our tree. To do so, we need to create a data member of type int or Int_t, to store (increment) the event number. Lets call it fNumberOfEvents. Add its declaration in the class definition, and initialize it to 0 in the constructor:; class EventSelector : public TSelector {; public :; // Variables used to store the data; Int_t fNumberOfEvents; // Total number of events. EventSelector(TTree * = 0): fNumberOfEvents(0) { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... The code : fNumberOfEvents(0) after the constructor is another way of initializing a data member. Then we have to count the total number of entries (events in our case) in the tree. This has to be done in TSelector::Process(Long64_t entry). We will print also the current entry number, to see what's happening:; Bool_t EventSelector::Process(Long64_t entry); {; // ... // print some information about the current entry; printf(""Processing Entry number %ld\n"", entry);; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:3532,simpl,simple,3532,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['simpl'],['simple']
Usability,"/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in the constructor or set later with the method SetWeight() of the class TMultiLayerPerceptron. Two datasets must be defined before learning the network: a training dataset that is used when minimizing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “graph” (evaluating graphical training curves), “update = X” (step for the text/graph output update) or “+” (will skip the randomization and start from the previous values). All combinations are available.; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:236581,learn,learning,236581,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learning']
Usability,"/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQCommand(). TQCommand::~TQCommand ; (; ). virtual . dtor. ; Definition at line 249 of file TQCommand.cxx. Member Function Documentation. ◆ Add() [1/2]. void TQCommand::Add ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 91 of file TQCommand.h. ◆ Add() [2/2]. void TQCommand::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add command to the list of merged commands. ; Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 360 of file TQCommand.cxx. ◆ CanCompress(). Bool_t TQCommand::CanCompress ; (; TQCommand * ; c); const. virtual . By default, commands can be compressed if they are: . equal; setter commands. More complicated commands might want to override this function. ; Definition at line 387 of file TQCommand.cxx. ◆ CanMerge(). Bool_t TQCommand::CanMerge ; (; TQCommand * ; c); const. virtual . Two commands can be merged if they can be composed into a single command (Macro command). ; To allow merging commands user might override this function. ; Definition at line 314 of file TQCommand.cxx. ◆ CanRedo(). Bool_t TQCommand::CanRedo ; (; ); const. virtual . Returns kTRUE if Redo action is possible, kFALSE if it's not. ; By default, only single sequential redo action is possible. ; Reimplemented in TQUndoManager.; Definition at line 57",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:33990,undo,undo,33990,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"/somefile.root"");. You can list the objects inside the file using .ls:; root [1] .ls; TFile** hsimple.root Demo ROOT file with histograms; TFile* hsimple.root Demo ROOT file with histograms; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple. You can access objects inside the files by their names, either by using this name as a variable on the prompt:; root [2] hpx->Draw();. In regular code you should use TFile::GetObject():; root [3] TH1* readThis = 0;; root [4] file->GetObject(""hpx"", readThis);. Now let's try this out: get the TTree called ""MyTree"" from a file located at http://root.cern.ch/root/files/tutorials/mockupx.root Note that you don't need to download it with your browser: you just specify the http:// location as an argument to TFile::Open(). Once you have the TTree object, call Print() on it to see its structure.; . ‹ 0. Setting up ROOT; up; 2. Running code in ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/1-extracting-object-tfile.html:3621,guid,guidelines,3621,d/1-extracting-object-tfile.html,https://root.cern,https://root.cern/d/1-extracting-object-tfile.html,1,['guid'],['guidelines']
Usability,"0 ; 4891 std::string scopename(demangled_name_c);; 4892 free(demangled_name_c);; 4893 ; 4894 //; 4895 // Separate out the class or namespace part of the; 4896 // function name.; 4897 //; 4898 std::string dataname;; 4899 ; 4900 if (!strncmp(scopename.c_str(), ""typeinfo for "", sizeof(""typeinfo for "")-1)) {; 4901 scopename.erase(0, sizeof(""typeinfo for "")-1);; 4902 } else if (!strncmp(scopename.c_str(), ""vtable for "", sizeof(""vtable for "")-1)) {; 4903 scopename.erase(0, sizeof(""vtable for "")-1);; 4904 } else {; 4905 // See if it is a function; 4906 std::string::size_type pos = scopename.rfind('(');; 4907 if (pos != std::string::npos) {; 4908 return nullptr;; 4909 }; 4910 // Separate the scope and member name; 4911 pos = scopename.rfind(':');; 4912 if (pos != std::string::npos) {; 4913 if ((pos != 0) && (scopename[pos-1] == ':')) {; 4914 dataname = scopename.substr(pos+1);; 4915 scopename.erase(pos-1);; 4916 }; 4917 } else {; 4918 scopename.clear();; 4919 dataname = scopename;; 4920 }; 4921 }; 4922 //fprintf(stderr, ""name: '%s'\n"", name.c_str());; 4923 // Now we have the class or namespace name, so do the lookup.; 4924 ; 4925 ; 4926 DeclId_t d;; 4927 if (scopename.size()) {; 4928 TClingClassInfo cl(GetInterpreterImpl(), scopename.c_str());; 4929 d = cl.GetDataMember(dataname.c_str());; 4930 }; 4931 else {; 4932 TClingClassInfo gcl(GetInterpreterImpl());; 4933 d = gcl.GetDataMember(dataname.c_str());; 4934 }; 4935 return d;; 4936}; 4937 ; 4938////////////////////////////////////////////////////////////////////////////////; 4939/// NOT IMPLEMENTED.; 4940 ; 4941TInterpreter::DeclId_t TCling::GetDataMemberWithValue(const void *ptrvalue) const; 4942{; 4943 Error(""GetDataMemberWithValue()"", ""not implemented"");; 4944 return nullptr;; 4945}; 4946 ; 4947////////////////////////////////////////////////////////////////////////////////; 4948/// Return pointer to cling DeclId for a data member with a given name.; 4949 ; 4950TInterpreter::DeclId_t TCling::GetDataMemberAtAddr(const vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:191307,clear,clear,191307,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"0 std::cout << ""Number of iterations = "" << iter<< std::endl;; 311 ; 312 PrintState();; 313 }; 314 }; 315 fIter = iter;; 316 fStatus = status;; 317 return (fStatus == GSL_SUCCESS);; 318 ; 319}; 320 ; 321void GSLMultiRootFinder::PrintState(std::ostream & os) {; 322 // print current state; 323 if (!fSolver) return;; 324 double ndigits = std::log10( double( Dim() ) );; 325 int wi = int(ndigits)+1;; 326 const double * xtmp = fSolver->X();; 327 const double * ftmp = fSolver->FVal();; 328 os << ""Root values = "";; 329 for (unsigned int i = 0; i< Dim(); ++i); 330 os << ""x["" << std::setw(wi) << i << ""] = "" << std::setw(12) << xtmp[i] << "" "";; 331 os << std::endl;; 332 os << ""Function values = "";; 333 for (unsigned int i = 0; i< Dim(); ++i); 334 os << ""f["" << std::setw(wi) << i << ""] = "" << std::setw(12) << ftmp[i] << "" "";; 335 os << std::endl;; 336}; 337 ; 338 ; 339 ; 340} // namespace Math; 341} // namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_INFO_MSGVAL#define MATH_INFO_MSGVAL(loc, txt, x)Definition Error.h:101; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; GSLMultiRootFinder.h; GSLMultiRootSolver.h; IFunction.h; f#define f(i)Definition RSha256.hxx:104; GSL_SUCCESS#define GSL_SUCCESSDefinition RooAdaptiveGaussKronrodIntegrator1D.cxx:379; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:12180,simpl,simply,12180,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['simpl'],['simply']
Usability,"0 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let’s think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let’s say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; 18.4.2.8 Volume Families; A volume family is represented by the class TGeoVolumeMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:950605,simpl,simple,950605,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Int_t fCount;  number of updates contributing to error field ;  ; Double_t fDEDw;  sum of deltas ;  ; Double_t fDelta;  local error field ;  ; Double_t fLearnRate;  learning rate parameter ;  ; TNeuron * fPostNeuron;  pointer to post-neuron ;  ; TNeuron * fPreNeuron;  pointer to pre-neuron ;  ; Double_t fWeight;  weight of the synapse ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSynapse.html:9942,learn,learning,9942,doc/master/classTMVA_1_1TSynapse.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSynapse.html,1,['learn'],['learning']
Usability,"0); TDecompQRH(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TDecompQRH(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompQRH.html:1419,Clear,Clear,1419,root/html532/TDecompQRH.html,https://root.cern,https://root.cern/root/html532/TDecompQRH.html,2,['Clear'],['Clear']
Usability,"0); TDecompSVD(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TDecompSVD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompSVD.html:1689,Clear,Clear,1689,root/html532/TDecompSVD.html,https://root.cern,https://root.cern/root/html532/TDecompSVD.html,2,['Clear'],['Clear']
Usability,"0); virtual voidAddWithBurnIn(RooStats::MarkovChain& otherChain, Int_t burnIn = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__MarkovChain.html:1112,Clear,Clear,1112,root/html534/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html534/RooStats__MarkovChain.html,1,['Clear'],['Clear']
Usability,"0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__MarkovChain.html:949,Clear,Clear,949,root/html532/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html532/RooStats__MarkovChain.html,1,['Clear'],['Clear']
Usability,0); virtual~TDecompBK(); voidTObject::AbstractMethod(co,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompBK.html:2214,Clear,Clear,2214,root/html532/TDecompBK.html,https://root.cern,https://root.cern/root/html532/TDecompBK.html,2,['Clear'],['Clear']
Usability,"0); virtual~TDecompChol(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompChol.html:1131,Clear,Clear,1131,root/html532/TDecompChol.html,https://root.cern,https://root.cern/root/html532/TDecompChol.html,2,['Clear'],['Clear']
Usability,"0);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,10,kBackDecreasingWindow,kBackOrder8,kTRUE,; kBackSmoothing5,,kTRUE);; for (i = 0; i < nbins; i++) d1->SetBinContent(i + 1,source[i]);; d1->SetLineColor(kRed);; d1->Draw(""SAME L"");; }. . const char* SmoothMarkov(Double_t* source, Int_t ssize, Int_t averWindow). One-dimensional markov spectrum smoothing function. This function calculates smoothed spectrum from source spectrum based on; Markov chain method. The result is placed in the array pointed by source; pointer. On successful completion it returns 0. On error it returns pointer; to the string describing error.; ; Function parameters:; ; source: pointer to the array of source spectrum; ssize: length of source array; averWindow: width of averaging smoothing window; ; The goal of this function is the suppression of the statistical fluctuations.; The algorithm is based on discrete Markov chain, which has very simple; invariant distribution:; . being defined; from the normalization condition; .; n is the length of the smoothed spectrum and; . Reference:; ; Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451.; . Example 14 - script Smoothing.c; . Fig. 23 Original noisy spectrum; . Fig. 24 Smoothed spectrum m=3; . Fig. 25 Smoothed spectrum; . Fig.26 Smoothed spectrum m=10; ; Script:; ; // Example to illustrate smoothing using Markov algorithm (class TSpectrum).; // To execute this example, do; // root > .x Smoothing.C; void Smoothing() {; Int_t i;; Double_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""Smoothed spectrum for m=3"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""smooth1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Smooth1 = gROOT->GetListOfCanvases()->FindObject(""Smooth1"");; if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:30772,simpl,simple,30772,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,4,['simpl'],['simple']
Usability,"0, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<double> datSig (numBinsData+1, 0);; 342 std::vector<double> datBkg (numBinsData+1, 0);; 343 ; 344 double binSizeROC = (maxVal - minVal)/(double)numBinsROC;; 345 double binSizeData = (maxVal - minVal)/(double)numBins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:12140,clear,clear,12140,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['clear'],['clear']
Usability,"0, Int_t implicit = 1); virtual~TDecompLU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompLU.html:1505,Clear,Clear,1505,root/html532/TDecompLU.html,https://root.cern,https://root.cern/root/html532/TDecompLU.html,2,['Clear'],['Clear']
Usability,"0, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNtuple.html:3264,undo,undo,3264,root/html532/TNtuple.html,https://root.cern,https://root.cern/root/html532/TNtuple.html,8,['undo'],['undo']
Usability,"0, const char* name = 0); virtual~RooLinTransBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_t*array() const; virtual Double_taverageBinWidth() const; virtual Double_tbinCenter(Int_t bin) const; virtual Double_tbinHigh(Int_t bin) const; virtual Double_tbinLow(Int_t bin) const; virtual Int_tbinNumber(Double_t x) const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsBinning*clone(const char* name = 0) const; virtual TObject*RooAbsBinning::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinTransBinning.html:1328,Clear,Clear,1328,root/html532/RooLinTransBinning.html,https://root.cern,https://root.cern/root/html532/RooLinTransBinning.html,2,['Clear'],['Clear']
Usability,"0,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; container1->AddNode(pvol, 1);; container2->AddNode(pvol, 1);; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the TGeoVolumeMulti class, which does not need to be instantiated by users. Dividing volumes; Volumes can be divided according a pattern. The most simple division can be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take the most simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; N#define N; TGeoVolume::Dividevirtual TGeoVolume * Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Division a la G3.Definition TGeoVolume.cxx:1103; where SLICE is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi. In fact, the division operation has the same effect as positioning volumes in a given",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:4413,simpl,simple,4413,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['simpl'],['simple']
Usability,"00 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably work - but we decided against it, and I believe that we have good reasons for that :-); GCCXML's future is limited; there is a re-write based on GCC's plugin mechanism, but both suffer from the same problems: we cannot influence what the GCC parser does. And reading headers, writing XML, parsing XML, writing (huge files of) C++, compiling, linking, loading - that's really, really inefficient and error prone.; Python is much simpler than C++. But it's still a horrible language in our environment, unless it's used as bash++. Not a single algorithm should be written in Python: it'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:16022,simpl,simplify,16022,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simplify']
Usability,"00, Int_t splitlevel=99);  Deprecated function. Use next function instead. ;  ; virtual TBranch * BranchOld (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:6773,undo,undo,6773,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,1,['undo'],['undo']
Usability,"000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeSQL.html:2802,undo,undo,2802,root/html602/TTreeSQL.html,https://root.cern,https://root.cern/root/html602/TTreeSQL.html,4,['undo'],['undo']
Usability,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df022__useKahan_8C.html:3024,simpl,simple,3024,doc/master/df022__useKahan_8C.html,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html,1,['simpl'],['simple']
Usability,"000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000. Note that the time to generate a number from an arbitrary TF1 function; using TF1::GetRandom or using TUnuran is independent of the complexity of the function. TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name). can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram; or from an existing function. Note this interesting feature when working with objects. You can use several TRandom objects, each with their ""independent""; random sequence. For example, one can imagine; TRandom *eventGenerator = new TRandom();; TRandom *tracking = new TRandom();; eventGenerator can be used to generate the event kinematics.; tracking can be used to track the generated particles with random numbers; independent from eventGenerator.; This very interesting feature gives the possibility to work with simple; and very fast random number generators without worrying about; random number periodicity as it was the case with Fortran.; One can use TRandom::SetSeed to modify the seed of one generator. a TRandom object may be written to a Root file. -as part of another object; -or with its own key (example gRandom->Write(""Random"");. Function Members (Methods); public:. TRandom(UInt_t seed = 65539); TRandom(const TRandom&); virtual~TRandom(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBinomial(Int_t ntot, Double_t prob); virtual Double_tBreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom.html:4569,simpl,simple,4569,root/html528/TRandom.html,https://root.cern,https://root.cern/root/html528/TRandom.html,6,['simpl'],['simple']
Usability,"000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000. Note that the time to generate a number from an arbitrary TF1 function; using TF1::GetRandom or using TUnuran is independent of the complexity of the function. TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name). can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram; or from an existing function. Note this interesting feature when working with objects. You can use several TRandom objects, each with their ""independent""; random sequence. For example, one can imagine; TRandom *eventGenerator = new TRandom();; TRandom *tracking = new TRandom();; eventGenerator can be used to generate the event kinematics.; tracking can be used to track the generated particles with random numbers; independent from eventGenerator.; This very interesting feature gives the possibility to work with simple; and very fast random number generators without worrying about; random number periodicity as it was the case with Fortran.; One can use TRandom::SetSeed to modify the seed of one generator. a TRandom object may be written to a Root file. -as part of another object; -or with its own key (example gRandom->Write(""Random"");. Function Members (Methods); public:. virtual~TRandom(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBinomial(Int_t ntot, Double_t prob); virtual Double_tBreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRandom.html:4593,simpl,simple,4593,root/html602/TRandom.html,https://root.cern,https://root.cern/root/html602/TRandom.html,4,['simpl'],['simple']
Usability,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:25735,simpl,simply,25735,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:25403,simpl,simply,25403,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"01); virtual~TCurlyArc(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCurlyArc.html:1186,Clear,Clear,1186,root/html532/TCurlyArc.html,https://root.cern,https://root.cern/root/html532/TCurlyArc.html,2,['Clear'],['Clear']
Usability,"01); virtual~TCurlyLine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCurlyLine.html:1194,Clear,Clear,1194,root/html534/TCurlyLine.html,https://root.cern,https://root.cern/root/html534/TCurlyLine.html,1,['Clear'],['Clear']
Usability,"01); virtual~TCurlyLine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCurlyLine.html:1175,Clear,Clear,1175,root/html532/TCurlyLine.html,https://root.cern,https://root.cern/root/html532/TCurlyLine.html,1,['Clear'],['Clear']
Usability,"01); virtual~TGeoOverlap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoOverlap.html:1020,Clear,Clear,1020,root/html532/TGeoOverlap.html,https://root.cern,https://root.cern/root/html532/TGeoOverlap.html,2,['Clear'],['Clear']
Usability,"05, Option_t* option = "">""); virtual~TArrow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& arrow) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TArrow.html:1785,Clear,Clear,1785,root/html532/TArrow.html,https://root.cern,https://root.cern/root/html532/TArrow.html,2,['Clear'],['Clear']
Usability,"06 int nodeid = 0;; 1607 ; 1608 for (auto &chindx : stack) {; 1609 auto &node = fDesc[nodeid];; 1610 if (chindx >= (int)node.chlds.size()); 1611 return -1;; 1612 nodeid = node.chlds[chindx];; 1613 }; 1614 ; 1615 return nodeid;; 1616}; 1617 ; 1618/////////////////////////////////////////////////////////////////////////////////; 1619/// Creates stack for given array of ids, first element always should be 0; 1620 ; 1621std::vector<int> RGeomDescription::MakeStackByIds(const std::vector<int> &ids); 1622{; 1623 TLockGuard lock(fMutex);; 1624 ; 1625 std::vector<int> stack;; 1626 ; 1627 if (ids.empty()); 1628 return stack;; 1629 ; 1630 if (ids[0] != 0) {; 1631 printf(""Wrong first id\n"");; 1632 return stack;; 1633 }; 1634 ; 1635 int nodeid = 0;; 1636 ; 1637 for (unsigned k = 1; k < ids.size(); ++k) {; 1638 ; 1639 int prntid = nodeid;; 1640 nodeid = ids[k];; 1641 ; 1642 if (nodeid >= (int)fDesc.size()) {; 1643 printf(""Wrong node id %d\n"", nodeid);; 1644 stack.clear();; 1645 return stack;; 1646 }; 1647 auto &chlds = fDesc[prntid].chlds;; 1648 auto pos = std::find(chlds.begin(), chlds.end(), nodeid);; 1649 if (pos == chlds.end()) {; 1650 printf(""Wrong id %d not a child of %d - fail to find stack num %d\n"", nodeid, prntid, (int)chlds.size());; 1651 stack.clear();; 1652 return stack;; 1653 }; 1654 ; 1655 stack.emplace_back(std::distance(chlds.begin(), pos));; 1656 }; 1657 ; 1658 return stack;; 1659}; 1660 ; 1661/////////////////////////////////////////////////////////////////////////////////; 1662/// Produce stack based on string path; 1663/// Used to highlight geo volumes by browser hover event; 1664 ; 1665std::vector<int> RGeomDescription::MakeStackByPath(const std::vector<std::string> &path); 1666{; 1667 TLockGuard lock(fMutex);; 1668 ; 1669 std::vector<int> res;; 1670 ; 1671 RGeomBrowserIter iter(*this);; 1672 ; 1673 if (iter.Navigate(path)); 1674 res = MakeStackByIds(iter.CurrentIds());; 1675 ; 1676 return res;; 1677}; 1678 ; 1679/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:49929,clear,clear,49929,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"0;  ; class  MethodCategory;  Class for categorizing the phase space. More...;  ; class  MethodCFMlpANN;  Interface to Clermond-Ferrand artificial neural network. More...;  ; class  MethodCFMlpANN_Utils;  Implementation of Clermond-Ferrand artificial neural network. More...;  ; class  MethodCompositeBase;  Virtual base class for combining several TMVA method. More...;  ; class  MethodCrossValidation;  ; class  MethodCuts;  Multivariate optimisation of signal efficiency for given background efficiency, applying rectangular minimum and maximum requirements. More...;  ; class  MethodDL;  ; class  MethodDNN;  Deep Neural Network Implementation. More...;  ; class  MethodDT;  Analysis of Boosted Decision Trees. More...;  ; class  MethodFDA;  Function discriminant analysis (FDA). More...;  ; class  MethodFisher;  Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis) More...;  ; class  MethodHMatrix;  H-Matrix method, which is implemented as a simple comparison of chi-squared estimators for signal and background, taking into account the linear correlations between the input variables. More...;  ; class  MethodInfo;  ; class  MethodKNN;  Analysis of k-nearest neighbor. More...;  ; class  MethodLD;  Linear Discriminant. More...;  ; class  MethodLikelihood;  Likelihood analysis (""non-parametric approach"") More...;  ; class  MethodMLP;  Multilayer Perceptron class built off of MethodANNBase. More...;  ; class  MethodPDEFoam;  The PDEFoam method is an extension of the PDERS method, which divides the multi-dimensional phase space in a finite number of hyper-rectangles (cells) of constant event density. More...;  ; class  MethodPDERS;  This is a generalization of the above Likelihood methods to \( N_{var} \) dimensions, where \( N_{var} \) is the number of input variables used in the MVA. More...;  ; class  MethodPyAdaBoost;  ; class  MethodPyGTB;  ; class  MethodPyKeras;  ; class  MethodPyRandomForest;  ; class  MethodPyTorch;  ; class  MethodRSNNS;  ; class  Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:6138,simpl,simple,6138,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['simpl'],['simple']
Usability,"0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; pack = 0, . Bool_t ; dolock = kTRUE . ). Remove package 'pack' If 'pack' is null or empty all packages are cleared. ; Definition at line 593 of file TPackMgr.cxx. ◆ SetLogger(). void TPackMgr::SetLogger ; (; TPackMgrLog_t ; logger). inline . Definition at line 67 of file TPackMgr.h. ◆ SetName(). void TPackMgr::SetName ; (; const char * ; name). inlineoverridevirtual . Set the name of the TNamed. ; WARNING: if the object is a member of a THashTable or THashList container the container must be Rehash()'ed after SetName(). For example the list of objects in the current directory is a THashList. ; Reimplemented from TNamed.; Definition at line 62 of file TPackMgr.h. ◆ SetPrefix(). void TPackMgr::SetPrefix ; (; const char * ; pfx). inline . Definition at line 68 of file TPackMgr.h. ◆ Show(). void TPackMgr::Show ; (; const char * ; title = 0). Show available packages. ; Definition at line 548 of file TPackMgr.cxx. ◆ ShowEnabled(). void TPackMgr::ShowEnabled ; (; const char * ; title = 0). Show enabled packages. ; Definition at line 662 of file TPackMgr.cxx. ◆ Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:22512,clear,cleared,22512,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['clear'],['cleared']
Usability,"1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; RooNormSetCache::PairIdxMapType_pairToIdx!; RooNormSetCache::PairVectType_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNormSetCache.html:2439,clear,clear,2439,root/html602/RooNormSetCache.html,https://root.cern,https://root.cern/root/html602/RooNormSetCache.html,6,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidAddDirectory(Bool_t add = kTRUE); static Bool_tAddDirectoryStatus(); virtual Double_tAndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tAndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); virtual Double_tChi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tChi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tChisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDivide(const TH1* h1); virtual Bool_tDivide(TF1* f1, Double_t c1 = 1); virtual Bool_tDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:18266,Clear,Clear,18266,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['Clear'],['Clear']
Usability,"1); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawFocusHilite(Int_t onoff); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidGotFocus(); virtual voidLostFocus(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGColorPalette&operator=(const TGColorPalette&); TGColorPalette(const TGColorPalette&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorPalette.html:14535,Clear,ClearFlags,14535,root/html602/TGColorPalette.html,https://root.cern,https://root.cern/root/html602/TGColorPalette.html,2,['Clear'],['ClearFlags']
Usability,"1, Float_t phi2);  TUBS shape ""simplified"" constructor. ;  ;  TTUBS (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2);  TUBS shape normal constructor. ;  ;  ~TTUBS () override;  TUBS shape default destructor. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a TUBE. ;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections) const override;  Get buffer 3d. ;  ; virtual Float_t GetPhi1 () const;  ; virtual Float_t GetPhi2 () const;  ; TClass * IsA () const override;  ; void Sizeof3D () const override;  Return total X3D needed by TNode::ls (when called with option ""x"") ;  ; void Streamer (TBuffer &) override;  Stream an object of class TTUBE. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBE;  TTUBE ();  TUBE shape default constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmax, Float_t dz);  TUBE shape ""simplified"" constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect=1);  TUBE shape normal constructor. ;  ;  ~TTUBE () override;  TUBE shape default destructor. ;  ; virtual Float_t GetAspectRatio () const;  ; virtual Float_t GetDz () const;  ; virtual Int_t GetNdiv () const;  ; virtual Int_t GetNumberOfDivisions () const;  ; virtual Float_t GetRmax () const;  ; virtual Float_t GetRmin () const;  ; virtual void SetAspectRatio (Float_t factor=1);  ; virtual void SetNumberOfDivisions (Int_t ndiv);  Set number of divisions used to draw this tube. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TShape;  TShape ();  Shape default constructor. ;  ;  TShape (const char *name, const char *title, const char *material);  Shape normal constructor. ;  ;  TShape (const TShape &);  copy constructor ;  ;  ~TShape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONS.html:2854,simpl,simplified,2854,doc/master/classTCONS.html,https://root.cern,https://root.cern/doc/master/classTCONS.html,3,['simpl'],['simplified']
Usability,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPainter.html:1762,Clear,Clear,1762,root/html532/TGeoPainter.html,https://root.cern,https://root.cern/root/html532/TGeoPainter.html,2,['Clear'],['Clear']
Usability,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualGeoPainter.html:1764,Clear,Clear,1764,root/html532/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html,2,['Clear'],['Clear']
Usability,"1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNodeMatrix.html:899,Clear,Clear,899,root/html532/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html532/TGeoNodeMatrix.html,2,['Clear'],['Clear']
Usability,"1.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization methods. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currently allowed values are 0 (low), 1 (default), and 2 (high).; 5.12.1 MnStrategy(); Default constructor, sets all settings according to \(\mbox{level}\)$ = 1.$; 5.12.2 MnStrategy(unsigned int level); Explicit constructor for predefined settings of desired \(\mbox{level}\) 0 (low), 1 (default), or 2 (high).; 5.12.3 setLowStrategy(), setMediumStrategy(), setHighStrategy(); Methods to set specific strategy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51702,Simpl,SimplexMinimizer,51702,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['Simpl'],['SimplexMinimizer']
Usability,"1//; 2852/// - kMissingBranch (-5) : Missing branch; 2853/// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); 2854/// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:112945,usab,usable,112945,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['usab'],['usable']
Usability,1/2]. RooExpensiveObjectCache::RooExpensiveObjectCache ; (; ). inline . Definition at line 27 of file RooExpensiveObjectCache.h. ◆ RooExpensiveObjectCache() [2/2]. RooExpensiveObjectCache::RooExpensiveObjectCache ; (; const RooExpensiveObjectCache & ; other). inline . Definition at line 28 of file RooExpensiveObjectCache.h. ◆ ~RooExpensiveObjectCache(). RooExpensiveObjectCache::~RooExpensiveObjectCache ; (; ). override . Destructor. ; Definition at line 45 of file RooExpensiveObjectCache.cxx. Member Function Documentation. ◆ Class(). static TClass * RooExpensiveObjectCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooExpensiveObjectCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooExpensiveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObj,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:12836,clear,clearAll,12836,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['clear'],['clearAll']
Usability,"10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level) const; virtual Int_tCountVisibleNodes(); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPainter.html:1712,Clear,Clear,1712,root/html602/TGeoPainter.html,https://root.cern,https://root.cern/root/html602/TGeoPainter.html,2,['Clear'],['Clear']
Usability,"10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGeoPainter.html:1806,Clear,Clear,1806,root/html602/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html,2,['Clear'],['Clear']
Usability,"10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeMatrix.html:832,Clear,Clear,832,root/html602/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html602/TGeoNodeMatrix.html,2,['Clear'],['Clear']
Usability,"1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36815,clear,clear,36815,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['clear'],['clear']
Usability,"103| DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; 104| Filter() | Filter rows based on user-defined conditions. |; 105| Range() | Filter rows based on entry number (single-thread only). |; 106| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 107| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 108| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 109| Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |; 110 ; 111 ; 112### Actions; 113Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 114 ; 115In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 116 ; 117Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 118produce many different results in one event loop. Instant actions trigger the event loop instantly.; 119 ; 120 ; 121| **Lazy action** | **Description** |; 122|------------------|-----------------|; 123| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 124| Book() | Book execution of a custom action using a user-defined helper object. |; 125| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 126| Count() | Return the number of events processed. Useful e.g. to get a quick count of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:6700,guid,guide,6700,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['guid'],['guide']
Usability,"1098 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1099}; 1100~~~; 1101 ; 1102A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1103converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1104~~~{.cpp}; 1105// a function that conditionally adds a Range to an RDataFrame node.; 1106RNode MaybeAddRange(RNode df, bool mustAddRange); 1107{; 1108 return mustAddRange ? df.Range(1) : df;; 1109}; 1110// use as :; 1111ROOT::RDataFrame df(10);; 1112auto maybeRangedDF = MaybeAddRange(df, true);; 1113~~~; 1114 ; 1115The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1116loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1117 ; 1118\anchor RDFCollections; 1119### Storing RDataFrame objects in collections; 1120 ; 1121ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1122 ; 1123~~~{.cpp}; 1124std::vector<ROOT::RDF::RNode> dfs;; 1125dfs.emplace_back(ROOT::RDataFrame(10));; 1126dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1127~~~; 1128 ; 1129\anchor callbacks; 1130### Executing callbacks every N events; 1131It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1132Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1133drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1134displaying a progress bar while the event loop runs.; 1135 ; 1136For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1137~~~{.cpp}; 1138auto h = df.Histo1D(""x"");; 1139TCanvas c(""c"",""x hist"");; 1140h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:65576,simpl,simple,65576,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"111; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TListA doubly linked list.Definition TList.h:38; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TPad::FindObjectTObject * FindObject(const char *name) const overrideSearch if object named name is inside this pad or in pads inside this pad.Definition TPad.cxx:2700; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TTextBase class for several text objects.Definition TText.h:22; TTree::GetSelectedRowsvirtual Long64_t GetSelectedRows()Definition TTree.h:553; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto3_8C.html:7324,simpl,simple,7324,doc/master/hlHisto3_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto3_8C.html,1,['simpl'],['simple']
Usability,"1138 return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; 1139}; 1140~~~; 1141 ; 1142A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; 1143converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; 1144~~~{.cpp}; 1145// a function that conditionally adds a Range to an RDataFrame node.; 1146RNode MaybeAddRange(RNode df, bool mustAddRange); 1147{; 1148 return mustAddRange ? df.Range(1) : df;; 1149}; 1150// use as :; 1151ROOT::RDataFrame df(10);; 1152auto maybeRangedDF = MaybeAddRange(df, true);; 1153~~~; 1154 ; 1155The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; 1156loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`.; 1157 ; 1158\anchor RDFCollections; 1159### Storing RDataFrame objects in collections; 1160 ; 1161ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:; 1162 ; 1163~~~{.cpp}; 1164std::vector<ROOT::RDF::RNode> dfs;; 1165dfs.emplace_back(ROOT::RDataFrame(10));; 1166dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; 1167~~~; 1168 ; 1169\anchor callbacks; 1170### Executing callbacks every N events; 1171It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; 1172Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; 1173drawing a partially-filled histogram every time a certain number of new entries is processed, or; 1174displaying a progress bar while the event loop runs.; 1175 ; 1176For example one can draw an up-to-date version of a result histogram every 100 entries like this:; 1177~~~{.cpp}; 1178auto h = df.Histo1D(""x"");; 1179TCanvas c(""c"",""x hist"");; 1180h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:67256,simpl,simple,67256,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTGX11::CloseDisplay(); virtual voidTGX11::ClosePixmap(); virtual voidTGX11::CloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGX11::ConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidTGX11::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTGX11::CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidTGX11::CopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidTGX11::CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tTGX11::CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tTGX11::CreateCursor(ECursor cursor); virtual GContext_tTGX11::CreateGC(Drawable_t id, GCV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:1936,Clear,ClearWindow,1936,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,3,['Clear'],['ClearWindow']
Usability,"1339 ; 1340void RGeomDescription::ProduceSearchData(); 1341{; 1342 TLockGuard lock(fMutex);; 1343 ; 1344 if (fSearch.empty() || !fSearchJson.empty()); 1345 return;; 1346 ; 1347 std::string hjson;; 1348 ; 1349 SearchVisibles(fSearch, hjson, fSearchJson);; 1350 ; 1351 (void)hjson; // not used here; 1352}; 1353 ; 1354/////////////////////////////////////////////////////////////////////; 1355/// Collect all information required to draw geometry on the client; 1356/// This includes list of each visible nodes, meshes and matrixes; 1357 ; 1358void RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406///////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41623,clear,clear,41623,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"14 ; 1715 } else if (extended) {; 1716 ; 1717 // Extended mode, set contents to Poisson(pdf*nEvents); 1718 double w = RooRandom::randomGenerator()->Poisson(hist->weight()*nEvents) ;; 1719 hist->set(w,sqrt(w)) ;; 1720 ; 1721 } else {; 1722 ; 1723 // Regular mode, fill array of weights with Poisson(pdf*nEvents), but to not fill; 1724 // histogram yet.; 1725 if (hist->weight()>histMax) {; 1726 histMax = hist->weight() ;; 1727 }; 1728 histOut[i] = RooRandom::randomGenerator()->Poisson(hist->weight()*nEvents) ;; 1729 histOutSum += histOut[i] ;; 1730 }; 1731 }; 1732 ; 1733 ; 1734 if (!expectedData && !extended) {; 1735 ; 1736 // Second pass for regular mode - Trim/Extend dataset to exact number of entries; 1737 ; 1738 // Calculate difference between what is generated so far and what is requested; 1739 Int_t nEvtExtra = std::abs(Int_t(nEvents)-histOutSum) ;; 1740 Int_t wgt = (histOutSum>nEvents) ? -1 : 1 ;; 1741 ; 1742 // Perform simple binned accept/reject procedure to get to exact event count; 1743 std::size_t counter = 0;; 1744 bool havePrintedInfo = false;; 1745 while(nEvtExtra>0) {; 1746 ; 1747 Int_t ibinRand = RooRandom::randomGenerator()->Integer(hist->numEntries()) ;; 1748 hist->get(ibinRand) ;; 1749 double ranY = RooRandom::randomGenerator()->Uniform(histMax) ;; 1750 ; 1751 if (ranY<hist->weight()) {; 1752 if (wgt==1) {; 1753 histOut[ibinRand]++ ;; 1754 } else {; 1755 // If weight is negative, prior bin content must be at least 1; 1756 if (histOut[ibinRand]>0) {; 1757 histOut[ibinRand]-- ;; 1758 } else {; 1759 continue ;; 1760 }; 1761 }; 1762 nEvtExtra-- ;; 1763 }; 1764 ; 1765 if ((counter++ > 10*nEvents || nEvents > 1.E7) && !havePrintedInfo) {; 1766 havePrintedInfo = true;; 1767 coutP(Generation) << ""RooAbsPdf::generateBinned("" << GetName() << "") Performing costly accept/reject sampling. If this takes too long, use ""; 1768 << ""extended mode to speed up the process."" << std::endl;; 1769 }; 1770 }; 1771 ; 1772 // Transfer working array to histogram; 1773 for (int ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:84334,simpl,simple,84334,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['simpl'],['simple']
Usability,"1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (makes outputfile big!) ; Definition at line 194 of file MethodMLP.h. ◆ fGA_nsteps. Int_t TMVA::MethodMLP::fGA_nsteps. private . GA settings: number of steps. ; Definition at line 197 of file MethodMLP.h. ◆ fGA_preCalc. Int_t TMVA::MethodMLP::fGA_preCalc. private . GA settings: number of pre-calc steps. ; Definition at line 198 of file MethodMLP.h. ◆ fGA_SC_factor. Double_t TMVA::MethodMLP::fGA_SC_factor. private . GA settings: SC_factor. ; Definition at line 201 of file MethodMLP.h. ◆ fGA_SC_rate. Int_t TMVA::MethodMLP::fGA_SC_rate. private . GA settings: SC_rate. ; Definition at line 200 of file MethodMLP.h. ◆ fGA_SC_steps. Int_t TMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:50462,learn,learning,50462,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"15 auto elem_root = Browsable::RProvider::Browse(rootfold);; 116 if (elem_root); 117 comp->Add(std::make_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &requ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:4542,clear,clear,4542,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"18 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105811,clear,clear,105811,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"184 If using a derivative type algorithm the function must implement the; 185 ROOT::Math::IMultiGradFunction interface; 186 Return the current number of function in the list and 0 if failed to add the function; 187 */; 188 int AddFunction( const ROOT::Math::IMultiGenFunction & func);; 189 ; 190 /// same method as before but using any function implementing; 191 /// the operator(), so can be wrapped in a IMultiGenFunction interface; 192 template <class Function>; 193 int AddFunction( Function & f, int ndim) {; 194 // no need to care about lifetime of wfunc. It will be cloned inside AddFunction; 195 WrappedMultiFunction<Function &> wfunc(f, ndim);; 196 return AddFunction(wfunc);; 197 }; 198 ; 199 /**; 200 return the number of sunctions set in the class.; 201 The number must be equal to the dimension of the functions; 202 */; 203 unsigned int Dim() const { return fFunctions.size(); }; 204 ; 205 /// clear list of functions; 206 void Clear();; 207 ; 208 /// return the root X values solving the system; 209 const double * X() const;; 210 ; 211 /// return the function values f(X) solving the system; 212 /// i.e. they must be close to zero at the solution; 213 const double * FVal() const;; 214 ; 215 /// return the last step size; 216 const double * Dx() const;; 217 ; 218 ; 219 /**; 220 Find the root starting from the point X;; 221 Use the number of iteration and tolerance if given otherwise use; 222 default parameter values which can be defined by; 223 the static method SetDefault...; 224 */; 225 bool Solve(const double * x, int maxIter = 0, double absTol = 0, double relTol = 0);; 226 ; 227 /// Return number of iterations; 228 int Iterations() const {; 229 return fIter;; 230 }; 231 ; 232 /// Return the status of last root finding; 233 int Status() const { return fStatus; }; 234 ; 235 /// Return the algorithm name used for solving; 236 /// Note the name is available only after having called solved; 237 /// Otherwise an empyty string is returned; 238 const char * Name() const;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html:8043,clear,clear,8043,doc/master/GSLMultiRootFinder_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html,1,['clear'],['clear']
Usability,"19 ; 720////////////////////////////////////////////////////////////////////////////////; 721/// To read a TObject* from the file.; 722///; 723/// The object associated to this key is read from the file into memory; 724/// Once the key structure is read (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:26671,simpl,simplified,26671,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['simpl'],['simplified']
Usability,"1Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 fValOffset = copy.fValOffset;; 575 fValDiff = copy.fValDiff;; 576 fValue = copy.fValue.load(std::memory_order_relaxed) ? new Val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:16499,clear,clear,16499,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['clear'],['clear']
Usability,"1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn the following way:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:68520,simpl,simply,68520,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,1,['simpl'],['simply']
Usability,"1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:2879,feedback,feedback,2879,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25103,clear,clearEmat,25103,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,12,['clear'],"['clear', 'clearEmat']"
Usability,"2 namespace Math {; 53 ; 54 template <class T, unsigned int D>; 55 class SVector;; 56 ; 57#ifdef XXX; 58//==============================================================================; 59// SMatrix * SVector; 60//==============================================================================; 61template <class T, unsigned int D1, unsigned int D2, class R>; 62SVector<T,D1> operator*(const SMatrix<T,D1,D2,R>& rhs, const SVector<T,D2>& lhs); 63{; 64 SVector<T,D1> tmp;; 65 for(unsigned int i=0; i<D1; ++i) {; 66 const unsigned int rpos = i*D2;; 67 for(unsigned int j=0; j<D2; ++j) {; 68 tmp[i] += rhs.apply(rpos+j) * lhs.apply(j);; 69 }; 70 }; 71 return tmp;; 72}; 73#endif; 74 ; 75 ; 76// matrix-vector product:; 77// use apply(i) function for matrices. Tested (11/05/06) with using (i,j) but; 78// performances are slightly worse (not clear why); 79 ; 80//==============================================================================; 81// meta_row_dot; 82//==============================================================================; 83template <unsigned int I>; 84struct meta_row_dot {; 85 template <class A, class B>; 86 static inline typename A::value_type f(const A& lhs, const B& rhs,; 87 const unsigned int offset) {; 88 return lhs.apply(offset+I) * rhs.apply(I) + meta_row_dot<I-1>::f(lhs,rhs,offset);; 89 }; 90};; 91 ; 92 ; 93//==============================================================================; 94// meta_row_dot<0>; 95//==============================================================================; 96template <>; 97struct meta_row_dot<0> {; 98 template <class A, class B>; 99 static inline typename A::value_type f(const A& lhs, const B& rhs,; 100 const unsigned int offset) {; 101 return lhs.apply(offset) * rhs.apply(0);; 102 }; 103};; 104 ; 105//==============================================================================; 106// VectorMatrixRowOp; 107//==============================================================================; 108template <class Matrix, cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MatrixFunctions_8h_source.html:2536,clear,clear,2536,doc/master/MatrixFunctions_8h_source.html,https://root.cern,https://root.cern/doc/master/MatrixFunctions_8h_source.html,1,['clear'],['clear']
Usability,"2) code = code | 0x8;; 908 return code;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Clip polygon using the Sutherland-Hodgman algorithm.; 913///; 914/// \param[in] n Number of points in the polygon to; 915/// be clipped; 916/// \param[in] x,y Polygon x[n], y[n] do be clipped vertices; 917/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 918/// \param[out] nn Number of points in xc and yc; 919/// \param[out] xc,yc Clipped polygon vertices. The Int_t; 920/// returned by this function is; 921/// the number of points in the clipped; 922/// polygon. These vectors must; 923/// be allocated by the calling function.; 924/// A size of 2*n for each is; 925/// enough.; 926///; 927/// Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; 928/// strategy: It solves a series of simple and identical problems that, when; 929/// combined, solve the overall problem. The simple problem is to clip a polygon; 930/// against a single infinite clip edge. Four clip edges, each defining one boundary; 931/// of the clip rectangle, successively clip a polygon against a clip rectangle.; 932///; 933/// Steps of Sutherland-Hodgman's polygon-clipping algorithm:; 934///; 935/// * Polygons can be clipped against each edge of the window one at a time.; 936/// Windows/edge intersections, if any, are easy to find since the X or Y coordinates; 937/// are already known.; 938/// * Vertices which are kept after clipping against one window edge are saved for; 939/// clipping against the remaining edges.; 940/// * Note that the number of vertices usually changes and will often increases.; 941///; 942/// The clip boundary determines a visible and invisible region. The edges from; 943/// vertex i to vertex i+1 can be one of four types:; 944///; 945/// * Case 1 : Wholly inside visible region - save endpoint; 946/// * Case 2 : Exit visible region - save the intersection; 947/// * Case 3 : Wholly outside visible regi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:29154,simpl,simple,29154,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['simpl'],['simple']
Usability,"2, data, y);; 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points. –Example: TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();; ...; e#define e(i)Definition RSha256.hxx:103; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr)This function is to use when you already have all the data in arrays and don't want to copy them into...Definition TLinearFitter.cxx:583; 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; –GetParameters, GetCovarianceMatrix, etc –the t-values of parameters and their significance can be reached by GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points which do not appear to follow the characteristic distribution of the rest of the data. These may reflect genuine properties of the underlying phenomenon(variable), or be due to measurement errors or anomalies which shouldn't be modelled. (StatSoft electronic textbook); Even a single gross outlier can greatly influence the results of least- squares fitting procedure, and in this case use of robust(resistant) methods is recommended.; The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:6218,clear,cleared,6218,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['clear'],['cleared']
Usability,"2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768044,Guid,Guide,768044,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C H1 analysis example expressed in terms of TTreeReader ;  h1analysisTreeReader.h;  h1chain.C Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed ;  hsimpleProxy.C ;  hsimpleProxyDriver.C This is the driver of the hsimpleProxy example It provides the infrastructure to run that code on an ntuple To be run from the tutorials directory ;  hsimpleReader.C TTreeReader simplest example ;  htest.C Save histograms in Tree branches ;  hvector.C Write and read STL vectors in a tree ;  JetEvent.cxx;  JetEvent.h;  jets.CUsage of a Tree using the JetEvent class ;  ntuple1.C Simple tree analysis ;  parallelcoord.C Script illustrating the use of the TParalleCoord class ;  parallelcoordtrans.C Use of transparency with ||-Coord ;  printSizes.C This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree ;  run_h1analysis.C Macro driving the analysis can specify file name and type ;  spider.C TSpider example ;  staff.C Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ;  tcl.C How to write a TClonesArray to a TTree ;  temperature.CThis tutorial illustrates how to use the highlight mode with trees ;  tree.C Display the Tree data structures ;  tree0.C Simple Event class example ;  tree1.C This example is a variant of hsimple.C but usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:168489,simpl,simplest,168489,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simplest']
Usability,"20 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;; 239 fpTmpBinEdgeVector= nullptr;; 240 }; 241 ; 242 if ( fpTmpCoordErrorVector ); 243 {; 244 delete[] fpTmpCoordErrorVector;; 245 fpTmpCoordErrorVector = nullptr;; 246 }; 247 ; 248 fDataPtr = nullptr;; 249 fDataErrorPtr= fDataErrorHighPtr= fDataErrorLowPtr= nullptr;; 250 ; 251 fErrorType = rhs.fErrorType;; 252 fRefVolume = rhs.fRefVolume;; 253 fBinEdge = rhs.fBinEdge;; 254 ; 255 if ( fWrapped ); 256 {; 257 fData.clear();; 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.front();; 290 }; 291 // copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:7186,clear,clear,7186,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"2068 ; 2069 RGeomBrowserIter giter(*this);; 2070 ; 2071 if (!giter.Navigate(path)); 2072 return false;; 2073 ; 2074 auto stack = MakeStackByIds(giter.CurrentIds());; 2075 ; 2076 for (auto iter = fVisibility.begin(); iter != fVisibility.end(); iter++); 2077 if (compare_stacks(iter->stack, stack) == 0) {; 2078 fVisibility.erase(iter);; 2079 ClearDrawData();; 2080 return true;; 2081 }; 2082 ; 2083 return false;; 2084}; 2085 ; 2086/////////////////////////////////////////////////////////////////////////////////; 2087/// Reset all custom visibility settings; 2088 ; 2089bool RGeomDescription::ClearAllPhysVisibility(); 2090{; 2091 TLockGuard lock(fMutex);; 2092 ; 2093 if (fVisibility.empty()); 2094 return false;; 2095 ; 2096 fVisibility.clear();; 2097 ClearDrawData();; 2098 return true;; 2099}; 2100 ; 2101/////////////////////////////////////////////////////////////////////////////////; 2102/// Change configuration by client; 2103/// Returns true if any parameter was really changed; 2104 ; 2105bool RGeomDescription::ChangeConfiguration(const std::string &json); 2106{; 2107 auto cfg = TBufferJSON::FromJSON<RGeomConfig>(json);; 2108 if (!cfg); 2109 return false;; 2110 ; 2111 TLockGuard lock(fMutex);; 2112 ; 2113 auto json1 = TBufferJSON::ToJSON(cfg.get());; 2114 auto json2 = TBufferJSON::ToJSON(&fCfg);; 2115 ; 2116 if (json1 == json2); 2117 return false;; 2118 ; 2119 fCfg = *cfg; // use assign; 2120 ; 2121 ClearDrawData();; 2122 ; 2123 return true;; 2124}; 2125 ; 2126/////////////////////////////////////////////////////////////////////////////////; 2127/// Change search query and belongs to it json string; 2128/// Returns true if any parameter was really changed; 2129 ; 2130bool RGeomDescription::SetSearch(const std::string &query, const std::string &json); 2131{; 2132 TLockGuard lock(fMutex);; 2133 ; 2134 bool changed = (fSearch != query) || (fSearchJson != json);; 2135 fSearch = query;; 2136 fSearchJson = json;; 2137 return changed;; 2138}; 2139 ; 2140/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:63203,clear,clear,63203,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8h_source.html:1876,simpl,simpler,1876,doc/master/TDirectory_8h_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html,1,['simpl'],['simpler']
Usability,"2108 void* dyLibHandle = dlopen(dyLibName.c_str(), RTLD_LAZY | RTLD_GLOBAL);; 2109 if (dyLibHandle) {; 2110 fRegisterModuleDyLibs.push_back(dyLibHandle);; 2111 wasDlopened = true;; 2112 } else {; 2113 PrintDlError(dyLibName.c_str(), modulename);; 2114 }; 2115 }; 2116 } // if (!lateRegistration); 2117 ; 2118 if (hasHeaderParsingOnDemand && fwdDeclsCode){; 2119 // We now parse the forward declarations. All the classes are then modified; 2120 // in order for them to have an external lexical storage.; 2121 std::string fwdDeclsCodeLessEnums;; 2122 {; 2123 // Search for enum forward decls and only declare them if no; 2124 // declaration exists yet.; 2125 std::string fwdDeclsLine;; 2126 std::istringstream fwdDeclsCodeStr(fwdDeclsCode);; 2127 std::vector<std::string> scopes;; 2128 while (std::getline(fwdDeclsCodeStr, fwdDeclsLine)) {; 2129 const auto enumPos = fwdDeclsLine.find(""enum __attribute__((annotate(\"""");; 2130 // We check if the line contains a fwd declaration of an enum; 2131 if (enumPos != std::string::npos) {; 2132 // We clear the scopes which we may have carried from a previous iteration; 2133 scopes.clear();; 2134 // We check if the enum is not in a scope. If yes, save its name; 2135 // and the names of the enclosing scopes.; 2136 if (enumPos != 0) {; 2137 // it's enclosed in namespaces. We need to understand what they are; 2138 auto nsPos = fwdDeclsLine.find(""namespace"");; 2139 R__ASSERT(nsPos < enumPos && ""Inconsistent enum and enclosing scope parsing!"");; 2140 while (nsPos < enumPos && nsPos != std::string::npos) {; 2141 // we have a namespace, let's put it in the collection of scopes; 2142 const auto nsNameStart = nsPos + 10;; 2143 const auto nsNameEnd = fwdDeclsLine.find('{', nsNameStart);; 2144 const auto nsName = fwdDeclsLine.substr(nsNameStart, nsNameEnd - nsNameStart);; 2145 scopes.push_back(nsName);; 2146 nsPos = fwdDeclsLine.find(""namespace"", nsNameEnd);; 2147 }; 2148 }; 2149 clang::DeclContext* DC = nullptr;; 2150 for (auto &&aScope: scopes) {; 2151",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:81805,clear,clear,81805,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"2344 }; 2345 }; 2346 subbranch->fOnfileObject = fOnfileObject;; 2347 lastbranch = subbranch;; 2348 }; 2349 }; 2350 if (toplevel) {; 2351 SetBit(kOwnOnfileObj);; 2352 if (lastbranch != this); 2353 lastbranch->ResetBit(kOwnOnfileObj);; 2354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:84840,clear,clear,84840,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"2498; TStatistic::HashULong_t Hash() const overrideReturn hash value for this object.Definition TStatistic.h:53. Reimplemented from TObject.; Definition at line 53 of file TStatistic.h. ◆ IsA(). TClass * TStatistic::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file TStatistic.h. ◆ ls(). void TStatistic::ls ; (; Option_t * ; option = """"); const. inlineoverridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). ; Reimplemented from TObject.; Definition at line 75 of file TStatistic.h. ◆ Merge(). Int_t TStatistic::Merge ; (; TCollection * ; in). Merge implementation of TStatistic. ; Parameters. [in]inOther TStatistic objects to be added to the current one. The function merges the statistics of all objects together to form a new one. Merging quantities is done via simple addition for the following class data members:; number of entries fN; the sum of weights fW; the sum of squared weights fW2; the sum of (value*weight) fM. The sum of squared (value*weight) pairs fM2 is updated using the same formula as in TStatistic::Fill() function.; The minimum(maximum) is updated by checking that the minimum(maximum) of the next TStatistic object in the queue is either less(greater) than the current minimum(maximum). ; Definition at line 137 of file TStatistic.cxx. ◆ Print(). void TStatistic::Print ; (; Option_t * ; = """"); const. overridevirtual . Print the content of the object. ; Prints the statistics held by the object in one line. These include the mean, mean error, RMS, the total number of values, the minimum and the maximum. ; Reimplemented from TObject.; Definition at line 115 of file TStatistic.cxx. ◆ Streamer(). void TStatistic::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TStatistic::StreamerNVirtual ; (; TBuffer & ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:17098,simpl,simple,17098,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['simpl'],['simple']
Usability,"2>> . ROOT::Math::Expr< ExprType, T, D, D2, R1 >::Expr ; (; const ExprType & ; rhs). inline . Definition at line 143 of file Expression.h. ◆ ~Expr(). template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . ROOT::Math::Expr< ExprType, T, D, D2, R1 >::~Expr ; (; ). inline . Definition at line 147 of file Expression.h. Member Function Documentation. ◆ apply(). template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . T ROOT::Math::Expr< ExprType, T, D, D2, R1 >::apply ; (; unsigned int ; i); const. inline . Definition at line 150 of file Expression.h. ◆ IsInUse(). template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . bool ROOT::Math::Expr< ExprType, T, D, D2, R1 >::IsInUse ; (; const T * ; p); const. inline . function to determine if any use operand is being used (has same memory address) ; Definition at line 161 of file Expression.h. ◆ operator()(). template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . T ROOT::Math::Expr< ExprType, T, D, D2, R1 >::operator() ; (; unsigned int ; i, . unsigned ; j . ); const. inline . Definition at line 153 of file Expression.h. ◆ print(). template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . std::ostream & ROOT::Math::Expr< ExprType, T, D, D2, R1 >::print ; (; std::ostream & ; os); const. inline . used by operator<<() simplify to use apply(i,j) ; Definition at line 184 of file Expression.h. Member Data Documentation. ◆ rhs_. template<class ExprType , class T , unsigned int D, unsigned int D2 = 1, class R1 = MatRepStd<T,D,D2>> . ExprType ROOT::Math::Expr< ExprType, T, D, D2, R1 >::rhs_. private . Definition at line 203 of file Expression.h. math/smatrix/inc/Math/Expression.h. ROOTMathExpr. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Expr.html:3232,simpl,simplify,3232,doc/master/classROOT_1_1Math_1_1Expr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Expr.html,1,['simpl'],['simplify']
Usability,"2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.CThis tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly), fill it and draw it using GL ;  th2polyUSA.CThis tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using GL ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to copy all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:124951,simpl,simple,124951,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"2Poly.h. ◆ GetOverflowContent(). Double_t TProfile2Poly::GetOverflowContent ; (; Int_t ; idx). inline . Definition at line 99 of file TProfile2Poly.h. ◆ GetOverflowRegionFromCoordinates(). Int_t TProfile2Poly::GetOverflowRegionFromCoordinates ; (; Double_t ; x, . Double_t ; y . ). protected . The overflow regions are calculated by considering x, y coordinates. ; The Middle bin at -5 contains all the TProfile2Poly bins.; -0 -1 -2; ________; -1: |__|__|__|; -4: |__|__|__|; -7: |__|__|__|. Definition at line 493 of file TProfile2Poly.cxx. ◆ GetStats(). void TProfile2Poly::GetStats ; (; Double_t * ; stats); const. overridevirtual . Fill the array stats from the contents of this profile. ; The array stats must be correctly dimensioned in the calling program. stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range. ; Reimplemented from TH2Poly.; Definition at line 433 of file TProfile2Poly.cxx. ◆ IsA(). TClass * TProfile2Poly::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TH2Poly.; Definition at line 115 of file TProfile2Poly.h. ◆ Merge() [1/2]. Long64_t TProfile2Poly::Merge ; (; const std::vector< TProfile2Poly * > & ; list). Merge. ; Definition at line 246 of file TProfile2Poly.cxx. ◆ Merge() [2/2]. Long64_t TProfile2Poly::Merge ; (; TCollection * ; in). overridevirtual . Merge. ; Reimplemented from TH2Poly.; Definition at line 230 of file TProfile2Poly.cxx. ◆ OverflowIdxToArrayIdx(). Int_t TProfile2Poly::OverflowIdxToArrayIdx ; (; Int_t ; val). inlineprotected . Definition at line 112 of file TProfile2Poly.h. ◆ PrintOverflowRegions(). void TProfile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2Poly.html:69597,simpl,simply,69597,doc/master/classTProfile2Poly.html,https://root.cern,https://root.cern/doc/master/classTProfile2Poly.html,1,['simpl'],['simply']
Usability,"3 ; 254 std::vector<std::pair<const char *, const char *>> &GetDelayedAddClassAlternate(); 255 {; 256 static std::vector<std::pair<const char *, const char *>> delayedAddClassAlternate;; 257 return delayedAddClassAlternate;; 258 }; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:8256,clear,clear,8256,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['clear'],['clear']
Usability,"3 return obj;; 2794}; 2795 ; 2796////////////////////////////////////////////////////////////////////////////////; 2797/// Perform the automatic addition of the histogram to the given directory; 2798///; 2799/// Note this function is called in place when the semantic requires; 2800/// this object to be added to a directory (I.e. when being read from; 2801/// a TKey or being Cloned); 2802 ; 2803void TH1::DirectoryAutoAdd(TDirectory *dir); 2804{; 2805 Bool_t addStatus = TH1::AddDirectoryStatus();; 2806 if (addStatus) {; 2807 SetDirectory(dir);; 2808 if (dir) {; 2809 ResetBit(kCanDelete);; 2810 }; 2811 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:112111,simpl,simple,112111,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simple']
Usability,3 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20564,clear,clear,20564,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; return c2e;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; char *os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. TCanvas *cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMinimumZero();. TH1F *h1b = new TH1F(""h1b"",""Option B example"",nx,0,nx);; h1b->SetFillColor(4);; h1b->SetBarWidth(0.4);; h1b->SetBarOffset(0.1);; h1b->SetStats(0);; h1b->SetMinimum(-5);; h1b->SetMaximum(5);. for (i=1; i<=nx; i++) {; h1b->Fill(os_X[i-1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:21662,simpl,simple,21662,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,4,['simpl'],['simple']
Usability,"3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; return c2e;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. TCanvas *cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMinimumZero();. TH1F *h1b = new TH1F(""h1b"",""Option B example"",nx,0,nx);; h1b->SetFillColor(4);; h1b->SetBarWidth(0.4);; h1b->SetBarOffset(0.1);; h1b->SetStats(0);; h1b->SetMinimum(-5);; h1b->SetMaximum(5);. for (i=1; i<=nx; i++) {; h1b->SetBinConten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:21838,simpl,simple,21838,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,2,['simpl'],['simple']
Usability,"3., 3.);; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore.; Language Bindings; Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel. We made it easier to use ROOT notebooks locally, by providing a ‘root –notebook’ command option to start a local notebook server customised with all the ROOT features.; New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found here and many more snippets here.; Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added.; JavaScript ROOT. support registered in THttpServer commands with arguments.; provide workaround for websites using require.js and older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Dox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:22116,simpl,simplest,22116,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['simpl'],['simplest']
Usability,"3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more information, the class names are given and they may refer to the online developer documentation. This is especially true for functions and methods that set and get internal values of the objects described here. By default 2D graphical objects are created in User Coordinates with (0, 0) in the lower left corner.; 9.4.1 Lines, Arrows and Polylines; The simplest graphical object is a line. It is implemented in the TLine class. The line constructor is:; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); The arguments x1, y1, x2, y2 are the coordinates of the first and second point. It can be used:; root[] l = new TLine(0.2,0.2,0.8,0.3); root[] l->Draw(); The arrow constructor is:; TArrow(Double_t x1, Double_t y1,; Double_t x2, Double_t y2,; Float_t arrowsize, Option_t *option); It defines an arrow between points x1,y1 and x2,y2. The arrow size is in percentage of the pad height. The option parameter has the following meanings:; “>”; “<|”; “<”; “|>”; “<>”; “<|>”; Once an arrow is drawn on the screen, one can:. click on one of the edges and move this edge.; click on any other arrow part to move the entire arrow. Different arrow formats. If FillColor is 0, an open triangle is drawn; else a full triangle is filled with the set fill color. If ar is an arrow object, fill color is set with:; ar.SetFillColor(icolor);; Where icolor is the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:319737,simpl,simplest,319737,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issued and SCAN enables redirecting of TTree::Scan command in; 47 an ASCII file (see -Scanning expressions-);; 48 - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; 49 drawing and stop the current command respectively, two text widgets where; 50 input and output event lists can be specified, a message box and a RESET; 51 button on the right that clear edited expression content (see Editing...); 52 - a tree-type list on the main left panel where you can select among trees or; 53 branches. The tree/branch will be detailed in the right panel.; 54 Mapped trees are provided with context menus, activated by right-clicking;; 55 - a view-type list on the right panel. The first column contain X, Y and; 56 Z expression items, an optional cut and ten optional editable expressions.; 57 Expressions and leaf-type items can be dragged or deleted. A right click on; 58 the list-box or item activates context menus.; 59 ; 60### Opening a new tree and saving a session :; 61 ; 62 To open a new tree in the viewer use `<File/Open tree file>` menu; 63The content of the file (keys) will be listed. Use `<SetTreeName>` function; 64from the context me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:2874,clear,clear,2874,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['clear'],['clear']
Usability,"32.exe; #Unix.*.Print.Command: a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; Default histogram binnings used by TTree::Draw() method.; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; Default statistics names used for parameters in TPaveStats:; Hist.Stats.Entries Entries; Hist.Stats.Mean Mean; Hist.Stats.MeanX Mean x; Hist.Stats.MeanY Mean y; Hist.Stats.RMS RMS; Hist.Stats.RMSX RMS x; Hist.Stats.RMSY RMS y; Hist.Stats.Underflow Underflow; Hist.Stats.Overflow Overflow; Hist.Stats.Integral Integral; Hist.Stats.Skewness Skewness; Hist.Stats.SkewnessX Skewness x; Hist.Stats.SkewnessY Skewness y; Hist.Stats.Kurtosis Kurtosis; Hist.Stats.KurtosisX Kurtosis x; Hist.Stats.KurtosisY Kurtosis y; 28.6.2 THtml Specific Settings; See the reference guide documentation of THtml class at https://root.cern/doc/master/classTHtml.html for more details.; XHTML content charset (see http://www.w3.org/TR/2002/REC-xhtml1-20020801, default: ISO-8859-1) is set by:; Root.Html.Charset:; Stem of a search engine for the documentation, where %s is replaced by the term entered in the search text box (example: http://www.google.com/search?q=%s+site%3Aroot.cern.ch%2Froot%2Fhtml, default is """"); Root.Html.Search:; Link to the site’s search engine (default: """", example: http://root.cern.ch/root/Search.phtml); Root.Html.SearchEngine:; String to prepend to TClass::GetImplFileName() names containing directories when looking for source files (default: """", example: ../root); Root.Html.SourcePrefix:; Link stem to ViewCVS entry for classes, where a class name is assumed to match a file name (default: """", example: http://root.cern.ch/viewcvs).; Root.Html.ViewCVS:; Stem of the CERN XWho system (default: http://consult.cern.ch/xwho/people?); Root.Html.XWho:; If se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1258160,guid,guide,1258160,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"3268 // Copy MakeClass status.; 3269 newtree->SetMakeClass(fMakeClass);; 3270 ; 3271 // Copy branch addresses.; 3272 CopyAddresses(newtree);; 3273 ; 3274 //; 3275 // Copy entries if requested.; 3276 //; 3277 ; 3278 if (nentries != 0) {; 3279 if (fastClone && (nentries < 0)) {; 3280 if ( newtree->CopyEntries( this, -1, option, false ) < 0 ) {; 3281 // There was a problem!; 3282 Error(""CloneTTree"", ""TTree has not been cloned\n"");; 3283 delete newtree;; 3284 newtree = nullptr;; 3285 return nullptr;; 3286 }; 3287 } else {; 3288 newtree->CopyEntries( this, nentries, option, false );; 3289 }; 3290 }; 3291 ; 3292 return newtree;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Set branch addresses of passed tree equal to ours.; 3297/// If undo is true, reset the branch addresses instead of copying them.; 3298/// This ensures 'separation' of a cloned tree from its original.; 3299 ; 3300void TTree::CopyAddresses(TTree* tree, bool undo); 3301{; 3302 // Copy branch addresses starting from branches.; 3303 TObjArray* branches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:130661,undo,undo,130661,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['undo'],['undo']
Usability,"332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 345 For the options same consideration as in the previous method; 346 */; 347 bool SetFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:14570,simpl,simple,14570,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['simpl'],['simple']
Usability,"34 if (!fDestFile || fDestFile->IsZombie()) {; 135 return R__FAIL(""cannot open dest file "" + std::string(fDestFileName));; 136 }; 137 ; 138 return RResult<void>::Success();; 139}; 140 ; 141void ROOT::Experimental::RNTupleImporter::ReportSchema(); 142{; 143 for (const auto &f : fImportFields) {; 144 std::cout << ""Importing '"" << f.fField->GetFieldName() << ""' ["" << f.fField->GetTypeName() << ""]\n"";; 145 }; 146 for (const auto &f : Internal::GetProjectedFieldsOfModel(*fModel).GetFieldZero().GetSubFields()) {; 147 std::cout << ""Importing (projected) '"" << f->GetFieldName() << ""' ["" << f->GetTypeName() << ""]\n"";; 148 }; 149}; 150 ; 151void ROOT::Experimental::RNTupleImporter::ResetSchema(); 152{; 153 fImportBranches.clear();; 154 fImportFields.clear();; 155 fLeafCountCollections.clear();; 156 fImportTransformations.clear();; 157 fModel = RNTupleModel::CreateBare();; 158 fEntry = nullptr;; 159}; 160 ; 161ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::PrepareSchema(); 162{; 163 ResetSchema();; 164 ; 165 // Browse through all branches and their leaves, create corresponding fields and prepare the memory buffers for; 166 // reading and writing. Usually, reading and writing share the same memory buffer, i.e. the object is read from TTree; 167 // and written as-is to the RNTuple. There are exceptions, e.g. for leaf count arrays and C strings.; 168 for (auto b : TRangeDynCast<TBranch>(*fSourceTree->GetListOfBranches())) {; 169 assert(b);; 170 const auto firstLeaf = static_cast<TLeaf *>(b->GetListOfLeaves()->First());; 171 assert(firstLeaf);; 172 ; 173 const bool isLeafList = b->GetNleaves() > 1;; 174 const bool isCountLeaf = firstLeaf->IsRange(); // A leaf storing the number of elements of a leaf count array; 175 const bool isClass = (firstLeaf->IsA() == TLeafElement::Class()); // STL or user-defined class; 176 if (isLeafList && isClass); 177 return R__FAIL(""unsupported: classes in leaf list, branch "" + std::string(b->GetName()));; 178 if (isLeafList && ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html:6192,clear,clear,6192,doc/master/RNTupleImporter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html,1,['clear'],['clear']
Usability,"35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. TCanvas *cbh = new TCanvas(""cbh"",""cbh"",400,600);; cbh->SetGrid();. gStyle->SetHistMinimumZero();. TH1F *h1bh = new TH1F(""h1bh"",""Option HBAR centered on 0"",nx,0,nx);; h1bh->SetFillColor(4);; h1bh->SetBarWidth(0.4);; h1bh->SetBarOffset(0.1);; h1bh->SetStats(0);; h1bh->SetMinimum(-5);; h1bh->SetMaximum(5);. for (i=1; i<=nx; i++) {; h1bh->Fill(os_X[i-1], d_35_0[i-1]);; h1bh->GetXaxis()->SetBinLabel(i,os_X[i-1]);; }. h1bh->Draw(""hbar"");. TH1F *h2bh = new TH1F(""h2bh"",""h2bh"",nx,0,nx);; h2bh->SetFillColor(38);; h2bh->SetBarWidth(0.4);; h2bh->SetBarOffset(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1], d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; TH2Poly can be drawn as a color plot (option COL).; TH2Poly bins can have any shapes. The bins are defined as graphs. The; following macro is a very simple example showing how to book a TH2Poly and draw; it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(4, x3, y3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(1);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The method AddBinBox allows; to define them more easily like shown in the following example. Picture; Source. //This tutorial illustrates how to create an histogram with p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:54527,simpl,simple,54527,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,1,['simpl'],['simple']
Usability,"360/// If this branch is a branch count, return the set of collection size for; 361/// the entry range requested; 362/// start: first entry to read and return information about; 363/// len: number of entries to read.; 364const TLeaf::Counts_t *TLeaf::GetLeafCountValues(Long64_t start, Long64_t len); 365{; 366 if (len <= 0 || !IsRange()); 367 return nullptr;; 368 ; 369 if (fLeafCountValues) {; 370 if (fLeafCountValues->fStartEntry == start && len < (Long64_t)fLeafCountValues->fValues.size()); 371 {; 372 return &fLeafCountValues->fValues;; 373 }; 374 if (start >= fLeafCountValues->fStartEntry &&; 375 (start+len) <= (Long64_t)(fLeafCountValues->fStartEntry + fLeafCountValues->fValues.size())); 376 {; 377 auto &values(fLeafCountValues->fValues);; 378 values.erase(values.begin(), values.begin() + start-fLeafCountValues->fStartEntry);; 379 return &values;; 380 }; 381 } else {; 382 fLeafCountValues = new LeafCountValues();; 383 }; 384 ; 385 ; 386 fLeafCountValues->fValues.clear();; 387 fLeafCountValues->fValues.reserve(len);; 388 fLeafCountValues->fStartEntry = start;; 389 ; 390 auto branch = GetBranch();; 391 Long64_t orig_leaf_entry = branch->GetReadEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:12366,clear,clear,12366,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['clear'],['clear']
Usability,"3C, TH3S, TH3I, TH3L, TH3F, TH3D, TProfile, TProfile2D, TProfile3D, TH2Poly, and TH1K.; Definition at line 2671 of file TH1.cxx. ◆ DeclFileName(). static const char * TH1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 444 of file TH1.h. ◆ DirectoryAutoAdd(). void TH1::DirectoryAutoAdd ; (; TDirectory * ; dir). virtual . Perform the automatic addition of the histogram to the given directory. ; Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a TKey or being Cloned) ; Definition at line 2801 of file TH1.cxx. ◆ DistancetoPrimitive(). Int_t TH1::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to a line. ; Compute the closest distance of approach from point px,py to elements of a histogram. The distance is computed in pixels units.; Algorithm:; Currently, this simple model computes the distance from the mouse to the histogram contour only. ; Reimplemented from TObject.; Definition at line 2823 of file TH1.cxx. ◆ Divide() [1/3]. Bool_t TH1::Divide ; (; const TH1 * ; h1). virtual . Divide this histogram by h1. ; this = this/h1 if errors are defined (see TH1::Sumw2), errors are also recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set. The resulting errors are calculated assuming uncorrelated histograms. See the other TH1::Divide that gives the possibility to optionally compute binomial errors.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Scale; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2908 of file TH1.cxx. ◆ Divide() [2/3]. Bool_t TH1::Divide ; (; const TH1 * ; h1, . const TH1 * ; h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:104781,simpl,simple,104781,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['simpl'],['simple']
Usability,"4 TransactionDeclSet.insert(*DI);; 6795 ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);; 6796 }; 6797 }; 6798 }; 6799 ; 6800 // The above might trigger more decls to be deserialized.; 6801 // Thus the iteration over the deserialized decls must be last.; 6802 for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),; 6803 E = T.deserialized_decls_end(); I != E; ++I) {; 6804 for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),; 6805 DE = I->m_DGR.end(); DI != DE; ++DI); 6806 if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {; 6807 //FIXME: HandleNewDecl should take DeclGroupRef; 6808 ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,; 6809 modifiedTClasses);; 6810 }; 6811 }; 6812 ; 6813 ; 6814 // When fully building the reflection info in TClass, a deserialization; 6815 // could be triggered, which may result in request for building the; 6816 // reflection info for the same TClass. This in turn will clear the caches; 6817 // for the TClass in-flight and cause null ptr derefs.; 6818 // FIXME: This is a quick fix, solving most of the issues. The actual; 6819 // question is: Shouldn't TClass provide a lock mechanism on update or lock; 6820 // itself until the update is done.; 6821 //; 6822 std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());; 6823 std::vector<TClass*>::iterator it;; 6824 it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),; 6825 ((TCling*)gCling)->GetModTClasses().begin(),; 6826 ((TCling*)gCling)->GetModTClasses().end(),; 6827 modifiedTClassesDiff.begin());; 6828 modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());; 6829 ; 6830 // Lock the TClass for updates; 6831 ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),; 6832 modifiedTClassesDiff.end());; 6833 for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),; 6834 E = modifiedTClassesDiff.end(); I != E; ++I) {; 6835 // Make sure the TClass has not been deleted.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:266093,clear,clear,266093,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"4 fCollect = info.fCollectFunc;; 655 fCreateEnv.call = info.fCreateEnv;; 656 ; 657 if (cl) {; 658 fName = cl->GetName();; 659 }; 660 CheckFunctions();; 661 ; 662 fValue = 0;; 663 fKey = 0;; 664 fVal = 0;; 665 fPointers = false;; 666 fSTL_type = ROOT::kNotSTL;; 667 ; 668 Env_t e;; 669 if ( info.fIterSize > sizeof(e.fIterator) ) {; 670 Fatal(""TGenCollectionProxy"",; 671 ""%s %s are too large:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21137,clear,clearVector,21137,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['clear'],['clearVector']
Usability,"40 fRealTime = fWatch->RealTime();; 341 fCpuTime = fWatch->CpuTime();; 342 if (fUnzipInputSize); 343 fCompress = ((double)fUnzipObjSize) / fUnzipInputSize;; 344 Int_t npoints = fGraphIO->GetN();; 345 if (!npoints) return;; 346 Double_t iomax = TMath::MaxElement(npoints,fGraphIO->GetY());; 347 fRealNorm = iomax/fRealTime;; 348 fGraphTime->GetY()[0] = fRealNorm*fGraphTime->GetEY()[0];; 349 // we normalize the fGraphTime such that it can be drawn on top of fGraphIO; 350 for (Int_t i=1;i<npoints;i++) {; 351 fGraphTime->GetY()[i] = fGraphTime->GetY()[i-1] +fRealNorm*fGraphTime->GetEY()[i];; 352 fGraphTime->GetEY()[i] = 0;; 353 }; 354}; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357/// Update the fBranchIndexCache collection to match the current TTree given; 358/// the ordered list of branch names.; 359 ; 360void TTreePerfStats::UpdateBranchIndices(TObjArray *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:12580,clear,clear,12580,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['clear'],['clear']
Usability,"40PoissonUNURAN(100) 62.000 256.000 69.000 78.000; 141~~~~; 142 ; 143Note that the time to generate a number from an arbitrary TF1 function; 144using TF1::GetRandom or using TUnuran is independent of the complexity of the function.; 145 ; 146TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name); 147can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram; 148or from an existing function.; 149 ; 150Note this interesting feature when working with objects.; 151 You can use several TRandom objects, each with their ""independent""; 152 random sequence. For example, one can imagine; 153~~~~; 154 TRandom *eventGenerator = new TRandom();; 155 TRandom *tracking = new TRandom();; 156~~~~; 157 `eventGenerator` can be used to generate the event kinematics.; 158 tracking can be used to track the generated particles with random numbers; 159 independent from eventGenerator.; 160 This very interesting feature gives the possibility to work with simple; 161 and very fast random number generators without worrying about; 162 random number periodicity as it was the case with Fortran.; 163 One can use TRandom::SetSeed to modify the seed of one generator.; 164 ; 165A TRandom object may be written to a Root file; 166 ; 167- as part of another object; 168- or with its own key (example: `gRandom->Write(""Random"")` ) ;; 169 ; 170*/; 171 ; 172#include ""TROOT.h""; 173#include ""TMath.h""; 174#include ""TRandom.h""; 175#include ""TRandom3.h""; 176#include ""TSystem.h""; 177#include ""TDirectory.h""; 178#include ""Math/QuantFuncMathCore.h""; 179#include ""TUUID.h""; 180#include ""TError.h""; 181 ; 182ClassImp(TRandom);; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// Default constructor. For seed see SetSeed().; 186 ; 187TRandom::TRandom(UInt_t seed): TNamed(""Random"",""Default Random number generator""); 188{; 189 SetSeed(seed);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Default de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:9831,simpl,simple,9831,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['simpl'],['simple']
Usability,"42 SetMaxVisFaces((maxnodes > 5000 ? 5000 : (maxnodes < 1000 ? 1000 : maxnodes)) * 100);; 443 ; 444 auto topnode = mgr->GetTopNode();; 445 ; 446 BuildDescription(topnode, topnode->GetVolume());; 447 ; 448 if (!volname.empty()) {; 449 auto vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12212,clear,clear,12212,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"438 of file RooAbsArg.cxx. ◆ checkObservables(). bool RooAbsArg::checkObservables ; (; const RooArgSet * ; nset); const. virtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented in RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooRealSumFunc, and RooRealSumPdf.; Definition at line 817 of file RooAbsArg.cxx. ◆ cleanBranchName(). TString RooAbsArg::cleanBranchName ; (; ); const. protected . Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ; Definition at line 2075 of file RooAbsArg.cxx. ◆ clearShapeDirty(). void RooAbsArg::clearShapeDirty ; (; ); const. inlineprotected . Definition at line 579 of file RooAbsArg.h. ◆ clearValueAndShapeDirty(). void RooAbsArg::clearValueAndShapeDirty ; (; ); const. inlineprotected . Definition at line 571 of file RooAbsArg.h. ◆ clearValueDirty(). void RooAbsArg::clearValueDirty ; (; ); const. inlineprotected . Definition at line 576 of file RooAbsArg.h. ◆ clients(). const RefCountList_t & RooAbsArg::clients ; (; ); const. inline . List of all clients of this object. ; Definition at line 166 of file RooAbsArg.h. ◆ clone(). virtual TObject * RooAbsArg::clone ; (; const char * ; newname = nullptr); const. pure virtual . Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:50799,clear,clearValueDirty,50799,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearValueDirty']
Usability,"44 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:28368,clear,clear,28368,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;; 4650 obj = nullptr;; 4651 }; 4652 ; 4653 //Stat is painted twice (first, it will be in canvas' list of primitives),; 4654 //second, it will be here, this is not required on iOS.; 4655 //Condition is ALWAYS true on a platform different from iOS.; 4656 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 4657 PaintStat(gStyle->GetOptStat(),(TF1*)obj);; 4658 }; 4659 fH->SetMinimum(minsav);; 4660 gCurrentHist = oldhist;; 4661 fXbuf.clear();; 4662 fYbuf.clear();; 4663}; 4664 ; 4665////////////////////////////////////////////////////////////////////////////////; 4666/// [Control function to draw a table as an arrow plot](\ref HP12); 4667 ; 4668void THistPainter::PaintArrows(Option_t *); 4669{; 4670 Double_t xk, xstep, yk, ystep;; 4671 Double_t dx, dy, x1, x2, y1, y2, xc, yc, dxn, dyn;; 4672 Int_t ncx = Hparam.xlast - Hparam.xfirst + 1;; 4673 Int_t ncy = Hparam.ylast - Hparam.yfirst + 1;; 4674 Double_t xrg = gPad->GetUxmin();; 4675 Double_t yrg = gPad->GetUymin();; 4676 Double_t xln = gPad->GetUxmax() - xrg;; 4677 Double_t yln = gPad->GetUymax() - yrg;; 4678 Double_t cx = (xln/Double_t(ncx))/2.;; 4679 Double_t cy = (yln/Double_t(ncy))/2.;; 4680 Double_t dn = 1.E-30;; 4681 ; 4682 auto arrow = new TArrow();; 4683 arrow->SetAngle(30);; 4684 arrow->SetFillStyle(1001);; 4685 arrow->SetFillColor(fH->GetLineColor());; 4686 arrow->SetLineColor(fH->GetLineColor());; 4687 arrow->SetLineWidth(fH->GetLineWidth());; 4688 ; 4689 // Initiali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:176101,clear,clear,176101,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"4_t bytesRead);  ; void IncCPUTime (Double_t procTime);  ; void IncEntries (Long64_t entries=1);  ; void IncProcTime (Double_t procTime);  ; void IncReadCalls (Long64_t readCalls);  ; TClass * IsA () const override;  ; TProofProgressStatus & operator+= (const TProofProgressStatus &st);  '+=' operator ;  ; TProofProgressStatus operator- (TProofProgressStatus &st);  '-' operator ;  ; TProofProgressStatus & operator-= (const TProofProgressStatus &st);  '-=' operator ;  ; void Print (Option_t *option="""") const override;  Dump the content. ;  ; void Reset ();  ; void SetBytesRead (Long64_t bytesRead);  ; void SetCPUTime (Double_t procTime);  ; void SetEntries (Long64_t entries);  ; void SetLastEntries (Long64_t entries);  ; void SetLastProcTime (Double_t procTime);  ; void SetLastUpdate (Double_t updtTime=0);  Update time stamp either with the passed value (if > 0) or with the current time. ;  ; void SetLearnTime (Double_t learnTime);  ; void SetProcTime (Double_t procTime);  ; void SetReadCalls (Long64_t readCalls);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressStatus.html:2723,learn,learnTime,2723,doc/master/classTProofProgressStatus.html,https://root.cern,https://root.cern/doc/master/classTProofProgressStatus.html,1,['learn'],['learnTime']
Usability,"5 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpreter);; 2129 fInterpreter->SetBit(kMustCleanup);; 2130 ; 2131 fgRootInit = kTRUE;; 2132 ; 2133 // initialize gClassTable is not already done; 2134 if (!gClassTable); 2135 new TClassTable;; 2136 ; 2137 // Initialize all registered dictionaries.; 2138 for (std::vector<ModuleHeaderInfo_t>::const_iterator; 2139 li = GetModuleHeaderInfoBuffer().begin(),; 2140 le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {; 2141 // process buffered module registrations; 2142 fInterpreter->RegisterModule(li->fModuleName,; 2143 li->fHeaders,; 2144 li->fIncludePaths,; 2145 li->fPayloadCode,; 2146 li->fFwdDeclCode,; 2147 li->fTriggerFunc,; 2148 li->fFwdNargsToKeepColl,; 2149 li->fClassesHeaders,; 2150 kTRUE /*lateRegistration*/,; 2151 li->fHasCxxModule);; 2152 }; 2153 GetModuleHeaderInfoBuffer().clear();; 2154 ; 2155 fInterpreter->Initialize();; 2156}; 2157 ; 2158////////////////////////////////////////////////////////////////////////////////; 2159/// Helper function used by TClass::GetClass().; 2160/// This function attempts to load the dictionary for 'classname'; 2161/// either from the TClassTable or from the list of generator.; 2162/// If silent is 'true', do not warn about missing dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:82177,clear,clear,82177,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['clear'],['clear']
Usability,"5 if (!closed) {; 5056 if (x[0] != x[npoints-1] || y[0] != y[npoints-1]) goto L40;; 5057 if (x[npoints-2] == x[npoints-1] && y[npoints-2] == y[npoints-1]) goto L40;; 5058 if (x[0] == x[1] && y[0] == y[1]) goto L40;; 5059 }; 5060 flgic = kFALSE;; 5061 flgis = kTRUE;; 5062 ; 5063 // flgic is true if the curve is open and false if it is closed.; 5064 // flgis is true in the main loop, but is false if there is; 5065 // a deviation from the main loop.; 5066 ; 5067 km = npoints - 1;; 5068 ; 5069 // Calculate direction cosines at P(1) using P(N-1),P(1),P(2).; 5070 ; 5071 goto L100;; 5072L40:; 5073 flgic = kTRUE;; 5074 flgis = kFALSE;; 5075 ; 5076 // Skip excessive consecutive equal points.; 5077 ; 5078L50:; 5079 if (k >= npoints) {; 5080 finished = 1; // Prepare to clear out remaining short vectors before returning; 5081 if (npt > 1) goto L310;; 5082 goto L390;; 5083 }; 5084 k++;; 5085 if (x[k-1] == x[k-2] && y[k-1] == y[k-2]) goto L50;; 5086L60:; 5087 km = k-1;; 5088 if (k > npoints) {; 5089 finished = 1; // Prepare to clear out remaining short vectors before returning; 5090 if (npt > 1) goto L310;; 5091 goto L390;; 5092 }; 5093 if (k < npoints) goto L90;; 5094 if (!flgic) { kp = 2; goto L130;}; 5095 ; 5096L80:; 5097 if (flgis) goto L150;; 5098 ; 5099 // Draw a straight line from P(k-1) to P(k).; 5100 ; 5101 finished = -1;; 5102 goto L170;; 5103 ; 5104 // Test whether P(k) is a cusp.; 5105 ; 5106L90:; 5107 if (x[k-1] == x[k] && y[k-1] == y[k]) goto L80;; 5108L100:; 5109 kp = k+1;; 5110 goto L130;; 5111 ; 5112 // Branch if the next section of the curve begins at a cusp.; 5113 ; 5114L110:; 5115 if (!flgis) goto L50;; 5116 ; 5117 // Carry forward the direction cosines from the previous arc.; 5118 ; 5119L120:; 5120 co = ct;; 5121 so = st;; 5122 k++;; 5123 goto L60;; 5124 ; 5125 // Calculate the direction cosines at P(k). If k=1 then; 5126 // N-1 is used for k-1. If k=N then 2 is used for k+1.; 5127 // direction cosines at P(k) obtained from P(k-1),P(k),P(k+1).; 5128 ; 5129L130",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:177801,clear,clear,177801,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['clear'],['clear']
Usability,"5,0.139,0.17,5);; f5->SetParameters(1000000,.25,2000,.1454,.001);; hdmd->Fit(""f5"",""lr"");. //create the canvas for tau d0; gStyle->SetOptFit(0);; gStyle->SetOptStat(1100);; TCanvas *c2 = new TCanvas(""c2"",""tauD0"",100,100,800,600);; c2->SetGrid();; c2->SetBottomMargin(0.15);. // Project slices of 2-d histogram h2 along X ,; // then fit each slice with function f2 and make a; // histogram for each fit parameter.; // Note that the generated histograms are added; // to the list of objects in the current directory. TF1 *f2 = new TF1(""f2"",fdm2,0.139,0.17,2);; f2->SetParameters(10000,10);; h2->FitSlicesX(f2,0,0,1,""qln"");; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; h2_1->GetXaxis()->SetTitle(""#tau[ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; TLine *line = new TLine(0,0,0,c2->GetUymax());; line->Draw();. // save the event list to a Root file if one was produced; if (fillList) {; TFile efile(""elist.root"",""recreate"");; elist->Write();; }; }; 22 Networking; In this chapter, you will learn how to send data over the network using the ROOT socket classes.; 22.1 Setting-up a Connection; On the serverside, we create a TServerSocket to wait for a connection request over the network. If the request is accepted, it returns a full-duplex socket. Once the connection is accepted, we can communicate to the client that we are ready to go by sending the string “go”, and we can close the server socket.; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; On the clientside, we create a socket and ask the socket to receive input.; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; 22.2 Sending Objects over the Network; We have just established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1097303,learn,learn,1097303,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learn']
Usability,"50130 124559; TDecayChannel Class describing a particle decay channel; TDecompBK Matrix Decomposition Bunch-Kaufman; TDecompBase Matrix Decomposition Base; TDecompChol Matrix Decompositition Cholesky; TDecompLU Matrix Decompositition LU; TDecompQRH Matrix Decompositition QRH; TDecompSVD Matrix Decompositition SVD; TDecompSparse Matrix Decompositition LU; TDialogCanvas A specialized canvas to set attributes.; TDiamond Diamond class; TDictionary ABC defining interface to dictionary; TDirectory Describe directory structure in memory; TDirectoryFile Describe directory structure in a ROOT file; TDocDirective THtml directive handler; TDocHtmlDirective Handler for ""Begin_Html""/""End_Html"" for raw HTML in documentation comments; TDocLatexDirective Handler for ""Begin_Latex""/""End_Latex"" to generate an image from latex; TDocMacroDirective Handler for ""Begin_Macro""/""End_Macro"" for code that is executed and that can generate an image for documentation; TDocOutput generates documentation web pages; TDocParser parser for reference documentation; TDrawFeedback Present PROOF query feedback; TELTU ELTU shape; TEditQueryFrame Edit query frame; TEfficiency calculating efficiencies; TEllipse An ellipse; TEmulatedCollectionProxy ; TEmulatedMapProxy ; TEntryList A list of entries in a TTree; TEntryListBlock Used internally in TEntryList to store the entry numbers; TEntryListFromFile Manager for entry lists from different files; TEnv Handle ROOT configuration resources; TEnvRec Individual TEnv records; TEve3DProjection 3D scaling ""projection""; TEveArrow Class for gl visualisation of arrow.; TEveArrowEditor GUI editor for TEveArrow.; TEveArrowGL GL renderer class for TEveArrow.; TEveBox 3D box with arbitrary vertices.; TEveBoxGL GL renderer class for TEveBox.; TEveBoxProjected Projection of TEveBox.; TEveBoxProjectedGL GL renderer class for TEveBoxProjected.; TEveBoxSet Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:56428,feedback,feedback,56428,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,['feedback'],['feedback']
Usability,"576 // process new version with new TFormula class which is contained in TF1; 3577 //printf(""reading TF1....- version %d..\n"",v);; 3578 ; 3579 if (v > 7) {; 3580 // new classes with new TFormula; 3581 // need to register the objects; 3582 b.ReadClassBuffer(TF1::Class(), this, v, R__s, R__c);; 3583 if (!TestBit(kNotGlobal)) {; 3584 R__LOCKGUARD(gROOTMutex);; 3585 gROOT->GetListOfFunctions()->Add(this);; 3586 }; 3587 return;; 3588 } else {; 3589 ROOT::v5::TF1Data fold;; 3590 //printf(""Reading TF1 as v5::TF1Data- version %d \n"",v);; 3591 fold.Streamer(b, v, R__s, R__c, TF1::Class());; 3592 // convert old TF1 to new one; 3593 ((TF1v5Convert *)this)->Convert(fold);; 3594 }; 3595 }; 3596 ; 3597 // Writing; 3598 else {; 3599 Int_t saved = 0;; 3600 // save not-formula functions as array of points; 3601 if (fType > 0 && fSave.empty() && fType != EFType::kCompositionFcn) {; 3602 saved = 1;; 3603 Save(fXmin, fXmax, 0, 0, 0, 0);; 3604 }; 3605 b.WriteClassBuffer(TF1::Class(), this);; 3606 ; 3607 // clear vector contents; 3608 if (saved) {; 3609 fSave.clear();; 3610 }; 3611 }; 3612}; 3613 ; 3614 ; 3615////////////////////////////////////////////////////////////////////////////////; 3616/// Called by functions such as SetRange, SetNpx, SetParameters; 3617/// to force the deletion of the associated histogram or Integral; 3618 ; 3619void TF1::Update(); 3620{; 3621 if (fHistogram) {; 3622 TString XAxisTitle = fHistogram->GetXaxis()->GetTitle();; 3623 TString YAxisTitle = fHistogram->GetYaxis()->GetTitle();; 3624 Int_t XLabCol = fHistogram->GetXaxis()->GetLabelColor();; 3625 Int_t YLabCol = fHistogram->GetYaxis()->GetLabelColor();; 3626 Int_t XLabFont = fHistogram->GetXaxis()->GetLabelFont();; 3627 Int_t YLabFont = fHistogram->GetYaxis()->GetLabelFont();; 3628 Float_t XLabOffset = fHistogram->GetXaxis()->GetLabelOffset();; 3629 Float_t YLabOffset = fHistogram->GetYaxis()->GetLabelOffset();; 3630 Float_t XLabSize = fHistogram->GetXaxis()->GetLabelSize();; 3631 Float_t YLabSize = fHistog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:137351,clear,clear,137351,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,"58 if(bin % (xbins*ybins) == 0) {; 1059 zbin++;; 1060 zvar->setVal(zaxis->GetBinCenter(zbin));; 1061 }; 1062 // fall through to next case...; 1063 case 2:; 1064 if(bin % xbins == 0) {; 1065 ybin= (ybin%ybins) + 1;; 1066 yvar->setVal(yaxis->GetBinCenter(ybin));; 1067 }; 1068 // fall through to next case...; 1069 case 1:; 1070 xbin= (xbin%xbins) + 1;; 1071 xvar->setVal(xaxis->GetBinCenter(xbin));; 1072 break;; 1073 default:; 1074 coutE(InputArguments) << ""RooAbsReal::fillHistogram: Internal Error!"" << std::endl;; 1075 break;; 1076 }; 1077 ; 1078 double result= scaleFactor*projected->getVal();; 1079 if (RooAbsReal::numEvalErrors()>0) {; 1080 coutW(Plotting) << ""WARNING: Function evaluation error(s) at coordinates [x]="" << xvar->getVal() ;; 1081 if (hdim==2) ccoutW(Plotting) << "" [y]="" << yvar->getVal() ;; 1082 if (hdim==3) ccoutW(Plotting) << "" [z]="" << zvar->getVal() ;; 1083 ccoutW(Plotting) << std::endl ;; 1084 // RooAbsReal::printEvalErrors(ccoutW(Plotting),10) ;; 1085 result = 0 ;; 1086 }; 1087 RooAbsReal::clearEvalErrorLog() ;; 1088 ; 1089 hist->SetBinContent(hist->GetBin(xbin,ybin,zbin),result);; 1090 if (setError) {; 1091 hist->SetBinError(hist->GetBin(xbin,ybin,zbin),sqrt(result)) ;; 1092 }; 1093 ; 1094 //cout << ""bin "" << bin << "" -> ("" << xbin << "","" << ybin << "","" << zbin << "") = "" << result << std::endl;; 1095 }; 1096 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;; 1097 ; 1098 // cleanup; 1099 delete cloneSet;; 1100 ; 1101 return hist;; 1102}; 1103 ; 1104 ; 1105 ; 1106////////////////////////////////////////////////////////////////////////////////; 1107/// Fill a RooDataHist with values sampled from this function at the; 1108/// bin centers. If extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:44092,clear,clearEvalErrorLog,44092,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['clearEvalErrorLog']
Usability,"5945 GetInfoImp();; 5946 ; 5947 if (!cl) {; 5948 return;; 5949 }; 5950 ; 5951 if (!mother->GetAddress()) {; 5952 // -- Our top-level branch has no address.; 5953 bool motherStatus = mother->TestBit(kDoNotProcess);; 5954 mother->ResetBit(kDoNotProcess);; 5955 // Note: This will allocate an object.; 5956 mother->SetAddress(nullptr);; 5957 mother->SetBit(kDoNotProcess, motherStatus);; 5958 }; 5959}; 5960 ; 5961////////////////////////////////////////////////////////////////////////////////; 5962/// Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // some",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:223783,clear,clear,223783,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"5] = 4 ;; ; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class SBPyramid : public Shape; {; public:; SBPyramid(Int_t color, Double_t d, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~SBPyramid() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Base half lengths dX,dY; // Pyr. height dZ; ; ClassDefOverride(SBPyramid,0);; };; ; ClassImp(SBPyramid);; ; SBPyramid::SBPyramid(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & SBPyramid::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLength[3] = { fDX, fDY, fDZ/2.0 };; Double_t origin[3] = { fX , fY, fZ + halfLength[2]};; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // No kShapeSpecific section; ; // Complete kRawSizes section; if (reqSections & TBuffer3D::kRawSizes) {; buffer.SetRawSizes(5, 3*5, 8, 3*8, 5, 6 + 4*5);; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; // Complete kRaw section; if (reqSections & TBuffer3D::kRaw) {; // Points (5); // 3 components: x,y,z; buffer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:9924,simpl,simple,9924,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['simpl'],['simple']
Usability,"6 ; 1447More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; 1448(e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`.; 1449 ; 1450\anchor rdf-from-spec; 1451### Creating an RDataFrame from a dataset specification file; 1452 ; 1453RDataFrame can be created using a dataset specification JSON file: ; 1454 ; 1455~~~{.python}; 1456import ROOT; 1457 ; 1458df = ROOT.RDF.Experimental.FromSpec(""spec.json""); 1459~~~; 1460 ; 1461The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; 1462their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1463required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1464sample in the ""metadata"" key.; 1465 ; 1466A simple example for the formatting of the specification in the JSON file is the following:; 1467 ; 1468~~~{.cpp}; 1469{; 1470 ""samples"": {; 1471 ""sampleA"": {; 1472 ""trees"": [""tree1"", ""tree2""],; 1473 ""files"": [""file1.root"", ""file2.root""],; 1474 ""metadata"": {; 1475 ""lumi"": 10000.0, ; 1476 ""xsec"": 1.0,; 1477 ""sample_category"" = ""data""; 1478 }; 1479 },; 1480 ""sampleB"": {; 1481 ""trees"": [""tree3"", ""tree4""],; 1482 ""files"": [""file3.root"", ""file4.root""],; 1483 ""metadata"": {; 1484 ""lumi"": 0.5, ; 1485 ""xsec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:84088,simpl,simple,84088,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"6 ; 1487More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; 1488(e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`.; 1489 ; 1490\anchor rdf-from-spec; 1491### Creating an RDataFrame from a dataset specification file; 1492 ; 1493RDataFrame can be created using a dataset specification JSON file: ; 1494 ; 1495~~~{.python}; 1496import ROOT; 1497 ; 1498df = ROOT.RDF.Experimental.FromSpec(""spec.json""); 1499~~~; 1500 ; 1501The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; 1502their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1503required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1504sample in the ""metadata"" key.; 1505 ; 1506A simple example for the formatting of the specification in the JSON file is the following:; 1507 ; 1508~~~{.cpp}; 1509{; 1510 ""samples"": {; 1511 ""sampleA"": {; 1512 ""trees"": [""tree1"", ""tree2""],; 1513 ""files"": [""file1.root"", ""file2.root""],; 1514 ""metadata"": {; 1515 ""lumi"": 10000.0, ; 1516 ""xsec"": 1.0,; 1517 ""sample_category"" = ""data""; 1518 }; 1519 },; 1520 ""sampleB"": {; 1521 ""trees"": [""tree3"", ""tree4""],; 1522 ""files"": [""file3.root"", ""file4.root""],; 1523 ""metadata"": {; 1524 ""lumi"": 0.5, ; 1525 ""xsec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:85768,simpl,simple,85768,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"6 ; 777 ; 778 ; 779 ; 780 ; 781 virtual void testSample (double /*error*/, double /*output*/, double /*target*/, double /*weight*/) {} ///< virtual function to be used for monitoring (callback); 782 virtual void startTrainCycle () ///< callback for monitoring and logging; 783 {; 784 m_convergenceCount = 0;; 785 m_maxConvergenceCount= 0;; 786 m_minError = 1e10;; 787 }; 788 virtual void endTrainCycle (double /*error*/) {} ///< callback for monitoring and logging; 789 ; 790 virtual void setProgressLimits (double minProgress = 0, double maxProgress = 100) ///< for monitoring and logging (set the current ""progress"" limits for the display of the progress) \param minProgress minimum value \param maxProgress maximum value; 791 {; 792 m_minProgress = minProgress;; 793 m_maxProgress = maxProgress;; 794 }; 795 virtual void startTraining () ///< start drawing the progress bar; 796 {; 797 m_timer.DrawProgressBar (Int_t(m_minProgress));; 798 }; 799 virtual void cycle (double progress, TString text) ///< advance on the progress bar \param progress the new value \param text a label; 800 {; 801 m_timer.DrawProgressBar (Int_t(m_minProgress+(m_maxProgress-m_minProgress)*(progress/100.0)), text);; 802 }; 803 ; 804 virtual void startTestCycle () {} ///< callback for monitoring and loggging; 805 virtual void endTestCycle () {} ///< callback for monitoring and loggging; 806 virtual void testIteration () {} ///< callback for monitoring and loggging; 807 virtual void drawSample (const std::vector<double>& /*input*/, const std::vector<double>& /* output */, const std::vector<double>& /* target */, double /* patternWeight */) {} ///< callback for monitoring and logging; 808 ; 809 virtual void computeResult (const Net& /* net */, std::vector<double>& /* weights */) {} ///< callback for monitoring and logging; 810 ; 811 virtual bool hasConverged (double testError); ///< has this training converged already?; 812 ; 813 EnumRegularization regularization () const { return m_regularization; } ///< s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:29271,progress bar,progress bar,29271,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress bar']
Usability,"6 else Error(where, ""Y must have N+1 values with option N"");; 2127 return;; 2128 }; 2129 gywork[npt-1] = y[i-1] + 0.5*(y[i]-y[i-1]);; 2130 }; 2131 gxwork[npt-1] = x[i-1];; 2132 ComputeLogs(npt, optionZ);; 2133 if ((gxworkl[npt] < uxmin) || (gxworkl[npt] > uxmax)) {; 2134 if (npt > 2) {; 2135 ComputeLogs(npt, optionZ);; 2136 Smooth(theGraph, npt,gxworkl.data(),gyworkl.data(),drawtype);; 2137 }; 2138 gxwork[0] = gxwork[npt-1];; 2139 gywork[0] = gywork[npt-1];; 2140 npt = 1;; 2141 continue;; 2142 }; 2143 if (npt >= fgMaxPointsPerLine) {; 2144 ComputeLogs(fgMaxPointsPerLine, optionZ);; 2145 Smooth(theGraph, fgMaxPointsPerLine,gxworkl.data(),gyworkl.data(),drawtype);; 2146 gxwork[0] = gxwork[npt-1];; 2147 gywork[0] = gywork[npt-1];; 2148 npt = 1;; 2149 }; 2150 } //endfor (i=first; i<=last;i++); 2151 if (npt > 1) {; 2152 ComputeLogs(npt, optionZ);; 2153 Smooth(theGraph, npt,gxworkl.data(),gyworkl.data(),drawtype);; 2154 }; 2155 }; 2156 }; 2157 ; 2158 // Draw the histogram with a simple line; 2159 ; 2160 if (optionLine) {; 2161 gPad->SetBit(TGraph::kClipFrame);; 2162 wminstep = wmin + 0.5*delta;; 2163 Axis_t ax1,ax2,ay1,ay2;; 2164 gPad->GetRangeAxis(ax1,ay1,ax2,ay2);; 2165 ; 2166 if (!optionRot) {; 2167 npt = 0;; 2168 for (i=first; i<=last;i++) {; 2169 npt++;; 2170 if (!optionBins) {; 2171 gxwork[npt-1] = wmin+(i-first)*delta+0.5*delta;; 2172 } else {; 2173 xi1 = x[i]; xi = x[i-1];; 2174 if (xi1 < xi) {; 2175 if (i != last) Error(where, ""X must be in increasing order"");; 2176 else Error(where, ""X must have N+1 values with option N"");; 2177 return;; 2178 }; 2179 gxwork[npt-1] = x[i-1] + 0.5*(x[i]-x[i-1]);; 2180 }; 2181 if (gxwork[npt-1] < uxmin || gxwork[npt-1] > uxmax) { npt--; continue;}; 2182 gywork[npt-1] = y[i-1];; 2183 gywork[npt] = y[i-1]; //new; 2184 if ((gywork[npt-1] < rwymin) || ((gywork[npt-1] > rwymax) && !optionFill2)) {; 2185 if (npt > 2) {; 2186 ComputeLogs(npt, optionZ);; 2187 gPad->PaintPolyLine(npt,gxworkl.data(),gyworkl.data());; 2188 }; 2189 gxwork[0] = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:78722,simpl,simple,78722,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"60 degrees to phi2. ; Definition at line 27 of file TCONS.h. Public Member Functions;  TCONS ();  CONS shape default constructor. ;  ;  TCONS (const char *name, const char *title, const char *material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2, Float_t phi1, Float_t phi2);  CONS shape normal constructor. ;  ;  TCONS (const char *name, const char *title, const char *material, Float_t rmax1, Float_t dz, Float_t phi1, Float_t phi2, Float_t rmax2=0);  CONS shape normal constructor. ;  ;  ~TCONS () override;  CONS shape default destructor. ;  ; virtual Float_t GetRmax2 () const;  ; virtual Float_t GetRmin2 () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBS;  TTUBS ();  TUBS shape default constructor. ;  ;  TTUBS (const char *name, const char *title, const char *material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2);  TUBS shape ""simplified"" constructor. ;  ;  TTUBS (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2);  TUBS shape normal constructor. ;  ;  ~TTUBS () override;  TUBS shape default destructor. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a TUBE. ;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections) const override;  Get buffer 3d. ;  ; virtual Float_t GetPhi1 () const;  ; virtual Float_t GetPhi2 () const;  ; TClass * IsA () const override;  ; void Sizeof3D () const override;  Return total X3D needed by TNode::ls (when called with option ""x"") ;  ; void Streamer (TBuffer &) override;  Stream an object of class TTUBE. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBE;  TTUBE ();  TUBE shape default constructor. ;  ;  TTUBE (const char *name, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONS.html:1840,simpl,simplified,1840,doc/master/classTCONS.html,https://root.cern,https://root.cern/doc/master/classTCONS.html,1,['simpl'],['simplified']
Usability,"61/**; 262 Param Functor class for Multidimensional functions.; 263 It is used to wrap in a very simple and convenient way; 264 any other C++ callable object (implementation double operator( const double *, const double * ) ); 265 or a member function with the correct signature,; 266 like Foo::EvalPar(const double *, const double *); 267 ; 268 @ingroup ParamFunc; 269 ; 270 */; 271 ; 272 ; 273template<class T>; 274class ParamFunctorTempl {; 275 ; 276 ; 277public:; 278 ; 279 typedef T EvalType;; 280 typedef ParamFunctionBase<T> Impl;; 281 ; 282 ; 283 /**; 284 Default constructor; 285 */; 286 ParamFunctorTempl () : fImpl(nullptr) {}; 287 ; 288 ; 289 /**; 290 construct from a pointer to member function (multi-dim type); 291 */; 292 template <class PtrObj, typename MemFn>; 293 ParamFunctorTempl(const PtrObj& p, MemFn memFn); 294 : fImpl(new ParamMemFunHandler<ParamFunctorTempl<T>, PtrObj, MemFn>(p, memFn)); 295 {}; 296 ; 297 ; 298 ; 299 /**; 300 construct from another generic Functor of multi-dimension; 301 */; 302 template <typename Func>; 303 explicit ParamFunctorTempl( const Func & f) :; 304 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>,Func>(f) ); 305 {}; 306 ; 307 ; 308 ; 309 // specialization used in TF1; 310 typedef T (* FreeFunc ) (T * , double *);; 311 ParamFunctorTempl(FreeFunc f) :; 312 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>,FreeFunc>(f) ); 313 {; 314 }; 315 ; 316 // specialization used in TF1; 317 ParamFunctorTempl(const std::function<T(const T *f, const Double_t *param)> &func) :; 318 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>, const std::function<T(const T *f, const Double_t *param)>>(func)); 319 {; 320 }; 321 ; 322 /**; 323 Destructor (no operations); 324 */; 325 virtual ~ParamFunctorTempl () {; 326 if (fImpl) delete fImpl;; 327 }; 328 ; 329 /**; 330 Copy constructor; 331 */; 332 ParamFunctorTempl(const ParamFunctorTempl & rhs) :; 333 fImpl(nullptr); 334 {; 335// if (rhs.fImpl.get() != 0); 336// fImpl = std::unique_ptr<Impl>( (rhs.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ParamFunctor_8h_source.html:7582,simpl,simple,7582,doc/master/ParamFunctor_8h_source.html,https://root.cern,https://root.cern/doc/master/ParamFunctor_8h_source.html,1,['simpl'],['simple']
Usability,"611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::first,; 615 T::next,; 616 T::construct,; 617 T::destruct,; 618 T::feed,; 619 T::collect,; 620 T::Env_t::Create);; 621 }; 622 ; 623 };; 624 ; 625 // This specialization is chosen if T is a vector<bool, A>, irrespective of the nature; 626 // of the allocator A represents.; 627 template <class A> struct TCollectionProxyInfo::Type<std::vector<Bool_t, A>>; 628 : public TCollectionProxyInfo::Address<typename std::vector<Bool_t, A>::const_reference>; 629 {; 630 typedef std::vector<Bool_t, A> Cont_t;; 631 typedef typename Cont_t::iterator Iter_t;; 632 typedef typename Cont_t::value_type Value_t;; 633 typedef Environ<Iter_t> Env_t;; 634 typedef Env_t *PEnv_t;; 635 typedef Cont_t *PCont_t;; 636 typedef Value_t *PValue_t;; 637 ; 638 virtual ~Type() {}; 639 ; 640 static inline PCont_t object(void* ptr) {; 641 return PCont_t(PEnv_t(ptr)->fObject);; 642 }; 643 static void* size(void* env) {; 644 PEnv_t e = PEnv_t(env);; 645 e->fSize = PCont_t(e->fObject)->size();; 646 return &e->fSize;; 647 }; 648 static void* clear(void* env) {; 649 object(env)->clear();; 650 return nullptr;; 651 }; 652 static void* first(void* env) {; 653 PEnv_t e = PEnv_t(env);; 654 PCont_t c = PCont_t(e->fObject);; 655#if 0; 656 // Assume iterators do not need destruction; 657 ::new(e->buff) Iter_t(c->begin());; 658#endif; 659 e->fIterator = c->begin();; 660 e->fSize = c->size();; 661 return nullptr;; 662 }; 663 static void* next(void* env) {; 664 PEnv_t e = PEnv_t(env);; 665 PCont_t c = PCont_t(e->fObject);; 666 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 667 // TODO: Need to find something for going backwards....; 668 return nullptr;; 669 }; 670 static void* construct(void*,size_t) {; 671 // Nothing to construct.; 672 return nullptr;; 673 }; 674 static void* collect(void *coll, void *array) {; 675 PCont_t c = PCont_t(coll);; 676 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 677 for (Iter_t i=c->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:22451,clear,clear,22451,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,2,['clear'],['clear']
Usability,"615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105735,clear,clear,105735,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"63 of file DeepNet.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t & ; input, . const Matrix_t & ; groundTruth, . const Matrix_t & ; weights, . bool ; inTraining = false, . bool ; includeRegularization = true . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . EOutputFunction ; f . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . Tensor_t & ; input, . EOutputFunction ; f . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. ◆ RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. ◆ ResetTraining(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::ResetTraining. Function that reset some training flags after looping all the events but not the weights. ; Definition at line 886 of file DeepNet.h. ◆ SetBatchDepth(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . void TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::SetBatchDept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:25005,learn,learned,25005,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['learn'],['learned']
Usability,"64 x 64 channels, with marks; (red circles) and blue grid.; References:; [1] Morh�č M., Kliman J., Matou�ek V., Turzo I.,; Sophisticated visualization algorithms for analysis of multidimensional; experimental nuclear data, Acta Physica Slovaca 54 (2004) 385.; [2] D. Hearn, M. P. Baker: Computer Graphics, Prentice Hall International,; Inc. 1994.; Script:. Example to draw source spectrum (class TSpectrum2Painter).; To execute this example, do; root > .x VisA.C; #include ""TSpectrum2Painter.h""; void VisA() {; �� TFile *f = new TFile(""TSpectrum2.root"");; �� TH2F *graph=(TH2F*) f->Get(""graph2;1"");; �� TCanvas *Graph2 = new TCanvas(""Graph2"",""Illustration of 2D graphics"",10,10,1000,700);; �� graph->Draw(""SPEC"");; }. void SetDisplayMode(Int_t modeGroup, Int_t displayMode); Sets display group mode and display mode:; -modeGroup - the following group modes can be set: simple modes-kPicture2ModeGroupSimple, modes with shading according to light-kPicture2ModeGroupLight, modes with shading according to channels counts-kPicture2ModeGroupHeight, modes of combination of shading according to light and to channels counts-kPicture2ModeGroupLightHeight; -displayMode - posible display modes are: points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles. void SetPenAttr(Int_t color, Int_t style, Int_t width); Sets pen attributes:; -color - color of spectrum; -style - style of pen (solid, dash, dot, dash-dot); -width - width of pen in pixels. void SetNodes(Int_t nodesx, Int_t nodesy); Sets nodes in both directions:; -nodesx, nodesy, only the bins at the nodes points are displayed. void SetAngles(Int_t alpha, Int_t beta, Int_t view); Sets angles of the view:; -alpha - angles of display,alpha+beta must be less or equal to 90, alpha- angle between base line of Canvas and right lower edge of picture base plane; -beta - angle between base line of Canvas and left lower edge of picture base plane; -view - rotation angle of the view, it can be 0, 90, 180, 270 degree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:27945,simpl,simple,27945,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,10,['simpl'],['simple']
Usability,"64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Learn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25377,learn,learning,25377,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"65 //====process old versions before automatic schema evolution; 966 Int_t nlevels;; 967 TF1::Streamer(R__b);; 968 if (R__v < 3) {; 969 Float_t ymin,ymax;; 970 R__b >> ymin; fYmin = ymin;; 971 R__b >> ymax; fYmax = ymax;; 972 } else {; 973 R__b >> fYmin;; 974 R__b >> fYmax;; 975 }; 976 R__b >> fNpy;; 977 R__b >> nlevels;; 978 if (R__v < 3) {; 979 Float_t *contour = nullptr;; 980 Int_t n = R__b.ReadArray(contour);; 981 fContour.Set(n);; 982 for (Int_t i=0;i<n;i++) fContour.fArray[i] = contour[i];; 983 delete [] contour;; 984 } else {; 985 fContour.Streamer(R__b);; 986 }; 987 R__b.CheckByteCount(R__s, R__c, TF2::IsA());; 988 //====end of old versions; 989 ; 990 } else {; 991 Int_t saved = 0;; 992 if (fType != EFType::kFormula && fSave.empty()) { saved = 1; Save(fXmin,fXmax,fYmin,fYmax,0,0);}; 993 ; 994 R__b.WriteClassBuffer(TF2::Class(),this);; 995 ; 996 if (saved) {fSave.clear(); }; 997 }; 998}; 999 ; 1000////////////////////////////////////////////////////////////////////////////////; 1001/// Return x^nx * y^ny moment of a 2d function in range [ax,bx],[ay,by]; 1002/// \author Gene Van Buren <gene@bnl.gov>; 1003 ; 1004Double_t TF2::Moment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon); 1005{; 1006 Double_t norm = Integral(ax,bx,ay,by,epsilon);; 1007 if (norm == 0) {; 1008 Error(""Moment2"", ""Integral zero over range"");; 1009 return 0;; 1010 }; 1011 ; 1012 // define integrand function as a lambda : g(x,y)= x^(nx) * y^(ny) * f(x,y); 1013 auto integrand = [&](double *x, double *) {; 1014 return std::pow(x[0], nx) * std::pow(x[1], ny) * this->EvalPar(x, nullptr);; 1015 };; 1016 // compute integral of g(x,y); 1017 TF2 fnc(""TF2_ExpValHelper"",integrand,ax,bx,ay,by,0);; 1018 // set same points as current function to get correct max points when computing the integral; 1019 fnc.fNpx = fNpx;; 1020 fnc.fNpy = fNpy;; 1021 return fnc.Integral(ax,bx,ay,by,epsilon)/norm;; 1022}; 1023 ; 1024///////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:34499,clear,clear,34499,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['clear'],['clear']
Usability,"679 if (fLogLike) {; 1680 fNumericDerivatives = kTRUE;; 1681 nx = fNED2;; 1682 k1 -= 2;; 1683 }; 1684 ; 1685 for (i=0;i<nx;i++){; 1686 ki += 1+i;; 1687 x[i] = fEXDA[ki];; 1688 }; 1689 // Double_t y = ARITHM(df,x);; 1690 Double_t y = EvalTFN(df,x);; 1691 if(fNumericDerivatives) Derivatives(df,x);; 1692 Double_t sig=1.;; 1693 if(fLogLike) { // Likelihood method; 1694 if(y>0.) {; 1695 fS = fS - log(y);; 1696 y = -y;; 1697 sig= y;; 1698 } else { //; 1699 delete [] x;; 1700 delete [] df;; 1701 fS = 1e10;; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:48926,simpl,simple,48926,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['simpl'],['simple']
Usability,"7 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173180,clear,clear,173180,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"7 of file TProfile3D.h. ◆ GetBinSumw2() [1/2]. virtual TArrayD * TProfile3D::GetBinSumw2 ; (; ). inlinevirtual . Definition at line 120 of file TProfile3D.h. ◆ GetBinSumw2() [2/2]. virtual const TArrayD * TProfile3D::GetBinSumw2 ; (; ); const. inlinevirtual . Definition at line 121 of file TProfile3D.h. ◆ GetErrorOption(). Option_t * TProfile3D::GetErrorOption ; (; ); const. Return option to compute profile2D errors. ; Definition at line 753 of file TProfile3D.cxx. ◆ GetStats(). void TProfile3D::GetStats ; (; Double_t * ; stats); const. overridevirtual . fill the array stats from the contents of this profile. ; The array stats must be correctly dimensioned in the calling program. stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2; stats[9] = sumwxz; stats[10]= sumwyz; stats[11]= sumwt; stats[12]= sumwt2. If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time. If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range. ; Reimplemented from TH3.; Definition at line 785 of file TProfile3D.cxx. ◆ GetTmax(). virtual Double_t TProfile3D::GetTmax ; (; ); const. inlinevirtual . Definition at line 125 of file TProfile3D.h. ◆ GetTmin(). virtual Double_t TProfile3D::GetTmin ; (; ); const. inlinevirtual . Definition at line 124 of file TProfile3D.h. ◆ GetW(). Double_t * TProfile3D::GetW ; (; ). inlineprivate . Definition at line 75 of file TProfile3D.h. ◆ GetW2(). Double_t * TProfile3D::GetW2 ; (; ). inlineprivate . Definition at line 76 of file TProfile3D.h. ◆ IsA(). TClass * TProfile3D::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TH3D.; Definition at line 150 of file TProfile3D.h. ◆ LabelsDeflate(). void TProfile3D::LabelsDeflate ; (; Option_t * ; axis = ""X""). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:91165,simpl,simply,91165,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['simpl'],['simply']
Usability,"72 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isSmall() && this->Owns()); 582 free(this->begin());; 583 }; 584 ; 585 // also give up adopted memory if applicable; 586 void clear(); 587 {; 588 if (this->Owns()) {; 589 this->destroy_range(this->begin(), this->end());; 590 this->fSize = 0;; 591 } else {; 592 this->resetToSmall();; 593 }; 594 }; 595 ; 596 void resize(size_type N); 597 {; 598 if (N < this->size()) {; 599 if (this->Owns()); 600 this->destroy_range(this->begin() + N, this->end());; 601 this->set_size(N);; 602 } else if (N > this->size()) {; 603 if (this->capacity() < N); 604 this->grow(N);; 605 for (auto I = this->end(), E = this->begin() + N; I != E; ++I); 606 new (&*I) T();; 607 this->set_size(N);; 608 }; 609 }; 610 ; 611 void resize(size_type N, const T &NV); 612 {; 613 if (N < this->size()) {; 614 if (this->Owns()); 615 this->destroy_range(this->begin() + N, this->end());; 616 this->set_size(N);; 617 } else if (N > this->size()) {; 618 if (this->capacity() < N); 619 this->grow(N);; 620 std::uninitialized_fill(this->end(), this->begin() + N, NV);; 621 this->set_size(N);; 622 }; 623 }; 624 ; 625 void reserve(size_type N); 626 {; 627 if (this->capacity() < N); 628 this->grow(N);; 629 }; 630 ; 631 void pop_back_n(size_type NumItems); 632 {; 633 if (this->size() < NumItems) {; 634 throw std::runtime_error(""Popping back more elements than those available."");; 635 }; 636 if (this->Owns()); 637 this->destroy_range(this->end() - NumItems, this->end());; 638 this->set_size(this->size() - NumItems);; 639 }; 640 ; 641 R__RVEC_NODISCARD T pop_back_val(); 642 {; 643 T Result = ::std::move(this->back());; 644 this->pop_back();; 645 return Result;; 646 }; 647 ; 648 void swap(RVecI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:21639,clear,clear,21639,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['clear'],['clear']
Usability,"785 Double_t w = GetBinContent(binx,biny,binz);; 7786 np+=w;; 7787 sum+=w*(x-mean)*(x-mean)*(x-mean)*(x-mean);; 7788 }; 7789 }; 7790 }; 7791 sum/=(np*stddev4);; 7792 return sum-3;; 7793 ; 7794 } else if (axis > 10 && axis <= 13) {; 7795 //compute standard error of skewness; 7796 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7797 Double_t neff = GetEffectiveEntries();; 7798 return ( neff > 0 ? TMath::Sqrt(24./neff ) : 0. );; 7799 }; 7800 else {; 7801 Error(""GetKurtosis"", ""illegal value of parameter"");; 7802 return 0;; 7803 }; 7804}; 7805 ; 7806////////////////////////////////////////////////////////////////////////////////; 7807/// fill the array stats from the contents of this histogram; 7808/// The array stats must be correctly dimensioned in the calling program.; 7809///; 7810/// ~~~ {.cpp}; 7811/// stats[0] = sumw; 7812/// stats[1] = sumw2; 7813/// stats[2] = sumwx; 7814/// stats[3] = sumwx2; 7815/// ~~~; 7816///; 7817/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 7818/// is simply a copy of the statistics quantities computed at filling time.; 7819/// If a sub-range is specified, the function recomputes these quantities; 7820/// from the bin contents in the current axis range.; 7821///; 7822/// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; 7823/// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; 7824/// otherwise, they are a copy of the histogram statistics computed at fill time,; 7825/// which are unbinned by default (calling TH1::ResetStats forces them to use; 7826/// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; 7827///; 7828/// Note that the mean value/StdDev is computed using the bins in the currently; 7829/// defined range (see TAxis::SetRange). By default the range includes; 7830/// all bins from 1 to nbins included, excluding underflows and overflows.; 7831/// To force the un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:306192,simpl,simply,306192,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simply']
Usability,"7}; 1678 ; 1679/////////////////////////////////////////////////////////////////////////////////; 1680/// Produce list of node ids for given stack; 1681/// If found nodes preselected - use their ids; 1682 ; 1683std::vector<int> RGeomDescription::MakeIdsByStack(const std::vector<int> &stack); 1684{; 1685 TLockGuard lock(fMutex);; 1686 ; 1687 std::vector<int> ids;; 1688 ; 1689 ids.emplace_back(0);; 1690 int nodeid = 0;; 1691 bool failure = false;; 1692 ; 1693 for (auto s : stack) {; 1694 auto &chlds = fDesc[nodeid].chlds;; 1695 if (s >= (int)chlds.size()) {; 1696 failure = true;; 1697 break;; 1698 }; 1699 ; 1700 ids.emplace_back(chlds[s]);; 1701 ; 1702 nodeid = chlds[s];; 1703 }; 1704 ; 1705 if (failure) {; 1706 printf(""Fail to convert stack into list of nodes\n"");; 1707 ids.clear();; 1708 }; 1709 ; 1710 return ids;; 1711}; 1712 ; 1713/////////////////////////////////////////////////////////////////////////////////; 1714/// Returns path string for provided stack; 1715 ; 1716std::vector<std::string> RGeomDescription::MakePathByStack(const std::vector<int> &stack); 1717{; 1718 TLockGuard lock(fMutex);; 1719 ; 1720 std::vector<std::string> path;; 1721 ; 1722 auto ids = MakeIdsByStack(stack);; 1723 path.reserve(ids.size());; 1724for (auto &id : ids); 1725 path.emplace_back(fDesc[id].name);; 1726 ; 1727 return path;; 1728}; 1729 ; 1730/////////////////////////////////////////////////////////////////////////////////; 1731/// Return string with only part of nodes description which were modified; 1732/// Checks also volume; 1733 ; 1734std::string RGeomDescription::ProduceModifyReply(int nodeid); 1735{; 1736 TLockGuard lock(fMutex);; 1737 ; 1738 std::vector<RGeomNodeBase *> nodes;; 1739 auto vol = GetVolume(nodeid);; 1740 ; 1741 // we take not only single node, but all there same volume is referenced; 1742 // nodes.push_back(&fDesc[nodeid]);; 1743 ; 1744 int id = 0;; 1745 for (auto &desc : fDesc); 1746 if (GetVolume(id++) == vol); 1747 nodes.emplace_back(&desc);; 1748 ; 1749 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:51689,clear,clear,51689,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"838 ; 839////////////////////////////////////////////////////////////////////////////////; 840/// Check if specified version string is correct and build version vector.; 841 ; 842Bool_t TSchemaRule::ProcessVersion( const TString& version ) const; 843{; 844 //---------------------------------------------------------------------------; 845 // Check if we have valid list; 846 /////////////////////////////////////////////////////////////////////////////; 847 ; 848 if( version[0] != '[' || version[version.Length()-1] != ']' ); 849 return kFALSE;; 850 std::string ver = version.Data();; 851 ; 852 std::list<std::string> versions;; 853 Internal::TSchemaRuleProcessor::SplitList( ver.substr( 1, ver.size()-2), versions );; 854 ; 855 if( versions.empty() ); 856 {; 857 delete fVersionVect;; 858 fVersionVect = nullptr;; 859 return kFALSE;; 860 }; 861 ; 862 if( !fVersionVect ); 863 fVersionVect = new std::vector<std::pair<Int_t, Int_t> >;; 864 fVersionVect->clear();; 865 ; 866 //---------------------------------------------------------------------------; 867 // Check the validity of each list element; 868 /////////////////////////////////////////////////////////////////////////////; 869 ; 870 std::list<std::string>::iterator it;; 871 for( it = versions.begin(); it != versions.end(); ++it ) {; 872 std::pair<Int_t, Int_t> verpair;; 873 if( !Internal::TSchemaRuleProcessor::ProcessVersion( *it, verpair ) ); 874 {; 875 delete fVersionVect;; 876 fVersionVect = nullptr;; 877 return kFALSE;; 878 }; 879 fVersionVect->push_back( verpair );; 880 }; 881 return kTRUE;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Check if specified checksum string is correct and build checksum vector.; 886 ; 887Bool_t TSchemaRule::ProcessChecksum( const TString& checksum ) const; 888{; 889 //---------------------------------------------------------------------------; 890 // Check if we have valid list; 891 ////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:28055,clear,clear,28055,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['clear'],['clear']
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TCanvas::cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCanvas::Clear(Option_t* option = """"); virtual voidTCanvas::Cleared(TVirtualPad* pad)SIGNAL ; voidTCanvas::ClearPadSave(); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); virtual Int_tTPad::ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); virtual Int_tTPad::ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TInspectCanvas.html:1460,Clear,Clear,1460,root/html532/TInspectCanvas.html,https://root.cern,https://root.cern/root/html532/TInspectCanvas.html,6,['Clear'],"['Clear', 'ClearPadSave', 'Cleared']"
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TCanvas::cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCanvas::Clear(Option_t* option = """"); virtual voidTCanvas::Cleared(TVirtualPad* pad)SIGNAL ; voidTCanvas::ClearPadSave(); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); virtual Int_tTPad::ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); virtual Int_tTPad::ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInspectCanvas.html:1419,Clear,Clear,1419,root/html602/TInspectCanvas.html,https://root.cern,https://root.cern/root/html602/TInspectCanvas.html,6,['Clear'],"['Clear', 'ClearPadSave', 'Cleared']"
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TPad::cd(Int_t subpadnumber = 0)MENU ; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPad::Clear(Option_t* option = """"); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGroupButton.html:1821,Clear,Clear,1821,root/html532/TGroupButton.html,https://root.cern,https://root.cern/root/html532/TGroupButton.html,2,['Clear'],['Clear']
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TPad::cd(Int_t subpadnumber = 0)MENU ; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPad::Clear(Option_t* option = """"); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); virtual Int_tTPad::ClippingCode(Double_t x, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGroupButton.html:1692,Clear,Clear,1692,root/html602/TGroupButton.html,https://root.cern,https://root.cern/root/html602/TGroupButton.html,2,['Clear'],['Clear']
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TPad::cd(Int_t subpadnumber = 0)MENU ; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPad::Clear(Option_t* option = """"); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); virtual Int_tTPad::ClippingCode(Double_t x, Double_t y, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePad.html:1683,Clear,Clear,1683,root/html532/TEvePad.html,https://root.cern,https://root.cern/root/html532/TEvePad.html,2,['Clear'],['Clear']
Usability,"88, const char* title = """")MENU ; virtual TVirtualPad*TPad::cd(Int_t subpadnumber = 0)MENU ; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPad::Clear(Option_t* option = """"); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); virtual Int_tTPad::Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); virtual Int_tTPad::ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); virtual Int_tTPad::ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePad.html:1513,Clear,Clear,1513,root/html602/TEvePad.html,https://root.cern,https://root.cern/root/html602/TEvePad.html,2,['Clear'],['Clear']
Usability,"88, const char* title = """")MENU ; virtual voidBuildStandardButtons(); virtual TVirtualPad*TCanvas::cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCanvas::Clear(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDialogCanvas.html:1988,Clear,Clear,1988,root/html532/TDialogCanvas.html,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html,3,['Clear'],"['Clear', 'ClearPadSave', 'Cleared']"
Usability,"88, const char* title = """")MENU ; virtual voidBuildStandardButtons(); virtual TVirtualPad*TCanvas::cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCanvas::Clear(Option_t* option = """"); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDialogCanvas.html:1958,Clear,Clear,1958,root/html534/TDialogCanvas.html,https://root.cern,https://root.cern/root/html534/TDialogCanvas.html,3,['Clear'],"['Clear', 'ClearPadSave', 'Cleared']"
Usability,"88, const char* title = """")MENU ; virtual voidBuildStandardButtons(); virtual TVirtualPad*TCanvas::cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCanvas::Clear(Option_t* option = """"); virtual voidTCanvas::Cleared(TVirtualPad* pad)SIGNAL ; voidTCanvas::ClearPadSave(); virtual Int_tTPad::Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDialogCanvas.html:1784,Clear,Clear,1784,root/html602/TDialogCanvas.html,https://root.cern,https://root.cern/root/html602/TDialogCanvas.html,6,['Clear'],"['Clear', 'ClearPadSave', 'Cleared']"
Usability,"9, TString options = """"); virtual~TFeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFeldmanCousins.html:1933,Clear,Clear,1933,root/html532/TFeldmanCousins.html,https://root.cern,https://root.cern/root/html532/TFeldmanCousins.html,2,['Clear'],['Clear']
Usability,"94 he was in charge of the Application Software group in the computing division. In 1995, at a time when the majority of software gurus had decided to follow a dead-end line, he created the ROOT system while working for the NA49 heavy ion experiment at the SPS. Rene has led the ROOT project from 1995-2010.; ; . Fons Rademakers ; ; Fons received his Ph.D. in particle physics from the Univ. of Amsterdam in 1991 for his work on event displays and data analysis for the DELPHI experiment at CERN's LEP collider. Since then he has worked at CERN and been involved in designing and developing data analysis programs. In 1991 he joined the PAW project where he developed the column wise-ntuples (a column-oriented storage system) and PIAF, a parallel data analysis system. In 1995, while working as Linux evangelist for Hewlett-Packard at CERN, he started with Rene Brun the ROOT project and has been involved in all aspects of the system since then. In 2001 Fons joined the ALICE collaboration and has worked as software architect on the initial version of the AliRoot framework. In recent years his special attention has gone to high performance parallel computing using PROOF. Fons took over from Rene Brun as ROOT project leader in 2011 and has led the project till 2014, culminating in the release of ROOT 6.; ; . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/project-founders.html:4071,guid,guidelines,4071,d/project-founders.html,https://root.cern,https://root.cern/d/project-founders.html,1,['guid'],['guidelines']
Usability,"94 of file PiecewiseInterpolation.cxx. ◆ setInterpCode(). void PiecewiseInterpolation::setInterpCode ; (; RooAbsReal & ; param, . int ; code, . bool ; silent = false . ). Definition at line 567 of file PiecewiseInterpolation.cxx. ◆ setPositiveDefinite(). void PiecewiseInterpolation::setPositiveDefinite ; (; bool ; flag = true). inline . Definition at line 61 of file PiecewiseInterpolation.h. ◆ Streamer(). void PiecewiseInterpolation::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class PiecewiseInterpolation. ; Reimplemented from TObject.; Definition at line 629 of file PiecewiseInterpolation.cxx. ◆ StreamerNVirtual(). void PiecewiseInterpolation::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 105 of file PiecewiseInterpolation.h. ◆ translate(). void PiecewiseInterpolation::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 187 of file PiecewiseInterpolation.cxx. Member Data Documentation. ◆ _highSet. RooListProxy PiecewiseInterpolation::_highSet. protected . High-side variation. ; Definition at line 95 of file PiecewiseInterpolation.h. ◆ _interpCode. std::vector<int> PiecewiseInterpolation::_interpCode. protected . Definition at line 100 of file PiecewiseInterpolation.h. ◆ _lowSet. RooListProxy PiecewiseInterpolation::_lowSet. protected . Low-si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:69657,simpl,simple,69657,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['simpl'],['simple']
Usability,"96 // Booking Seed; 2297 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2298 ; 2299 // Train/Test/Evaluation; 2300 TrainAllMethods();; 2301 TestAllMethods();; 2302 EvaluateAllMethods();; 2303 ; 2304 // getting ROC; 2305 ROC[x] = GetROCIntegral(xbitset.to_string(), methodTitle);; 2306 ; 2307 // cleaning information to process sub-seeds; 2308 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2309 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2310 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2311 delete sresults;; 2312 delete seedloader;; 2313 this->DeleteAllMethods();; 2314 ; 2315 fMethodsMap.clear();; 2316 // removing global result because it is requiring a lot of RAM for all seeds; 2317 }; 2318 ; 2319 for (x = 0; x < range; x++) {; 2320 SROC = ROC[x];; 2321 for (uint32_t i = 0; i < VIBITS; ++i) {; 2322 if (x & (uint64_t(1) << i)) {; 2323 y = x & ~(1 << i);; 2324 std::bitset<VIBITS> ybitset(y);; 2325 // need at least one variable; 2326 // NOTE: if sub-seed is zero then is the special case; 2327 // that count in xbitset is 1; 2328 uint32_t ny = static_cast<uint32_t>( log(x - y) / 0.693147 ) ;; 2329 if (y == 0) {; 2330 importances[ny] = SROC - 0.5;; 2331 continue;; 2332 }; 2333 ; 2334 // getting ROC; 2335 SSROC = ROC[y];; 2336 importances[ny] += SROC - SSROC;; 2337 // cleaning information; 2338 }; 2339 }; 2340 }; 2341 std::cout << ""--- Variable Importance Results (All)"" << std::endl;; 2342 return GetImportance(nbits, importances, varNames);; 2343}; 2344 ; 2345static uint64_t sum(uint64_t i); 2346{; 2347 // add a limit for overflows; 2348 if (i > 62) return 0;; 2349 return static_cast<uint64_t>( std::pow(2, i + 1)) - 1;; 2350 // uint64_t _sum = 0;; 2351 // for (uint64_t n = 0; n < i; n++); 2352 // _sum += pow(2, n);; 2353 // return _sum;; 2354}; 2355 ; 2356/////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:97340,clear,clear,97340,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"97372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:21961,simpl,simply,21961,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"99// -----------------------------------------------------; 7400// UNKNOWN COMMAND; 7401L1900:; 7402 Printf("" THE COMMAND:%10s IS UNKNOWN."",(const char*)fCword);; 7403 goto L2100;; 7404// -----------------------------------------------------; 7405// HELP SHOW, HELP SET, SHOW SET, or SHOW SHOW; 7406L2000:; 7407 ckind = ""SET "";; 7408 ctemp2 = fCword(3,7);; 7409 if (strcmp(ctemp2.Data(), ""SHO"")) ckind = ""SHOW"";; 7410L2100:; 7411 Printf("" THE FORMAT OF THE %4s COMMAND IS:"",(const char*)ckind);; 7412 Printf("" %s xxx [numerical arguments if any]"",(const char*)ckind);; 7413 Printf("" WHERE xxx MAY BE ONE OF THE FOLLOWING:"");; 7414 for (kk = 1; kk <= nname; ++kk) {; 7415 Printf("" %s"",cname[kk-1]);; 7416 }; 7417 return;; 7418// -----------------------------------------------------; 7419// ILLEGAL COMMAND; 7420L3000:; 7421 Printf("" ABOVE COMMAND IS ILLEGAL. IGNORED"");; 7422 ; 7423}; 7424 ; 7425////////////////////////////////////////////////////////////////////////////////; 7426/// Minimization using the simplex method of Nelder and Mead; 7427///; 7428/// Performs a minimization using the simplex method of Nelder; 7429/// and Mead (ref. -- Comp. J. 7,308 (1965)).; 7430 ; 7431void TMinuit::mnsimp(); 7432{; 7433 /* Initialized data */; 7434 ; 7435 static constexpr Double_t alpha = 1;; 7436 static constexpr Double_t beta = .5;; 7437 static constexpr Double_t gamma = 2;; 7438 static constexpr Double_t rhomin = 4;; 7439 static constexpr Double_t rhomax = 8;; 7440 ; 7441 /* Local variables */; 7442 Double_t dmin_, dxdi, yrho, f, ynpp1, aming, ypbar;; 7443 Double_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:237636,simpl,simplex,237636,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,['simpl'],['simplex']
Usability,"9999999999999998E-8, Double_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrack.html:1189,Clear,Clear,1189,root/html602/TGeoTrack.html,https://root.cern,https://root.cern/root/html602/TGeoTrack.html,2,['Clear'],['Clear']
Usability,": array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFumili.html:18083,SIMpl,SIMplex,18083,root/html532/TFumili.html,https://root.cern,https://root.cern/root/html532/TFumili.html,2,['SIMpl'],['SIMplex']
Usability,": column \"""" + colName + ""\"" is being used as "";; 421 if (tName.empty()) {; 422 errMsg += requestedType.name();; 423 errMsg += "" (extracted from type info)"";; 424 } else {; 425 errMsg += tName;; 426 }; 427 errMsg += "" but the Define or Vary node advertises it as "";; 428 if (colTypeName.empty()) {; 429 auto &id = colType;; 430 errMsg += id.name();; 431 errMsg += "" (extracted from type info)"";; 432 } else {; 433 errMsg += colTypeName;; 434 }; 435 throw std::runtime_error(errMsg);; 436 }; 437}; 438 ; 439bool IsStrInVec(const std::string &str, const std::vector<std::string> &vec); 440{; 441 return std::find(vec.cbegin(), vec.cend(), str) != vec.cend();; 442}; 443 ; 444auto RStringCache::Insert(const std::string &string) -> decltype(fStrings)::const_iterator; 445{; 446 {; 447 std::shared_lock l{fMutex};; 448 if (auto it = fStrings.find(string); it != fStrings.end()); 449 return it;; 450 }; 451 ; 452 // TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; 453 // but that is unfortunately not usable outside the already available ROOT mutexes; 454 std::unique_lock l{fMutex};; 455 if (auto it = fStrings.find(string); it != fStrings.end()); 456 return it;; 457 ; 458 return fStrings.insert(string).first;; 459}; 460} // end NS RDF; 461} // end NS Internal; 462} // end NS ROOT; RDataSource.hxx; RDefineBase.hxx; RLogger.hxx; R__LOG_DEBUG#define R__LOG_DEBUG(DEBUGLEVEL,...)Definition RLogger.hxx:365; RLoopManager.hxx; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TBranchElement.h; TBranch.h; TClassEdit.h; TClassRef.h; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFUtils_8cxx_source.html:18151,usab,usable,18151,doc/master/RDFUtils_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html,1,['usab'],['usable']
Usability,": determines resolution of the neighbouring peaks default value is 1 correspond to 3 sigma distance between peaks. ; Higher values allow higher resolution (smaller distance between peaks. May be set later through SetResolution. ; Definition at line 229 of file TSpectrum3.cxx. ◆ SmoothMarkov(). const char * TSpectrum3::SmoothMarkov ; (; Double_t *** ; source, . Int_t ; ssizex, . Int_t ; ssizey, . Int_t ; ssizez, . Int_t ; averWindow . ). This function calculates smoothed spectrum from source spectrum based on Markov chain method. ; The result is placed in the array pointed by spectrum pointer.; Function parameters:; source-pointer to the array of source spectrum; working_space-pointer to the working array; ssizex-x length of spectrum and working space arrays; ssizey-y length of spectrum and working space arrays; ssizey-z length of spectrum and working space arrays; averWindow-width of averaging smoothing window. Smoothing; Goal: Suppression of statistical fluctuations the algorithm is based on discrete Markov chain, which has very simple invariant distribution. \[; U_2 = \frac{p_{1.2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2 U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1} ... U_2 U_1; \]. \(U_1\) being defined from the normalization condition \( \sum_{i=1}^{n} U_i = 1\) n is the length of the smoothed spectrum and ; \[; p_{i,i\pm1} = A_i \sum_{k=1}^{m} exp\left[\frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; \]. is the probability of the change of the peak position from channel i to the channel i+1. \(A_i\) is the normalization constant so that \( p_{i,i-1}+p_{i,i+1}=1\) and m is a width of smoothing window. We have extended this algorithm to three dimensions.; Reference:; [1] Z.K. Silagadze, A new algorithm for automatic photo-peak searches. NIM A 376 (1996), 451-. Example 1 - script SmootMarkov3.c :. Fig. 1 Original noisy spectrum. Fig. 2 Smoothed spectrum with averaging window m=3.; Script:; Example to illustrate the Markov smoothing (class TSpectrum3). To",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum3.html:41820,simpl,simple,41820,doc/master/classTSpectrum3.html,https://root.cern,https://root.cern/doc/master/classTSpectrum3.html,1,['simpl'],['simple']
Usability,": invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected. /*; ; */. Special functions. By default, the formula is assigned fNumber=0. However, the following; formula built with simple functions are assigned fNumber:; ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation; at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:18656,simpl,simple,18656,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,6,['simpl'],['simple']
Usability,":(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfDebugDebug level; TPythia8*fPythia8Pointer to pythia8. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia8Decayer(); constructor. void Init(); Initialize the decayer. void Decay(Int_t pdg, TLorentzVector* p); Decay a single particle. Int_t ImportParticles(TClonesArray* particles); import the decay products into particles array. void SetForceDecay(Int_t type); Set forced decay mode. void ForceDecay(); ForceDecay not yet implemented. Float_t GetPartialBranchingRatio(Int_t ipart). Float_t GetLifetime(Int_t kf); return lifetime in seconds of teh particle with PDG number pdg. void ReadDecayTable(); to read a decay table (not yet implemented). void AppendParticle(Int_t pdg, TLorentzVector* p); Append a particle to the stack. void ClearEvent(); Clear the event stack. TPythia8Decayer(). virtual ~TPythia8Decayer(); {;}. void SetDebugLevel(Int_t debug); {fDebug = debug;}. » Author: Andreas Morsch 04/07/2008 » Copyright (c) 1998-2008, ALICE Experiment at CERN, All rights reserved. *; » Last changed: root/pythia8:$Name$:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPythia8Decayer.html:6814,Clear,ClearEvent,6814,root/html604/TPythia8Decayer.html,https://root.cern,https://root.cern/root/html604/TPythia8Decayer.html,2,['Clear'],"['Clear', 'ClearEvent']"
Usability,":(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfDebugDebug level; TPythia8*fPythia8Pointer to pythia8. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia8Decayer(); constructor. void Init(); Initialize the decayer. void Decay(Int_t pdg, TLorentzVector* p); Decay a single particle. Int_t ImportParticles(TClonesArray* particles); import the decay products into particles array. void SetForceDecay(Int_t type); Set forced decay mode. void ForceDecay(); ForceDecay not yet implemented. Float_t GetPartialBranchingRatio(Int_t ipart). Float_t GetLifetime(Int_t kf); return lifetime in seconds of teh particle with PDG number pdg. void ReadDecayTable(); to read a decay table (not yet implemented). void AppendParticle(Int_t pdg, TLorentzVector* p); Append a particle to the stack. void ClearEvent(); Clear the event stack. TPythia8Decayer(). virtual ~TPythia8Decayer(); {;}. void SetDebugLevel(Int_t debug); {fDebug = debug;}. » Author: Andreas Morsch 04/07/2008 » Copyright (c) 1998-2008, ALICE Experiment at CERN, All rights reserved. *; » Last changed: root/pythia8:$Name$:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPythia8Decayer.html:6814,Clear,ClearEvent,6814,root/html602/TPythia8Decayer.html,https://root.cern,https://root.cern/root/html602/TPythia8Decayer.html,2,['Clear'],"['Clear', 'ClearEvent']"
Usability,":(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter(const char* name, const char* title = ""Generic Interpreter""); TInterpreter ctor only called by derived classes. TInterpreter * Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). Bool_t SetSuspendAutoParsing(Bool_t value). Bool_t IsAutoParsingSuspended() const. TInterpreter(); { }. TInterpreter(const char* name, const char* title = ""Generic Interpreter""). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). void * SetAutoLoadCallBack(void* ); { return 0; }. void * GetAutoLoadCallBack() const; { return 0; }. Int_t AutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoParse(const char* cls). void ClearFileBusy(). void ClearStack(). Bool_t Declare(const char* code). void EnableAutoLoading(). void EndOfLineAction(). TClass * GetClass(const type_info& typeinfo, Bool_t load) const. Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. TClass * GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:26058,Clear,ClearFileBusy,26058,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Clear'],['ClearFileBusy']
Usability,":. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable; RooRealVar*_wgtVarPointer to weight variable (if set); static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:19313,Clear,Clear,19313,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['Clear'],['Clear']
Usability,":. TStringfGetterName! buffer for name of getter method; TStringfSetterName! buffer for name of setter method; TXMLSetupfXmlSetup! buffer for xml names convertion. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXMLPlayer(); default constructor. ~TXMLPlayer(); destructor of TXMLPlayer object. TString GetStreamerName(TClass* cl); returns streamer function name for given class. Bool_t ProduceCode(TList* cllist, const char* filename); Produce streamers for provide class list; TList should include list of classes, for which code should be generated.; filename specify name of file (without extension), where streamers should be; created. Function produces two files: header file and source file.; For instance, if filename is ""streamers"", files ""streamers.h"" and ""streamers.cxx""; will be created. TString GetMemberTypeName(TDataMember* member); returns name of simple data type for given data member. TString GetBasicTypeName(TStreamerElement* el); return simple data types for given TStreamerElement object. TString GetBasicTypeReaderMethodName(Int_t type, const char* realname); return functions name to read simple data type from xml file. const char* ElementGetter(TClass* cl, const char* membername, int specials = 0); produce code to access member of given class.; Parameter specials has following meaning:; 0 - nothing special; 1 - cast to data type; 2 - produce pointer on given member; 3 - skip casting when produce pointer by buf.P() function. const char* ElementSetter(TClass* cl, const char* membername, char* endch); Produce code to set value to given data member.; endch should be output after value is specified. void ProduceStreamerSource(ostream& fs, TClass* cl, TList* cllist); Produce source code of streamer function for specified class. void ReadSTLarg(ostream& fs, TString& argname, int argtyp, Bool_t isargptr, TClass* argcl, TString& tname, TString& ifcond); Produce code to read argument of stl container from xml file. void Writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLPlayer.html:10342,simpl,simple,10342,root/html528/TXMLPlayer.html,https://root.cern,https://root.cern/root/html528/TXMLPlayer.html,6,['simpl'],['simple']
Usability,"::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLockable::ELockTGLLockable::kModifyLock; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TGLViewer::ESecSelTypeTGLViewer::kOnKeyMod1; static TGLViewer::ESecSelTypeTGLViewer::kOnRequest; static TObject::(anonymous)TObject::kOverwrite; static TGLViewer::EPushActionTGLViewer::kPushAnnotate; static TGLViewer::EPushActionTGLViewer::kPushCamCenter; static TGLViewer::EPushActionTGLViewer::kPushStd; static TGLLockable::ELockTGLLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLEmbeddedViewer.html:21466,guid,guides,21466,root/html602/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html,8,['guid'],['guides']
Usability,"::AbstractMethod(const char* method) const; virtual Int_tTVirtualX::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); static intCoinFlag(); virtual const QColor&ColorIndex(Color_t indx) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t widt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGQt.html:1534,Clear,Clear,1534,root/html534/TGQt.html,https://root.cern,https://root.cern/root/html534/TGQt.html,1,['Clear'],['Clear']
Usability,"::AbstractMethod(const char* method) const; virtual Int_tTVirtualX::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); static intCoinFlag(); virtual const QColor&ColorIndex(Color_t indx) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual voidCopyPixmap(const QPixmap& p, Int_t px1, Int_t py1); virtual Pix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:1461,Clear,Clear,1461,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,2,['Clear'],['Clear']
Usability,"::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tTEveWindow::CanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidTEveWindow::ClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*TEveWindow::CreateDefaultWindowSlot(); static TEveWindowSlot*TEveWindow::CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); static TEveWindowSlot*TEveWindow::CreateWindowMainFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveViewer.html:2813,Clear,ClearEveFrame,2813,root/html532/TEveViewer.html,https://root.cern,https://root.cern/root/html532/TEveViewer.html,12,['Clear'],['ClearEveFrame']
Usability,"::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearNewEventCommands(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidClose(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveEventManager.html:2438,Clear,ClearStamps,2438,root/html532/TEveEventManager.html,https://root.cern,https://root.cern/root/html532/TEveEventManager.html,4,['Clear'],['ClearStamps']
Usability,"::AppendPad(Option_t* option = """"); TGraph*Approx(TGraph* grin, Option_t* option = ""linear"", Int_t nout = 50, Double_t* xout = 0, Double_t yleft = 0, Double_t yright = 0, Int_t rule = 0, Double_t f = 0, Option_t* ties = ""mean""); static Double_tApprox1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); voidApproxin(TGraph* grin, Int_t iKind, Double_t& Ylow, Double_t& Yhigh, Int_t rule, Int_t iTies); static voidBDRksmooth(Double_t* x, Double_t* y, Int_t n, Double_t* xp, Double_t* yp, Int_t np, Int_t kernel, Double_t bw); static voidBDRsmooth(Int_t n, Double_t* x, Double_t* y, Double_t* w, Double_t span, Int_t iper, Double_t vsmlsq, Double_t* smo, Double_t* acvr); static voidBDRsupsmu(Int_t n, Double_t* x, Double_t* y, Double_t* w, Int_t iper, Double_t span, Double_t alpha, Double_t* smo, Double_t* sc); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphSmooth.html:1592,Clear,Clear,1592,root/html532/TGraphSmooth.html,https://root.cern,https://root.cern/root/html532/TGraphSmooth.html,4,['Clear'],['Clear']
Usability,"::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; Int_tTProof::DeactivateWorker(const char* ord); static voidTProof::DelEnvVar(const char* name); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:2385,Clear,ClearPackages,2385,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,2,['Clear'],['ClearPackages']
Usability,"::DNN::Steepest::operator() ; (; Function & ; fitnessFunction, . Weights & ; weights, . PassThrough & ; passThrough . ). operator to call the steepest gradient descent algorithm ; implementation of the steepest gradient descent algorithm; entry point to start the minimization procedure; Parameters. fitnessFunction(templated) function which has to be provided. This function is minimized ; weights(templated) a reference to a container of weights. The result of the minimization procedure is returned via this reference (needs to support std::begin and std::end ; passThrough(templated) object which can hold any data which the fitness function needs. This object is not touched by the minimizer; This object is provided to the fitness function when called. Can be used with multithreading (i.e. ""HogWild!"" style); see call in trainCycle ; Definition at line 271 of file NeuralNet.icc. Member Data Documentation. ◆ m_alpha. double TMVA::DNN::Steepest::m_alpha. internal parameter (learningRate) ; Definition at line 371 of file NeuralNet.h. ◆ m_beta. double TMVA::DNN::Steepest::m_beta. internal parameter (momentum) ; Definition at line 372 of file NeuralNet.h. ◆ m_localGradients. std::vector<double> TMVA::DNN::Steepest::m_localGradients. local gradients for reuse in thread. ; Definition at line 376 of file NeuralNet.h. ◆ m_localWeights. std::vector<double> TMVA::DNN::Steepest::m_localWeights. local weights for reuse in thread. ; Definition at line 375 of file NeuralNet.h. ◆ m_prevGradients. std::vector<double> TMVA::DNN::Steepest::m_prevGradients. vector remembers the gradients of the previous step ; Definition at line 373 of file NeuralNet.h. ◆ m_repetitions. size_t TMVA::DNN::Steepest::m_repetitions. Definition at line 337 of file NeuralNet.h. Libraries for TMVA::DNN::Steepest:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/NeuralNet.h; tmva/tmva/inc/TMVA/NeuralNet.icc. TMVADNNSteepest. ROOT master - Reference Guide Genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html:2766,learn,learningRate,2766,doc/master/classTMVA_1_1DNN_1_1Steepest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Steepest.html,1,['learn'],['learningRate']
Usability,"::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:4467,clear,clear,4467,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,2,['clear'],['clear']
Usability,"::DestroyWindow(); voidDisableOpen(Bool_t disable = kTRUE); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(const char* class_name, const char* signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidDrawActive(Handle_t id, TGListTreeItem* item); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidDrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); virtual voidDrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::Emi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTree.html:5050,clear,clear,5050,root/html528/TGListTree.html,https://root.cern,https://root.cern/root/html528/TGListTree.html,6,['clear'],['clear']
Usability,"::DestroyWindow(); voidDisableOpen(Bool_t disable = kTRUE); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(const char* class_name, const char* signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidDrawActive(Handle_t id, TGListTreeItem* item); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidDrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 12303291, Bool_t clear = kFALSE); virtual voidDrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::Emi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListTree.html:4868,clear,clear,4868,root/html602/TGListTree.html,https://root.cern,https://root.cern/root/html602/TGListTree.html,4,['clear'],['clear']
Usability,"::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a variable or function).; In contrast, in compiled code, you can use:; TTree *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584872,Simpl,Simple,584872,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,::EContext_tkCXX_ScopeProto; static TTabCom::(anonymous)kDebug; static TTabCom::EContext_tkNUM_PAT; static TTabCom::EContext_tkROOT_Load; static TTabCom::EContext_tkSYS_EnvVar; static TTabCom::EContext_tkSYS_FileName; static TTabCom::EContext_tkSYS_UserName; static TTabCom::EContext_tkUNKNOWN_CONTEXT. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. v,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:7598,Clear,ClearClasses,7598,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,4,['Clear'],"['Clear', 'ClearClasses']"
Usability,::EDataSetkTraining; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentTree! index of the current tree in a chain; Double_tfCurrentTreeWeight! weight of the current tree in a chain; TTree*fData! pointer to the tree used as datasource; Double_tfDelta! Delta - used in stochastic minimisation - Default=0.; Double_tfEpsilon! Epsilon - used in stochastic minimisation - Default=0.; Double_tfEta! Eta - used in stochastic minimisation - Default=0.1; Double_tfEtaDecay! EtaDecay - Eta *= EtaDecay at each epoch - Default=1.; TTreeFormula*fEventWeight! formula representing the event weight; TObjArrayfFirstLayerCollection of the input neurons; subset of fNetwork; Double_tfLastAlpha! internal parameter used in line search; TObjArrayfLastLayerCollection of the output neurons; subset of fNetwork; TMultiLayerPerceptron::ELearningMethodfLearningMethod! The Learning Method; TTreeFormulaManager*fManager! TTreeFormulaManager for the weight and neurons; TObjArrayfNetworkCollection of all the neurons in the network; TNeuron::ENeuronTypefOutTypeType of output neurons; Int_tfReset! number of epochs between two resets of the search direction to the steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentati,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiLayerPerceptron.html:18583,Learn,Learning,18583,root/html602/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html602/TMultiLayerPerceptron.html,2,['Learn'],['Learning']
Usability,"::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:4491,simpl,simple,4491,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,2,['simpl'],['simple']
Usability,"::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualCollectionProxy.html:4940,simpl,simple,4940,root/html602/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html,4,['simpl'],['simple']
Usability,"::GSLMultiRootFinder::kDNewton with name ""DNewton"": discrete Newton algorithm . ROOT::Math::GSLMultiRootFinder::kBroyden with name ""Broyden"": Broyden algorithm . Definition at line 95 of file GSLMultiRootFinder.h. Public Types; enum  EDerivType { kHybridSJ; , kHybridJ; , kNewton; , kGNewton; };  enumeration specifying the types of GSL multi root finders requiring the derivatives More...;  ; enum  EType { kHybridS; , kHybrid; , kDNewton; , kBroyden; };  enumeration specifying the types of GSL multi root finders which do not require the derivatives More...;  . Public Member Functions;  GSLMultiRootFinder (const char *name=nullptr);  ;  GSLMultiRootFinder (const GSLMultiRootFinder &)=delete;  ;  GSLMultiRootFinder (EDerivType type);  create a multi-root finder based on an algorithm requiring function derivative ;  ;  GSLMultiRootFinder (EType type);  create a multi-root finder based on an algorithm not requiring function derivative ;  ;  GSLMultiRootFinder (GSLMultiRootFinder &&)=delete;  ; virtual ~GSLMultiRootFinder ();  destructor ;  ; int AddFunction (const ROOT::Math::IMultiGenFunction &func);  ; template<class Function > ; int AddFunction (Function &f, int ndim);  same method as before but using any function implementing the operator(), so can be wrapped in a IMultiGenFunction interface ;  ; void Clear ();  clear list of functions ;  ; unsigned int Dim () const;  return the number of sunctions set in the class. ;  ; const double * Dx () const;  return the last step size ;  ; const double * FVal () const;  return the function values f(X) solving the system i.e. ;  ; int Iterations () const;  Return number of iterations. ;  ; const char * Name () const;  Return the algorithm name used for solving Note the name is available only after having called solved Otherwise an empyty string is returned. ;  ; GSLMultiRootFinder & operator= (const GSLMultiRootFinder &)=delete;  ; GSLMultiRootFinder & operator= (GSLMultiRootFinder &&)=delete;  ; int PrintLevel () const;  return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html:3325,clear,clear,3325,doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"::GetOption() const; virtual voidTProofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; static Long_tTProofServ::GetResMemMax(); const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; static Long_tTProofServ::GetVirtMemMax(); const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionTProofServ::GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidTProofServ::HandleException(Int_t sig); virtual voidHandleFork(TMessage* mess); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidTProofServ::HandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServLite.html:7408,resume,resume,7408,root/html530/TProofServLite.html,https://root.cern,https://root.cern/root/html530/TProofServLite.html,3,['resume'],['resume']
Usability,"::GetRedo ; (; ); const. inline . Definition at line 75 of file TQCommand.h. ◆ GetRedoArgs(). Long_t * TQCommand::GetRedoArgs ; (; ); const. Returns a pointer to array of redo arguments. ; Definition at line 752 of file TQCommand.cxx. ◆ GetRedoName(). const char * TQCommand::GetRedoName ; (; ); const. Returns the name of redo command. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at line 76 of file TQCommand.h. ◆ GetUndoArgs(). Long_t * TQCommand::GetUndoArgs ; (; ); const. Returns a pointer to array of undo arguments. ; Definition at line 760 of file TQCommand.cxx. ◆ GetUndoName(). const char * TQCommand::GetUndoName ; (; ); const. Returns the name of undo command. ; Definition at line 744 of file TQCommand.cxx. ◆ Init(). void TQCommand::Init ; (; const char * ; cl, . void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:39061,undo,undo,39061,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:429554,learn,learning,429554,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrack.html:3044,Clear,ClearStamps,3044,root/html534/TEveTrack.html,https://root.cern,https://root.cern/root/html534/TEveTrack.html,3,['Clear'],['ClearStamps']
Usability,"::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTEveTrack::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackProjected.html:2693,Clear,ClearStamps,2693,root/html534/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html,3,['Clear'],['ClearStamps']
Usability,"::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLineProjected.html:2581,Clear,ClearStamps,2581,root/html534/TEveLineProjected.html,https://root.cern,https://root.cern/root/html534/TEveLineProjected.html,3,['Clear'],['ClearStamps']
Usability,"::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. TMVA::IFitterTarget*fFitness; doublefMinValue; ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; ROOT::Math::GeneticMinimizerParametersfParameters; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int i = 0); GeneticMinimizer (int = 0);. virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool SetFixedVariable(unsigned int ivar, const string& name, double val). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetRandomSeed(int seed); { fParameters.fSeed = seed; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. » Last changed: root/mathcore:$Id » Last generated: 2015-09-08 16:59; This page has been automatically",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html:5485,Clear,Clear,5485,root/html534/ROOT__Math__GeneticMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html,1,['Clear'],['Clear']
Usability,"::Notify, itself called by TRef::GetObject. ; The function reads the branch containing the object referenced by the TRef. ; Reimplemented from TObject.; Definition at line 115 of file TBranchRef.cxx. ◆ Print(). void TBranchRef::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the TRefTable branch. ; Reimplemented from TBranch.; Definition at line 159 of file TBranchRef.cxx. ◆ ReadLeavesImpl(). void TBranchRef::ReadLeavesImpl ; (; TBuffer & ; b). protected . This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. ; Definition at line 167 of file TBranchRef.cxx. ◆ Reset(). void TBranchRef::Reset ; (; Option_t * ; option = """"). overridevirtual . Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. . Reimplemented from TBranch.; Definition at line 187 of file TBranchRef.cxx. ◆ ResetAfterMerge(). void TBranchRef::ResetAfterMerge ; (; TFileMergeInfo * ; info). overridevirtual . Reset a Branch after a Merge operation (drop data but keep customizations) TRefTable is cleared. ; Reimplemented from TBranch.; Definition at line 198 of file TBranchRef.cxx. ◆ SetParent(). Int_t TBranchRef::SetParent ; (; const TObject * ; object, . Int_t ; branchID . ). virtual . Set the current parent branch. ; This function is called by TBranchElement::GetEntry() and TBranchElement::Fill() when reading or writing branches that may contain referenced objects. ; Definition at line 212 of file TBranchRef.cxx. ◆ SetRequestedEntry(). virtual void TBranchRef::SetRequestedEntry ; (; Long64_t ; entry). inlinevirtual . Definition at line 55 of file TBranchRef.h. ◆ Streamer(). void TBranchRef::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TBranch. ◆ StreamerNVirtual(). void TBranchRef::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 60 of file TBranchRef.h. Member Data Documentation. ◆ fRefTable. TRefTable* TBranchRef::fRefTable. protected . pointer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:31458,clear,cleared,31458,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,1,['clear'],['cleared']
Usability,"::RNTupleImporter::InitDestination(std::string_view destFileName); 131{; 132 fDestFileName = destFileName;; 133 fDestFile = std::unique_ptr<TFile>(TFile::Open(fDestFileName.c_str(), ""UPDATE""));; 134 if (!fDestFile || fDestFile->IsZombie()) {; 135 return R__FAIL(""cannot open dest file "" + std::string(fDestFileName));; 136 }; 137 ; 138 return RResult<void>::Success();; 139}; 140 ; 141void ROOT::Experimental::RNTupleImporter::ReportSchema(); 142{; 143 for (const auto &f : fImportFields) {; 144 std::cout << ""Importing '"" << f.fField->GetFieldName() << ""' ["" << f.fField->GetTypeName() << ""]\n"";; 145 }; 146 for (const auto &f : Internal::GetProjectedFieldsOfModel(*fModel).GetFieldZero().GetSubFields()) {; 147 std::cout << ""Importing (projected) '"" << f->GetFieldName() << ""' ["" << f->GetTypeName() << ""]\n"";; 148 }; 149}; 150 ; 151void ROOT::Experimental::RNTupleImporter::ResetSchema(); 152{; 153 fImportBranches.clear();; 154 fImportFields.clear();; 155 fLeafCountCollections.clear();; 156 fImportTransformations.clear();; 157 fModel = RNTupleModel::CreateBare();; 158 fEntry = nullptr;; 159}; 160 ; 161ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::PrepareSchema(); 162{; 163 ResetSchema();; 164 ; 165 // Browse through all branches and their leaves, create corresponding fields and prepare the memory buffers for; 166 // reading and writing. Usually, reading and writing share the same memory buffer, i.e. the object is read from TTree; 167 // and written as-is to the RNTuple. There are exceptions, e.g. for leaf count arrays and C strings.; 168 for (auto b : TRangeDynCast<TBranch>(*fSourceTree->GetListOfBranches())) {; 169 assert(b);; 170 const auto firstLeaf = static_cast<TLeaf *>(b->GetListOfLeaves()->First());; 171 assert(firstLeaf);; 172 ; 173 const bool isLeafList = b->GetNleaves() > 1;; 174 const bool isCountLeaf = firstLeaf->IsRange(); // A leaf storing the number of elements of a leaf count array; 175 const bool isClass = (firstLeaf->IsA() == TLeafEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html:6155,clear,clear,6155,doc/master/RNTupleImporter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html,1,['clear'],['clear']
Usability,"::RNTupleModel::GetDescriptionconst std::string & GetDescription() constDefinition RNTupleModel.hxx:386; ROOT::Experimental::RNTupleModel::AddFieldvoid AddField(std::unique_ptr< RFieldBase > field)Adds a field whose type is not known at compile time.Definition RNTupleModel.cxx:312; ROOT::Experimental::RNTupleModel::RegisterSubfieldvoid RegisterSubfield(std::string_view qualifiedFieldName)Register a subfield so it can be accessed directly from entries belonging to the model.Definition RNTupleModel.cxx:335; ROOT::Experimental::RNTupleModel::operator=RNTupleModel & operator=(const RNTupleModel &)=delete; ROOT::Experimental::RNTupleModel::~RNTupleModel~RNTupleModel()=default; ROOT::Experimental::RNTupleModel::fIsFrozenbool fIsFrozenChanged by Freeze() / Unfreeze() and by the RUpdater.Definition RNTupleModel.hxx:215; ROOT::Experimental::RNTupleModel::Unfreezevoid Unfreeze()Definition RNTupleModel.cxx:493; ROOT::Experimental::RNTupleModel::fFieldZerostd::unique_ptr< RFieldZero > fFieldZeroHierarchy of fields consisting of simple types and collections (sub trees)Definition RNTupleModel.hxx:198; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RResultThe class is used as a return type for operations that can fail; wraps a value of type T or an RError...Definition RError.hxx:194; ROOT::Experimental::Internal::GetProjectedFieldsOfModelRProjectedFields & GetProjectedFieldsOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:42; ROOT::Experimental::Internal::GetFieldZeroOfModelRFieldZero & GetFieldZeroOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:36; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:32526,simpl,simple,32526,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['simpl'],['simple']
Usability,"::RVecImpl< T > &&RHS);  ; RVecN & operator= (RVecN &&RHS);  ; RVecN & operator= (std::initializer_list< T > IL);  ; RVecN operator[] (const RVecN< V, M > &conds) const;  ; reference operator[] (size_type idx);  ; const_reference operator[] (size_type idx) const;  ;  Public Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (const RVecImpl &)=delete;  ;  ~RVecImpl ();  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void append (in_iter in_start, in_iter in_end);  Add the specified range to the end of the SmallVector. ;  ; void append (size_type NumInputs, const T &Elt);  Append NumInputs copies of Elt to the end. ;  ; void append (std::initializer_list< T > IL);  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void assign (in_iter in_start, in_iter in_end);  ; void assign (size_type NumElts, const T &Elt);  ; void assign (std::initializer_list< T > IL);  ; void clear ();  ; template<typename... ArgTypes> ; reference emplace_back (ArgTypes &&...Args);  ; iterator erase (const_iterator CI);  ; iterator erase (const_iterator CS, const_iterator CE);  ; iterator insert (iterator I, const T &Elt);  ; template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type> ; iterator insert (iterator I, ItTy From, ItTy To);  ; iterator insert (iterator I, size_type NumToInsert, const T &Elt);  ; void insert (iterator I, std::initializer_list< T > IL);  ; iterator insert (iterator I, T &&Elt);  ; RVecImpl & operator= (const RVecImpl &RHS);  ; RVecImpl & operator= (RVecImpl &&RHS);  ; void pop_back_n (size_type NumItems);  ; T pop_back_val ();  ; void reserve (size_type N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:14835,clear,clear,14835,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['clear'],['clear']
Usability,"::Register ; (; RDFInternal::RVariationBase * ; varPtr). Definition at line 995 of file RLoopManager.cxx. ◆ Register() [4/5]. void RLoopManager::Register ; (; RFilterBase * ; filterPtr). Definition at line 959 of file RLoopManager.cxx. ◆ Register() [5/5]. void RLoopManager::Register ; (; RRangeBase * ; rangePtr). Definition at line 974 of file RLoopManager.cxx. ◆ RegisterCallback(). void RLoopManager::RegisterCallback ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int)> && ; f . ). Definition at line 1033 of file RLoopManager.cxx. ◆ Report(). void RLoopManager::Report ; (; ROOT::RDF::RCutFlowReport & ; rep); const. finalvirtual . Call FillReport on all booked filters. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1012 of file RLoopManager.cxx. ◆ Run(). void RLoopManager::Run ; (; bool ; jit = true). Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. ◆ RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. ◆ RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. ◆ RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. ◆ RunEmptySource(). void RLoopManager::RunEmptySource ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:23918,clear,clear,23918,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['clear'],['clear']
Usability,"::RooNumConvPdf ; (; const char * ; name, . const char * ; title, . RooRealVar & ; convVar, . RooAbsPdf & ; pdf, . RooAbsPdf & ; resmodel . ). Definition at line 89 of file RooNumConvPdf.cxx. ◆ RooNumConvPdf() [3/3]. RooNumConvPdf::RooNumConvPdf ; (; const RooNumConvPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 110 of file RooNumConvPdf.cxx. ◆ ~RooNumConvPdf(). RooNumConvPdf::~RooNumConvPdf ; (; ). override . Destructor. ; Definition at line 129 of file RooNumConvPdf.cxx. Member Function Documentation. ◆ Class(). static TClass * RooNumConvPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumConvPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumConvPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file RooNumConvPdf.h. ◆ clearConvolutionWindow(). void RooNumConvPdf::clearConvolutionWindow ; (; ). inline . Definition at line 43 of file RooNumConvPdf.h. ◆ clone(). TObject * RooNumConvPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 36 of file RooNumConvPdf.h. ◆ conv(). RooNumConvolution & RooNumConvPdf::conv ; (; ); const. inlineprotected . Definition at line 63 of file RooNumConvPdf.h. ◆ convIntConfig(). RooNumIntConfig & RooNumConvPdf::convIntConfig ; (; ). inline . Definition at line 42 of file RooNumConvPdf.h. ◆ DeclFileName(). static const char * RooNumConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file RooNumConvPdf.h. ◆ evaluate(). double RooNumConvPdf::evaluate ; (; ); const. overridevirtual . Calculate and return value of p.d.f. ; Implements RooAbsReal.; Definition at line 136 of file RooNumConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooNumConvPdf::genContext ; (; const RooArgSet & ; vars, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:77713,clear,clearConvolutionWindow,77713,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:49673,learn,learning,49673,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:49743,learn,learning,49743,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"::SetStreamerElementNumber ; (; TStreamerElement * ; elem, . Int_t ; comp_type . ). finalvirtual . Function is called from TStreamerInfo WriteBuffer and Readbuffer functions and add/verify next element in sql tables This calls allows separate data, correspondent to one class member, from another. ; Implements TBuffer.; Definition at line 509 of file TBufferSQL2.cxx. ◆ SkipObjectAny(). void TBufferSQL2::SkipObjectAny ; (; ). finalvirtual . ?????? Skip any kind of object from buffer !!!!!! fix me, not yet implemented Should be just skip of current column later ; Implements TBuffer.; Definition at line 861 of file TBufferSQL2.cxx. ◆ SqlObjectData(). TSQLObjectData * TBufferSQL2::SqlObjectData ; (; Long64_t ; objid, . TSQLClassInfo * ; sqlinfo . ). protected . Creates TSQLObjectData for specified object id and specified class. ; Object data for each class can be stored in two different tables. First table contains data in column-wise form for simple types like integer, strings and so on when second table contains any other data which cannot be converted into column-wise representation. TSQLObjectData will contain results of the requests to both such tables for concrete object id. ; Definition at line 205 of file TBufferSQL2.cxx. ◆ SqlObjectInfo(). Bool_t TBufferSQL2::SqlObjectInfo ; (; Long64_t ; objid, . TString & ; clname, . Version_t & ; version . ). protected . Returns object info like classname and version Should be taken from buffer, which is produced in the beginning. ; Definition at line 160 of file TBufferSQL2.cxx. ◆ SqlReadAny(). void * TBufferSQL2::SqlReadAny ; (; Long64_t ; keyid, . Long64_t ; objid, . TClass ** ; cl, . void * ; obj = nullptr . ). Recreate object from sql structure. ; Return pointer to read object. if (cl!=0) returns pointer to class of object ; Definition at line 132 of file TBufferSQL2.cxx. ◆ SqlReadArray(). template<typename T > . R__ALWAYS_INLINE Int_t TBufferSQL2::SqlReadArray ; (; T *& ; arr, . Bool_t ; is_static = kFALSE . ). protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL2.html:67195,simpl,simple,67195,doc/master/classTBufferSQL2.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL2.html,1,['simpl'],['simple']
Usability,"::SlaveBegin(TTree*); virtual voidTSelector::SlaveTerminate(); virtual UInt_tTSelectorDraw::SplitNames(const TString& varexp, vector<TString>& names); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSelectorDraw::TakeAction(); virtual voidTSelectorDraw::TakeEstimate(); virtual voidTSelectorDraw::Terminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSelectorDraw::ClearFormula(); virtual Bool_tTSelectorDraw::CompileVariables(const char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTSelectorDraw::InitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TEveSelectorToEventList(const TEveSelectorToEventList&); TEveSelectorToEventList&operator=(const TEveSelectorToEventList&). Data Members; public:. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelectorDraw::fDime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveSelectorToEventList.html:7244,Clear,ClearFormula,7244,root/html532/TEveSelectorToEventList.html,https://root.cern,https://root.cern/root/html532/TEveSelectorToEventList.html,1,['Clear'],['ClearFormula']
Usability,"::Steffenson. ROOT::Math::VavilovAccurate. ROOT::Math::VavilovAccurateCdf. ROOT::Math::VavilovAccuratePdf. ROOT::Math::VavilovAccurateQuantile. ROOT::Math::VavilovFast. ROOT::Math::VirtualIntegratorMultiDim←. ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::GSLMCIntegrator. ROOT::Math::VirtualIntegratorOneDim←. ROOT::Math::GSLIntegrator. ROOT::Math::GaussIntegrator; ←. ROOT::Math::GaussLegendreIntegrator. ROOT::Math::WrappedMultiTF1. ROOT::Math::WrappedTF1. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FCNBase←. ROOT::Minuit2::FCNGradientBase. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FCNGradientBase. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::Minuit2Minimizer. ROOT::Minuit2::MnFumiliMinimize. ROOT::Minuit2::MnMigrad. ROOT::Minuit2::MnMinimize. ROOT::Minuit2::MnScan. ROOT::Minuit2::MnSimplex. ROOT::Minuit2::ModularFunctionMinimizer←. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<double,0> >. ROOT::TArrayProxy<ROOT::TArrayType<float,0> >. ROOT::TArrayProxy<ROOT::TArrayType<int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<short,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> >. ROOT::TBranchProxyClassDescriptor. ROOT::TBranchProxyDescriptor. ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TClaArrayProxy<R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassHierarchy.html:4922,Simpl,SimplexMinimizer,4922,root/html602/ClassHierarchy.html,https://root.cern,https://root.cern/root/html602/ClassHierarchy.html,2,['Simpl'],['SimplexMinimizer']
Usability,"::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:17789,Clear,Clear,17789,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,1,['Clear'],['Clear']
Usability,"::ToyMCSample::GenerateToyData; [#13387] - Please recover SrvAuthenticate from libSrvAuth library; [#14541] - [ROOT-6193] Editor for palette axis cannot set title properties; [#15104] - new PyROOT/cppyy fails to pickle enums; [#15161] - Attribute (getitem) differences for PyROOT objects in ROOT master; [#15234] - cppyy - wrong object type when iterating over a polymorphic container; [#15269] - Iterators in pyROOT working differently in ROOT master compared to 6.30/02; [#15315] - PyROOT Example with inheriting from ROOT.Math.IMultiGenFunction doesn’t work after recent cppyy upgrade; [#15425] - TTreeProcessorMP processes events multiple times when there are more threads than entries; [#15755] - [RF][HS3] Higgs discovery workspaces roundtrip; [#15874] - [Hist] Backwards compatibility broken for THnSparseL in 6.32; [#15887] - Broken plot .C macros for default Name() argument in plotOn(); [#15977] - [gui] Event StatusBar does not work well when TMarker outside of zoom region; [#15986] - Problems with TUri compilation; [#16031] - VecOps binary functions not using the right types; [#16038] - Could NOT find Vdt error when using 6.32.02 docker image; [#16087] - [docs] Potential typo in function name case: DistanceToPrimitive; [#16201] - PyROOT Support most recent numba version 0.60.0 intervals; [ROOT-6286] - Reading a TChain and TTreeCache; [ROOT-7991] - THnSparse::ProjectionND yields disfunctional histogram; [ROOT-8238] - TPrincipal tries to make histograms with nbin=0; [ROOT-8519] - Bug when use simple math functions in TTree::SetAlias(). Release 6.32.06; Published on September 22, 2024; Items addressed in this release; This is the first ROOT release supporting macOS 15 Sequoia. [#15178] - ROOT generates CMake warnings when building from the tarball; [#16219] - Module map on the new XCode version for macos15-beta; [#16249] - Iterating with a range for does one extra iteration; [ROOT-10902] - SMatrix read from TTree contains all zeroes. HEAD of the v6-32-00-patches branch. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:46029,simpl,simple,46029,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['simpl'],['simple']
Usability,"::Type< Internal::TStdBitsetHelper< Bitset_t > >::constructstatic void * construct(void *, size_t)Definition TCollectionProxyInfo.h:794; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::collectstatic void * collect(void *coll, void *array)Definition TCollectionProxyInfo.h:798; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:787; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:762; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Iterators_tIterators Iterators_tDefinition TCollectionProxyInfo.h:856; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:779; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:775; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Deta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:51701,clear,clearstatic,51701,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,2,['clear'],"['clear', 'clearstatic']"
Usability,"::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidTGTextEntry::CopyText() const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGTextEntry::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Int_tTGTextEntry::GetCharacterIndex(Int_t xcoord); static const TGGC&TGTextEntry::GetDefaultSelectedBackgroundGC(); static const TGGC&TGTextEntry::GetDefaultSelectedGC(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTextEntry::Init(); virtual Bool_tTGTextEntry::IsCursorOutOfFrame(); voidTObject::MakeZombie(); voidTGTextEntry::Paste(); virtual voidTGTextEntry::PastePrimary(Window_t wid, Atom_t property, Bool_t del); virtual voidTGTextEntry::ScrollByChar(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTextEntry::UpdateOffset(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGNumberEntryField.html:21336,Clear,ClearFlags,21336,root/html602/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html602/TGNumberEntryField.html,2,['Clear'],['ClearFlags']
Usability,"::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdjustPos(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidCopy(TObject&) const; virtual voidCursorOff(); virtual voidCursorOn(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGView::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawCursor(Int_t mode); static const TGGC&GetCursor0GC(); static const TGGC&GetCursor1GC(); static FontStruct_tTGTextView::GetDefaultFontStruct(); static const TGGC&TGTextView::GetDefaultGC(); static const TGGC&TGTextView::GetDefaultSelectedBackgroundGC(); static const TGGC&TGTextView::GetDefaultSelectedGC(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTextView::HLayout(); voidInit(); virtual Bool_tTGView::ItemLayout(); voidTObject::MakeZombie(); virtual voidTGTextView::Mark(Long_t xPos, Long_t yPos); Int_tTGWidget::SetFlags(Int_t flags); virtual voidSetMenuState(); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTextView::UnMark(); virtual voidTGView::UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGTextView::VLayout(). private:. TGTextEdit&operator=(const TGTextEdit&); TGTextEdit(const TGTextEdit&). Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEdit.html:19396,Clear,ClearFlags,19396,root/html602/TGTextEdit.html,https://root.cern,https://root.cern/root/html602/TGTextEdit.html,2,['Clear'],['ClearFlags']
Usability,"::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfAreaBin area; Bool_tfChangedFor the 3D Painter; Double_tfContentBin content; Int_tfNumberBin number of the bin in TH2Poly; TObject*fPolyObject holding the polygon definition; Double_tfXmaxX maximum value; Double_tfXminX minimum value; Double_tfYmaxY maximum value; Double_tfYminY minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH2PolyBin(). TH2PolyBin(TObject* poly, Int_t bin_number). virtual ~TH2PolyBin(). void ClearContent(); {fContent = 0;}. void Fill(Double_t w); {fContent = fContent+w; SetChanged(true);}. Double_t GetArea(). Double_t GetContent() const; {return fContent;}. Bool_t GetChanged() const; {return fChanged;}. Int_t GetBinNumber() const; {return fNumber;}. TObject * GetPolygon() const; {return fPoly;}. Double_t GetXMax(). Double_t GetXMin(). Double_t GetYMax(). Double_t GetYMin(). Bool_t IsInside(Double_t x, Double_t y) const. void SetChanged(Bool_t flag); {fChanged = flag;}. void SetContent(Double_t content); {fContent = content; SetChanged(true);}. » Author: Olivier Couet, Deniz Gunceler » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TH2Poly.h 37945 2011-02-02 15:35:05Z couet $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2PolyBin.html:5967,Clear,ClearContent,5967,root/html532/TH2PolyBin.html,https://root.cern,https://root.cern/root/html532/TH2PolyBin.html,1,['Clear'],['ClearContent']
Usability,"::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:3550,clear,clearEvalError,3550,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['clear'],['clearEvalError']
Usability,"::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:3550,clear,clearEvalError,3550,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2,['clear'],['clearEvalError']
Usability,"::createvoid create(std::string histoName, int bins, double min, double max, int bins2, double min2, double max2)for monitoringDefinition NeuralNet.h:820; TMVA::DNN::Settings::useMultithreadingbool useMultithreading() constis multithreading turned on?Definition NeuralNet.h:815; TMVA::DNN::Settings::regularizationEnumRegularization regularization() constsome regularization of the DNN is turned on?Definition NeuralNet.h:813; TMVA::DNN::Settings::convergenceCountsize_t convergenceCount() constreturns the current convergence countDefinition NeuralNet.h:827; TMVA::DNN::Settings::momentumdouble momentum() constget the momentum (e.g. for SGD)Definition NeuralNet.h:772; TMVA::DNN::Settings::count_Esize_t count_EDefinition NeuralNet.h:842; TMVA::DNN::Settings::m_timerTimer m_timertimer for monitoringDefinition NeuralNet.h:832; TMVA::DNN::Settings::testRepetitionssize_t testRepetitions() consthow often is the test data testedDefinition NeuralNet.h:768; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::endTestCyclevirtual void endTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::fMinimizerTypeMinimizerType fMinimizerTypeDefinition NeuralNet.h:855; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x, double y)for monitoringDefinition NeuralNet.h:822; TMVA::DNN::Settings::setMonitoringvoid setMonitoring(std::shared_ptr< Monitoring > ptrMonitoring)prepared for monitoringDefinition NeuralNet.h:764; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::m_convergenceStepssize_t m_convergenceStepsnumber of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:72443,clear,clearvoid,72443,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['clear'],"['clear', 'clearvoid']"
Usability,"::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfSmartRefresh; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveScene(const char* n = ""TEveScene"", const char* t = """"); Constructor. ~TEveScene(); Destructor. void CollectSceneParents(TEveElement::List_t& scenes); Virtual from TEveElement; here we simply append this scene to; the list. void Repaint(Bool_t dropLogicals = kFALSE); Repaint the scene. void RetransHierarchically(); Entry point for hierarchical transformation update.; Calls the recursive variant on all children. void RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp); Set transformation matrix for physical shape of element el in; the GL-scene and recursively descend into children (if enabled). void SetName(const char* n); Set scene's name. void Paint(Option_t* option = """"); Paint the scene. Iterate over children and calls PadPaint(). void DestroyElementRenderers(TEveElement* element); Remove element from the scene.; It is not an error if the element is not found in the scene. void DestroyElementRenderers(TObject* rnrObj); Remove element represented by object rnrObj from the scene.; It is not an error if the element is not found in the scene. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return icon for scene. TEveSce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveScene.html:20379,simpl,simply,20379,root/html528/TEveScene.html,https://root.cern,https://root.cern/root/html528/TEveScene.html,4,['simpl'],['simply']
Usability,"::fProcessedRun! Events processed in this run; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; Long64_tTProofPlayer::fReadBytesRun! Bytes read in this run; Long64_tTProofPlayer::fReadCallsRun! Read calls in this run; Long_tTProofPlayer::fSaveMemThresholdThreshold for saving output to file; Bool_tTProofPlayer::fSavePartialResultsWhether to save the partial results; Bool_tTProofPlayer::fSaveResultsPerPacketWhether to save partial results after each packet; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-03 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSlave.html:17599,feedback,feedback,17599,root/html604/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSlave.html,4,['feedback'],['feedback']
Usability,"::fProcessedRun! Events processed in this run; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; Long64_tTProofPlayer::fReadBytesRun! Bytes read in this run; Long64_tTProofPlayer::fReadCallsRun! Read calls in this run; Long_tTProofPlayer::fSaveMemThresholdThreshold for saving output to file; Bool_tTProofPlayer::fSavePartialResultsWhether to save the partial results; Bool_tTProofPlayer::fSaveResultsPerPacketWhether to save partial results after each packet; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 16:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSlave.html:16664,feedback,feedback,16664,root/html534/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSlave.html,4,['feedback'],['feedback']
Usability,"::fProcessedRun! Events processed in this run; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; Long64_tTProofPlayer::fReadBytesRun! Bytes read in this run; Long64_tTProofPlayer::fReadCallsRun! Read calls in this run; Long_tTProofPlayer::fSaveMemThresholdThreshold for saving output to file; Bool_tTProofPlayer::fSavePartialResultsWhether to save the partial results; Bool_tTProofPlayer::fSaveResultsPerPacketWhether to save partial results after each packet; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:17516,feedback,feedback,17516,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,4,['feedback'],['feedback']
Usability,"::fSignalsBlocked! flag used for suppression of signals; TGTextEntry*fTitleSlice label; TGNumberEntry*fValueValue of the slice; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TPieSlice*fPieSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); TPieSliceEditor constructor. ~TPieSliceEditor(); TPieSliceEditor destructor. void SetModel(TObject* ); Set model. void ConnectSignals2Slots(); Connect signals to slots. void DoTitle(const char* ); Slot for setting the graph title. void DoValue(); Slot for setting the graph title. void DoOffset(); Slot for setting the graph title. » Author: Guido Volpi 05/18/2008 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:21:18 2011 » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPieSliceEditor.html:20399,Guid,Guido,20399,root/html532/TPieSliceEditor.html,https://root.cern,https://root.cern/root/html532/TPieSliceEditor.html,1,['Guid'],['Guido']
Usability,"::fSizenumber of elements in collection; static TCollection::(anonymous)TCollection::kIsOwner; static TMap::(anonymous)kIsOwnerValue. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMap.html:9650,Clear,Clear,9650,root/html602/TMap.html,https://root.cern,https://root.cern/root/html602/TMap.html,2,['Clear'],['Clear']
Usability,"::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGVProgressBar.html:21828,progress bar,progress bar,21828,root/html604/TGVProgressBar.html,https://root.cern,https://root.cern/root/html604/TGVProgressBar.html,2,['progress bar'],['progress bar']
Usability,"::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGVProgressBar.html:21828,progress bar,progress bar,21828,root/html602/TGVProgressBar.html,https://root.cern,https://root.cern/root/html602/TGVProgressBar.html,2,['progress bar'],['progress bar']
Usability,"::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TVirtualX::ETextSetModeTVirtualX::kLoad; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TVirtualX::ETextModeTVirtualX::kOpaque; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TVirtualX::EDrawModeTVirtualX::kXor; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfBlockRGBProtect against color double setting; Float_tfCharacterUpXCharacter Up vector along X; Float_tfCharacterUpYCharacter Up vector along Y; TGQt::TQTCLIPMAPfClipMap; QTextCodec*fCodecThe Current text decoder; TGQt::COLORMAPfColorMapto back the TG widgets; ECursorfCursorCurrent cursor number;; QVector<QCursor*>fCursors; Int_tfDisplayOpened; QPainter::CompositionModefDrawMode; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; TQtEmitterfEmitterobject to emit Qt signals on behalf of TVirtualX; Bool_tfFeedBackModeTCanvas feedback mode; TQtFeedBackWidget*fFeedBackWidgetThe dedicated widget for TCanvas feedback mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; QStringfFontTextCodeThe default code text code page (from the Gui.DefaultFont); Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tfMarkerStyle; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; QMap<Color_t,QColor*>fPallete; TQtClientWidget*fPointerGrabber; QPaintDevice*fPrevWindowPointer to the previous ""Window""; TQtBrush*fQBrush; TQtClientFilter*fQClientFilter; TQtEventQueue*fQClientFilterBuffer; TQtClientGuardfQClientGuardguard TQtClientWibdget against of dead poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:24904,feedback,feedback,24904,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,8,['feedback'],['feedback']
Usability,"::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:15544,Clear,Clear,15544,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['Clear'],['Clear']
Usability,"::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; Architecture_t::ActivationDescriptor_t fActivationDesc;  ; Tensor_t fDerivatives;  activation function gradient ;  ; Scalar_t fDropoutProbability;  Probability that an input is active. ;  ; EActivationFunction fF;  Activation function of the layer. ;  ; Tensor_t fInputActivation;  output of GEMM and input to activation function ;  ; ERegularization fReg;  The regularization method. ;  ; Scalar_t fWeightDecay;  The weight decay. ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::VGeneralLayer< Architecture_t >; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for training and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:7280,learn,learningRate,7280,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; bool fFlattening;  Whether the layer is doing flattening. ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::VGeneralLayer< Architecture_t >; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for training and evaluation. ;  ; std::vector< Matrix_t > fBiases;  The biases associated to the layer. ;  ; std::vector< Matrix_t > fBiasGradients;  Gradients w.r.t. the bias values of the layer. ;  ; size_t fDepth;  The depth of the layer. ;  ; size_t fHeight;  The height of the layer. ;  ; EInitialization fInit;  The initialization method. ;  ; size_t fInputDepth;  The depth of the pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html:6602,learn,learningRate,6602,doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Protected Attributes; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for training and evaluation. ;  ; std::vector< Matrix_t > fBiases;  The biases associated to the layer. ;  ; std::vector< Matrix_t > fBiasGradients;  Gradients w.r.t. the bias values of the layer. ;  ; size_t fDepth;  The depth of the layer. ;  ; size_t fHeight;  The height of the layer. ;  ; EInitialization fInit;  The initialization method. ;  ; size_t fInputDepth;  The depth of the previous layer or input. ;  ; size_t fInputHeight;  The height of the previous layer or input. ;  ; size_t fInputWidth;  The width of the previous layer or input. ;  ; bool f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:5854,learn,learningRate,5854,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,":; TSpectrum2Painter::SetPenAttr(Int_t color,Int_t style,Int_t width). Using this function one can change pen color, pen style and pen width.; Possible pen styles are:. kPenStyleSolid,; kPenStyleDash,; kPenStyleDot,; kPenStyleDashDot. Default values:. color = kBlack; style = kPenStyleSolid; width = 1. Simple modes group, display mode = linesX, 64 x 64 channels. Pen width = 3.; Function:; TSpectrum2Painter::SetNodes(Int_t nodesx,Int_t nodesy); Sometimes the displayed region is rather large. When displaying all channels; pictures become very dense and complicated. It is very difficult to understand; overall shape of the data. Therefore in the package we have implemented the; possibility to change the density of displayed channels. Only channels; coinciding with given nodes are displayed. In the next figure we introduce the; example of the above presented spectrum with number of nodes set to 64x64.; Default values:. nodesx = Xmax-Xmin+1; nodesy = Ymax-Ymin+1. Simple modes group, display mode = grid, 256 x 256 channels.; Number of nodes is 64x64.; Function:; void TSpectrum2Painter::SetAngles (Int_t alpha,Int_t beta, Int_t view); One can change the angles of the position of 3-d space and to rotate the; space. Alpha parameter defines the angle between bottom horizontal screen line; and the displayed space on the right side of the picture and beta on the left; side, respectively. One can rotate the 3-d space around vertical axis going; through the center of it employing the view parameter.; Allowed values are 0, 90, 180 and 270 degrees respectively.; Default values:. alpha = 20; beta = 60; view = 0. Light modes group, display mode = surface, 256 x 256 channels. Angles are; set as follows: alpha=40, beta=30, view=0. Light modes group, display mode = surface, 256 x 256 channels. Angles are; set as follows: alpha=30, beta=30, view=90.; Function:; TSpectrum2Painter::SetZScale(Int_t scale); One can change the scale of z-axis. Possible values are:. kZScaleLinear; kZScaleLog; kZSc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:20217,Simpl,Simple,20217,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,":AbstractMethod(const char* method) const; voidRooStats::SamplingDistPlot::AddLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* title = NULL); Double_tRooStats::SamplingDistPlot::AddSamplingDistribution(const RooStats::SamplingDistribution* samplingDist, Option_t* drawOptions = ""NORMALIZE HIST""); Double_tRooStats::SamplingDistPlot::AddSamplingDistributionShaded(const RooStats::SamplingDistribution* samplingDist, Double_t minShaded, Double_t maxShaded, Option_t* drawOptions = ""NORMALIZE HIST""); voidRooStats::SamplingDistPlot::AddTF1(TF1* f, const char* title = NULL, Option_t* drawOptions = ""SAME""); voidRooStats::SamplingDistPlot::AddTH1(TH1* h, Option_t* drawOptions = """"); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyDefaultStyle(); voidApplyResult(RooStats::HypoTestResult& result, Option_t* opt = ""NORMALIZE HIST""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooStats::SamplingDistPlot::Draw(Option_t* options = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidRooStats::SamplingDistPlot::DumpToFile(const char* RootFileName, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestPlot.html:1422,Clear,Clear,1422,root/html534/RooStats__HypoTestPlot.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestPlot.html,1,['Clear'],['Clear']
Usability,":AddParent(TEveElement* re); virtual voidAddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCanEditElement() const; virtual Bool_tTEveGeoNode::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveGeoNode::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyPare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoTopNode.html:2214,Clear,ClearStamps,2214,root/html532/TEveGeoTopNode.html,https://root.cern,https://root.cern/root/html532/TEveGeoTopNode.html,4,['Clear'],['ClearStamps']
Usability,":AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tTEveWindow::CanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidTEveWindow::ClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*TEveWindow::CreateDefaultWindowSlot(); static TEveWindowSlot*TEveWindow::CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveViewer.html:2767,Clear,Clear,2767,root/html532/TEveViewer.html,https://root.cern,https://root.cern/root/html532/TEveViewer.html,12,['Clear'],['Clear']
Usability,":AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearNewEventCommands(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidClose(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveEventManager.html:2391,Clear,ClearProjectedList,2391,root/html532/TEveEventManager.html,https://root.cern,https://root.cern/root/html532/TEveEventManager.html,4,['Clear'],['ClearProjectedList']
Usability,":CheckCount(UInt_t offset); UInt_tTBufferFile::CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); TBufferXML(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferXML.html:19629,simpl,simple,19629,root/html602/TBufferXML.html,https://root.cern,https://root.cern/root/html602/TBufferXML.html,4,['simpl'],['simple']
Usability,:Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. virtual~Config(); TMVA::ConfigConfig(); TMVA::ConfigConfig(const TMVA::Config&); TMVA::MsgLogger&Log() const; TMVA::Config&operator=(const TMVA::Config&). Data Members; public:. IONamesfIONamesCustomisable weight file properties; VariablePlottingfVariablePlottingCustomisable plotting properties. private:. atomic<Bool_t>fDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; atomic<Bool_t>fSilentno output at all; atomic<Bool_t>fUseColoredConsolecoloured standard output; atomic<Bool_t>fWriteOptionsReferenceif set true: Configurable objects write file with option reference; static atomic<TMVA::Config*>fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. ~Config(); destructor. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariable,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Config.html:1255,progress bar,progress bar,1255,root/html602/TMVA__Config.html,https://root.cern,https://root.cern/root/html602/TMVA__Config.html,4,['progress bar'],['progress bar']
Usability,":DNN::TReference< Real_t >::TanhDerivative ; (; TMatrixT< AReal > & ; B, . const TMatrixT< AReal > & ; A . ). inlinestatic . Definition at line 125 of file ActivationFunctions.hxx. ◆ UpdateParams(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParams ; (; TMatrixT< AReal > & ; x, . TMatrixT< AReal > & ; tildeX, . TMatrixT< AReal > & ; y, . TMatrixT< AReal > & ; z, . TMatrixT< AReal > & ; fVBiases, . TMatrixT< AReal > & ; fHBiases, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; VBiasError, . TMatrixT< AReal > & ; HBiasError, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 48 of file DenoisePropagation.hxx. ◆ UpdateParamsLogReg(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParamsLogReg ; (; TMatrixT< AReal > & ; input, . TMatrixT< AReal > & ; output, . TMatrixT< AReal > & ; difference, . TMatrixT< AReal > & ; p, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; fBiases, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 191 of file DenoisePropagation.hxx. Member Data Documentation. ◆ fgRandomGen. template<typename Real_t > . TRandom * TMVA::DNN::TReference< Real_t >::fgRandomGen = nullptr. staticprivate . Definition at line 55 of file Reference.h. tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h; tmva/tmva/src/DNN/Architectures/Reference/ActivationFunctions.hxx; tmva/tmva/src/DNN/Architectures/Reference/Arithmetic.hxx; tmva/tmva/src/DNN/Architectures/Reference/DenoisePropagation.hxx; tmva/tmva/src/DNN/Architectures/Reference/Initialization.hxx; tmva/tmva/src/DNN/Architectures/Reference/LossFunctions.hxx; tmva/tmva/src/DNN/Architectures/Reference/OutputFunctions.hxx; tmva/tmva/src/DNN/Architectures/Reference/Propagation.hxx; tmva/tmva/src/DNN/Architectures/Reference/RecurrentPropagation.hxx; tmva/tmva/src/DNN/Architectures/Reference/Regularization.hxx. TMVADNNTReference. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:46 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:46000,learn,learningRate,46000,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,1,['learn'],['learningRate']
Usability,":DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 1658 of file TProofPlayer.cxx. ◆ Feedback(). void TProofPlayer::Feedback ; (; TList * ; objs). overridevirtual . Set feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 724 of file TProofPlayer.cxx. ◆ FeedBackCanvas(). void TProofPlayer::FeedBackCanvas ; (; const char * ; name, . Bool_t ; create . ). Create/destroy a named canvas for feedback. ; Definition at line 1765 of file TProofPlayer.cxx. ◆ Finalize() [1/2]. Long64_t TProofPlayer::Finalize ; (; Bool_t ; force = kFALSE, . Bool_t ; sync = kFALSE . ). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1571 of file TProofPlayer.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayer::Finalize ; (; TQueryResult * ; qr). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1580 of file TProofPlayer.cxx. ◆ GetCacheSize(). Long64_t TProofPlayer::GetCacheSize ; (; ). overridevirtual . Return the size in bytes of the cache. ; Implements TVirtualProofPlayer.; Definition at line 1796 of file TProofPlayer.cxx. ◆ GetCurrentQuery(). TQueryResult * TProofPlayer::GetCurrentQuery ; (; ); const. inlineoverridevirtual . Imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:28727,feedback,feedback,28727,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,":GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTProofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; Long_tTProofServ::GetVirtMemHWM() const; const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionTProofServ::GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidTProofServ::HandleException(Int_t sig); virtual voidHandleFork(TMessage* mess); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidTProofServ::HandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServLite.html:7287,resume,resume,7287,root/html528/TProofServLite.html,https://root.cern,https://root.cern/root/html528/TProofServLite.html,1,['resume'],['resume']
Usability,":IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 102 of file TGSpeedo.h. ◆ IsThresholdActive(). Bool_t TGSpeedo::IsThresholdActive ; (; ). inline . Definition at line 73 of file TGSpeedo.h. ◆ LedClicked(). void TGSpeedo::LedClicked ; (; ). inline . Definition at line 100 of file TGSpeedo.h. ◆ OdoClicked(). void TGSpeedo::OdoClicked ; (; ). inline . Definition at line 99 of file TGSpeedo.h. ◆ ResetPeakVal(). void TGSpeedo::ResetPeakVal ; (; ). inline . Definition at line 95 of file TGSpeedo.h. ◆ SetBufferSize(). void TGSpeedo::SetBufferSize ; (; Int_t ; size). Change the circular buffer size (used for the automatic mean calculation). ; SetMeanValue is ignored if SetBufferSize is called with a greater-than-zero argument. The mean value is then automatically calculated by using the sum of values contained in the buffer divided by their count. To disable automatic mean calculation, simply call SetBufferSize with a zero argument ; Definition at line 322 of file TGSpeedo.cxx. ◆ SetDisplayText(). void TGSpeedo::SetDisplayText ; (; const char * ; text1, . const char * ; text2 = """" . ). Set small display text (two lines). ; Definition at line 347 of file TGSpeedo.cxx. ◆ SetLabelText(). void TGSpeedo::SetLabelText ; (; const char * ; text1, . const char * ; text2 = """" . ). Set main label text (two lines). ; Definition at line 361 of file TGSpeedo.cxx. ◆ SetMeanValue(). void TGSpeedo::SetMeanValue ; (; Float_t ; mean). inline . Definition at line 96 of file TGSpeedo.h. ◆ SetMinMaxScale(). void TGSpeedo::SetMinMaxScale ; (; Float_t ; min, . Float_t ; max . ). Set min and max scale values. ; Definition at line 377 of file TGSpeedo.cxx. ◆ SetOdoValue(). void TGSpeedo::SetOdoValue ; (; Int_t ; val). Set actual value of odo meter. ; Definition at line 334 of file TGSpeedo.cxx. ◆ SetScaleValue() [1/2]. void TGSpeedo::SetScaleValue ; (; Float_t ; val). Set actual scale (needle position) value. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSpeedo.html:37110,simpl,simply,37110,doc/master/classTGSpeedo.html,https://root.cern,https://root.cern/doc/master/classTGSpeedo.html,1,['simpl'],['simply']
Usability,":MethodBase. ◆ GetTrainingSettings() [1/2]. std::vector< TTrainingSettings > & TMVA::MethodDL::GetTrainingSettings ; (; ). inline . Definition at line 281 of file MethodDL.h. ◆ GetTrainingSettings() [2/2]. const std::vector< TTrainingSettings > & TMVA::MethodDL::GetTrainingSettings ; (; ); const. inline . Definition at line 280 of file MethodDL.h. ◆ GetTrainingStrategyString(). TString TMVA::MethodDL::GetTrainingStrategyString ; (; ); const. inline . Definition at line 276 of file MethodDL.h. ◆ GetWeightInitialization(). DNN::EInitialization TMVA::MethodDL::GetWeightInitialization ; (; ); const. inline . Definition at line 268 of file MethodDL.h. ◆ GetWeightInitializationString(). TString TMVA::MethodDL::GetWeightInitializationString ; (; ); const. inline . Definition at line 277 of file MethodDL.h. ◆ HasAnalysisType(). Bool_t TMVA::MethodDL::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). virtual . Check the type of analysis the deep learning network can do. ; What kind of analysis type can handle the CNN. ; Implements TMVA::IMethod.; Definition at line 1091 of file MethodDL.cxx. ◆ Init(). void TMVA::MethodDL::Init ; (; void ; ). privatevirtual . default initializations ; Implements TMVA::MethodBase.; Definition at line 432 of file MethodDL.cxx. ◆ IsA(). virtual TClass * TMVA::MethodDL::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodBase.; Definition at line 212 of file MethodDL.h. ◆ ParseBatchLayout(). void TMVA::MethodDL::ParseBatchLayout ; (; ). private . Parse the input layout. ; Definition at line 482 of file MethodDL.cxx. ◆ ParseBatchNormLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseBatchNormLayer ; (; DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:43835,learn,learning,43835,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['learn'],['learning']
Usability,":MethodMLP::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . get the mva value generated by the NN ; Reimplemented from TMVA::MethodANNBase.; Definition at line 1549 of file MethodMLP.cxx. ◆ HasAnalysisType(). Bool_t TMVA::MethodMLP::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). virtual . MLP can handle classification with 2 classes and regression with one regression-target. ; Implements TMVA::IMethod.; Definition at line 152 of file MethodMLP.cxx. ◆ HasInverseHessian(). bool TMVA::MethodMLP::HasInverseHessian ; (; ). inline . Definition at line 94 of file MethodMLP.h. ◆ Init(). void TMVA::MethodMLP::Init ; (; void ; ). privatevirtual . default initializations ; Implements TMVA::MethodBase.; Definition at line 164 of file MethodMLP.cxx. ◆ InitializeLearningRates(). void TMVA::MethodMLP::InitializeLearningRates ; (; ). private . initialize learning rates of synapses, used only by back propagation ; Definition at line 278 of file MethodMLP.cxx. ◆ IsA(). virtual TClass * TMVA::MethodMLP::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodANNBase.; Definition at line 219 of file MethodMLP.h. ◆ LineSearch(). Bool_t TMVA::MethodMLP::LineSearch ; (; TMatrixD & ; Dir, . std::vector< Double_t > & ; Buffer, . Double_t * ; dError = nullptr . ). private . zjh ; Definition at line 840 of file MethodMLP.cxx. ◆ MakeClassSpecific(). void TMVA::MethodMLP::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. protectedvirtual . write specific classifier response ; Reimplemented from TMVA::MethodANNBase.; Definition at line 1704 of file MethodMLP.cxx. ◆ ProcessOptions(). void TMVA::MethodMLP::ProcessOptions ; (; ). privatevirtual . process user options ; Reimplemented from TMVA::MethodANNBase.; Definition at line 247 of file MethodMLP.cxx. ◆ SetDir(). void TMVA::MethodMLP::SetDir ; (; TMatrixD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:45482,learn,learning,45482,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,":RField< TObject >.; Definition at line 431 of file RFieldBase.hxx. ◆ operator=() [1/2]. RFieldBase & ROOT::Experimental::RFieldBase::operator= ; (; const RFieldBase & ; ). delete . ◆ operator=() [2/2]. RFieldBase & ROOT::Experimental::RFieldBase::operator= ; (; RFieldBase && ; ). default . ◆ Read() [1/2]. void ROOT::Experimental::RFieldBase::Read ; (; NTupleSize_t ; globalIndex, . void * ; to . ). inlineprotected . Populate a single value with data from the field. ; The memory location pointed to by to needs to be of the fitting type. The fast path is conditioned by the field qualifying as simple, i.e. maps as-is to a single column and has no read callback. ; Definition at line 362 of file RFieldBase.hxx. ◆ Read() [2/2]. void ROOT::Experimental::RFieldBase::Read ; (; RClusterIndex ; clusterIndex, . void * ; to . ). inlineprotected . Populate a single value with data from the field. ; The memory location pointed to by to needs to be of the fitting type. The fast path is conditioned by the field qualifying as simple, i.e. maps as-is to a single column and has no read callback. ; Definition at line 378 of file RFieldBase.hxx. ◆ ReadBulk(). std::size_t ROOT::Experimental::RFieldBase::ReadBulk ; (; const RBulkSpec & ; bulkSpec). protected . Returns the number of newly available values, that is the number of bools in bulkSpec.fMaskAvail that flipped from false to true. ; As a special return value, kAllSet can be used if all values are read independent from the masks. ; Definition at line 1086 of file RField.cxx. ◆ ReadBulkImpl(). std::size_t ROOT::Experimental::RFieldBase::ReadBulkImpl ; (; const RBulkSpec & ; bulkSpec). protectedvirtual . General implementation of bulk read. ; Loop over the required range and read values that are required and not already present. Derived classes may implement more optimized versions of this method. See ReadBulk() for the return value. ; Reimplemented in ROOT::Experimental::RField< RNTupleCardinality< SizeT > >, and ROOT::Experimental::RR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:47792,simpl,simple,47792,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['simpl'],['simple']
Usability,":SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TGaxis::IsATClass * IsA() const overrideDefinition TGaxis.h:136; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideReturn text size in pixels.Definition TLatex.cxx:2600; TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::operator=TLine & operator=(const TLine &src)Assignment operator.Definition TLine.cxx:67; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TLine::PaintLineNDCvirtual void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2)Draw this line with new coordinates in NDC.Definition TLine.cxx:409; TLine::Streamervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:125688,simpl,simple,125688,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['simpl'],['simple']
Usability,":TSGD< Architecture_t, Layer_t, DeepNet_t >. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual void TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedpure virtual . Update the weights, given the current weight gradients. ; Implemented in TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >, and TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >. Member Data Documentation. ◆ fDeepNet. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . DeepNet_t& TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fDeepNet. protected . The reference to the deep net. ; Definition at line 53 of file Optimizer.h. ◆ fGlobalStep. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . size_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fGlobalStep. protected . The current global step count during training. ; Definition at line 52 of file Optimizer.h. ◆ fLearningRate. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::fLearningRate. protected . The learning rate used for training. ; Definition at line 51 of file Optimizer.h. tmva/tmva/inc/TMVA/DNN/Optimizer.h. TMVADNNVOptimizer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:47 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:8201,learn,learning,8201,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['learn'],['learning']
Usability,":_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:39350,clear,clearCacheObject,39350,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,4,['clear'],['clearCacheObject']
Usability,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:2394,clear,clearValueDirty,2394,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,2,['clear'],['clearValueDirty']
Usability,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:2325,clear,clearValueDirty,2325,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,2,['clear'],['clearValueDirty']
Usability,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:2153,clear,clearValueDirty,2153,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,2,['clear'],['clearValueDirty']
Usability,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:2193,clear,clearValueDirty,2193,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,12,['clear'],['clearValueDirty']
Usability,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:2048,clear,clearValueDirty,2048,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,2,['clear'],['clearValueDirty']
Usability,":binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:4953,clear,clearEvalError,4953,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,6,['clear'],['clearEvalError']
Usability,":branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsReal*RooAbsPdf::createChi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:7412,clear,clearValueDirty,7412,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,2,['clear'],['clearValueDirty']
Usability,":chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:5606,clear,clearShapeDirty,5606,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,2,['clear'],['clearShapeDirty']
Usability,":chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:5765,clear,clearShapeDirty,5765,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,6,['clear'],['clearShapeDirty']
Usability,":chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:5606,clear,clearShapeDirty,5606,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['clear'],['clearShapeDirty']
Usability,":fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionboo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:39850,clear,cleared,39850,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['clear'],['cleared']
Usability,":fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionboo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:39995,clear,cleared,39995,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['clear'],['cleared']
Usability,":fSignalsBlocked! flag used for suppression of signals; TGTextEntry*fTitleSlice label; TGNumberEntry*fValueValue of the slice; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TPieSlice*fPieSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); TPieSliceEditor constructor. ~TPieSliceEditor(); TPieSliceEditor destructor. void SetModel(TObject* ); Set model. void ConnectSignals2Slots(); Connect signals to slots. void DoTitle(const char* ); Slot for setting the graph title. void DoValue(); Slot for setting the graph title. void DoOffset(); Slot for setting the graph title. » Author: Guido Volpi 05/18/2008 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:46:52 2015 » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPieSliceEditor.html:20418,Guid,Guido,20418,root/html534/TPieSliceEditor.html,https://root.cern,https://root.cern/root/html534/TPieSliceEditor.html,1,['Guid'],['Guido']
Usability,":fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TPieSlice*fPieSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); TPieSliceEditor constructor. ~TPieSliceEditor(); TPieSliceEditor destructor. void SetModel(TObject* ); Set model. void ConnectSignals2Slots(); Connect signals to slots. void DoTitle(const char* ); Slot for setting the graph title. void DoValue(); Slot for setting the graph title. void DoOffset(); Slot for setting the graph title. TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Guido Volpi 05/18/2008 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:27:31 2015 » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPieSliceEditor.html:21433,Guid,Guido,21433,root/html604/TPieSliceEditor.html,https://root.cern,https://root.cern/root/html604/TPieSliceEditor.html,1,['Guid'],['Guido']
Usability,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTorusEditor.html:22296,undo,undoing,22296,root/html604/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTorusEditor.html,2,['undo'],['undoing']
Usability,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorusEditor.html:22296,undo,undoing,22296,root/html602/TGeoTorusEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTorusEditor.html,2,['undo'],['undoing']
Usability,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTranslationEditor.html:22291,undo,undoing,22291,root/html604/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTranslationEditor.html,2,['undo'],['undoing']
Usability,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTranslationEditor.html:22291,undo,undoing,22291,root/html602/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTranslationEditor.html,2,['undo'],['undoing']
Usability,":fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGHProgressBar.html:20718,progress bar,progress bar,20718,root/html534/TGHProgressBar.html,https://root.cern,https://root.cern/root/html534/TGHProgressBar.html,7,"['Simpl', 'progress bar']","['Simple', 'progress bar']"
Usability,":fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedEditor.html:27642,simpl,simply,27642,root/html602/TGedEditor.html,https://root.cern,https://root.cern/root/html602/TGedEditor.html,4,['simpl'],['simply']
Usability,":kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:50900,learn,learning,50900,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,":kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2170 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2211 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:50970,learn,learning,50970,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,":kZombie. Class Charts. Inheritance Chart:. TObject. ←; TVirtualViewer3D. ←. TGLScenePad. TGLViewer; ←. TGLEmbeddedViewer. TGLSAViewer. TViewer3DPad. TViewerX3D. Function documentation; TVirtualViewer3D* Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); Create a Viewer 3D of specified type. virtual ~TVirtualViewer3D(); {}. Bool_t PreferLocalFrame() const; Viewers must always handle master (absolute) positions - and; buffer producers must be able to supply them. Some viewers may; prefer local frame & translation - and producers can optionally; supply them. Bool_t CanLoopOnPrimitives() const; Viewers can implement their own loop over pad's primitive list. { return kFALSE; }. void PadPaint(TVirtualPad* ); When they can, TPad::Paint() and TPad::PaintModified() simply; call the following function:. {}. void ObjectPaint(TObject* , Option_t* = """"); {}. void BeginScene(); Addition/removal of objects must occur between Begin/EndUpdate calls. Bool_t BuildingScene() const. void EndScene(). Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Simple object addition - buffer represents a unique single positioned object. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Complex object addition - for adding physical objects which have common logical; shapes. In this case buffer describes template shape (aside from kCore). Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0). void CloseComposite(). void AddCompositeOp(UInt_t operation). TObject * SelectObject(Int_t , Int_t ); {return 0;}. void DrawViewer(); {}. void PrintObjects(); {}. void ResetCameras(); {}. void ResetCamerasAfterNextUpdate(); {}. » Author: Olivier Couet 05/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualViewer3D.html:18336,Simpl,Simple,18336,root/html604/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html604/TVirtualViewer3D.html,1,['Simpl'],['Simple']
Usability,":kZombie. Class Charts. Inheritance Chart:. TObject. ←; TVirtualViewer3D. ←. TGLScenePad. TGLViewer; ←. TGLEmbeddedViewer. TGLSAViewer. TViewer3DPad. TViewerX3D. Function documentation; TVirtualViewer3D* Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); Create a Viewer 3D of specified type. virtual ~TVirtualViewer3D(); {}. Bool_t PreferLocalFrame() const; Viewers must always handle master (absolute) positions - and; buffer producers must be able to supply them. Some viewers may; prefer local frame & translation - and producers can optionally; supply them. Bool_t CanLoopOnPrimitives() const; Viewers can implement their own loop over pad's primitive list. { return kFALSE; }. void PadPaint(TVirtualPad* ); When they can, TPad::Paint() and TPad::PaintModified() simply; call the following function:. {}. void ObjectPaint(TObject* , Option_t* = """"); {}. void BeginScene(); Addition/removal of objects must occur between Begin/EndUpdate calls. Bool_t BuildingScene() const. void EndScene(). Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Simple object addition - buffer represents a unique single positioned object. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Complex object addition - for adding physical objects which have common logical; shapes. In this case buffer describes template shape (aside from kCore). Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0). void CloseComposite(). void AddCompositeOp(UInt_t operation). TObject * SelectObject(Int_t , Int_t ); {return 0;}. void DrawViewer(); {}. void PrintObjects(); {}. void ResetCameras(); {}. void ResetCamerasAfterNextUpdate(); {}. » Author: Olivier Couet 05/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualViewer3D.html:18336,Simpl,Simple,18336,root/html602/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html602/TVirtualViewer3D.html,1,['Simpl'],['Simple']
Usability,":kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter(const char* name, const char* title = ""Generic Interpreter""); TInterpreter ctor only called by derived classes. TInterpreter * Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). Bool_t SetSuspendAutoParsing(Bool_t value). Bool_t IsAutoParsingSuspended() const. TInterpreter(); { }. TInterpreter(const char* name, const char* title = ""Generic Interpreter""). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). void * SetAutoLoadCallBack(void* ); { return 0; }. void * GetAutoLoadCallBack() const; { return 0; }. Int_t AutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoParse(const char* cls). void ClearFileBusy(). void ClearStack(). Bool_t Declare(const char* code). void EnableAutoLoading(). void EndOfLineAction(). TClass * GetClass(const type_info& typeinfo, Bool_t load) const. Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. TClass * GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:26080,Clear,ClearStack,26080,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Clear'],['ClearStack']
Usability,":numWeightssize_t numWeights(size_t numInputNodes) constreturn the number of weights for this layer (fully connected)Definition NeuralNet.h:686; TMVA::DNN::Layer::inverseActivationFunctionstd::shared_ptr< std::function< double(double)> > inverseActivationFunction() constfetch the inverse activation function for this layerDefinition NeuralNet.h:689; TMVA::DNN::Layer::m_activationFunctionTypeEnumFunction m_activationFunctionTypeDefinition NeuralNet.h:703; TMVA::DNN::Layer::activationFunctionTypeEnumFunction activationFunctionType() constget the activation function type for this layerDefinition NeuralNet.h:691; TMVA::DNN::Layer::modeOutputValuesModeOutputValues modeOutputValues() constget the mode-output-value (direct, probabilities)Definition NeuralNet.h:682; TMVA::DNN::MeanVarianceDefinition NeuralNet.h:75; TMVA::DNN::MeanVariance::meandouble mean() constDefinition NeuralNet.h:126; TMVA::DNN::MeanVariance::MeanVarianceMeanVariance()Definition NeuralNet.h:77; TMVA::DNN::MeanVariance::clearvoid clear()Definition NeuralNet.h:84; TMVA::DNN::MeanVariance::var_corrdouble var_corr() constDefinition NeuralNet.h:136; TMVA::DNN::MeanVariance::countint count() constDefinition NeuralNet.h:124; TMVA::DNN::MeanVariance::addvoid add(T value, double weight=1.0)Definition NeuralNet.h:93; TMVA::DNN::MeanVariance::stdDev_corrdouble stdDev_corr() constDefinition NeuralNet.h:144; TMVA::DNN::MeanVariance::weightsdouble weights() constDefinition NeuralNet.h:125; TMVA::DNN::MeanVariance::m_meandouble m_meanDefinition NeuralNet.h:150; TMVA::DNN::MeanVariance::m_nsize_t m_nDefinition NeuralNet.h:148; TMVA::DNN::MeanVariance::m_squareddouble m_squaredDefinition NeuralNet.h:151; TMVA::DNN::MeanVariance::m_sumWeightsdouble m_sumWeightsDefinition NeuralNet.h:149; TMVA::DNN::MeanVariance::addvoid add(ITERATOR itBegin, ITERATOR itEnd)Definition NeuralNet.h:116; TMVA::DNN::MeanVariance::vardouble var() constDefinition NeuralNet.h:127; TMVA::DNN::MeanVariance::stdDevdouble stdDev() constDefinition Neu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:63433,clear,clearvoid,63433,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['clear'],"['clear', 'clearvoid']"
Usability,":operator=(const TVirtualGLPainter&); virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Bool_tBuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGraph* mg, Double_t z); Bool_tCacheGeometry(); Bool_tClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; voidDrawCaps() const; voidDrawExtrusion() const; voidDrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFillTemporaryP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLH2PolyPainter.html:1605,Clear,ClearBuffers,1605,root/html532/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html532/TGLH2PolyPainter.html,1,['Clear'],['ClearBuffers']
Usability,":operator=(const TVirtualGLPainter&); virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. voidClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawContoursProjection() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; voidDrawProjections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidGenTexMap() const; Bool_tHasProjections() const; Bool_tHasSections() const; Bool_tInitGeometryCartesian(); Bool_tInitGeometryCylindrical(); Bool_tInitGeometryPolar(); Bool_tInitGeometrySpherical(); virtual voidInitGL() const; Bool_tPreparePalette() const; voidSetNormals(); voidSetSurfaceColor() const; Bool_tTextured() const; char*WindowPointTo3DPoint(Int_t px, Int_t py) const. Data Members; public:. enum ESurfaceType { kSurf; kSurf1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLSurfacePainter.html:1657,Clear,ClearBuffers,1657,root/html532/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html532/TGLSurfacePainter.html,1,['Clear'],['ClearBuffers']
Usability,":printValue ; (; std::ostream & ; os); const. overridevirtual . Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. ; Reimplemented from RooPrintable.; Definition at line 1428 of file RooFitResult.cxx. ◆ randomizePars(). const RooArgList & RooFitResult::randomizePars ; (; ); const. Generate random perturbations of the final parameters using the covariance matrix. ; Return a list of floating parameter values that are perturbed from the final fit values by random amounts sampled from the covariance matrix.; The returned object is overwritten with each call and belongs to the RooFitResult. Uses the ""square root method"" to decompose the covariance matrix, which makes inverting it unnecessary. ; Definition at line 336 of file RooFitResult.cxx. ◆ reducedCovarianceMatrix(). TMatrixDSym RooFitResult::reducedCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are ordered to matched the convention given in input argument 'params'. ; Definition at line 1124 of file RooFitResult.cxx. ◆ setConstParList(). void RooFitResult::setConstParList ; (; const RooArgList & ; list). Fill the list of constant parameters. ; Definition at line 136 of file RooFitResult.cxx. ◆ setCovarianceMatrix(). void RooFitResult::setCovarianceMatrix ; (; TMatrixDSym & ; V). Store externally provided correlation matrix in this RooFitResult ;. ; Definition at line 1052 of file RooFitResult.cxx. ◆ setCovQual(). void RooFitResult::setCovQual ; (; Int_t ; val). inline . Definition at line 169 of file RooFitResult.h. ◆ setEDM(). void RooFitResult::setEDM ; (; double ; val). inline . Definition at line 167 of file RooFitResult.h. ◆ setFinalParList(). void RooFitResult::setFinalParList ; (; const RooArgList & ; list). Fill the list of final values of the floating parameters. ; Definition at line 170 of file RooFitResult.cxx. ◆ setInitParList(). void RooFitResult::setIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:36218,simpl,simple,36218,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['simpl'],['simple']
Usability,":string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:3938,clear,clearEvalErrorLog,3938,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,3,['clear'],['clearEvalErrorLog']
Usability,":string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4384,clear,clearEvalErrorLog,4384,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,":string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4384,clear,clearEvalErrorLog,4384,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,":system_clock::now();; 330 std::chrono::time_point<std::chrono::system_clock> fLastPrintTime = fBeginTime;; 331 std::chrono::seconds fPrintInterval{1};; 332 ; 333 std::atomic<std::size_t> fProcessedEvents{0};; 334 std::size_t fLastProcessedEvents{0};; 335 std::size_t fIncrement;; 336 ; 337 mutable std::mutex fSampleNameToEventEntriesMutex;; 338 std::map<std::string, ULong64_t> fSampleNameToEventEntries; // Filename, events in the file; 339 ; 340 std::array<double, 20> fEventsPerSecondStatistics;; 341 std::size_t fEventsPerSecondStatisticsIndex{0};; 342 ; 343 unsigned int fBarWidth;; 344 unsigned int fTotalFiles;; 345 ; 346 std::mutex fPrintMutex;; 347 bool fIsTTY;; 348 bool fUseShellColours;; 349 ; 350 std::shared_ptr<TTree> fTree{nullptr};; 351 ; 352public:; 353 /// Create a progress helper.; 354 /// \param increment RDF callbacks are called every `n` events. Pass this `n` here.; 355 /// \param totalFiles read total number of files in the RDF.; 356 /// \param progressBarWidth Number of characters the progress bar will occupy.; 357 /// \param printInterval Update every stats every `n` seconds.; 358 /// \param useColors Use shell colour codes to colour the output. Automatically disabled when; 359 /// we are not writing to a tty.; 360 ProgressHelper(std::size_t increment, unsigned int totalFiles = 1, unsigned int progressBarWidth = 40,; 361 unsigned int printInterval = 1, bool useColors = true);; 362 ; 363 ~ProgressHelper() = default;; 364 ; 365 friend class ProgressBarAction;; 366 ; 367 /// Register a new sample for completion statistics.; 368 /// \see ROOT::RDF::RInterface::DefinePerSample().; 369 /// The *id.AsString()* refers to the name of the currently processed file.; 370 /// The idea is to populate the event entries in the *fSampleNameToEventEntries* map; 371 /// by selecting the greater of the two values:; 372 /// *id.EntryRange().second* which is the upper event entry range of the processed sample; 373 /// and the current value of the event entries in the *f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:16675,progress bar,progress bar,16675,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['progress bar'],['progress bar']
Usability,"; (; Int_t & ; scale). Gets z-axis scale: . scale - it can be linear, sqrt or log . Definition at line 7337 of file TSpectrum2Painter.cxx. ◆ IsA(). TClass * TSpectrum2Painter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 205 of file TSpectrum2Painter.h. ◆ operator=(). TSpectrum2Painter & TSpectrum2Painter::operator= ; (; const TSpectrum2Painter & ; ). private . ◆ Paint(). void TSpectrum2Painter::Paint ; (; Option_t * ; option). overridevirtual . Paints histogram according to preset parameters. . Visualization; Goal: to present 2-dimensional spectra in suitable visual form; This package has several display mode groups and display modes, which can be employed for the presentation of 2-dimensional histograms Display modes groups:. kModeGroupSimple - it covers simple display modes using one color only; kModeGroupLight - in this group the shading is carried out according to the position of the fictive light source; kModeGroupHeight - in this group the shading is carried out according to the channel contents; kModeGroupLightHeight - combination of two previous shading algorithms. One can control the weight between both algorithms. Display modes:. kDisplayModePoints,; kDisplayModeGrid,; kDisplayModeContours,; kDisplayModeBars,; kDisplayModeLinesX,; kDisplayModeLinesY,; kDisplayModeBarsX,; kDisplayModeBarsY,; kDisplayModeNeedles,; kDisplayModeSurface,; kDisplayModeTriangles. one can combine the above given modes groups and display modes. The meaningful combinations (denoted by x) are given in the next table. Simple Light Height Light-Height . Points X X X X . Grid X X X X . Contours X - X - . Bars X - X - . LinesX X X X X . LinesY X X X X . BarsX X - X - . BarsY X - X - . Needles X - - - . Surface - X X X . Triangles X X X X . Function: void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode); This function controls the display mode group and display mode of the histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:31539,simpl,simple,31539,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"; (; Option_t * ; option = """"). overridevirtual . Performs redo action. Move cursor position forward in history stack. ; Reimplemented from TQCommand.; Definition at line 1053 of file TQCommand.cxx. ◆ SetLimit(). void TQUndoManager::SetLimit ; (; UInt_t ; limit). virtual . Returns a maximum number of commands which could be located in stack. ; Definition at line 1137 of file TQCommand.cxx. ◆ SetLogging(). void TQUndoManager::SetLogging ; (; Bool_t ; on = kTRUE). virtual . Start logging. ; Delete all previous log records Note: logging is not implemented yet ; Definition at line 938 of file TQCommand.cxx. ◆ Streamer(). void TQUndoManager::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TQCommand. ◆ StreamerNVirtual(). void TQUndoManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 133 of file TQCommand.h. ◆ Undo(). void TQUndoManager::Undo ; (; Option_t * ; option = """"). overridevirtual . Performs undo action. Move cursor position backward in history stack. ; Reimplemented from TQCommand.; Definition at line 1021 of file TQCommand.cxx. Member Data Documentation. ◆ fCurrent. TQCommand* TQUndoManager::fCurrent. protected . Definition at line 107 of file TQCommand.h. ◆ fCursor. TObjLink* TQUndoManager::fCursor. protected . Definition at line 106 of file TQCommand.h. ◆ fLimit. UInt_t TQUndoManager::fLimit. protected . Definition at line 108 of file TQCommand.h. ◆ fLogBook. TList* TQUndoManager::fLogBook. protected . Definition at line 109 of file TQCommand.h. ◆ fLogging. Bool_t TQUndoManager::fLogging. protected . Definition at line 110 of file TQCommand.h. Libraries for TQUndoManager:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TQCommand.h; core/base/src/TQCommand.cxx. TQUndoManager. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:33008,undo,undo,33008,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"; (; const TMVA::Event *& ; evt, . std::vector< Double_t > & ; parameters, . std::vector< Float_t > & ; values . ). private . calculate the values for multiclass ; Definition at line 581 of file MethodFDA.cxx. ◆ CheckSetup(). void TMVA::MethodFDA::CheckSetup ; (; ). inlinevirtual . check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ; Reimplemented from TMVA::MethodBase.; Definition at line 101 of file MethodFDA.h. ◆ Class(). static TClass * TMVA::MethodFDA::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodFDA::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodFDA::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 154 of file MethodFDA.h. ◆ ClearAll(). void TMVA::MethodFDA::ClearAll ; (; void ; ). private . delete and clear all class members ; Definition at line 346 of file MethodFDA.cxx. ◆ CreateFormula(). void TMVA::MethodFDA::CreateFormula ; (; ). private . translate formula string into TFormula, and parameter string into par ranges ; Definition at line 183 of file MethodFDA.cxx. ◆ CreateRanking(). const Ranking * TMVA::MethodFDA::CreateRanking ; (; ). inlinevirtual . Implements TMVA::MethodBase.; Definition at line 96 of file MethodFDA.h. ◆ DeclareOptions(). void TMVA::MethodFDA::DeclareOptions ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; format of function string: ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables; format of parameter string: ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges; each parameter defined in the function string must have a corresponding range ; Implements TMVA::MethodBase.; Definition at line 163 of file MethodFDA.cxx. ◆ DeclFileName(). static cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html:32584,clear,clear,32584,doc/master/classTMVA_1_1MethodFDA.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html,1,['clear'],['clear']
Usability,"; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodTMlpANN::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 121 of file MethodTMlpANN.h. ◆ CreateMLPOptions(). void TMVA::MethodTMlpANN::CreateMLPOptions ; (; TString ; layerSpec). private . translates options from option string into TMlpANN language ; Definition at line 140 of file MethodTMlpANN.cxx. ◆ CreateRanking(). const Ranking * TMVA::MethodTMlpANN::CreateRanking ; (; ). inlinevirtual . Implements TMVA::MethodBase.; Definition at line 84 of file MethodTMlpANN.h. ◆ DeclareOptions(). void TMVA::MethodTMlpANN::DeclareOptions ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; know options:. NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); specifications for each hidden layer are separated by comma; for each layer the number of nodes can be either absolut (simply a number) or relative to the number of input nodes to the neural net (N); there is always a single node in the output layer. example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the layers 1,2,3,4, respectively . Implements TMVA::MethodBase.; Definition at line 195 of file MethodTMlpANN.cxx. ◆ DeclFileName(). static const char * TMVA::MethodTMlpANN::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file MethodTMlpANN.h. ◆ GetHelpMessage(). void TMVA::MethodTMlpANN::GetHelpMessage ; (; ); const. protectedvirtual . get help message text ; typical length of text line: ""|--------------------------------------------------------------|"" ; Implements TMVA::IMethod.; Definition at line 504 of file MethodTMlpANN.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodTMlpANN::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html:31288,simpl,simply,31288,doc/master/classTMVA_1_1MethodTMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html,1,['simpl'],['simply']
Usability,"; ). virtual . destructor ; Definition at line 112 of file Timer.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::Timer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Timer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Timer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 99 of file Timer.h. ◆ DeclFileName(). static const char * TMVA::Timer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 99 of file Timer.h. ◆ DrawProgressBar() [1/3]. void TMVA::Timer::DrawProgressBar ; (; Int_t ; icounts, . const TString & ; comment = """" . ). draws progress bar in color or B&W caution: ; Definition at line 202 of file Timer.cxx. ◆ DrawProgressBar() [2/3]. void TMVA::Timer::DrawProgressBar ; (; TString ; theString). draws a string in the progress bar ; Definition at line 181 of file Timer.cxx. ◆ DrawProgressBar() [3/3]. void TMVA::Timer::DrawProgressBar ; (; void ; ). draws the progressbar ; Definition at line 166 of file Timer.cxx. ◆ ElapsedSeconds(). Double_t TMVA::Timer::ElapsedSeconds ; (; void ; ). computes elapsed tim in seconds ; Definition at line 137 of file Timer.cxx. ◆ GetElapsedTime(). TString TMVA::Timer::GetElapsedTime ; (; Bool_t ; Scientific = kTRUE). returns pretty string with elapsed time ; Definition at line 146 of file Timer.cxx. ◆ GetLeftTime(). TString TMVA::Timer::GetLeftTime ; (; Int_t ; icounts). returns pretty string with time left ; Definition at line 154 of file Timer.cxx. ◆ Init(). void TMVA::Timer::Init ; (; Int_t ; ncounts). Definition at line 117 of file Timer.cxx. ◆ IsA(). virtual TClass * TMVA::Timer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 99 of file Timer.h. ◆ Log(). MsgLogger & TMVA::Timer::Log ; (; ); const. inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:15321,progress bar,progress bar,15321,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['progress bar'],['progress bar']
Usability,"; , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TCONE.h>. Inheritance diagram for TCONE:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TCONE() [1/3]. TCONE::TCONE ; (; ). CONE shape default constructor. ; Definition at line 38 of file TCONE.cxx. ◆ TCONE() [2/3]. TCONE::TCONE ; (; const char * ; name, . const char * ; title, . const char * ; material, . Float_t ; dz, . Float_t ; rmin1, . Float_t ; rmax1, . Float_t ; rmin2, . Float_t ; rmax2 . ). CONE shape normal constructor. ; Definition at line 47 of file TCONE.cxx. ◆ TCONE() [3/3]. TCONE::TCONE ; (; const char * ; name, . const char * ; title, . const char * ; material, . Float_t ; dz, . Float_t ; rmax1, . Float_t ; rmax2 = 0 . ). CONE shape ""simplified"" constructor. ; Definition at line 59 of file TCONE.cxx. ◆ ~TCONE(). TCONE::~TCONE ; (; ). override . CONE shape default destructor. ; Definition at line 69 of file TCONE.cxx. Member Function Documentation. ◆ Class(). static TClass * TCONE::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCONE::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCONE::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 45 of file TCONE.h. ◆ DeclFileName(). static const char * TCONE::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 45 of file TCONE.h. ◆ GetRmax2(). Float_t TCONE::GetRmax2 ; (; ); const. inline . Definition at line 43 of file TCONE.h. ◆ GetRmin2(). Float_t TCONE::GetRmin2 ; (; ); const. inline . Definition at line 42 of file TCONE.h. ◆ IsA(). TClass * TCONE::IsA ; (; ); const. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONE.html:19921,simpl,simplified,19921,doc/master/classTCONE.html,https://root.cern,https://root.cern/doc/master/classTCONE.html,1,['simpl'],['simplified']
Usability,"; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Types |; Protected Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TTreeReader Class ReferenceTreePlayer Library. ; A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. ; TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely access the information in the dataset.; Example code can be found in; tutorials/tree/hsimpleReader.C; tutorials/tree/h1analysisTreeReader.C; This example. You can generate a skeleton of TTreeReaderValue<T> and TTreeReaderArray<T> declarations for all of a tree's branches using TTree::MakeSelector().; Roottest contains an example showing the full power.; A simpler analysis example can be found below: it histograms a function of the px and py branches.; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:1027,simpl,simpler,1027,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['simpl'],['simpler']
Usability,"; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Sphere : public Shape; {; public:; Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius);; ~Sphere() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fRadius;; ; ClassDefOverride(Sphere,0);; };; ; ClassImp(Sphere);; ; Sphere::Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius) :; Shape(color,x,y,z),; fRadius(radius); {}; ; TBuffer3D & Sphere::GetBuffer3D(UInt_t reqSections); {; static TBuffer3DSphere buffer;; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t origin[3] = { 0.0, 0.0, 0.0 };; Double_t halfLength[3] = { fRadius, fRadius, fRadius };; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // Complete kShapeSpecific section; if (reqSections & TBuffer3D::kShapeSpecific) {; buffer.fRadiusOuter = fRadius;; buffer.fRadiusInner = 0.0;; buffer.fThetaMin = 0.0;; buffer.fThetaMax = 180.0;; buffer.fPhiMin = 0.0;; buffer.fPhiMax = 360.0;; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; }; // We don't implement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:2724,simpl,simple,2724,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['simpl'],['simple']
Usability,"; // old formula from G. Flucke; 3018 // formula which works also for weighted histogram (see http://root-forum.cern.ch/viewtopic.php?t=3753 ); 3019 fSumw2.fArray[i] = TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq + b1sq * e2sq / b2sq ) / b2sq );; 3020 } else {; 3021 //in case b1=b2 error is zero; 3022 //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero; 3023 fSumw2.fArray[i] = 0;; 3024 }; 3025 } else {; 3026 fSumw2.fArray[i] = c1sq * c2sq * (e1sq * b2sq + e2sq * b1sq) / (c2sq * c2sq * b2sq * b2sq);; 3027 }; 3028 }; 3029 }; 3030 ResetStats();; 3031 if (binomial); 3032 // in case of binomial division use denominator for number of entries; 3033 SetEntries ( h2->GetEntries() );; 3034 ; 3035 return kTRUE;; 3036}; 3037 ; 3038////////////////////////////////////////////////////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histogram is drawn in a pad, then filled again, the new status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:120756,usab,usable,120756,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['usab'],['usable']
Usability,"; 1 : Portrait mode with a small margin at the bottom of the page.; 2 : Landscape mode with a small margin at the bottom of the page.; 4 : Portrait mode with a large margin at the bottom of the page.; 5 : Landscape mode with a large margin at the bottom of the page.; The large margin is useful for some PostScript printers (very often; for the colour printers) as they need more space to grip the paper; for mechanical reasons. Note that some PostScript colour printers; can also use the so called special A4 format permitting the full; usage of the A4 area; in this case larger margins are not necessary; and Type=1 or 2 can be used.; 3 : Encapsulated PostScript. This Type permits the generation of files; which can be included in other documents, for example in LaTeX; files.; . Making several pictures in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw(). {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }. Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture. {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPostScript.html:3725,Clear,Clear,3725,root/html532/TPostScript.html,https://root.cern,https://root.cern/root/html532/TPostScript.html,1,['Clear'],['Clear']
Usability,"; 1 : Portrait mode with a small margin at the bottom of the page.; 2 : Landscape mode with a small margin at the bottom of the page.; 4 : Portrait mode with a large margin at the bottom of the page.; 5 : Landscape mode with a large margin at the bottom of the page.; The large margin is useful for some PostScript printers (very often; for the colour printers) as they need more space to grip the paper; for mechanical reasons. Note that some PostScript colour printers; can also use the so called special A4 format permitting the full; usage of the A4 area; in this case larger margins are not necessary; and Type=1 or 2 can be used.; 3 : Encapsulated PostScript. This Type permits the generation of files; which can be included in other documents, for example in LaTeX; files.; . Making several pictures in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw().; ; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ; Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture.; ; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPostScript.html:3754,Clear,Clear,3754,root/html534/TPostScript.html,https://root.cern,https://root.cern/root/html534/TPostScript.html,3,['Clear'],['Clear']
Usability,"; 1388In case the significance of the median is greater that the size of the box, the; 1389box will have an unnatural shape. Usually it means the chart has not enough data,; 1390or that representing this uncertainty is not useful; 1391 ; 1392##### The Mean; 1393The mean can be drawn as a dashed line or as a circle or not drawn at all.; 1394The mean is the arithmetic average of the values in the distribution.; 1395It is calculated using GetMean(). Because histograms are; 1396binned data, the mean value can differ from a calculation on the raw-data.; 1397If the distribution is large enough and gaussian shaped the mean will be; 1398exactly the median.; 1399 ; 1400##### The Whiskers; 1401The whiskers represent the part of the distribution not covered by the box.; 1402The upper 25% and the lower 25% of the distribution are located within the whiskers.; 1403Two representations are available.; 1404 ; 1405 - A simple one (using w=1) defining the lower whisker from the lowest data value; 1406 to the bottom of the box, and the upper whisker from the top of the box to the; 1407 highest data value. In this representation the whisker-lines are dashed.; 1408 - A more complex one having a further restriction. The whiskers are still connected; 1409 to the box but their length cannot exceed \f$ 1.5\times iqr \f$. So it might; 1410 be that the outermost part of the underlying distribution will not be covered; 1411 by the whiskers. Usually these missing parts will be represented by the outliers; 1412 (see points). Of course the upper and the lower whisker may differ in length.; 1413 In this representation the whiskers are drawn as solid lines.; 1414 ; 1415\since **ROOT version 6.11/01**; 1416 ; 1417Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1; 1418will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; 1419the lower whisker to the upper whisker in order to cover 95% of the distribution inside; 1420that candle. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:58890,simpl,simple,58890,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"; 16 auto *tt = new TText(0.1,0.1,""Text angle is 45 degrees"");; 17 tt->SetTextAlign(11); tt->SetTextSize(0.1);; 18 tt->SetTextAngle(45);; 19 tt->Draw();; 20 auto *t1 = new TLatex(0.3,0.18,""45^{o}"");; 21 t1->Draw();; 22}; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TArcCreate an Arc.Definition TArc.h:26; TArc::DrawArcvirtual TArc * DrawArc(Double_t x1, Double_t y1, Double_t radius, Double_t phimin=0, Double_t phimax=360, Option_t *option="""")Draw this arc with new coordinates.Definition TArc.cxx:79; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TMarkerManages Markers.Definition TMarker.h:22; TMarker::DrawMarkervirtual TMarker * DrawMarker(Double_t x, Double_t y)Draw this marker with new coordinates.Definition TMarker.cxx:208; TTextBase class for several text objects.Definition TText.h:22; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; aTArc aDefinition textangle.C:12; ttauto * ttDefinition textangle.C:16; t1auto * t1Definition textangle.C:20. corebasedocmacrostextangle.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/textangle_8C_source.html:1840,simpl,simple,1840,doc/master/textangle_8C_source.html,https://root.cern,https://root.cern/doc/master/textangle_8C_source.html,1,['simpl'],['simple']
Usability,"; 197 void MakeCopyNodes(const TGeoVolume *other);; 198 TGeoVolume *MakeReflectedVolume(const char *newname = """") const;; 199 Bool_t OptimizeVoxels(); // *MENU*; 200 void RandomPoints(Int_t npoints = 1000000, Option_t *option = """"); // *MENU*; 201 void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 202 const char *target_vol = nullptr, Bool_t check_norm = kFALSE); // *MENU*; 203 void Raytrace(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsRaytracing; 204 void RegisterYourself(Option_t *option = """");; 205 void RemoveNode(TGeoNode *node);; 206 TGeoNode *ReplaceNode(TGeoNode *nodeorig, TGeoShape *newshape = nullptr, TGeoMatrix *newpos = nullptr,; 207 TGeoMedium *newmed = nullptr);; 208 void ResetTransparency(Char_t transparency = -1); // *MENU*; 209 void SaveAs(const char *filename = """", Option_t *option = """") const override; // *MENU*; 210 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 211 void SelectVolume(Bool_t clear = kFALSE);; 212 void SetActivity(Bool_t flag = kTRUE) { TGeoAtt::SetActivity(flag); }; 213 void SetActiveDaughters(Bool_t flag = kTRUE) { TGeoAtt::SetActiveDaughters(flag); }; 214 void SetAsTopVolume(); // *TOGGLE* *GETTER=IsTopVolume; 215 void SetAdded() { TObject::SetBit(kVolumeAdded); }; 216 void SetReplicated() { TObject::SetBit(kVolumeReplicated); }; 217 void SetCurrentPoint(Double_t x, Double_t y, Double_t z);; 218 void SetCylVoxels(Bool_t flag = kTRUE); 219 {; 220 TObject::SetBit(kVoxelsCyl, flag);; 221 TObject::SetBit(kVoxelsXYZ, !flag);; 222 }; 223 void SetNodes(TObjArray *nodes); 224 {; 225 fNodes = nodes;; 226 TObject::SetBit(kVolumeImportNodes);; 227 }; 228 void SetOverlappingCandidate(Bool_t flag) { TObject::SetBit(kVolumeOC, flag); }; 229 void SetShape(const TGeoShape *shape);; 230 void SetTransparency(Char_t transparency = 0); // *MENU*; 231 void SetField(TObject *field) { fField = field; }; 232 void SetOption(const char *option);; 233 void SetAttVisibility(Bool_t vis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8h_source.html:10151,clear,clear,10151,doc/master/TGeoVolume_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html,1,['clear'],['clear']
Usability,"; 210 ; 211std::string ROOT::Experimental::RCanvas::CreateJSON(); 212{; 213 if (!fPainter); 214 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 215 ; 216 if (!fPainter); 217 return """";; 218 ; 219 return fPainter->ProduceJSON();; 220}; 221 ; 222//////////////////////////////////////////////////////////////////////////; 223/// Remove canvas from global canvas lists, will be destroyed once last shared_ptr is disappear; 224 ; 225void ROOT::Experimental::RCanvas::Remove(); 226{; 227 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 228 auto &held = GetHeldCanvases();; 229 auto indx = held.size();; 230 while (indx-- > 0) {; 231 if (held[indx].get() == this); 232 held.erase(held.begin() + indx);; 233 }; 234}; 235 ; 236//////////////////////////////////////////////////////////////////////////////////////////////; 237/// Set handle which will be cleared when connection is closed; 238 ; 239void ROOT::Experimental::RCanvas::ClearOnClose(const std::shared_ptr<void> &handle); 240{; 241 if (fPainter); 242 fPainter->SetClearOnClose(handle);; 243}; 244 ; 245//////////////////////////////////////////////////////////////////////////; 246/// Run canvas functionality for the given time (in seconds); 247/// Used to process canvas-related actions in the appropriate thread context.; 248/// Must be regularly called when canvas created and used in extra thread.; 249/// Time parameter specifies minimal execution time in seconds - if default value 0 is used,; 250/// just all pending actions will be performed.; 251/// When canvas is not yet displayed - just performs sleep for given time interval.; 252///; 253/// Example of usage:; 254///; 255/// ~~~ {.cpp}; 256/// void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); 257/// {; 258/// auto canvas = RCanvas::Create(""Canvas title"");; 259/// canvas->Draw(hist)->SetLineColor(RColor::kBlue);; 260/// canvas->Show();; 261/// while (run_loop) {; 262/// pHist->Fill(1);; 263/// canvas->Modified();; 264/// canvas->Update();; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:7735,clear,cleared,7735,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['clear'],['cleared']
Usability,"; 2381 ComputeLogs(npt, optionZ);; 2382 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2383 }; 2384 } else {; 2385 wminstep = wmin + 0.5*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86277,clear,clear,86277,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"; 2610}; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105483,clear,clear,105483,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]; Example of custom setting for the Rint application (root.exe). This overrides the default specified above for a generic application. Color 5 is yellow.; Rint.Canvas.HighLightColor: 5; 28.7 Documentation to Download. The latest ROOT Users Guide; https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html; ROOT Reference Guide; http://root.cern.ch/root/Reference.html. http://root.cern.ch/twiki/bin/view/ROOT/PROOF↩. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1265552,guid,guides,1265552,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,6,"['Guid', 'guid']","['Guide', 'guide', 'guides']"
Usability,"; 3050 } else {; 3051 Error(""InspectMembers"",; 3052 ""Cannot calculate offset of virtual base %s of class %s"",; 3053 sBaseName.c_str(), clname);; 3054 continue;; 3055 }; 3056 }; 3057 } else {; 3058 baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();; 3059 }; 3060 // TOFIX: baseCl can be null here!; 3061 if (baseCl->IsLoaded()) {; 3062 // For loaded class, CallShowMember will (especially for TObject); 3063 // call the virtual ShowMember rather than the class specific version; 3064 // resulting in an infinite recursion.; 3065 InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);; 3066 } else {; 3067 baseCl->CallShowMembers(cobj + baseOffset,; 3068 insp, isTransient);; 3069 }; 3070 } // loop over bases; 3071}; 3072 ; 3073////////////////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090////////////////////////////////////////////////////////////////////////////////; 3091/// Declare code to the interpreter, without any of the interpreter actions; 3092/// that could trigger a re-interpretation of the code. I.e. make cling; 3093/// behave like a compiler: no dynamic lookup, no input wrapping for; 3094/// subsequent execution, no automatic provision of declarations but just a; 3095/// plain `#include`.; 3096/// Returns true on success, false on failure.; 3097 ; 3098bool TCling::Declare(const char* code); 3099{; 3100 R__LOCKGUARD_CLING(gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:118899,clear,cleared,118899,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['cleared']
Usability,"; 30class RooDataSet ;; 31class RooPlot;; 32class RooRealVar;; 33class RooAbsFunc;; 34class RooAbsCategoryLValue ;; 35class RooLinkedList ;; 36class RooNumIntConfig ;; 37class RooDataHist ;; 38class RooFunctor ;; 39class RooFitResult ;; 40class RooAbsMoment ;; 41class RooDerivative ;; 42class RooVectorDataStore ;; 43struct TreeReadBuffer; /// A space to attach TBranches; 44namespace RooBatchCompute {; 45struct RunContext;; 46}; 47 ; 48class TH1;; 49class TH1F;; 50class TH2F;; 51class TH3F;; 52 ; 53#include <iostream>; 54#include <list>; 55#include <map>; 56#include <string>; 57#include <sstream>; 58 ; 59class RooAbsReal : public RooAbsArg {; 60public:; 61 using value_type = double;; 62 ; 63 /// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; 64 /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:2311,simpl,simply,2311,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['simpl'],['simply']
Usability,"; 3256 lb1->RemoveAt(k);; 3257 delete b2;; 3258 b2 = nullptr;; 3259 lb1->Compress();; 3260 break;; 3261 }; 3262 }; 3263 }; 3264 }; 3265 }; 3266 leaves->Compress();; 3267 ; 3268 // Copy MakeClass status.; 3269 newtree->SetMakeClass(fMakeClass);; 3270 ; 3271 // Copy branch addresses.; 3272 CopyAddresses(newtree);; 3273 ; 3274 //; 3275 // Copy entries if requested.; 3276 //; 3277 ; 3278 if (nentries != 0) {; 3279 if (fastClone && (nentries < 0)) {; 3280 if ( newtree->CopyEntries( this, -1, option, false ) < 0 ) {; 3281 // There was a problem!; 3282 Error(""CloneTTree"", ""TTree has not been cloned\n"");; 3283 delete newtree;; 3284 newtree = nullptr;; 3285 return nullptr;; 3286 }; 3287 } else {; 3288 newtree->CopyEntries( this, nentries, option, false );; 3289 }; 3290 }; 3291 ; 3292 return newtree;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Set branch addresses of passed tree equal to ours.; 3297/// If undo is true, reset the branch addresses instead of copying them.; 3298/// This ensures 'separation' of a cloned tree from its original.; 3299 ; 3300void TTree::CopyAddresses(TTree* tree, bool undo); 3301{; 3302 // Copy branch addresses starting from branches.; 3303 TObjArray* branches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:130468,undo,undo,130468,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['undo'],['undo']
Usability,"; 3599 ; 3600 Bool_t began3DScene = kFALSE;; 3601 fPadPaint = 1;; 3602 ; 3603 {; 3604 TContext ctxt(this, kTRUE);; 3605 ; 3606 PaintBorder(GetFillColor(), kTRUE);; 3607 PaintDate();; 3608 ; 3609 auto lnk = GetListOfPrimitives()->FirstLink();; 3610 ; 3611 while (lnk) {; 3612 TObject *obj = lnk->GetObject();; 3613 ; 3614 // Create a pad 3D viewer if none exists and we encounter a 3D shape; 3615 if (!fViewer3D && obj->InheritsFrom(TAtt3D::Class())) {; 3616 GetViewer3D(""pad"");; 3617 }; 3618 ; 3619 // Open a 3D scene if required; 3620 if (fViewer3D && !fViewer3D->BuildingScene()) {; 3621 fViewer3D->BeginScene();; 3622 began3DScene = kTRUE;; 3623 }; 3624 ; 3625 obj->Paint(lnk->GetOption());; 3626 lnk = lnk->Next();; 3627 }; 3628 }; 3629 ; 3630 fPadPaint = 0;; 3631 Modified(kFALSE);; 3632 ; 3633 // Close the 3D scene if we opened it. This must be done after modified; 3634 // flag is cleared, as some viewers will invoke another paint by marking pad modified again; 3635 if (began3DScene) {; 3636 fViewer3D->EndScene();; 3637 }; 3638}; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Paint the pad border.; 3642/// Draw first a box as a normal filled box; 3643 ; 3644void TPad::PaintBorder(Color_t color, Bool_t tops); 3645{; 3646 if (color >= 0) {; 3647 TAttLine::Modify(); //Change line attributes only if necessary; 3648 TAttFill::Modify(); //Change fill area attributes only if necessary; 3649 ; 3650 //With Cocoa we have a transparency. But we also have; 3651 //pixmaps, and if you just paint a new content over the old one; 3652 //with alpha < 1., you'll be able to see the old content.; 3653 if (!gROOT->IsBatch() && gVirtualX->InheritsFrom(""TGCocoa"") && GetPainter()); 3654 GetPainter()->ClearDrawable();; 3655 ; 3656 PaintBox(fX1,fY1,fX2,fY2);; 3657 }; 3658 if (color < 0) color = -color;; 3659 // then paint 3d frame (depending on bordermode); 3660 if (IsTransparent()) return;; 3661 // Paint a 3D frame around the pad.; 3662 ; 3663 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:114259,clear,cleared,114259,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['cleared']
Usability,"; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:19319,learn,learningRate,19319,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],['learningRate']
Usability,"; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return 0 if the formula compilation is successful; 649 ; 650Int_t TFormula::Compile(const char *expression); 651{; 652 TString formula = expression;; 653 if (formula.IsNull() ) {; 654 formula = fFormula;; 655 if (formula.IsNull() ) formula = GetTitle();; 656 }; 657 ; 658 if (formula.IsNull() ) return -1;; 659 ; 660 // do not re-process if it was done before; 661 if (IsValid() && formula == fFormula ) return 0;; 662 ; 663 // clear if a formula was already existing; 664 if (!fFormula.IsNull() ) Clear();; 665 ; 666 fFormula = formula;; 667 ; 668 if (TestBit(TFormula::kLambda) ) {; 669 bool ret = InitLambdaExpression(fFormula);; 670 return (ret) ? 0 : 1;; 671 }; 672 ; 673 if (fVars.empty() ) FillDefaults();; 674 // prepare the formula for Cling; 675 //printf(""compile: processing formula %s\n"",fFormula.Data() );; 676 PreProcessFormula(fFormula);; 677 // pass formula in CLing; 678 bool ret = PrepareFormula(fFormula);; 679 ; 680 return (ret) ? 0 : 1;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684void TFormula::Copy(TObject &obj) const; 685{; 686 TNamed::Copy(obj);; 687 // need to copy also cling parameters; 688 TFormula & fnew = dynamic_cast<TFormula&>(obj);; 689 ; 690 fnew.fClingParameters = fClingParameters;; 691 fnew.fClingVariables = fClingVariables;; 692 ; 693 fnew.fFuncs = fFuncs;; 694 fnew.fVars = fVars;; 695 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:24598,clear,clear,24598,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"; 6358 std::vector<dField> otherDist;; 6359 Int_t pMX, pMY;; 6360 Double_t MX, MY;; 6361 Int_t threshold;; 6362 TList *prims;; 6363 UInt_t n;; 6364 Rectangle_t aBBox, bBBox;; 6365 aBBox = bBBox = Rectangle_t();; 6366 TLine *L;; 6367 TArrow *A;; 6368 Int_t dSizeArrow = 12; // distance of arrows indicating same size from BBox in px; 6369 Bool_t movedX, movedY; // make sure the current object is moved just once; 6370 movedX = movedY = false;; 6371 Bool_t resize = false; // indicates resize mode; 6372 Bool_t log = gPad->GetLogx() || gPad->GetLogy();; 6373 if (mode != 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:210349,guid,guidePadClicked,210349,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['guid'],['guidePadClicked']
Usability,"; 697 newCols.AddDefine(std::move(newColumn));; 698 ; 699 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 700 ; 701 return newInterface;; 702 }; 703 ; 704 // clang-format off; 705 ////////////////////////////////////////////////////////////////////////////; 706 /// \brief Define a new column that is updated when the input sample changes.; 707 /// \param[in] name The name of the defined column.; 708 /// \param[in] expression A C++ callable that computes the new value of the defined column.; 709 /// \return the first node of the computation graph for which the new quantity is defined.; 710 ///; 711 /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; 712 /// where:; 713 /// - `T` is the type of the defined column; 714 /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; 715 /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; 716 /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; 717 /// being processed (see the class docs for more information).; 718 ///; 719 /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; 720 /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; 721 /// starts rather than at every entry.; 722 ///; 723 /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; 724 ///; 725 /// ### Example usage:; 726 /// ~~~{.cpp}; 727 /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; 728 /// df.DefinePerSample(""weightbysample"",; 729 /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); 730 /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; 731 /// ~~~; 732 // clang-format ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:37630,simpl,simplify,37630,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['simpl'],['simplify']
Usability,"; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ; 743 TString opt = option;; 744 opt.ToLower();; 745 if (opt.Contains(""d"")) {; 746 // clear subpads, but do not delete pads in case the canvas; 747 // has been divided (note: option ""D"" is propagated so could cause; 748 // conflicts for primitives using option ""D"" for something else); 749 if (fPrimitives) {; 750 TIter next(fPrimitives);; 751 TObject *obj;; 752 while ((obj=next())) {; 753 obj->Clear(option);; 754 }; 755 }; 756 } else {; 757 //default, clear everything in the canvas. Subpads are deleted; 758 TPad::Clear(option); //Remove primitives from pad; 759 }; 760 ; 761 fSelected = nullptr;; 762 fClickSelected = nullptr;; 763 fSelectedPad = nullptr;; 764 fClickSelectedPad = nullptr;; 765}; 766 ; 767//////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:23981,clear,cleared,23981,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['clear'],['cleared']
Usability,"; 777 fHistogram->SetLineStyle(GetLineStyle());; 778 fHistogram->SetLineWidth(GetLineWidth());; 779 fHistogram->SetFillColor(GetFillColor());; 780 fHistogram->SetFillStyle(GetFillStyle());; 781 fHistogram->SetMarkerColor(GetMarkerColor());; 782 fHistogram->SetMarkerStyle(GetMarkerStyle());; 783 fHistogram->SetMarkerSize(GetMarkerSize());; 784 fHistogram->SetStats(false);; 785 ; 786//- Draw the histogram; 787 if (!gPad) return;; 788 if (opt.Length() == 0) fHistogram->Paint(""cont3"");; 789 else if (opt == ""same"") fHistogram->Paint(""cont2same"");; 790 else fHistogram->Paint(option);; 791}; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Save values of function in array fSave; 795 ; 796void TF2::Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t, Double_t); 797{; 798 if (!fSave.empty()); 799 fSave.clear();; 800 Int_t npx = fNpx, npy = fNpy;; 801 if ((npx < 2) || (npy < 2)); 802 return;; 803 Double_t dx = (xmax-xmin)/fNpx;; 804 Double_t dy = (ymax-ymin)/fNpy;; 805 if (dx <= 0) {; 806 dx = (fXmax-fXmin)/fNpx;; 807 npx--;; 808 xmin = fXmin + 0.5*dx;; 809 xmax = fXmax - 0.5*dx;; 810 }; 811 if (dy <= 0) {; 812 dy = (fYmax-fYmin)/fNpy;; 813 npy--;; 814 ymin = fYmin + 0.5*dy;; 815 ymax = fYmax - 0.5*dy;; 816 }; 817 ; 818 Int_t nsave = (npx + 1) * (npy + 1);; 819 fSave.resize(nsave + 6);; 820 Double_t xv[2];; 821 Double_t *parameters = GetParameters();; 822 InitArgs(xv, parameters);; 823 for (Int_t j = 0, k = 0; j <= npy; j++) {; 824 xv[1] = ymin + dy*j;; 825 for (Int_t i = 0; i <= npx; i++) {; 826 xv[0] = xmin + dx*i;; 827 fSave[k++] = EvalPar(xv, parameters);; 828 }; 829 }; 830 fSave[nsave+0] = xmin;; 831 fSave[nsave+1] = xmax;; 832 fSave[nsave+2] = ymin;; 833 fSave[nsave+3] = ymax;; 834 fSave[nsave+4] = npx;; 835 fSave[nsave+5] = npy;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// Save primitive as a C++ statement(s) on output stream out; 840 ; 841",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:28009,clear,clear,28009,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['clear'],['clear']
Usability,"; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offset;; 927 }; 928 ; 929 //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,""DEBUG: checking on %s vs %s %lu %lu\n"",tname.c_str(),inner,offset,end);; 930 if (gROOT->GetListOfClasses()->FindObject(inner); 931 || TClassTable::Check(inner,result) ) {; 932 // This is a known class.; 933 return true;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:32092,clear,clear,32092,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"; 903 Int_t code = 0;; 904 if (x < xcl1) code = code | 0x1;; 905 if (x > xcl2) code = code | 0x2;; 906 if (y < ycl1) code = code | 0x4;; 907 if (y > ycl2) code = code | 0x8;; 908 return code;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Clip polygon using the Sutherland-Hodgman algorithm.; 913///; 914/// \param[in] n Number of points in the polygon to; 915/// be clipped; 916/// \param[in] x,y Polygon x[n], y[n] do be clipped vertices; 917/// \param[in] xclipl,yclipb,xclipr,yclipt Clipping boundary; 918/// \param[out] nn Number of points in xc and yc; 919/// \param[out] xc,yc Clipped polygon vertices. The Int_t; 920/// returned by this function is; 921/// the number of points in the clipped; 922/// polygon. These vectors must; 923/// be allocated by the calling function.; 924/// A size of 2*n for each is; 925/// enough.; 926///; 927/// Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; 928/// strategy: It solves a series of simple and identical problems that, when; 929/// combined, solve the overall problem. The simple problem is to clip a polygon; 930/// against a single infinite clip edge. Four clip edges, each defining one boundary; 931/// of the clip rectangle, successively clip a polygon against a clip rectangle.; 932///; 933/// Steps of Sutherland-Hodgman's polygon-clipping algorithm:; 934///; 935/// * Polygons can be clipped against each edge of the window one at a time.; 936/// Windows/edge intersections, if any, are easy to find since the X or Y coordinates; 937/// are already known.; 938/// * Vertices which are kept after clipping against one window edge are saved for; 939/// clipping against the remaining edges.; 940/// * Note that the number of vertices usually changes and will often increases.; 941///; 942/// The clip boundary determines a visible and invisible region. The edges from; 943/// vertex i to vertex i+1 can be one of four types:; 944///; 945/// * Case 1 : W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:29064,simpl,simple,29064,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['simpl'],['simple']
Usability,"; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:28320,simpl,simply,28320,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simply']
Usability,"; ; h2bh->Draw(""hbar min0 same"");; }. TH2Poly Drawing; The following options are supported:. Option Description . ""SCAT"" Draw a scatter plot (legacy draw option). . ""COL"" Draw a color plot. All the bins are painted even the empty bins (default). . ""COLZ"" Same as ""COL"". In addition the color palette is also drawn. . ""0"" When used with any COL options, the empty bins are not drawn. . ""TEXT"" Draw bin contents as text (format set via gStyle->SetPaintTextFormat). . ""TEXTN"" Draw bin names as text. . ""TEXTnn"" Draw bin contents as text at angle nn (0 < nn <= 90). . ""L"" Draw the bins boundaries as lines. The lines attributes are the TGraphs ones. . ""P"" Draw the bins boundaries as markers. The markers attributes are the TGraphs ones. . ""F"" Draw the bins boundaries as filled polygons. The filled polygons attributes are the TGraphs ones. . TH2Poly can be drawn as a color plot (option COL). TH2Poly bins can have any shapes. The bins are defined as graphs. The following macro is a very simple example showing how to book a TH2Poly and draw it.; {; auto ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; auto h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; double px1[] = {0, 5, 6};; double py1[] = {0, 0, 5};; double px2[] = {0, -1, -1, 0};; double py2[] = {0, 0, -1, 3};; double px3[] = {4, 3, 0, 1, 2.4};; double py3[] = {4, 3.7, 1, 3.7, 2.5};; h2p->AddBin(3, px1, py1);; h2p->AddBin(4, px2, py2);; h2p->AddBin(5, px3, py3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; double fx[] = {0.1, -0.5, -0.7, 1};; double fy[] = {0.01, -0.5, -0.5, 3};; double fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; h2p->Draw(""col"");; }; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66. Rectangular bins are a frequent case. The special version of the AddBin method allows to define them more easily like shown in the following example (th2polyBoxes.C).; ; TCanvas *th2polyBoxes() {; TCanvas *ch2p2 = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:102721,simpl,simple,102721,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"; Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. void Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. void Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the histogram (also called ""the sea""). The third parameter can be left; blank.; The overflow/underflow bins are:. -1 | -2 | -3. -4 | -5 | -6. -7 | -8 | -9. where -5 means is the ""sea"" bin (i.e. unbinned areas). Int_t Fill(Double_t x, Double_t y); Increment the bin containing (x,y) by 1.; Uses the partitioning algorithm. Int_t Fill(Double_t x, Double_t y, Double_t w); Increment the bin containing (x,y) by w.; Uses the partitioning algorithm. Int_t Fill(const char* name, Double_t w); Increment the bin named ""name"" by w. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2Poly.html:32574,Clear,ClearBinContents,32574,root/html532/TH2Poly.html,https://root.cern,https://root.cern/root/html532/TH2Poly.html,2,['Clear'],"['ClearBinContents', 'Clears']"
Usability,"; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible effects of the various display; modes we introduce a set of examples. Default values:. modeGroup = kModeGroupLightHeight ; displayMode = kDisplayModeSurface . Simple modes group, display mode = points, 256 x 256 channels. Simple modes group, display mode = grid, 64 x 64 channels. Simple modes group, display mode = contours, 64 x 64 channels. Simple modes group, display mode = bars, 64 x 64 channels. Simple modes group, display mode = linesX, 64 x 64 channels. Simple modes group, display mode = linesY, 64 x 64 channels. Simple modes group, display mode = barsX, 64 x 64 channels. Simple modes group, display mode = barsY, 64 x 64 channels. Simple modes group, display mode = needles, 64 x 64 channels. Simple modes group, display mode = triangles, 64 x 64 channels. Light modes group, display mode = points, 256 x 256 channels. Light modes group, display mode = grid, 256 x 256 channels. Light modes group, display mode = surface, 64 x 64 channels. Light modes group, display mode = triangles, 64 x 64 channels. Height modes group, display mode = points, 256 x 256 channels. Height modes group, display mode = grid, 256 x 256 channels. Height modes group, display mode = contours, 64 x 64 channels. Height modes group, display mode = bars, 64 x 64 channels. Height modes group, display mode = surface, 64 x 64 channels. Height modes group, display mode = triangles, 64 x 64 channels. Light - height modes group, display mode = surface, 64 x 64 channels. The weight; between both shading algorithms is set to 0.5. One can observe the influence of; both shadings.; Function:; TSpectrum2Painter::SetPenAttr(Int_t color,Int_t style,Int_t width). Using this function one can change pen color, pen style and pen width.; Possible pen styles",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:18377,Simpl,Simple,18377,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Tue Jun 2 15:29:53 2015 » Last generated: 2015-06-02 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooChangeTracker.html:38551,clear,clearState,38551,root/html604/RooChangeTracker.html,https://root.cern,https://root.cern/root/html604/RooChangeTracker.html,8,['clear'],"['clearState', 'cleared']"
Usability,"; Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooThresholdCategory.html:2177,clear,clearValueAndShapeDirty,2177,root/html532/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 11. Done!. Congratulations for finishing the tutorials! Here are a few relevant pointers on where to go from here:; The forum; Bug reports - also for bugs in this workshop!; The ROOT's tutorials - you find them in $ROOTSYS/tutorials; We hope to hear from you!; Your ROOT team. . ‹ TutorialSelector.C; up. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/11-done.html:2732,guid,guidelines,2732,d/11-done.html,https://root.cern,https://root.cern/d/11-done.html,1,['guid'],['guidelines']
Usability,"; Build session frame. void ProofInfos(); Display information on current session. void OnBtnUploadDSet(); Open Upload Dataset dialog. void UpdateListOfDataSets(); Update list of dataset present on the cluster. void OnBtnRemoveDSet(); Remove dataset from the list and from the cluster. void OnBtnVerifyDSet(); Verify that the files in the selected dataset are present on the cluster. void OnApplyLogLevel(); Apply selected log level on current session. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. TSessionFrame(TGWindow* parent, Int_t w, Int_t h).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionFrame.html:23240,Clear,Clear,23240,root/html602/TSessionFrame.html,https://root.cern,https://root.cern/root/html602/TSessionFrame.html,2,['Clear'],['Clear']
Usability,"; Build session frame. void ProofInfos(); Display information on current session. void OnBtnUploadDSet(); Open Upload Dataset dialog. void UpdateListOfDataSets(); Update list of dataset present on the cluster. void OnBtnRemoveDSet(); Remove dataset from the list and from the cluster. void OnBtnVerifyDSet(); Verify that the files in the selected dataset are present on the cluster. void OnApplyLogLevel(); Apply selected log level on current session. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionFrame.html:22281,Clear,Clear,22281,root/html534/TSessionFrame.html,https://root.cern,https://root.cern/root/html534/TSessionFrame.html,1,['Clear'],['Clear']
Usability,"; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::QuickMVAProbEstimator. class TMVA::QuickMVAProbEstimator. Function Members (Methods); public:. virtual~QuickMVAProbEstimator(); voidAddEvent(Double_t val, Double_t weight, Int_t type); static TClass*Class(); static boolcompare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); Double_tGetMVAProbAt(Double_t value); virtual TClass*IsA() const; TMVA::QuickMVAProbEstimator&operator=(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. vector<EventInfo>fEvtVector; Bool_tfIsSorted; TMVA::MsgLogger*fLogger; UInt_tfNMax; UInt_tfNMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddEvent(Double_t val, Double_t weight, Int_t type). Double_t GetMVAProbAt(Double_t value); Well.. if it's fast is actually another question all together, merely; it's a quick and dirty simple kNN approach to the 1-Dim signal/backgr. MVA; distributions. bool compare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); {return e1.eventValue < e2.eventValue;}. QuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); { fLogger = new MsgLogger(""QuickMVAProbEstimator"");}. virtual ~QuickMVAProbEstimator(); {delete fLogger;}. » Last changed: Tue Sep 8 17:04:43 2015 » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__QuickMVAProbEstimator.html:1465,simpl,simple,1465,root/html534/TMVA__QuickMVAProbEstimator.html,https://root.cern,https://root.cern/root/html534/TMVA__QuickMVAProbEstimator.html,2,['simpl'],['simple']
Usability,"; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 0. Setting up ROOT. Downloading; If you don't have ROOT yet, download it! We have binaries but you can also build it yourself.; Environment Variables; ROOT expects ROOTSYS, PATH and LD_LIBRARY_PATH to be set correctly. If which root does not show anything then use the script that does all of that:; source wherever/root/is/bin/thisroot.sh. Starting ROOT; Now you can start ROOT using root or root -l to suppress the logo. See root --help for more options. . ‹ ROOT 6 Analysis Workshop; up; 1. Extracting an object from a TFile ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/0-setting-root.html:2967,guid,guidelines,2967,d/0-setting-root.html,https://root.cern,https://root.cern/d/0-setting-root.html,1,['guid'],['guidelines']
Usability,"; Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:45141,Clear,ClearOverlaps,45141,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,8,['Clear'],"['Clear', 'ClearOverlaps']"
Usability,"; Definition at line 212 of file DecisionTree.h. ◆ fSepType. SeparationBase* TMVA::DecisionTree::fSepType. private . the separation criteria ; Definition at line 211 of file DecisionTree.h. ◆ fSigClass. UInt_t TMVA::DecisionTree::fSigClass. private . class which is treated as signal when building the tree ; Definition at line 235 of file DecisionTree.h. ◆ fTreeID. Int_t TMVA::DecisionTree::fTreeID. private . just an ID number given to the tree.. makes debugging easier as tree knows who he is. ; Definition at line 237 of file DecisionTree.h. ◆ fUseExclusiveVars. Bool_t TMVA::DecisionTree::fUseExclusiveVars. private . individual variables already used in fisher criterium are not anymore analysed individually for node splitting ; Definition at line 209 of file DecisionTree.h. ◆ fUseFisherCuts. Bool_t TMVA::DecisionTree::fUseFisherCuts. private . use multivariate splits using the Fisher criterium ; Definition at line 207 of file DecisionTree.h. ◆ fUseNvars. Int_t TMVA::DecisionTree::fUseNvars. private . the number of variables used in randomised trees; ; Definition at line 227 of file DecisionTree.h. ◆ fUsePoissonNvars. Bool_t TMVA::DecisionTree::fUsePoissonNvars. private . use ""fUseNvars"" not as fixed number but as mean of a poisson distr. in each split ; Definition at line 228 of file DecisionTree.h. ◆ fUseSearchTree. Bool_t TMVA::DecisionTree::fUseSearchTree. private . cut scan done with binary trees or simple event loop. ; Definition at line 218 of file DecisionTree.h. ◆ fVariableImportance. std::vector< Double_t > TMVA::DecisionTree::fVariableImportance. private . the relative importance of the different variables ; Definition at line 232 of file DecisionTree.h. Libraries for TMVA::DecisionTree:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/DecisionTree.h; tmva/tmva/src/DecisionTree.cxx. TMVADecisionTree. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:31689,simpl,simple,31689,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['simpl'],['simple']
Usability,"; Definition at line 384 of file RooAbsArg.h. ◆ changeServer(). void RooAbsArg::changeServer ; (; RooAbsArg & ; server, . bool ; valueProp, . bool ; shapeProp . ). Change dirty flag propagation mask for specified server. ; Definition at line 438 of file RooAbsArg.cxx. ◆ checkObservables(). bool RooAbsArg::checkObservables ; (; const RooArgSet * ; nset); const. virtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented in RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooRealSumFunc, and RooRealSumPdf.; Definition at line 817 of file RooAbsArg.cxx. ◆ cleanBranchName(). TString RooAbsArg::cleanBranchName ; (; ); const. protected . Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ; Definition at line 2075 of file RooAbsArg.cxx. ◆ clearShapeDirty(). void RooAbsArg::clearShapeDirty ; (; ); const. inlineprotected . Definition at line 579 of file RooAbsArg.h. ◆ clearValueAndShapeDirty(). void RooAbsArg::clearValueAndShapeDirty ; (; ); const. inlineprotected . Definition at line 571 of file RooAbsArg.h. ◆ clearValueDirty(). void RooAbsArg::clearValueDirty ; (; ); const. inlineprotected . Definition at line 576 of file RooAbsArg.h. ◆ clients(). const RefCountList_t & RooAbsArg::clients ; (; ); const. inline . List of all clients of this object. ; Definition at line 166 of file RooAbsArg.h. ◆ clone(). virtual TObject * RooAbsArg::clone ; (; const char * ; newname = nullptr); const. pure virtual . Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:50558,clear,clearShapeDirty,50558,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearShapeDirty']
Usability,"; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Program of Work. The program of work is guided by the project vision laid out here, and documented for the relevant years in the following documents:; 2019. Presentation. 2018. Presentation. 2017. Presentation at the ROOT planning meeting, Jan 11 2017; JIRA items. 2016. Presentation at the EP-SFT group meeting. 2015. Presentation at the PH-SFT group meeting. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/program-work.html:1904,guid,guided,1904,d/program-work.html,https://root.cern,https://root.cern/d/program-work.html,2,['guid'],"['guided', 'guidelines']"
Usability,"; FitAndPlotH2(*h2ARP);; }; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< int >; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::VecOps::powRVec< PromoteTypes< T0, T1 > > pow(const T0 &x, const RVec< T1 > &v)Definition RVec.hxx:1846; ROOT::VecOps::expRVec< PromoteType< T > > exp(const RVec< T > &v)Definition RVec.hxx:1837; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; fdm5Double_t fdm5(Double_t *xx, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df101__h1Analysis_8C.html:4996,simpl,simple,4996,doc/master/df101__h1Analysis_8C.html,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html,1,['simpl'],['simple']
Usability,"; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 91 of file RooProofDriverSelector.cxx. ◆ Process(). bool RooProofDriverSelector::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector.; Definition at line 66 of file RooProofDriverSelector.cxx. ◆ SetInputList(). void RooProofDriverSelector::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 35 of file RooProofDriverSelector.h. ◆ SetObject(). void RooProofDriverSelector::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 34 of file RooProofDriverSelector.h. ◆ SetOption(). void Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProofDriverSelector.html:15896,simpl,simple,15896,doc/master/classRooProofDriverSelector.html,https://root.cern,https://root.cern/doc/master/classRooProofDriverSelector.html,1,['simpl'],['simple']
Usability,"; Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:18810,Clear,Clear,18810,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"; Int_tTGFrame::fBorderWidthframe border width; TGTextButton*fCancelCancel-Button to reprobate the rebinned histogram; TGClient*TGObject::fClientConnection to display server; TGComboBox*fCoordsComboCoordinate System combo box; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelaydrawDelayed drawing of the new axis range; TGRadioButton*fDim2D-Plot RadioButton; TGRadioButton*fDim03D-Plot RadioButton; TGLayoutHints*fDim0lhlayout hints for 3D-Plot RadioButton; TGHButtonGroup*fDimGroupRadiobuttongroup to change 2D <-> 3D-Plot; TGLayoutHints*fDimlhlayout hints for 2D-Plot RadioButton; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGComboBox*fErrorComboError combo box; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; TH1*fHisthistogram object; TGCheckButton*fHistOnOffDraw a simple histogram with default options; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fMakeHBarDraw Horizontal Bar Chart; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:24587,simpl,simple,24587,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,10,['simpl'],['simple']
Usability,"; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidexpand(). Data Members; protected:. RooSetPair*_asArr! do not persist; RooHashTable*_htable! do not persist; RooNameSet_name1!; RooNameSet_name2!; Int_t_nreg; Int_t_regSize; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(Int_t regSize); Construct normalization set manager with given initial size. RooNormSetCache(const RooNormSetCache& other); Copy constructor. ~RooNormSetCache(); Destructor. void clear(); Clear contents. void initialize(const RooNormSetCache& other); Initialize cache from contents of given other cache. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. void expand(); Expand registry size by doubling capacity. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0). Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }. const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNormSetCache.html:2569,clear,clear,2569,root/html526/RooNormSetCache.html,https://root.cern,https://root.cern/root/html526/RooNormSetCache.html,1,['clear'],['clear']
Usability,"; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development » Git Primer A suggested work flow for distributed projects: NoSY. Overview; Building on the tips and other points explained elsewhere, this workflow has the following advantages relative to always working on the master branch:; It is easy to keep track of upstream changes even when working on a protracted task.; The change tree remains simple, easy to understand at a glance and even (mostly) linear (revision trees with multiple developers can quickly start looking like a train switch yard); Unsightly ""merge with branch"" commits are minimized.; It is easy to keep separate unrelated tasks upon which you may be working simultaneously.; Commits related to each other can be kept together or merged for increased clarity.; For the purposes of having an easy-to-remember label, I will refer to this workflow as the ""No Switch Yard"" (NoSY) workflow.; Details of NoSY; For each specific, well-defined task:; Create a local branch and switch to it:git checkout -b <local-branch>; Work on the branch, both committing regularly and keeping up-to-date with the remote (eg):git fetch origin; git rebase origin/master; When ready to push back to the main remote, squash related commits (see above).; Change back to your master branch:git checkout master; Make sure your master is up-to-date:git pull; Merge with the branch:git merge --ff-only <local-branch>; If this operation fails:; Swap back to the other branchgit checkout <local-br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/suggested-work-flow-distributed-projects-nosy.html:2240,simpl,simple,2240,d/suggested-work-flow-distributed-projects-nosy.html,https://root.cern,https://root.cern/d/suggested-work-flow-distributed-projects-nosy.html,1,['simpl'],['simple']
Usability,"; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:7109,learn,learning,7109,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,3,['learn'],['learning']
Usability,"; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:226175,Guid,Guide,226175,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"; PEAC - A set of tools to quickly enable PROOF on a cluster poster presented by Gerri Ganis and Martin Vala.; Preparing for the new C++11 standard poster presented by Axel Naumann;; ROOT: High Quality, Systematically poster presented by Axel Naumann;; Improvements in ROOT I/O poster presented by Philippe Canal. An Exhibition Booth for demonstrating recent developments in data processing software used at the LHC presented by the CERN PH-SFT group (in Kimmel).; Papers NOT by the ROOT team, but related in spirit. The ""Bazaar"" software development process we try to follow:; The Cathedral and the Bazaar by Eric S. Raymond. In case you want to cite CINT, use the following references. C++ Interpreter - CINT, Masaharu Goto, CQ publishing, ISBN4-789-3085-3 (Japanese); Concept and application of Cint C++ interpreter, Masaharu Goto, Interface magazine 1996Aug-Nov, CQ publisihing, (Japanese); Cint - embedding Tcl/Tk graphics, Masaharu Goto, Interface magazine 1997 Feb, CQ publishing, (Japanese); BeOS and ROOT, Masaharu Goto, Interface magazine 1997 Sep, CQ publisihing, (Japanese); Learning C++ with CINT, Masaharu Goto, C magazine 1998Apr-1999Mar, Softbank Co, (Japanese); ROOT: An object oriented data analysis framework, Rene Brun & Fons Rademakers Linux Journal 998July Issue 51, Metro Link Inc, (English). Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/publications.html:5456,guid,guidelines,5456,d/publications.html,https://root.cern,https://root.cern/d/publications.html,1,['guid'],['guidelines']
Usability,"; Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value).Define(""twice"", ""col * 2"");; auto df_filtered = df.FilterAvailable(""col"").Define(""twice"", ""col * 2"");; ; // Same number of total entries as the input dataset, with defaulted values; df_default.Display({""twice""})->Print();; // Only keep the entries where ""col"" has values; df_filtered.Display({""twice""})->Print();; Further considerations; Note that working with missing values is currently supported with a TTree-based data source. Support of this functionality for other data sources may come in the future. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:86631,simpl,simple,86631,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"; Protected Member Functions |; List of all members ; RooConstVar Class ReferencefinalRooFit » RooFit Core. ; Represents a constant real-valued object. ; Definition at line 23 of file RooConstVar.h. Public Member Functions;  RooConstVar ();  ;  RooConstVar (const char *name, const char *title, double value);  Constructor with value. ;  ;  RooConstVar (const RooConstVar &other, const char *name=nullptr);  Copy constructor. ;  ; void changeVal (double value);  Change the value of this constant. ;  ; TObject * clone (const char *newname) const override;  ; double getValV (const RooArgSet *) const override;  Return (constant) value. ;  ; TClass * IsA () const override;  ; bool isDerived () const override;  Returns false, as the value of the constant doesn't depend on other objects. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:1319,simpl,simple,1319,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['simpl'],['simple']
Usability,"; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >Stochastic Batch Gradient Descent Optimizer class. ; This class represents the Stochastic Batch Gradient Descent Optimizer with options for applying momentum and nesterov momentum. ; Definition at line 46 of file SGD.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TSGD (Scalar_t learningRate, DeepNet_t &deepNet, Scalar_t momentum);  Constructor. ;  ;  ~TSGD ()=default;  Destructor. ;  ; Scalar_t GetMomentum () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastBiasGradients ();  ; std::vector< Matrix_t > & GetPastBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastWeightGradients ();  ; std::vector< Matrix_t > & GetPastWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html:1178,learn,learningRate,1178,doc/master/classTMVA_1_1DNN_1_1TSGD.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html,1,['learn'],['learningRate']
Usability,"; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Types |; Protected Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TTreeReader Class ReferenceTreePlayer Library. ; A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. ; TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely access the information in the dataset.; Example code can be found in; tutorials/tree/hsimpleReader.C; tutorials/tree/h1analysisTreeReader.C; This example. You can generate a skeleton of TTreeReaderValue<T> and TTreeReaderArray<T> declarations for all of a tree's branches using TTree::MakeSelector().; Roottest contains an example showing the full power.; A simpler analysis example can be found below: it histograms a function of the px and py branches.; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:1130,simpl,simple,1130,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['simpl'],['simple']
Usability,"; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Meetings. All ROOT-related meetings ca be found in ROOT's Indico category; the upcoming ones can be seen here to the right.; Weekly Developers Meetings; Developers get together on a weekly basis to discuss the plans and review the progress on Monday's at 16:00 CET. Indico category; Vidyo ROOT Team meeting. Experiments Planning Meetings; Experiments and core developers meet regularly to discuss the progress of open issues and future plans on Wednesdays at 16:00 CET. Indico category; Vidyo Room . Topical meetings; Several of the ROOT packages have dedicated meetings, for instance I/O, TMVA, RooFit, C++ Modules. These meetings, too, can be found in ROOT's Indico category. Root Meetings. ROOT Framework Meetings ; 78th ROOT Parallelism, Performance and Programming Model Meeting ; 07/02/2020 - ; CERN - ; 4/S-030 . ROOT Framework Meetings ; ROOT I/O Meeting ; 07/03/2020 - ; CERN - ; 32/1-A24 . ROOT Framework Meetings ; TMVA Developers Meeting ; 07/03/2020 . ROOT Framework Meetings ; Biweekly meeting: C++ Modules in ROOT ; 07/08/2020 . ROOT Framework Meetings ; ROOT I/O Meeting ; 07/10/2020 - ; CERN - ; 32/1-A24 .  ; 1 of 5; next ›. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meetings.html:3236,guid,guidelines,3236,d/meetings.html,https://root.cern,https://root.cern/d/meetings.html,1,['guid'],['guidelines']
Usability,"; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TMultiLayerPerceptron Class Reference. ; This class describes a neural network. ; There are facilities to train the network and use the output.; The input layer is made of inactive neurons (returning the optionally normalized input) and output neurons are linear. The type of hidden neurons is free, the default being sigmoids. (One should still try to pass normalized inputs, e.g. between [0.,1]); The basic input is a TTree and two (training and test) TEventLists. Input and output neurons are assigned a value computed for each event with the same possibilities as for TTree::Draw(). Events may be weighted individually or via TTree::SetWeight(). 6 learning methods are available: kStochastic, kBatch, kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; This implementation, written by C. Delaere, is inspired from the mlpfit package from J.Schwindling et al. with some extensions:. the algorithms are globally the same; in TMultilayerPerceptron, there is no limitation on the number of layers/neurons, while MLPFIT was limited to 2 hidden layers; TMultilayerPerceptron allows you to save the network in a root file, and provides more export functionalities; TMultilayerPerceptron gives more flexibility regarding the normalization of inputs/outputs; TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to use cross-entropy errors, which allows to train a network for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:993,learn,learning,993,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"; ROOT::Math::VirtualIntegratorOneDim ; ROOT::Math::WrappedMultiTF1 ; ROOT::Math::WrappedTF1 ; ROOT::MathMore ; ROOT::Minuit2::CombinedMinimizer ; ROOT::Minuit2::FCNBase ; ROOT::Minuit2::FCNGradientBase ; ROOT::Minuit2::FumiliFCNBase ; ROOT::Minuit2::FumiliMinimizer ; ROOT::Minuit2::FunctionMinimizer ; ROOT::Minuit2::FunctionMinimum ; ROOT::Minuit2::GenericFunction ; ROOT::Minuit2::MinosError ; ROOT::Minuit2::Minuit2Minimizer ; ROOT::Minuit2::MinuitParameter ; ROOT::Minuit2::MnApplication ; ROOT::Minuit2::MnContours ; ROOT::Minuit2::MnFumiliMinimize ; ROOT::Minuit2::MnHesse ; ROOT::Minuit2::MnMachinePrecision ; ROOT::Minuit2::MnMigrad ; ROOT::Minuit2::MnMinimize ; ROOT::Minuit2::MnMinos ; ROOT::Minuit2::MnPlot ; ROOT::Minuit2::MnScan ; ROOT::Minuit2::MnSimplex ; ROOT::Minuit2::MnStrategy ; ROOT::Minuit2::MnTraceObject ; ROOT::Minuit2::MnUserParameterState ; ROOT::Minuit2::MnUserParameters ; ROOT::Minuit2::ModularFunctionMinimizer ; ROOT::Minuit2::ScanMinimizer ; ROOT::Minuit2::SimplexMinimizer ; ROOT::Minuit2::VariableMetricMinimizer ; ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<bool,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<char,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<double,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<float,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<int,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<long,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<short,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> > ; ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> > ; ROOT::TBranchProxy ; ROOT::TBranchProxyClassDescriptor Class to cache the information we gathered about the branch and its content; ROOT::TBranchProxyDescriptor Describe the proxy for a branch; ROOT::TBranchProxyDirector ; ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> > ; ROOT::TClaArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:21210,Simpl,SimplexMinimizer,21210,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Simpl'],['SimplexMinimizer']
Usability,"; ROOT::TSchemaRule::fChecksumTString fChecksumSource version vector (for searching purposes)Definition TSchemaRule.h:103; ROOT::TSchemaRule::fTargetClassTString fTargetClassDefinition TSchemaRule.h:106; ROOT::TSchemaRule::SetSourcevoid SetSource(const TString &source)Set the list of source members.Definition TSchemaRule.cxx:538; ROOT::TSchemaRule::IsRenameRuleBool_t IsRenameRule() constReturn kTRUE if the rule is a strict renaming of the class to a new name.Definition TSchemaRule.cxx:756; ROOT::TSchemaRule::SetAttributesvoid SetAttributes(const TString &attributes)Set the attributes code of this rule.Definition TSchemaRule.cxx:656; ROOT::TSchemaRule::fSourceClassTString fSourceClassSource checksum vector (for searching purposes)Definition TSchemaRule.h:105; ROOT::TSchemaRule::HasTargetBool_t HasTarget(const TString &target) constReturn true if one of the rule's data member target is 'target'.Definition TSchemaRule.cxx:672; ROOT::TSchemaRule::GetTargetStringconst char * GetTargetString() constGet the target data members of this rule as a simple string (i.e. the in memory data member).Definition TSchemaRule.cxx:512; ROOT::TSchemaRule::fVersionVectstd::vector< std::pair< Int_t, Int_t > > * fVersionVectDefinition TSchemaRule.h:102; ROOT::TSchemaRule::fReadRawFuncPtrReadRawFuncPtr_t fReadRawFuncPtrConversion function pointer for read rule.Definition TSchemaRule.h:116; ROOT::TSchemaRule::fRuleTypeRuleType_t fRuleTypeConversion function pointer for readraw rule.Definition TSchemaRule.h:117; ROOT::TSchemaRule::IsValidBool_t IsValid() constReturn kTRUE if this rule is valid.Definition TSchemaRule.cxx:632; ROOT::TSchemaRule::GetReadFunctionPointerReadFuncPtr_t GetReadFunctionPointer() constGet the pointer to the function to be run for the rule (if it is a read rule).Definition TSchemaRule.cxx:716; ROOT::TSchemaRule::GetVersionconst char * GetVersion() constGet the version string.Definition TSchemaRule.cxx:393; ROOT::TSchemaRule::GetAttributesconst char * GetAttributes() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:43778,simpl,simple,43778,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,2,['simpl'],['simple']
Usability,"; Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17053,feedback,feedback,17053,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['feedback'],['feedback']
Usability,"; Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:15694,feedback,feedback,15694,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"; Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSceneBase.html:5376,clear,clear,5376,root/html528/TGLSceneBase.html,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html,10,['clear'],['clear']
Usability,"; Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. Long64_t GetBin(const Int_t* idx) const; { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }. Long64_t GetBin(const Double_t* x) const; { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }. Long64_t GetBin(const char** name)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:18835,Clear,Clear,18835,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,1,['Clear'],['Clear']
Usability,"; Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse(const THnSparse& ). THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024 * 16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024 * 16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. Long64_t GetBin(const Int_t* idx) const; { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }. Long64_t GetBin(const Double_t* x) const; { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:20085,Clear,Clear,20085,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,2,['Clear'],['Clear']
Usability,"; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:3667,clear,clearValueAndShapeDirty,3667,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:6624,clear,clearValueAndShapeDirty,6624,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2844,clear,clearEvalErrorLog,2844,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,6,['clear'],['clearEvalErrorLog']
Usability,"; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__BayesianCalculator.html:11307,clear,clear,11307,root/html534/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__BayesianCalculator.html,9,"['Clear', 'clear']","['ClearAll', 'clear']"
Usability,"; RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:2456,Clear,Clear,2456,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,1,['Clear'],['Clear']
Usability,"; Searching...; No Matches. df004_cutFlowReport.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Display cut/Filter efficiencies with RDataFrame. ; This tutorial shows how to get information about the efficiency of the filters applied; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectors = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(50);; int i(0);; d.Define(""b1"", [&i]() { return (double)i; }); .Define(""b2"",; [&i]() {; auto j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; void df004_cutFlowReport(); {; ; // We prepare an input tree to run on; auto fileName = ""df004_cutFlowReport.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName, {""b1"", ""b2""});; ; // ## Define cuts and create the report; // Here we define two simple cuts; auto cut1 = [](double b1) { return b1 > 25.; };; auto cut2 = [](int b2) { return 0 == b2 % 2; };; ; // An optional string parameter name can be passed to the Filter method to create a named filter.; // Named filters work as usual, but also keep track of how many entries they accept and reject.; auto filtered1 = d.Filter(cut1, {""b1""}, ""Cut1"");; auto filtered2 = d.Filter(cut2, {""b2""}, ""Cut2"");; ; auto augmented1 = filtered2.Define(""b3"", [](double b1, int b2) { return b1 / b2; });; auto cut3 = [](double x) { return x < .5; };; auto filtered3 = augmented1.Filter(cut3, {""b3""}, ""Cut3"");; ; // Statistics are retrieved through a call to the Report method:; // when Report is called on the main RDataFrame object, it retrieves stats; // for all named filters declared up to that point.; // When called on a stored chain state (i.e. a chain/graph node), it; // retrieves stats for all named fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df004__cutFlowReport_8C.html:1215,simpl,simple,1215,doc/master/df004__cutFlowReport_8C.html,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8C.html,1,['simpl'],['simple']
Usability,"; TDecompBK Matrix Decomposition Bunch-Kaufman; TDecompBase Matrix Decomposition Base; TDecompChol Matrix Decompositition Cholesky; TDecompLU Matrix Decompositition LU; TDecompQRH Matrix Decompositition QRH; TDecompSVD Matrix Decompositition SVD; TDecompSparse Matrix Decompositition LU; TDialogCanvas A specialized canvas to set attributes.; TDiamond Diamond class; TDictAttributeMap Container for name/value pairs of TDictionary attributes; TDictionary ABC defining interface to dictionary; TDirectory Describe directory structure in memory; TDirectoryFile Describe directory structure in a ROOT file; TDocDirective THtml directive handler; TDocHtmlDirective Handler for ""Begin_Html""/""End_Html"" for raw HTML in documentation comments; TDocLatexDirective Handler for ""Begin_Latex""/""End_Latex"" to generate an image from latex; TDocMacroDirective Handler for ""Begin_Macro""/""End_Macro"" for code that is executed and that can generate an image for documentation; TDocOutput generates documentation web pages; TDocParser parser for reference documentation; TDrawFeedback Present PROOF query feedback; TELTU ELTU shape; TEditQueryFrame Edit query frame; TEfficiency calculating efficiencies; TEllipse An ellipse; TEmulatedCollectionProxy ; TEmulatedMapProxy ; TEntryList A list of entries in a TTree; TEntryListArray A list of entries and subentries in a TTree; TEntryListBlock Used internally in TEntryList to store the entry numbers; TEntryListFromFile Manager for entry lists from different files; TEnv Handle ROOT configuration resources; TEnvRec Individual TEnv records; TEve3DProjection 3D scaling ""projection""; TEveArrow Class for gl visualisation of arrow.; TEveArrowEditor GUI editor for TEveArrow.; TEveArrowGL GL renderer class for TEveArrow.; TEveBox 3D box with arbitrary vertices.; TEveBoxGL GL renderer class for TEveBox.; TEveBoxProjected Projection of TEveBox.; TEveBoxProjectedGL GL renderer class for TEveBoxProjected.; TEveBoxSet Collection of 3D primitives (fixed-size boxes, boxes of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:60062,feedback,feedback,60062,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['feedback'],['feedback']
Usability,"; TGHtmlBlock * ; pBlock, . Drawable_t ; wid, . int ; left, . int ; top, . int ; width, . int ; height, . Pixmap_t ; pixmap . ). protected . Display a single HtmlBlock. This is where all the drawing happens. ; Definition at line 315 of file TGHtmlDraw.cxx. ◆ ButtonClicked(). void TGHtml::ButtonClicked ; (; const char * ; name, . const char * ; val . ). virtual . Emit ButtonClicked() signal. ; Definition at line 1286 of file TGHtml.cxx. ◆ CellSpacing(). int TGHtml::CellSpacing ; (; TGHtmlElement * ; pTable). Return the appropriate cell spacing for the given table. ; Definition at line 53 of file TGHtmlTable.cxx. ◆ CheckToggled(). void TGHtml::CheckToggled ; (; const char * ; name, . Bool_t ; on, . const char * ; val . ). virtual . Emit CheckToggled() signal. ; Definition at line 1299 of file TGHtml.cxx. ◆ ClassDefOverride(). TGHtml::ClassDefOverride ; (; TGHtml ; , . 0 ;  . ). protected . ◆ Clear(). void TGHtml::Clear ; (; Option_t * ; = """"). overridevirtual . Erase all HTML from this widget and clear the screen. ; This is typically done before loading a new document. ; Reimplemented from TObject.; Definition at line 310 of file TGHtml.cxx. ◆ ClearGcCache(). void TGHtml::ClearGcCache ; (; ). protected . Clear the cache of GCs. ; Definition at line 516 of file TGHtml.cxx. ◆ ColorDistance(). float TGHtml::ColorDistance ; (; ColorStruct_t * ; pA, . ColorStruct_t * ; pB . ). protected . Compute the squared distance between two colors. ; Definition at line 1613 of file TGHtml.cxx. ◆ ComputeVirtualSize(). void TGHtml::ComputeVirtualSize ; (; ). protected . Computes virtual size of html area. ; Definition at line 508 of file TGHtml.cxx. ◆ ControlSize(). int TGHtml::ControlSize ; (; TGHtmlInput * ; pElem). protected . This routine implements the Sizer() function for <INPUT>, <SELECT> and <TEXTAREA> markup. ; A side effect of sizing these markups is that widgets are created to represent the corresponding input controls.; The function normally returns 0. But if it is dealing w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:57129,clear,clear,57129,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['clear'],['clear']
Usability,"; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:23916,Clear,Clear,23916,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['Clear'],['Clear']
Usability,"; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Ren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressLog.html:23709,Clear,Clear,23709,root/html532/TProofProgressLog.html,https://root.cern,https://root.cern/root/html532/TProofProgressLog.html,2,['Clear'],['Clear']
Usability,"; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoGtraEditor.html:23389,undo,undoing,23389,root/html604/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html604/TGeoGtraEditor.html,2,['undo'],['undoing']
Usability,"; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtraEditor.html:23389,undo,undoing,23389,root/html602/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html602/TGeoGtraEditor.html,2,['undo'],['undoing']
Usability,"; TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:1530,Clear,ClearThreadData,1530,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,1,['Clear'],['ClearThreadData']
Usability,"; TList*fActiveSlaveslist of active slaves (subset of all slaves); TStringfActiveSlavesSavedcomma-separated list of active slaves (before last call to; TMonitor*fAllUniqueMonitormonitor activity on all unique slave sockets, including all submasters; TList*fAllUniqueSlaveslist of all active slaves with unique file systems, including all submasters; Long64_tfBytesReadbytes read by all slaves during the session; TList*fChainschains with this proof set; Int_tfCheckFileStatusremote return status after kPROOF_CHECKFILE; TVirtualMutex*fCloseMutexAvoid crashes in MarkBad or alike while closing; Float_tfCpuTimeCPU time spent by all slaves during the session; TMonitor*fCurrentMonitorcurrently active monitor; TDSet*fDSetcurrent TDSet being validated; Int_tfDrawQueriesnumber of draw queries during this sessions; TList*fEnabledPackagesOnClientlist of packages enabled on client; Bool_tfEndMastertrue for a master in direct contact only with workers; TList*fFeedbacklist of names to be returned as feedback; TProof::FileMap_tfFileMapmap keeping track of a file's md5 and mod time; Bool_tfFinalizationRunning; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupPROOF group of this user; TList*fInactiveSlaveslist of inactive slaves (good but not used for processing); TList*fInputDataInput data objects sent over via file; TStringfInputDataFileFile with input data objects; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfIsPollingWorkerswill be set to kFALSE to prevent recursive dyn workers check in dyn mode; Bool_tfIsWaitingtrue if queries have been enqueued; Int_tfLastAssignedMerger; Long64_tfLastPollWorkers_stimestamp (in seconds) of last poll for workers, -1 if never checked; TList*fLoadedMacrosList of loaded macros (just file names); TStringfLogFileNamename of the temp file for redirected logs; FILE*fLogFileRtemp file to read redirected logs; FILE*fLogFileWtemp file to redirect logs; Int_tfLogLevelserver debug logging leve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:31094,feedback,feedback,31094,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['feedback'],['feedback']
Usability,"; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuitMinimizer.html:6786,Simpl,Simplex,6786,root/html602/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html602/TMinuitMinimizer.html,4,['Simpl'],['Simplex']
Usability,"; TRandomRanlux48 : Generator based on a the RanLux generator with 48 bits and highest luxury level using the implementation provided by the standard library (std::ranlux48). The drawback of this generator is its slow generation time.; TRandom2 is based on the Tausworthe generator of L'Ecuyer, and it has the advantage of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is 10**26. Using the template TRandomGen class (template on the contained Engine type), it is possible to add any generator based on the standard C++ random library (see the C++ random documentation.) or different variants of the MIXMAX generator using the ROOT::Math::MixMaxEngine. Some of the listed generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template TRandomGen class.; Please note also that this class (TRandom) implements also a very simple generator (linear congruential) with period = \(10^9\), known to have defects (the lower random bits are correlated) and it is failing the majority of the random number generator tests. Therefore it should NOT be used in any statistical study.; The following table shows some timings (in nanoseconds/call) for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:. TRandom 3 ns/call (but this is a very BAD Generator, not to be used); TRandom2 5 ns/call; TRandom3 5 ns/call; TRandomMixMax 6 ns/call; TRandomMixMax17 6 ns/call; TRandomMT64 9 ns/call; TRandomMixMax256 10 ns/call; TRandomRanluxpp 14 ns/call; TRandom1 80 ns/call; TRandomRanlux48 250 ns/call. The following methods are provided to generate random numbers distributed according to some basic distributions:. Exp(Double_t tau); Integer(UInt_t imax); Gaus(Double_t mean, Double_t sigma); Rndm(); Uniform(Double_t); Landau(Double_t mean, Double_t sigma); Poisson(Double_t mean); Binomial(Int_t ntot, Double_t prob). Random numbers distributed according to 1-d, 2-d or 3-d dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom.html:4340,simpl,simple,4340,doc/master/classTRandom.html,https://root.cern,https://root.cern/doc/master/classTRandom.html,1,['simpl'],['simple']
Usability,"; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:21806,progress bar,progress bar,21806,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,2,['progress bar'],['progress bar']
Usability,; TTextEditor text editor; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of contex-menu toggle objects; TTree Tree descriptor (the main ROOT I/O class); TTreeCache Specialization of TFileCacheRead for a TTree; TTreeCacheUnzip Specialization of TTreeCache for parallel unzipping; TTreeCloner helper used for the fast cloning of TTrees.; TTreeDrawArgsParser Helper class to parse the argument to TTree::Draw; TTreeFormula The Tree formula; TTreeFormulaManager A class coordinating several TTreeFormula objects.; TTreeFriendLeafIter Linked list iterator; TTreeIndex A Tree Index with majorname and minorname.; TTreeInput Simple input dialog; TTreePerfStats TTree I/O performance measurement; TTreePlayer Manager class to play with TTrees; TTreeReader A simple interface to read trees; TTreeResult TTree query result; TTreeRow One row of an TTree query result; TTreeSQL TTree Implementation read and write to a SQL database.; TTreeTableInterface Interface to data in a TTree; TTreeViewer A GUI oriented tree viewer; TUDPSocket This class implements UDP client sockets; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldBinning Complex binning schemes for TUnfoldDensity; TUnfoldDensity Unfolding with densisty regularisation; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUpload,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:130895,simpl,simple,130895,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,6,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"; The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Sat Sep 5 16:39:54 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsGenContext.html:10573,clear,clear,10573,root/html534/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html,2,['clear'],['clear']
Usability,"; class charts. ROOT; » HIST; » HIST; » THnT<ULong64_t>. class THnT<ULong64_t>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<ULong64_t>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_ULong64_t_.html:1008,Clear,Clear,1008,root/html602/THnT_ULong64_t_.html,https://root.cern,https://root.cern/root/html602/THnT_ULong64_t_.html,2,['Clear'],['Clear']
Usability,"; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::BuildConfig. class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__BuildConfig.html:1090,simpl,simple,1090,root/html534/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__BuildConfig.html,6,['simpl'],['simple']
Usability,"; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum alo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:4361,learn,learning,4361,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"; dataloader->AddSpectator( ""spec1 := var1*2"", ""Spectator 1"", ""units"", 'F' );; dataloader->AddSpectator( ""spec2 := var1*3"", ""Spectator 2"", ""units"", 'F' );; ; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; dataloader->AddSignalTree ( signalTree, signalWeight );; dataloader->AddBackgroundTree( background, backgroundWeight );; ; // To give different trees for training and testing, do as follows:; //; // dataloader->AddSignalTree( signalTrainingTree, signalTrainWeight, ""Training"" );; // dataloader->AddSignalTree( signalTestTree, signalTestWeight, ""Test"" );; ; // Use the following code instead of the above two or four lines to add signal and background; // training and test events ""by hand""; // NOTE that in this case one should not give expressions (such as ""var1+var2"") in the input; // variable definition, but simply compute the expression before adding the event; // ```cpp; // // --- begin ----------------------------------------------------------; // std::vector<Double_t> vars( 4 ); // vector has size of number of input variables; // Float_t treevars[4], weight;; //; // // Signal; // for (UInt_t ivar=0; ivar<4; ivar++) signalTree->SetBranchAddress( Form( ""var%i"", ivar+1 ), &(treevars[ivar]) );; // for (UInt_t i=0; i<signalTree->GetEntries(); i++) {; // signalTree->GetEntry(i);; // for (UInt_t ivar=0; ivar<4; ivar++) vars[ivar] = treevars[ivar];; // // add training and test events; here: first half is training, second is testing; // // note that the weight can also be event-wise; // if (i < signalTree->GetEntries()/2.0) dataloader->AddSignalTrainingEvent( vars, signalWeight );; // else dataloader->AddSignalTestEvent ( vars, signalWeight );; // }; //; // // Background (has event weights); // background->SetBranchAddress( ""weight"", &weight );; // for (UInt_t ivar=0; ivar<4; ivar++) background->SetBranchAddress(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:88627,simpl,simply,88627,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simply']
Usability,"; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCONE.html:9547,simpl,simplified,9547,root/html534/TCONE.html,https://root.cern,https://root.cern/root/html534/TCONE.html,2,['simpl'],['simplified']
Usability,"; in case of success. Bool_t JoinProcess(TList* workers); Prepares the given list of new workers to join a progressing process.; Returns kTRUE on success, kFALSE otherwise. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:20142,Feedback,Feedback,20142,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,2,['Feedback'],['Feedback']
Usability,"; kGeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGenTrans.html:15621,clear,clear,15621,root/html528/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html528/TGeoGenTrans.html,1,['clear'],['clear']
Usability,"; kGeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGenTrans.html:15721,clear,clear,15721,root/html530/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html,1,['clear'],['clear']
Usability,"; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Int_tfNvertnumber of vertices of the 2D polygon (at least 3); Int_tfNznumber of z planes (at least two); Double_tTGeoBBox::fOrigin[3]box origin; Double_t*fScale[fNz] array of scale factors (for each Z); UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; vector<ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! size of thread-specific array; TStringTNamed::fTitleobject title; Double_t*fX[fNvert] X positions for polygon vertices; Double_t*fX0[fNz] array of X offsets (for each Z); Double_t*fY[fNvert] Y positions for polygon vertices; Double_t*fY0[fNz] array of Y offsets (for each Z); Double_t*fZ[fNz] array of Z planes positions ; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. void SetIz(Int_t iz); Set current z-plane. void SetSeg(Int_t iseg); Set current segment. TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:15123,Clear,ClearThreadData,15123,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,1,['Clear'],['ClearThreadData']
Usability,"; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Int_tfNvertnumber of vertices of the 2D polygon (at least 3); Int_tfNznumber of z planes (at least two); Double_tTGeoBBox::fOrigin[3]box origin; Double_t*fScale[fNz] array of scale factors (for each Z); UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; vector<ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! size of thread-specific array; TStringTNamed::fTitleobject title; Double_t*fX[fNvert] X positions for polygon vertices; Double_t*fX0[fNz] array of X offsets (for each Z); Double_t*fY[fNvert] Y positions for polygon vertices; Double_t*fY0[fNz] array of Y offsets (for each Z); Double_t*fZ[fNz] array of Z planes positions ; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void SetIz(Int_t iz); Set current z-plane. void SetSeg(Int_t iseg); Set current segment. TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoXtru.html:14155,Clear,ClearThreadData,14155,root/html532/TGeoXtru.html,https://root.cern,https://root.cern/root/html532/TGeoXtru.html,1,['Clear'],['ClearThreadData']
Usability,"; obj). protected . Set the message to be notified in case of exception. ; Definition at line 3613 of file TProofPlayer.cxx. ◆ SetMerging(). void TProofPlayerRemote::SetMerging ; (; Bool_t ; on = kTRUE). overridevirtual . Switch on/off merge timer. ; Reimplemented from TProofPlayer.; Definition at line 1814 of file TProofPlayer.cxx. ◆ SetSelectorDataMembersFromOutputList(). void TProofPlayerRemote::SetSelectorDataMembersFromOutputList ; (; ). protected . Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSupe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37045,feedback,feedback,37045,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"; return of()->asCATLV(of()->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return of()->asCATFUNC(of()->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return of()->asSET(of()->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return of()->asLIST(of()->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return of()->asDATA(of()->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return of()->asDHIST(of()->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return of()->asDSET(of()->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return of()->asOBJ(of()->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return of()->asSTRING(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. const char* autoClassNamePostFix() const; { return _autoClassPostFix.c_str() ; }. void setAutoClassNamePostFix(const char* pfix); { _autoClassPostFix = pfix ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Tue Jun 30 14:32:55 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:25972,clear,clearError,25972,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['clear'],['clearError']
Usability,"; return of()->asCATLV(of()->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return of()->asCATFUNC(of()->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return of()->asSET(of()->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return of()->asLIST(of()->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return of()->asDATA(of()->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return of()->asDHIST(of()->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return of()->asDSET(of()->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return of()->asOBJ(of()->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return of()->asSTRING(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asINT(of()->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>of()->_args.size()-1) return defVal ; return of()->asDOUBLE(of()->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. const char* autoClassNamePostFix() const; { return _autoClassPostFix.c_str() ; }. void setAutoClassNamePostFix(const char* pfix); { _autoClassPostFix = pfix ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Tue Mar 10 17:16:44 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFactoryWSTool.html:25010,clear,clearError,25010,root/html534/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html534/RooFactoryWSTool.html,2,['clear'],['clearError']
Usability,"; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:1949,Undo,Undo,1949,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,8,['Undo'],['Undo']
Usability,"; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output. Class Charts. Inheritance Chart:. TObject. ←; TSQLStatement. ←. TMySQLStatement. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:19510,Clear,ClearError,19510,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['Clear'],['ClearError']
Usability,; static voidDestroyInstance(); Bool_tDrawProgressBar() const; TMVA::Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; TMVA::Config&operator=(const TMVA::Config&); voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. (unknown)(); TMVA::ConfigConfig(); TMVA::MsgLogger&Log() const. Data Members; public:. TMVA::Config::IONamesfIONamesCustomisable weight file properties; TMVA::Config::VariablePlottingfVariablePlottingCustomisable plotting properties. private:. Bool_tfDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; Bool_tfSilentno output at all; Bool_tfUseColoredConsolecoloured standard output; Bool_tfWriteOptionsReferenceif set true: Configurable objects write file with option reference; static TMVA::Config*fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariablePlotting; }. IONames& GetIONames(); { retur,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Config.html:1240,progress bar,progress bar,1240,root/html528/TMVA__Config.html,https://root.cern,https://root.cern/root/html528/TMVA__Config.html,4,['progress bar'],['progress bar']
Usability,"; static voidTSQLServer::SetFloatFormat(const char* fmt = ""%e""); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tShutdown(); virtual Bool_tStartTransaction(); virtual TSQLStatement*Statement(const char* sql, Int_t = 100); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTSQLServer::ClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTSQLServer::SetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TSQLServer::ESQLDataTypes { kSQL_NONE; kSQL_CHAR; kSQL_VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMySQLServer.html:7401,Clear,ClearError,7401,root/html534/TMySQLServer.html,https://root.cern,https://root.cern/root/html534/TMySQLServer.html,1,['Clear'],['ClearError']
Usability,"; t.DrawText(xc1,y,text);; sprintf(text,""`%s"",symbol[i]);; t.DrawText(xc2,y,text);; sprintf(text,""'%s"",symbol[i]);; t.DrawText(xc3,y,text);; sprintf(text,""~%s"",symbol[i]);; t.DrawText(xc4,y,text);; y -= dy;; }; }; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; AuthorOlivier Couet ; Definition in file pstable.C. tutorialsgraphicspstable.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pstable_8C.html:5570,simpl,simple,5570,doc/master/pstable_8C.html,https://root.cern,https://root.cern/doc/master/pstable_8C.html,1,['simpl'],['simple']
Usability,"; typedef std::vector< TGLOverlayElement * > OverlayElmVec_t;  ; typedef SceneInfoList_t::iterator SceneInfoList_i;  ; typedef std::list< TGLSceneInfo * > SceneInfoList_t;  ; typedef SceneInfoVec_t::iterator SceneInfoVec_i;  ; typedef std::vector< TGLSceneInfo * > SceneInfoVec_t;  ; typedef void(TGLSceneBase::* SubRender_foo) (TGLRnrCtx &);  ;  Protected Member Functions inherited from TGLViewer; void FadeView (Float_t alpha);  Draw a rectangle (background color and given alpha) across the whole viewport. ;  ; void InitGL ();  Initialise GL state. ;  ; void MakeCurrent () const;  Make GL context current. ;  ; void PostDraw ();  Perform GL work which must be done after each draw. ;  ; void PreDraw ();  Perform GL work which must be done before each draw. ;  ; void SetupCameras (Bool_t reset);  Setup cameras for current bounding box. ;  ; void SetupClipObject () override;  allow simple guide axes labels to be scaled relative to scene units ;  ; void SetViewport (const TGLRect &vp);  ; void SetViewport (Int_t x, Int_t y, Int_t width, Int_t height);  Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ;  ; void SwapBuffers () const;  Swap GL buffers. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGLViewerBase; SceneInfoList_i FindScene (TGLSceneBase *scene);  Find scene-info corresponding to scene. ;  ; void SubRenderScenes (SubRender_foo render_foo);  Call sub-rendering function render_foo on all currently visible scenes. ;  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:32322,simpl,simple,32322,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,4,"['guid', 'simpl']","['guide', 'simple']"
Usability,"; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6964,learn,learned,6964,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,2,['learn'],['learned']
Usability,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:6277,simpl,simple,6277,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,20,['simpl'],['simple']
Usability,"; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void SetMenuHidingTimeout (Long_t timeout);  Set global timeout for menu-hiding in mili-seconds. ;  ;  Static Public Member Functions inherited from TGLViewer; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGLColorSet & GetDefaultColorSet ();  Returns reference to the default color-set. ;  ; static Bool_t IsUsingDefaultColorSetForNewViewers ();  Returns the value of the static flag that determines if new viewers should use the default color-set. ;  ; static void SetAxisLabelScale (Float_t als);  Sets static scaling facor that allows simple guide axies to have label values scaled relative to actual scene dimensions. ;  ; static void UseDefaultColorSetForNewViewers (Bool_t x);  Sets static flag that determines if new viewers should use the default color-set. ;  ;  Static Public Member Functions inherited from TVirtualViewer3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualViewer3D * Viewer3D (TVirtualPad *pad=nullptr, Option_t *type="""");  Create a Viewer 3D of specified type. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:29415,simpl,simple,29415,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"; virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:3375,undo,undo,3375,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['undo'],['undo']
Usability,"; virtual TGButton*AddButton(const TGWindow* w, TGPictureButton* button, Int_t spacing = 0); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidButtonClicked(); virtual voidButtonPressed(); virtual voidButtonReleased(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeIcon(ToolBarData_t* button, const char* new_icon); virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidClicked(Int_t id)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGToolBar.html:1800,Clear,Clear,1800,root/html532/TGToolBar.html,https://root.cern,https://root.cern/root/html532/TGToolBar.html,4,['Clear'],['Clear']
Usability,"; virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:3714,clear,clearCacheOnServerRedirect,3714,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"; virtual voidTEveElement::AddParent(TEveElement* re); virtual voidAddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCanEditElement() const; virtual Bool_tCanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tCanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyPare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoNode.html:1913,Clear,ClearStamps,1913,root/html532/TEveGeoNode.html,https://root.cern,https://root.cern/root/html532/TEveGeoNode.html,4,['Clear'],['ClearStamps']
Usability,"; virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidCloseBins(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSetArray.html:2654,Clear,Clear,2654,root/html532/TEvePointSetArray.html,https://root.cern,https://root.cern/root/html532/TEvePointSetArray.html,4,['Clear'],['Clear']
Usability,"; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTGSlider::CreateDisabledPicture(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringTGSlider::GetTypeString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; static TGWindow::EEditModeTGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHSlider.html:15145,Clear,ClearFlags,15145,root/html602/TGHSlider.html,https://root.cern,https://root.cern/root/html602/TGHSlider.html,4,['Clear'],['ClearFlags']
Usability,"; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tCanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*CreateDefaultWindowSlot(); static TEveWindowSlot*CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); static TEveWindowSlot*CreateWindowMainFrame(TEveWindow* eve_parent = 0); voidTEveElement::CSCApplyMainColorToAllChildren(); void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveWindow.html:2418,Clear,ClearProjectedList,2418,root/html532/TEveWindow.html,https://root.cern,https://root.cern/root/html532/TEveWindow.html,4,['Clear'],['ClearProjectedList']
Usability,"; virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); voidChangeBackgroundColor(TGListBox*)MENU ; voidChangeBackgroundColor(TGCanvas*)MENU ; voidChangeBackgroundColor(TGComboBox*)MENU ; voidChangeBackgroundColor(TGFrame*)MENU ; voidChangeBackgroundColor(TGCompositeFrame*)MENU ; voidChangeBarColor(TGProgressBar*)MENU ; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; voidChangeImage(TGIcon*)MENU ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidChangePicture(TGPictureButton*)MENU ; voidChangeProperties(TGLabel*)MENU ; voidChangeProperties(TGTextButton*)MENU ; voidChangeTextColor(TGGroupFrame*)MENU ; voidChangeTextColor(TGLabel*)MENU ; voidChangeTextColor(TGTextButton*)MENU ; voidChangeTextColor(TGProgressBar*)MENU ; voidChangeTextColor(TGTextEntry*)MENU ; voidChangeTextFont(TGGroupFrame*)MENU ; voidChangeTextFont(TGTextEntry*)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGuiBldDragManager.html:1870,Clear,Clear,1870,root/html532/TGuiBldDragManager.html,https://root.cern,https://root.cern/root/html532/TGuiBldDragManager.html,4,['Clear'],['Clear']
Usability,"; virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTGDoubleSlider::ChangeCursor(Event_t* event); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static voidTGDoubleSlider::FixBounds(Float_t& min, Float_t& max); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringTGDoubleSlider::GetSString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDoubleHSlider.html:15674,Clear,ClearFlags,15674,root/html602/TGDoubleHSlider.html,https://root.cern,https://root.cern/root/html602/TGDoubleHSlider.html,4,['Clear'],['ClearFlags']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:4010,clear,clearEvalErrorLog,4010,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:3110,clear,clearEvalErrorLog,3110,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:2514,clear,clearEvalErrorLog,2514,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:2816,clear,clearEvalErrorLog,2816,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,4,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:2714,clear,clearEvalErrorLog,2714,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgusBG.html:2538,clear,clearEvalErrorLog,2538,root/html526/RooArgusBG.html,https://root.cern,https://root.cern/root/html526/RooArgusBG.html,49,['clear'],['clearEvalErrorLog']
Usability,"; voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2828,Clear,Clear,2828,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,3,['Clear'],['Clear']
Usability,"; voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddItem(TGLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContaine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLVContainer.html:2112,Clear,Clear,2112,root/html532/TGLVContainer.html,https://root.cern,https://root.cern/root/html532/TGLVContainer.html,4,['Clear'],['Clear']
Usability,"; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is possible, kFALSE if it's not. ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:6079,undo,undo,6079,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of four types:. * Case 1 : Wholly inside visible region - save endpoint; * Case 2 : Exit visible region - save the intersection; * Case 3 : Wholly outside visibl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:34203,simpl,simple,34203,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,10,['simpl'],['simple']
Usability,"; }. void AddRange(double xmin, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataRange.h 25486 2008-09-22 12:43:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__DataRange.html:5508,clear,clear,5508,root/html526/ROOT__Fit__DataRange.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__DataRange.html,1,['clear'],['clear']
Usability,";   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ; file  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ; file  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ; file  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ; file  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ; file  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ; file  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ; file  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ; file  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  ; file  TMVAMultipleBackgroundExample.C;   This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ;  ; file  TMVARegression.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ; file  TMVARegressionApplication.C;   This macr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:6245,simpl,simple,6245,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,";  ; Long64_t Process (TSelector *selector, Long64_t nentries=-1, Option_t *option="""");  Process the specified TSelector object 'nentries' times. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:2165,feedback,feedback,2165,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['feedback'],['feedback']
Usability,";  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentBiases;  The decaying average of the first moment of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentWeights;  The decaying average of the first moment of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fSecondMomentBiases;  The decaying average of the second moment of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fSecondMomentWeights;  The decaying average of the second moment of the past weight gradients associated with the deep net. ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Adam.h>. Inheritance diagram for TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Adam.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Adam.h. Constructor & Destructor Documentation. ◆ TAdam(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:3992,learn,learning,3992,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learning']
Usability,";  ; class  MinimumSeedGenerator;  base class for seed generators (starting values); the seed generator prepares initial starting values from the input (MnUserParameterState) for the minimization; More...;  ; class  MinimumState;  MinimumState keeps the information (position, Gradient, 2nd deriv, etc) after one minimization step (usually in MinimumBuilder). More...;  ; class  MinosError;  Class holding the result of Minos (lower and upper values) for a specific parameter. More...;  ; class  Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  MinuitParameter;  class for the individual Minuit Parameter with Name and number; contains the input numbers for the minimization or the output result from minimization; possible interactions: Fix/release, set/remove limits, set Value/error; More...;  ; class  MnApplication;  application interface class for minimizers (migrad, simplex, Minimize, Scan) User normally instantiates the derived class like ROOT::Minuit2::MnMigrad for using Migrad for minimization More...;  ; class  MnContours;  API class for Contours Error analysis (2-dim errors); minimization has to be done before and Minimum must be valid; possibility to ask only for the points or the points and associated Minos errors;. More...;  ; class  MnCovarianceSqueeze;  class to reduce the covariance matrix when a parameter is fixed by removing the corresponding row and index More...;  ; class  MnCross;  ; class  MnEigen;  API class for calculating the eigenvalues of symmetric matrix. More...;  ; class  MnFcn;  Wrapper class to FCNBase interface used internally by Minuit. More...;  ; class  MnFumiliMinimize;  API class for minimization using Fumili technology; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnFunctionCross;  MnFunctionCross. More...;  ; class  Mn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:5566,simpl,simplex,5566,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['simpl'],['simplex']
Usability,";  ; file  gerrors.C;   Draw a graph with error bars ;  ; file  gerrors2.C;   Draw two graphs with error bars ;  ; file  gmultierrors.C;   Draw a graph with multiple y errors ;  ; file  graph.C;   Draw a simple graph. ;  ; file  graph2derrorsfit.C;   Draw and fit a TGraph2DErrors ;  ; file  graphApply.C;   A macro to demonstrate the functionality of TGraph::Apply() method. ;  ; file  graphpalettecolor.C;   Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  graphpolar.C;   Create and draw a polar graph. ;  ; file  graphpolar2.C;   Create and draw a polar graph with PI axis ;  ; file  graphpolar3.C;   Create and draw a polar graph with PI axis using a TF1. ;  ; file  graphreverse.C;   This example test all the various case of reverse graphs combined with logarithmic scale. ;  ; file  graphShade.C;   Show how to shade an area between two graphs ;  ; file  graphstruct.C;   Draw a simple graph structure. ;  ; file  graphtext.C;   Draw a graph with text attached to each point. ;  ; file  gtime.C;   Example of TGraphTime. ;  ; file  gtime2.C;   Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ;  ; file  hlGraph1.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ; file  hlGraph2.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ; file  labels1.C;   Setting alphanumeric labels in a 1-d histogram. ;  ; file  labels2.C;   Setting alphanumeric labels. ;  ; file  motorcycle.C;   Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  ; file  multigraph.C;   Create and Draw a TMultiGraph. ;  ; file  multigraphpalettecolor.C;   Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  multipalette.C;   Draw color plo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__graphs.html:1588,simpl,simple,1588,doc/master/group__tutorial__graphs.html,https://root.cern,https://root.cern/doc/master/group__tutorial__graphs.html,1,['simpl'],['simple']
Usability,";  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TGProgressBar; TGGC fBarColorGC;  progress bar drawing context ;  ; EBarType fBarType;  OPTION={GetMethod=""GetBarType"";SetMethod=""SetBarType"";Items=(kStandard=""Standard"",kFancy=""Fancy"")} ;  ; Int_t fBarWidth;  progress bar width ;  ; Bool_t fDrawBar;  if true draw only bar in DoRedraw() ;  ; EFillType fFillType;  OPTION={GetMethod=""GetFillType"";SetMethod=""SetFillType"";Items=(kSolidFill=Solid"",kBlockFill=""Block"")} ;  ; FontStruct_t fFontStruct;  font used to draw position text ;  ; TString fFormat;  format used to show position not in percent ;  ; Float_t fMax;  logical maximum value (default 100) ;  ; Float_t fMin;  logical minimum value (default 0) ;  ; GContext_t fNormGC;  text drawing graphics context ;  ; Bool_t fPercent;  show position in percent (default true) ;  ; Float_t fPos;  logical position [fMin,fMax] ;  ; Int_t fPosPix;  position of progress bar in pixel coordinates ;  ; Bool_t fShowPos;  show position value (default false) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:27912,progress bar,progress bar,27912,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,6,['progress bar'],['progress bar']
Usability,";  ; virtual const char * GetElementName () const;  Virtual function for retrieving name of the element. ;  ; virtual const char * GetElementTitle () const;  Virtual function for retrieving title of the render-element. ;  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveBoxSet.html:17194,feedback,feedback,17194,doc/master/classTEveBoxSet.html,https://root.cern,https://root.cern/doc/master/classTEveBoxSet.html,3,['feedback'],['feedback']
Usability,";  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooNumRunningInt; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsCachedReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:46955,clear,clearEvalErrorLog,46955,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['clear'],['clearEvalErrorLog']
Usability,";  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDeviceTDevice ;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTSharedLayerLayer class width shared weight and bias layers ;  ►NkNN;  CEvent;  CModulekNN;  CNode;  CAbsoluteDeviationLossFunction;  CAbsoluteDeviationLossFunctionBDT;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTree;  CBinarySearchTreeNode;  CBinaryTree;  CCCPruner;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactory;  CClassInfo;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfig;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTest;  CCostComplexityPruneTool;  CCrossEntropy;  CCrossValidation;  CCrossValidationResult;  CDataInputHandler;  CDataLoader;  CDataSet;  ►CDataSetFactory;  CEventStats;  CDataSetInfo;  CDataSetManager;  CDecisionTree;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeBase class for all machine learning algorithms ;  CEvent;  CExpectedErrorPruneTool;  CFactory;  CFitterBase;  CGeneticAlgorithm;  CGeneticFitter;  CGeneticGenes;  CGeneticPopulation;  CGeneticRange;  CGiniIndex;  CGiniIndexWithLaplace;  CHuberLossFunction;  CHuberLossFunctionBDT;  CHyperParameterOptimisation;  CHyperParameterOptimisationResult;  CIFitterTarget;  CIMethod;  CIncrement;  CInterval;  CIPruneTool;  CIPythonInteractiveThis class is needed by JsMVA, and it's a helper class for tracking errors during the training in Jupyter notebook ;  CKDEKernel;  CLDA;  CLeastSquaresLossFunction;  CLeastSquaresLossFunctionBDT;  CLogInterval;  CLossFunction;  CLossFunctionBDT;  CLossFunctionEventInfo;  CMCFitter;  CMethodANNBase;  CMethodBase;  CMethodBayesClassifier;  CMethodBDT;  CMethodBoost;  CMethodC50;  CMethodCategory;  CMethodCFMlpANN;  ►CMethodCFMlpANN_Utils;  CVARn2;  CMethodCompositeBase;  CMethodCuts;  ►CMethodDNN;  CTTrainingSettings;  CMethodDT;  CMethodFDA;  CMethodFisher;  CMethodHMatrix;  CMethodInfo;  CMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:68302,learn,learning,68302,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['learn'],['learning']
Usability,";  Close system files. ;  ; void ClearUsers ();  Forget all user seen so far. ;  ; const TSeqCollection * GetListOfClasses ();  Return the list of classes. ;  ; const TSeqCollection * GetListOfCppDirectives ();  Return the list of CPP directives. ;  ; const TSeqCollection * GetListOfEnvVars ();  Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. ;  ; const TSeqCollection * GetListOfFilesInPath (const char path[]);  ""path"" should be initialized with a colon separated list of system directories ;  ; TCollection * GetListOfGlobalFunctions ();  Return the list of global functions. ;  ; const TSeqCollection * GetListOfGlobals ();  Return the list of globals. ;  ; const TSeqCollection * GetListOfPragmas ();  Return the list of pragmas. ;  ; const TSeqCollection * GetListOfSysIncFiles ();  Return the list of system include files. ;  ; const TSeqCollection * GetListOfUsers ();  reads from ""/etc/passwd"" ;  ; Int_t Hook (char *buf, int *pLoc, std::ostream &out);  [private] ;  ; virtual TClass * IsA () const;  ; void RehashAll ();  clears and then rebuilds all lists except for user names and system include files. ;  ; void RehashClasses ();  Do the class rehash. ;  ; void RehashCppDirectives ();  Cpp rehashing. ;  ; void RehashEnvVars ();  Environemnt variables rehashing. ;  ; void RehashFiles ();  Close files. ;  ; void RehashGlobalFunctions ();  Reload global functions. ;  ; void RehashGlobals ();  Reload globals. ;  ; void RehashPragmas ();  Reload pragmas. ;  ; void RehashSysIncFiles ();  Reload system include files. ;  ; void RehashUsers ();  Reload users. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static Char_t AllAgreeOnChar (int i, const TSeqCollection *pList, Int_t &nGoodStrings);  [static utility function]/////////////////////////////////////////// ;  ; static void AppendListOfFilesInDirectory (const char dirName[], TSeqCollection *pList);  [static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:2708,clear,clears,2708,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,";  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:3140,feedback,feedback,3140,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,3,['feedback'],['feedback']
Usability,;  FrequentistCalculator.h;  Heaviside.h;  HLFactory.h;  HybridCalculator.h;  HybridCalculatorOriginal.h;  HybridPlot.h;  HybridResult.h;  HypoTestCalculator.h;  HypoTestCalculatorGeneric.h;  HypoTestInverter.h;  HypoTestInverterOriginal.h;  HypoTestInverterPlot.h;  HypoTestInverterResult.h;  HypoTestPlot.h;  HypoTestResult.h;  IntervalCalculator.h;  LikelihoodInterval.h;  LikelihoodIntervalPlot.h;  MarkovChain.h;  MaxLikelihoodEstimateTestStat.h;  MCMCCalculator.h;  MCMCInterval.h;  MCMCIntervalPlot.h;  MetropolisHastings.h;  MinNLLTestStat.h;  ModelConfig.h;  NeymanConstruction.h;  NumberCountingPdfFactory.h;  NumberCountingUtils.h;  NumEventsTestStat.h;  PdfProposal.h;  PointSetInterval.h;  ProfileInspector.h;  ProfileLikelihoodCalculator.h;  ProfileLikelihoodTestStat.h;  ProofConfig.h;  ProposalFunction.h;  ProposalHelper.h;  RatioOfProfiledLikelihoodsTestStat.h;  RooStatsUtils.h;  SamplingDistPlot.h;  SamplingDistribution.h;  SequentialProposal.h;  SimpleInterval.h;  SimpleLikelihoodRatioTestStat.h;  SPlot.h;  TestStatistic.h;  TestStatSampler.h;  ToyMCImportanceSampler.h;  ToyMCSampler.h;  ToyMCStudy.h;  UniformProposal.h;  UpperLimitMCSModule.h;  LinkDef.h;  ► src;  AsymptoticCalculator.cxx;  BayesianCalculator.cxx;  BernsteinCorrection.cxx;  ConfidenceBelt.cxx;  DetailedOutputAggregator.cxx;  FeldmanCousins.cxx;  FrequentistCalculator.cxx;  Heaviside.cxx;  HLFactory.cxx;  HybridCalculator.cxx;  HybridCalculatorOriginal.cxx;  HybridPlot.cxx;  HybridResult.cxx;  HypoTestCalculatorGeneric.cxx;  HypoTestInverter.cxx;  HypoTestInverterOriginal.cxx;  HypoTestInverterPlot.cxx;  HypoTestInverterResult.cxx;  HypoTestPlot.cxx;  HypoTestResult.cxx;  LikelihoodInterval.cxx;  LikelihoodIntervalPlot.cxx;  MarkovChain.cxx;  MCMCCalculator.cxx;  MCMCInterval.cxx;  MCMCIntervalPlot.cxx;  MetropolisHastings.cxx;  ModelConfig.cxx;  NeymanConstruction.cxx;  NumberCountingPdfFactory.cxx;  NumberCountingUtils.cxx;  PdfProposal.cxx;  PointSetInterval.cxx;  ProfileInspector.cxx;  P,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:85804,Simpl,SimpleLikelihoodRatioTestStat,85804,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,;  LaInnerProduct.cxx;  LaInverse.cxx;  LaOuterProduct.cxx;  LaSumOfElements.cxx;  LaVtMVSimilarity.cxx;  MinimumBuilder.cxx;  Minuit2Minimizer.cxx;  MnApplication.cxx;  mnbins.cxx;  MnContours.cxx;  MnCovarianceSqueeze.cxx;  mndasum.cxx;  mndaxpy.cxx;  mnddot.cxx;  mndscal.cxx;  mndspmv.cxx;  mndspr.cxx;  MnEigen.cxx;  MnFcn.cxx;  MnFumiliMinimize.cxx;  MnFunctionCross.cxx;  MnGlobalCorrelationCoeff.cxx;  MnHesse.cxx;  MnLineSearch.cxx;  mnlsame.cxx;  MnMachinePrecision.cxx;  MnMinos.cxx;  MnParabolaFactory.cxx;  MnParameterScan.cxx;  MnPlot.cxx;  MnPosDef.cxx;  MnPrint.cxx;  MnScan.cxx;  MnSeedGenerator.cxx;  MnStrategy.cxx;  mnteigen.cxx;  MnTiny.cxx;  mntplot.cxx;  MnTraceObject.cxx;  MnUserFcn.cxx;  MnUserParameters.cxx;  MnUserParameterState.cxx;  MnUserTransformation.cxx;  mnvert.cxx;  mnxerbla.cxx;  ModularFunctionMinimizer.cxx;  MPIProcess.cxx;  NegativeG2LineSearch.cxx;  Numerical2PGradientCalculator.cxx;  ParametricFunction.cxx;  ScanBuilder.cxx;  SimplexBuilder.cxx;  SimplexParameters.cxx;  SimplexSeedGenerator.cxx;  SinParameterTransformation.cxx;  SqrtLowParameterTransformation.cxx;  SqrtUpParameterTransformation.cxx;  TMinuit2TraceObject.cxx;  VariableMetricBuilder.cxx;  VariableMetricEDMEstimator.cxx;  ► test;  ► MnSim;  DemoFumili.cxx;  DemoGaussSim.cxx;  demoMinimizer.cxx;  FlatRandomGen.h;  GaussDataGen.cxx;  GaussDataGen.h;  GaussFcn.cxx;  GaussFcn.h;  GaussFcn2.cxx;  GaussFcn2.h;  GaussFunction.h;  GaussianModelFunction.h;  GaussRandomGen.h;  ParallelTest.cxx;  PaulTest.cxx;  PaulTest2.cxx;  PaulTest3.cxx;  PaulTest4.cxx;  ReneTest.cxx;  ► MnTutorial;  Quad12F.h;  Quad12FMain.cxx;  Quad1F.h;  Quad1FMain.cxx;  Quad4F.h;  Quad4FMain.cxx;  Quad8F.h;  Quad8FMain.cxx;  testMinimizer.cxx;  testNdimFit.cxx;  testUnbinGausFit.cxx;  testUserFunc.cxx;  ► mlp;  ► inc;  LinkDef.h;  TMLPAnalyzer.h;  TMultiLayerPerceptron.h;  TNeuron.h;  TSynapse.h;  ► src;  TMLPAnalyzer.cxx;  TMultiLayerPerceptron.cxx;  TNeuron.cxx;  TSynapse.cxx;  ► physics;  ► inc;  LinkDe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:54228,Simpl,SimplexParameters,54228,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimplexParameters']
Usability,";  Remove files for the data directory. ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Int_t Echo (const char *str);  Sends a string to master and workers and expect them to echo it back to the client via a message. ;  ; virtual Int_t Echo (const TObject *obj);  Sends an object to master and workers and expect them to send back a message with the output",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:8334,feedback,feedback,8334,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,";  This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ;  ; file  hlHisto4.C;  This tutorial demonstrates how the highlight mechanism can be used on an histogram. ;  ; file  hstack.C;   Example of stacked histograms: class THStack. ;  ; file  hstackpads.C;   Drawing stack histograms on subpads. ;  ; file  hsum.C;   Histograms filled and drawn in a loop. ;  ; file  hsumTimer.C;   Demo of Timers. ;  ; file  legendautoplaced.C;   The legend can be placed automatically in the current pad in an empty space found at painting time. ;  ; file  logscales.C;   Draw parametric functions with log scales. ;  ; file  movepalette.C;   When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ;  ; file  multicolor.C;   Use a THStack to show a 2-D hist with cells with different colors. ;  ; file  NormalizeHistogram.C;   Normalizing a Histogram ;  ; file  ratioplot1.C;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ; file  ratioplot1.py;   Example creating a simple ratio plot of two histograms using the pois division option. ;  ; file  ratioplot2.C;   Example of a fit residual plot. ;  ; file  ratioplot2.py;   Example of a fit residual plot. ;  ; file  ratioplot3.C;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ; file  ratioplot3.py;   Example which shows how you can get the graph of the lower plot and set the y axis range for it. ;  ; file  ratioplot4.C;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ; file  ratioplot4.py;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ; file  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ; file  ratioplot5.py;   Example that shows how you can set the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__hist.html:3706,simpl,simple,3706,doc/master/group__tutorial__hist.html,https://root.cern,https://root.cern/doc/master/group__tutorial__hist.html,1,['simpl'],['simple']
Usability,";  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:16264,learn,learning,16264,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,";  class dealing with the transformation between user specified parameters (external) and internal parameters used for minimization More...;  ; class  MnVectorTransform;  ; class  ModularFunctionMinimizer;  Base common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one More...;  ; class  SqrtLowParameterTransformation;  Transformation from external to internal Parameter based o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:11228,simpl,simplex,11228,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['simpl'],['simplex']
Usability,";  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:156305,simpl,simple,156305,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,";. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*fRotationrotation matrix; TStringTNamed::fTitleobject title; Double_tfTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTrans(); dummy ctor. TGeoCombiTrans(const TGeoCombiTrans& other); Copy ctor. TGeoCombiTrans(const TGeoMatrix& other); Copy ctor. TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRotation& rot); Constructor from a translation and a rotation. TGeoCombiTrans(const char* name); Named ctor. TGeoCombiTrans(Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); Constructor from a translation specified by X,Y,Z and a pointer to a rotation. The rotation will not be owned by this. TGeoCombiTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); Named ctor. TGeoCombiTrans & operator=(const TGeoMatrix& matrix); Assignment operator. ~TGeoCombiTrans(); destructor. void Clear(Option_t* option = """"); Reset translation/rotation to identity. TGeoMatrix& Inverse() const; Return a temporary inverse of this. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RegisterYourself(); Register the matrix in the current manager, which will become the owner. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoRotation* rot); Assign a foreign rotation to the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCombiTrans.html:15717,Clear,Clear,15717,root/html532/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html,2,['Clear'],['Clear']
Usability,";; 1346 ; 1347 std::string hjson;; 1348 ; 1349 SearchVisibles(fSearch, hjson, fSearchJson);; 1350 ; 1351 (void)hjson; // not used here; 1352}; 1353 ; 1354/////////////////////////////////////////////////////////////////////; 1355/// Collect all information required to draw geometry on the client; 1356/// This includes list of each visible nodes, meshes and matrixes; 1357 ; 1358void RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41650,clear,clear,41650,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,4,['clear'],['clear']
Usability,";; 1499 for (size_t l = 0; l < nlayers; ++l) {; 1500 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0); 1501 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),; 1502 TString::Format(""initial weights layer %d"", l).Data());; 1503 ; 1504 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetOutput(),; 1505 TString::Format(""output tensor layer %d"", l).Data());; 1506 }; 1507#endif; 1508 ; 1509 //Architecture_t::PrintTensor(deepNet.GetLayerAt(nlayers-1)->GetOutput(),""output tensor last layer"" );; 1510 ; 1511 deepNet.Backward(my_batch.GetInput(), my_batch.GetOutput(), my_batch.GetWeights());; 1512 ; 1513 if (debugFirstEpoch); 1514 std::cout << ""- doing optimizer update \n"";; 1515 ; 1516 // increment optimizer step that is used in some algorithms (e.g. ADAM); 1517 optimizer->IncrementGlobalStep();; 1518 optimizer->Step();; 1519 ; 1520#ifdef DEBUG; 1521 std::cout << ""minmimizer step - momentum "" << settings.momentum << "" learning rate "" << optimizer->GetLearningRate() << std::endl;; 1522 for (size_t l = 0; l < nlayers; ++l) {; 1523 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0) {; 1524 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),TString::Format(""weights after step layer %d"",l).Data());; 1525 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightGradientsAt(0),""weight gradients"");; 1526 }; 1527 }; 1528#endif; 1529 ; 1530 }; 1531 ; 1532 if (debugFirstEpoch) std::cout << ""\n End batch loop - compute validation loss \n"";; 1533 //}; 1534 debugFirstEpoch = false;; 1535 if ((nTrainEpochs % settings.testInterval) == 0) {; 1536 ; 1537 std::chrono::time_point<std::chrono::system_clock> t1,t2;; 1538 ; 1539 t1 = std::chrono::system_clock::now();; 1540 ; 1541 // Compute validation error.; 1542 ; 1543 ; 1544 Double_t valError = 0.0;; 1545 bool inTraining = false;; 1546 for (auto batch : validationData) {; 1547 auto inputTensor = batch.GetInput();; 1548 auto outputMatrix = batch.GetOutput();; 1549 auto weights = batch.GetWeights();; 1550 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:60391,learn,learning,60391,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learning']
Usability,";; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;; 239 fpTmpBinEdgeVector= nullptr;; 240 }; 241 ; 242 if ( fpTmpCoordErrorVector ); 243 {; 244 delete[] fpTmpCoordErrorVector;; 245 fpTmpCoordErrorVector = nullptr;; 246 }; 247 ; 248 fDataPtr = nullptr;; 249 fDataErrorPtr= fDataErrorHighPtr= fDataErrorLowPtr= nullptr;; 250 ; 251 fErrorType = rhs.fErrorType;; 252 fRefVolume = rhs.fRefVolume;; 253 fBinEdge = rhs.fBinEdge;; 254 ; 255 if ( fWrapped ); 256 {; 257 fData.clear();; 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:7132,clear,clear,7132,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,";; 251 ++itTargetDelta; ++itTargetGradient; ++itGradient; ++itWeight;; 252 }; 253 ++itSource;; 254 }; 255 }; 256 ; 257 ; 258 ; 259 ; 260 ; 261 ; 262#define USELOCALWEIGHTS 1; 263 ; 264 ; 265 ; 266/*! \brief implementation of the steepest gradient descent algorithm; 267 *; 268 * Can be used with multithreading (i.e. ""HogWild!"" style); see call in trainCycle; 269 */; 270 template <typename Function, typename Weights, typename PassThrough>; 271 double Steepest::operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough); 272 {; 273 size_t numWeights = weights.size ();; 274 // std::vector<double> gradients (numWeights, 0.0);; 275 m_localGradients.assign (numWeights, 0.0);; 276 // std::vector<double> localWeights (begin (weights), end (weights));; 277 // m_localWeights.reserve (numWeights);; 278 m_localWeights.assign (begin (weights), end (weights));; 279 ; 280 double E = 1e10;; 281 if (m_prevGradients.size () != numWeights); 282 {; 283 m_prevGradients.clear ();; 284 m_prevGradients.assign (weights.size (), 0);; 285 }; 286 ; 287 bool success = true;; 288 size_t currentRepetition = 0;; 289 while (success); 290 {; 291 if (currentRepetition >= m_repetitions); 292 break;; 293 ; 294 m_localGradients.assign (numWeights, 0.0);; 295 ; 296 // --- nesterov momentum ---; 297 // apply momentum before computing the new gradient; 298 auto itPrevG = begin (m_prevGradients);; 299 auto itPrevGEnd = end (m_prevGradients);; 300 auto itLocWeight = begin (m_localWeights);; 301 for (; itPrevG != itPrevGEnd; ++itPrevG, ++itLocWeight); 302 {; 303 (*itPrevG) *= m_beta;; 304 (*itLocWeight) += (*itPrevG);; 305 }; 306 ; 307 E = fitnessFunction (passThrough, m_localWeights, m_localGradients);; 308// plotGradients (gradients);; 309// plotWeights (localWeights);; 310 ; 311 double alpha = gaussDouble (m_alpha, m_alpha/2.0);; 312// double alpha = m_alpha;; 313 ; 314 auto itG = begin (m_localGradients);; 315 auto itGEnd = end (m_localGradients);; 316 itPrevG = begin (m_prevGradients",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:8764,clear,clear,8764,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,";; 3142 ; 3143}; 3144 ; 3145 ; 3146////////////////////////////////////////////////////////////////////////////////; 3147/// Release parameter number ipar during a fit operation.; 3148/// After releasing it, the parameter; 3149/// can vary freely in the fit. The parameter limits are reset to 0,0.; 3150 ; 3151void TF1::ReleaseParameter(Int_t ipar); 3152{; 3153 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3154 SetParLimits(ipar, 0, 0);; 3155}; 3156 ; 3157 ; 3158////////////////////////////////////////////////////////////////////////////////; 3159/// Save values of function in array fSave; 3160 ; 3161void TF1::Save(Double_t xmin, Double_t xmax, Double_t, Double_t, Double_t, Double_t); 3162{; 3163 if (!fSave.empty()); 3164 fSave.clear();; 3165 ; 3166 Double_t *parameters = GetParameters();; 3167 //if (fSave != 0) {delete [] fSave; fSave = 0;}; 3168 if (fParent && fParent->InheritsFrom(TH1::Class())) {; 3169 //if parent is a histogram save the function at the center of the bins; 3170 if ((xmin > 0 && xmax > 0) && TMath::Abs(TMath::Log10(xmax / xmin) > TMath::Log10(fNpx))) {; 3171 TH1 *h = (TH1 *)fParent;; 3172 Int_t bin1 = h->GetXaxis()->FindBin(xmin);; 3173 Int_t bin2 = h->GetXaxis()->FindBin(xmax);; 3174 int nsave = bin2 - bin1 + 4;; 3175 fSave.resize(nsave);; 3176 Double_t xv[1];; 3177 ; 3178 InitArgs(xv, parameters);; 3179 for (Int_t i = bin1; i <= bin2; i++) {; 3180 xv[0] = h->GetXaxis()->GetBinCenter(i);; 3181 fSave[i - bin1] = EvalPar(xv, parameters);; 3182 }; 3183 fSave[nsave - 3] = xmin;; 3184 fSave[nsave - 2] = xmax;; 3185 fSave[nsave - 1] = xmax;; 3186 return;; 3187 }; 3188 }; 3189 ; 3190 Int_t npx = fNpx;; 3191 if (npx <= 0); 3192 return;; 3193 ; 3194 Double_t dx = (xmax - xmin) / fNpx;; 3195 if (dx <= 0) {; 3196 dx = (fXmax - fXmin) / fNpx;; 3197 npx--;; 3198 xmin = fXmin + 0.5 * dx;; 3199 xmax = fXmax - 0.5 * dx;; 3200 }; 3201 if (npx <= 0); 3202 return;; 3203 fSave.resize(npx + 3);; 3204 Double_t xv[1];; 3205 InitArgs(xv, parameters);; 3206 for (Int_t i =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:120648,clear,clear,120648,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,";; 3527 if (firstBracket != std::string::npos) {; 3528 // -- We are looking for an array data member.; 3529 std::string nameNoDim(givenName.substr(0, firstBracket));; 3530 TObjLink* lnk = fRealData->FirstLink();; 3531 while (lnk) {; 3532 TObject* obj = lnk->GetObject();; 3533 std::string objName(obj->GetName());; 3534 std::string::size_type pos = objName.find_first_of(""["");; 3535 // Only match arrays to arrays for now.; 3536 if (pos != std::string::npos) {; 3537 objName.erase(pos);; 3538 if (objName == nameNoDim) {; 3539 return static_cast<TRealData*>(obj);; 3540 }; 3541 }; 3542 lnk = lnk->Next();; 3543 }; 3544 }; 3545 ; 3546 // Now try it as a pointer.; 3547 std::ostringstream ptrname;; 3548 ptrname << ""*"" << givenName;; 3549 rd = (TRealData*) fRealData->FindObject(ptrname.str().c_str());; 3550 if (rd) {; 3551 return rd;; 3552 }; 3553 ; 3554 // Check for a dot in the name.; 3555 std::string::size_type firstDot = givenName.find_first_of(""."");; 3556 if (firstDot == std::string::npos) {; 3557 // -- Not found, a simple name, all done.; 3558 return nullptr;; 3559 }; 3560 ; 3561 //; 3562 // At this point the name has a dot in it, so it is the name; 3563 // of some contained sub-object.; 3564 //; 3565 ; 3566 // May be a pointer like in TH1: fXaxis.fLabels (in TRealdata is named fXaxis.*fLabels); 3567 std::string::size_type lastDot = givenName.find_last_of(""."");; 3568 std::ostringstream starname;; 3569 starname << givenName.substr(0, lastDot) << "".*"" << givenName.substr(lastDot + 1);; 3570 rd = (TRealData*) fRealData->FindObject(starname.str().c_str());; 3571 if (rd) {; 3572 return rd;; 3573 }; 3574 ; 3575 // Last attempt in case a member has been changed from; 3576 // a static array to a pointer, for example the member; 3577 // was arr[20] and is now *arr.; 3578 //; 3579 // Note: In principle, one could also take into account; 3580 // the opposite situation where a member like *arr has; 3581 // been converted to arr[20].; 3582 //; 3583 // FIXME: What about checking after ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:134952,simpl,simple,134952,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,";; 3594 if (firstBracket != std::string::npos) {; 3595 // -- We are looking for an array data member.; 3596 std::string nameNoDim(givenName.substr(0, firstBracket));; 3597 TObjLink* lnk = fRealData->FirstLink();; 3598 while (lnk) {; 3599 TObject* obj = lnk->GetObject();; 3600 std::string objName(obj->GetName());; 3601 std::string::size_type pos = objName.find_first_of(""["");; 3602 // Only match arrays to arrays for now.; 3603 if (pos != std::string::npos) {; 3604 objName.erase(pos);; 3605 if (objName == nameNoDim) {; 3606 return static_cast<TRealData*>(obj);; 3607 }; 3608 }; 3609 lnk = lnk->Next();; 3610 }; 3611 }; 3612 ; 3613 // Now try it as a pointer.; 3614 std::ostringstream ptrname;; 3615 ptrname << ""*"" << givenName;; 3616 rd = (TRealData*) fRealData->FindObject(ptrname.str().c_str());; 3617 if (rd) {; 3618 return rd;; 3619 }; 3620 ; 3621 // Check for a dot in the name.; 3622 std::string::size_type firstDot = givenName.find_first_of(""."");; 3623 if (firstDot == std::string::npos) {; 3624 // -- Not found, a simple name, all done.; 3625 return nullptr;; 3626 }; 3627 ; 3628 //; 3629 // At this point the name has a dot in it, so it is the name; 3630 // of some contained sub-object.; 3631 //; 3632 ; 3633 // May be a pointer like in TH1: fXaxis.fLabels (in TRealdata is named fXaxis.*fLabels); 3634 std::string::size_type lastDot = givenName.find_last_of(""."");; 3635 std::ostringstream starname;; 3636 starname << givenName.substr(0, lastDot) << "".*"" << givenName.substr(lastDot + 1);; 3637 rd = (TRealData*) fRealData->FindObject(starname.str().c_str());; 3638 if (rd) {; 3639 return rd;; 3640 }; 3641 ; 3642 // Last attempt in case a member has been changed from; 3643 // a static array to a pointer, for example the member; 3644 // was arr[20] and is now *arr.; 3645 //; 3646 // Note: In principle, one could also take into account; 3647 // the opposite situation where a member like *arr has; 3648 // been converted to arr[20].; 3649 //; 3650 // FIXME: What about checking after ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:137703,simpl,simple,137703,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,";; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionProxy* p = const_cast<TGenCollectionProxy*>(this);; 773 if ( fValue.load() ) return p;; 774 return p->InitializeEx(silent);; 775}; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Reset the info gathered from StreamerInfos and value's TClass.; 779Bool_t TGenCollectionProxy::Reset(); 780{; 781 if (fReadMemberWise); 782 fReadMemberWise->Clear();; 783 delete fWriteMemberWise;; 784 fWriteMemberWise = nullptr;; 785 if (fConversionReadMemberWise); 786 fConversionReadMemberWise->clear();; 787 return kTRUE;; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Check existence of function pointers; 792 ; 793void TGenCollectionProxy::CheckFunctions() const; 794{; 795 if ( 0 == fSize.call ) {; 796 Fatal(""TGenCollectionProxy"",""No 'size' function pointer for class %s present."",fName.c_str());; 797 }; 798 if ( 0 == fResize ) {; 799 Fatal(""TGenCollectionProxy"",""No 'resize' function for class %s present."",fName.c_str());; 800 }; 801 if ( 0 == fNext.call ) {; 802 Fatal(""TGenCollectionProxy"",""No 'next' function for class %s present."",fName.c_str());; 803 }; 804 if ( 0 == fFirst.call ) {; 805 Fatal(""TGenCollectionProxy"",""No 'begin' function for class %s present."",fName.c_str());; 806 }; 807 if ( 0 == fClear.call ) {; 808 Fatal(""TGenCollectionProxy"",""No 'clear' function for class %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:24073,clear,clear,24073,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['clear'],['clear']
Usability,";; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TStyle::SetPaperSizevoid SetPaperSize(EPaperSize size)Set paper size for PostScript output.Definition TStyle.cxx:1704; Then, the generated file (hpx.tex) can be included in a LaTeX document (simple.tex) in the following way: \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; TTeXDumpInterface to TeX.Definition TTeXDump.h:20; Rcpp::asTString as(SEXP s)Definition RExports.h:86; TMVA_SOFIE_GNN.endendDefinition TMVA_SOFIE_GNN.py:207; Note the three directives needed at the top of the LaTeX file: \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; Then including the picture in the document is done with the \input directive.; The command pdflatex simple.tex will generate the corresponding pdf file simple.pdf. ; Definition at line 20 of file TTeXDump.h. Public Member Functions;  TTeXDump ();  Default TeX constructor. ;  ;  TTeXDump (const char *filename, Int_t type=-113);  Initialize the TeX interface. ;  ;  ~TTeXDump () override;  Default TeX destructor. ;  ; void CellArrayBegin (Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2) override;  Begin the Cell Array painting. ;  ; void CellArrayEnd () override;  End the Cell Array painting. ;  ; void CellArrayFill (Int_t r, Int_t g, Int_t b) override;  Paint the Cell Array. ;  ; void Close (Option_t *opt="""") override;  Close a TeX file. ;  ; Int_t CMtoTeX (Double_t u);  ; void DefineMarkers ();  add additional pgfplotmarks ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Draw a Box. ;  ; void DrawFrame (Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light) override;  Draw a F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTeXDump.html:1809,simpl,simple,1809,doc/master/classTTeXDump.html,https://root.cern,https://root.cern/doc/master/classTTeXDump.html,1,['simpl'],['simple']
Usability,";; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop, one needs to detect the special cases of first and last page. The “[” and “]” can be used instead of “(” and “)” as shown in the next example.; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; The following script illustrates how to open a postscript file and draw several pictures. The generation of a new postscript page is automatic when TCanvas::Clear is called by object->Draw().; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a script; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; The next example does the same:; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //set x,y of printed page; gStyle->SetPaperSize(16,24);. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1->Print(""test1.ps("", ""Portrait"");; hprof->Draw();; c1->Print(""test1.ps"");; hpx->Draw(""lego1"");; c1->Print(""test1.ps)"");; }; This following example shows two pages. The canvas is divided. TPos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:377795,Clear,Clear,377795,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Clear'],['Clear']
Usability,";; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:1680,Clear,Clear,1680,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"< Architecture_t, Layer_t, DeepNet_t >::GetLayers ; (; ). inline . Definition at line 82 of file Optimizer.h. ◆ GetLearningRate(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::GetLearningRate ; (; ); const. inline . Getters. ; Definition at line 77 of file Optimizer.h. ◆ IncrementGlobalStep(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . void TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::IncrementGlobalStep ; (; ). inline . Increments the global step. ; Definition at line 74 of file Optimizer.h. ◆ SetLearningRate(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . void TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::SetLearningRate ; (; size_t ; learningRate). inline . Setters. ; Definition at line 86 of file Optimizer.h. ◆ Step(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . auto TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Step. Performs one step of optimization. ; Definition at line 101 of file Optimizer.h. ◆ UpdateBiases(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . virtual void TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::UpdateBiases ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; biases, . const std::vector< Matrix_t > & ; biasGradients . ). protectedpure virtual . Update the biases, given the current bias gradients. ; Implemented in TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >, TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >, TMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:5411,learn,learningRate,5411,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['learn'],['learningRate']
Usability,"< std::endl;; 2678 out << ""{"" << std::endl;; 2679 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2680 out << ""//=== Attributes for "" << GetTitle() << "" geometry"" << std::endl;; 2681 out << ""//===== <run this macro AFTER loading the geometry in memory>"" << std::endl;; 2682 // save current top volume; 2683 out << "" TGeoVolume *top = gGeoManager->GetVolume(\"""" << fTopVolume->GetName() << ""\"");"" << std::endl;; 2684 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2685 out << "" TGeoNode *node = 0;"" << std::endl;; 2686 out << "" // clear all volume attributes and get painter"" << std::endl;; 2687 out << "" gGeoManager->ClearAttributes();"" << std::endl;; 2688 out << "" gGeoManager->GetGeomPainter();"" << std::endl;; 2689 out << "" // set visualization modes and bomb factors"" << std::endl;; 2690 out << "" gGeoManager->SetVisOption("" << GetVisOption() << "");"" << std::endl;; 2691 out << "" gGeoManager->SetVisLevel("" << GetVisLevel() << "");"" << std::endl;; 2692 out << "" gGeoManager->SetExplodedView("" << GetBombMode() << "");"" << std::endl;; 2693 Double_t bombx, bomby, bombz, bombr;; 2694 GetBombFactors(bombx, bomby, bombz, bombr);; 2695 out << "" gGeoManager->SetBombFactors("" << bombx << "","" << bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:94968,clear,clear,94968,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['clear'],['clear']
Usability,"</a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Performance tips and parallel execution](\ref parallel-execution); 71- [More features](\ref more-features); 72 - [Systematic variations](\ref systematics); 73 - [RDataFrame objects as function arguments and return values](\ref rnode); 74 - [Storing RDataFrame objects in collections](\ref RDFCollections); 75 - [Executing callbacks every N events](\ref callbacks); 76 - [Default column lists](\ref default-branches); 77 - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87- [Efficient analysis in Python](\ref python); 88- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 89 ; 90\anchor cheatsheet; 91## Cheat sheet; 92These are the operations which can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:4253,progress bar,progress bar,4253,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"<< std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 3608 if (i > maxPerNode) {; 3609 os << "" ... (remaining "" << item.second.second.size() - maxPerNode << "" messages suppressed)""; 3610 << std::endl;; 3611 break;; 3612 }; 3613 i++;; 3614 }; 3615 }; 3616 }; 3617}; 3618 ; 3619 ; 3620 ; 3621////////////////////////////////////////////////////////////////////////////////; 3622/// Return the number of logged evaluation errors since the last clearing.; 3623 ; 3624Int_t RooAbsReal::numEvalErrors(); 3625{; 3626 auto &evalErrors = evalErrorData();; 3627 if (evalErrors.mode == CountErrors) {; 3628 return evalErrors.count;; 3629 }; 3630 ; 3631 Int_t ntot(0);; 3632 for (auto const &elem : evalErrors.errorList) {; 3633 ntot += elem.second.second.size();; 3634 }; 3635 return ntot;; 3636}; 3637 ; 3638 ; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Fix the interpretation of the coefficient of any RooAddPdf component in; 3642/// the expression tree headed by this object to the given set of observables.; 3643///; 3644/// If the force flag is false, the normalization choice is only fixed for those; 3645/// RooAddPdf components that have the default 'automatic' interpretation of; 3646/// coefficients (i.e. the interpretation is defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:154627,clear,clearing,154627,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['clearing']
Usability,"<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVectorT_float_.html:18387,Clear,Clear,18387,root/html532/TVectorT_float_.html,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html,1,['Clear'],['Clear']
Usability,"<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:3233,clear,clearEvalErrorLog,3233,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['clear'],['clearEvalErrorLog']
Usability,"= """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t* option = """", Double_t norm = 1) const; Draw a normalized copy of this histogram. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned.; The contents of the histogram copy are scaled such that the new; sum of weights (excluding under and overflow) is equal to norm.; Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory.; It is the user's responsability to delete this histogram.; The kCanDelete bit is set for the returned object. If a pad containing; this copy is cleared, the histogram will be automatically deleted. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void DrawPanel(); -*-*-*-*-*Display a panel with all histogram drawing options*-*-*-*-*-*. See class TDrawPanelHist for example. void Eval(TF1* f1, Option_t* option = """"); -*-*-*Evaluate function f1 at the center of bins of this histogram-*-*-*-*. If option ""R"" is specified, the function is evaluated only; for the bins included in the function range.; If option ""A"" is specified, the value of the function is added to the; existing bin contents; If option ""S"" is specified, the value of the function is used to; generate a value, distributed according to the Poisson; distribution, with f1 as the mean. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Execute action corresponding to one event*-*-*-*. This member function is called when a histogram ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:67039,clear,cleared,67039,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['clear'],['cleared']
Usability,"= """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t* option = """", Double_t norm = 1) const; Draw a normalized copy of this histogram. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned.; The contents of the histogram copy are scaled such that the new; sum of weights (excluding under and overflow) is equal to norm.; Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory.; It is the user's responsability to delete this histogram.; The kCanDelete bit is set for the returned object. If a pad containing; this copy is cleared, the histogram will be automatically deleted.; See also remark about calling Sumw2 before scaling a histogram to get; a correct computation of the error bars. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void DrawPanel(); -*-*-*-*-*Display a panel with all histogram drawing options*-*-*-*-*-*. See class TDrawPanelHist for example. void Eval(TF1* f1, Option_t* option = """"); -*-*-*Evaluate function f1 at the center of bins of this histogram-*-*-*-*. If option ""R"" is specified, the function is evaluated only; for the bins included in the function range.; If option ""A"" is specified, the value of the function is added to the; existing bin contents; If option ""S"" is specified, the value of the function is used to; generate a value, distributed according to the Poisson; distribution, with f1 as the mean. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:62062,clear,cleared,62062,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['clear'],['cleared']
Usability,"= 'i') resize = true;; 6374 ; 6375 TPad *is_pad = dynamic_cast<TPad *>( object );; 6376 ; 6377 TContext ctxt(kTRUE);; 6378 ; 6379 if (is_pad && is_pad->GetMother()); 6380 is_pad->GetMother()->cd();; 6381 ; 6382 static TPad *tmpGuideLinePad = nullptr;; 6383 ; 6384 //delete all existing Guidelines and create new invisible pad; 6385 if (tmpGuideLinePad) {; 6386 ctxt.PadDeleted(tmpGuideLinePad);; 6387 auto guidePadClicked = (object == tmpGuideLinePad); // in case of funny button click combination.; 6388 tmpGuideLinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:210518,guid,guidePadClicked,210518,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['guid'],['guidePadClicked']
Usability,"= 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj)SIGNAL ; TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCloneBrowser(); virtual voidCloseTab(Int_t id); virtual voidCloseTabs(); virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; voidCreateBrowser(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootBrowser.html:2008,Clear,Clear,2008,root/html534/TRootBrowser.html,https://root.cern,https://root.cern/root/html534/TRootBrowser.html,3,['Clear'],['Clear']
Usability,"= 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj)SIGNAL ; TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCloneBrowser(); voidCloseTab(Int_t id); virtual voidCloseTabs(); virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; voidCreateBrowser(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootBrowser.html:2008,Clear,Clear,2008,root/html532/TRootBrowser.html,https://root.cern,https://root.cern/root/html532/TRootBrowser.html,1,['Clear'],['Clear']
Usability,"= 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2920,clear,clearValueAndShapeDirty,2920,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"= 0, TGHotString* s = 0, Int_t id = -1, UInt_t options = 0); virtual~TGShutterItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGShutterItem.html:1596,Clear,Clear,1596,root/html532/TGShutterItem.html,https://root.cern,https://root.cern/root/html532/TGShutterItem.html,2,['Clear'],['Clear']
Usability,"= 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGDockableFrame.h>. Inheritance diagram for TGUndockedFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGUndockedFrame() [1/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGUndockedFrame & ; ). privatedelete . ◆ TGUndockedFrame() [2/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGWindow * ; p = nullptr, . TGDockableFrame * ; dockable = nullptr . ). Create the undocked (transient) frame. ; Definition at line 176 of file TGDockableFrame.cxx. ◆ ~TGUndockedFrame(). TGUndockedFrame::~TGUndockedFrame ; (; ). override . Delete undocked frame. Puts back dockable frame in its original container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGDockableFrame.h. ◆ FixSize(). void TGUndockedFrame:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:36852,undo,undocked,36852,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"= 2); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3522,Clear,Clear,3522,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['Clear'],['Clear']
Usability,"= 230, UInt_t h = 150); virtual~TGRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGRecorder.html:1401,Clear,Clear,1401,root/html532/TGRecorder.html,https://root.cern,https://root.cern/root/html532/TGRecorder.html,2,['Clear'],['Clear']
Usability,"= kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6739,clear,clearValueDirty,6739,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['clear'],['clearValueDirty']
Usability,"= kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:1910,Clear,Clear,1910,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['Clear'],['Clear']
Usability,"= kTRUE, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t fontstruct = GetDefaultFontStruct(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGSplitButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSplitButton.html:4078,Clear,Clear,4078,root/html532/TGSplitButton.html,https://root.cern,https://root.cern/root/html532/TGSplitButton.html,2,['Clear'],['Clear']
Usability,"= max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:9127,learn,learned,9127,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['learn'],['learned']
Usability,"= typename std::enable_if<std::is_convertible<; 653 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 654 void append(in_iter in_start, in_iter in_end); 655 {; 656 size_type NumInputs = std::distance(in_start, in_end);; 657 if (NumInputs > this->capacity() - this->size()); 658 this->grow(this->size() + NumInputs);; 659 ; 660 this->uninitialized_copy(in_start, in_end, this->end());; 661 this->set_size(this->size() + NumInputs);; 662 }; 663 ; 664 /// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:24340,clear,clearing,24340,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['clear'],['clearing']
Usability,"= xmax-xmin;; 436 dy = ymax-ymin;; 437 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 438 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 439 ; 440 // Range() could change the size of the pad pixmap and therefore should; 441 // be called before the other paint routines; 442 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 443 ymin - dyr*gPad->GetBottomMargin(),; 444 xmax + dxr*gPad->GetRightMargin(),; 445 ymax + dyr*gPad->GetTopMargin());; 446 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 447 ; 448 if (!x.empty() && !y.empty()) {; 449 if (middle) {; 450 for(i=0;i<np;i++) {; 451 fX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 452 fY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 453 }; 454 } else {; 455 fX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 456 fY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 457 }; 458 x.clear();; 459 y.clear();; 460 }; 461 gPad->Modified(kTRUE);; 462 gVirtualX->SetLineColor(-1);; 463 }; 464}; 465 ; 466////////////////////////////////////////////////////////////////////////////////; 467/// List this polyline with its attributes.; 468/// The option string is ignored.; 469 ; 470void TPolyLine::ls(Option_t *) const; 471{; 472 TROOT::IndentLevel();; 473 printf(""TPolyLine N=%d\n"",fN);; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Merge polylines in the collection in this polyline; 478 ; 479Int_t TPolyLine::Merge(TCollection *li); 480{; 481 if (!li) return 0;; 482 TIter next(li);; 483 ; 484 //first loop to count the number of entries; 485 TPolyLine *pl;; 486 Int_t npoints = 0;; 487 while ((pl = (TPolyLine*)next())) {; 488 if (!pl->InheritsFrom(TPolyLine::Class())) {; 489 Error(""Add"",""Attempt to add object of class: %s to a %s"",pl->ClassName(),this->ClassName());; 490 return -1;; 491 }; 492 npoints += pl->Size();; 493 }; 494 ; 495 //extend this polyline to hold npoints; 496 if (npoints > 1) SetPoint(npoints-1,0,0);; 497 ; 498 //merge all polyline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPolyLine_8cxx_source.html:14940,clear,clear,14940,doc/master/TPolyLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html,1,['clear'],['clear']
Usability,"== '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpace(const std::string &txt)Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36849,clear,clear,36849,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['clear'],['clear']
Usability,"== 2) {; 2471 // Need to add the rule targeting transient members.; 2472 TStreamerInfo *localInfo = fInfo;; 2473 if (fType == 3 || fType == 4) {; 2474 // Don't we have real version information?; 2475 // Not unless there is a subbranch with a non-split element of the class.; 2476 // Search for the correct version.; 2477 localInfo = FindOnfileInfo(fClonesClass, fBranches);; 2478 }; 2479 ; 2480 TString prefix(GetFullName());; 2481 if (fType == 2 && fID >= 0) {; 2482 auto start = prefix.Length();; 2483 if (prefix[start - 1] == '.'); 2484 --start;; 2485 std::string_view view(prefix.Data(), start);; 2486 auto cutoff = view.find_last_of('.');; 2487 if (cutoff != std::string::npos) {; 2488 prefix.Remove(cutoff + 1);; 2489 }; 2490 }; 2491 if (prefix[prefix.Length()-1] != '.') {; 2492 if (fType == 3 || fType == 4 || prefix.Index('.') != TString::kNPOS) {; 2493 prefix += ""."";; 2494 } else {; 2495 prefix = """";; 2496 }; 2497 }; 2498 fNewIDs.clear();; 2499 ; 2500 GatherArtificialElements(fBranches, fNewIDs, prefix, localInfo, 0);; 2501 ; 2502 if (!fNewIDs.empty() && fOnfileObject == nullptr && localInfo->GetElement(0)->GetType() == TStreamerInfo::kCacheNew); 2503 {; 2504 SetOnfileObject(localInfo);; 2505 }; 2506 ; 2507 }; 2508 fInit = true;; 2509 ; 2510 // Get the action sequence we need to copy for reading.; 2511 SetReadActionSequence();; 2512 SetFillActionSequence();; 2513 } else if (!fReadActionSequence) {; 2514 // Get the action sequence we need to copy for reading.; 2515 SetReadActionSequence();; 2516 SetFillActionSequence();; 2517 }; 2518 SetReadLeavesPtr();; 2519 SetFillLeavesPtr();; 2520 fInInitInfo = false;; 2521 }; 2522}; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Return the collection proxy describing the branch content, if any.; 2526 ; 2527TVirtualCollectionProxy* TBranchElement::GetCollectionProxy(); 2528{; 2529 if (fCollProxy) {; 2530 return fCollProxy;; 2531 }; 2532 TBranchElement* thiscast = const_cast<TBra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:89323,clear,clear,89323,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['clear'],['clear']
Usability,"==(const Iterator_t &lhs) constCompare two iterators for equality.Definition TTreeReader.h:83; TTreeReader::Iterator_t::fReaderTTreeReader * fReaderThe reader we select the entries on.Definition TTreeReader.h:61; TTreeReader::Iterator_t::operator*const Long64_t & operator*()Set the entry number in the reader and return it.Definition TTreeReader.h:134; TTreeReader::Iterator_t::IsValidbool IsValid() constWhether the iterator points to a valid entry.Definition TTreeReader.h:64; TTreeReader::Iterator_t::iterator_categorystd::input_iterator_tag iterator_categoryDefinition TTreeReader.h:67; TTreeReader::Iterator_t::operator!=bool operator!=(const Iterator_t &lhs) constCompare two iterators for inequality.Definition TTreeReader.h:109; TTreeReader::Iterator_t::operator++Iterator_t operator++(int)Increment the iterator (postfix i++).Definition TTreeReader.h:114; TTreeReader::Iterator_t::pointerconst Long64_t * pointerDefinition TTreeReader.h:70; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::TTreeReaderTTreeReader()Default constructor. Call SetTree to connect to a TTree.Definition TTreeReader.cxx:191; TTreeReader::fMissingProxiesstd::vector< std::string > fMissingProxiesDefinition TTreeReader.h:351; TTreeReader::fLoadTreeStatusELoadTreeStatus fLoadTreeStatusIndicator on how LoadTree was called 'last' time.Definition TTreeReader.h:321; TTreeReader::SetTreevoid SetTree(const char *keyname, TEntryList *entryList=nullptr)Definition TTreeReader.h:198; TTreeReader::IsInvalidbool IsInvalid() constDefinition TTreeReader.h:205; TTreeReader::GetEntriesLong64_t GetEntries() constReturns the number of entries of the TEntryList if one is provided, else of the TTree / TChain,...Definition TTreeReader.cxx:589; TTreeReader::fEntryStatusEEntryStatus fEntryStatusstatus of most recent read requestDefinition TTreeReader.h:320; TTreeReader::fSuppressErrorsForMissingBranchesstd::vector< std::strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:18679,simpl,simple,18679,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['simpl'],['simple']
Usability,"===. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:30144,usab,usable,30144,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['usab'],['usable']
Usability,"==========. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. Int_t InitWindow(ULong_t window); -; *-* if window == 0 InitWindow creates his own instance of TQtWindowsObject object; -; *-* Create a new windows; -; window is QWidget. Int_t OpenPixmap(UInt_t w, UInt_t h); *-* Create a new pixmap object. const QColor & ColorIndex(Color_t indx) const; Define the QColor object by ROOT color index. UInt_t ExecCommand(TGWin32Command* code); deprecated. void SetDoubleBufferOFF(); deprecated. void SetDoubleBufferON(); deprecated. void GetPlanes(Int_t& nplanes); Get maximum number of planes*-; *-* ============================; *-* nplanes : number of bit planes; *. void ClearWindow(); Clear current window. void ClosePixmap(); Delete the current pixmap. void CloseWindow(); Delete the current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wd at the position xpos, ypos in the current window. void CreateOpenGLContext(Int_t wid = 0); Create OpenGL context for win windows (for ""selected"" Window by default); printf("" TGQt::CreateOpenGLContext for wd = %x fSelected= %x, threadID= %d \n"",wd,fSelectedWindow,; GetCurrentThreadId());. void DeleteOpenGLContext(Int_t wid = 0); Delete OpenGL context for win windows (for ""selected"" Window by default). void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draw a box.; mode=0 hollow (kHollow); mode=1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array. Draw a cell array. The drawing is done with the pixel precision; if (X2-X1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGQt.html:24397,Clear,ClearWindow,24397,root/html532/TGQt.html,https://root.cern,https://root.cern/root/html532/TGQt.html,4,['Clear'],"['Clear', 'ClearWindow']"
Usability,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:54230,simpl,simplex,54230,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,16,['simpl'],['simplex']
Usability,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMinuit.html:54866,simpl,simplex,54866,root/html604/TMinuit.html,https://root.cern,https://root.cern/root/html604/TMinuit.html,4,['simpl'],['simplex']
Usability,"=============. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:21596,usab,usable,21596,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,8,['usab'],['usable']
Usability,"===================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t max); {fMaximum = max;}. void SetMinimum(Long64_t min); {fMinimum = min;}. » Author: Rene Brun 19/12/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLeafL.html:10265,simpl,simple,10265,root/html604/TLeafL.html,https://root.cern,https://root.cern/root/html604/TLeafL.html,2,['simpl'],['simple']
Usability,"===================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t max); {fMaximum = max;}. void SetMinimum(Long64_t min); {fMinimum = min;}. » Author: Rene Brun 19/12/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 15:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLeafL.html:10265,simpl,simple,10265,root/html602/TLeafL.html,https://root.cern,https://root.cern/root/html602/TLeafL.html,2,['simpl'],['simple']
Usability,"========================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t max); {fMaximum = max;}. void SetMinimum(Long64_t min); {fMinimum = min;}. » Author: Rene Brun 19/12/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafL.html:9768,simpl,simple,9768,root/html534/TLeafL.html,https://root.cern,https://root.cern/root/html534/TLeafL.html,2,['simpl'],['simple']
Usability,"==========================. this = (c1*h1)*(c2*h2). TH3D * ProjectionXYZ(const char* name = ""_pxyz"", Option_t* option = ""e"") const; Project this profile3D into a 3-D histogram along X,Y,Z*-*-; *-* =====================================================. The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling directly a TH2D using the 3-rd value as a weight.; This option makes sense only for profile filled with all weights =1.; When the profile is weighted (filled with weights different than 1) the; bin error of the projected histogram (obtained using this option ""W"") cannot be; correctly computed from the information stored in the profile. In that case the; obtained histogram contains as bin error square the weighted sum of the square of the; profiled observable (TProfile2D::fSumw2[bin] ). TProfile2D * Project3DProfile(Option_t* option = ""xy"") const; *-*-*-*-*Project a 3-D profile into a 2D-profile histogram depending; on the option parameter; option may contain a combination ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:39988,simpl,simply,39988,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,6,['simpl'],['simply']
Usability,"=n. ;  ; void ClearSscp (TMatrixD &sscp);  clear the sscp matrix, used for covariance and mean calculation ;  ; void Correl ();  transforms covariance matrix into correlation matrix ;  ; void Covar (TMatrixD &sscp, TVectorD &m, TMatrixDSym &cov, TVectorD &sd, Int_t nvec);  calculates mean and covariance ;  ; void CreateOrtSubset (TMatrixD &dat, Int_t *index, Int_t hmerged, Int_t nmerged, TMatrixD &sscp, Double_t *ndist);  creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ;  ; void CreateSubset (Int_t ntotal, Int_t htotal, Int_t p, Int_t *index, TMatrixD &data, TMatrixD &sscp, Double_t *ndist);  creates a subset of htotal elements from ntotal elements first, p+1 elements are drawn randomly(without repetitions) if their covariance matrix is singular, more elements are added one by one, until their covariance matrix becomes regular or it becomes clear that htotal observations lie on a hyperplane If covariance matrix determinant!=0, distances of all ntotal elements are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is mean and S_inv is the inverse of the covariance matrix htotal points with smallest distances are included in the returned subset. ;  ; Double_t CStep (Int_t ntotal, Int_t htotal, Int_t *index, TMatrixD &data, TMatrixD &sscp, Double_t *ndist);  from the input htotal-subset constructs another htotal subset with lower determinant ;  ; Int_t Exact (Double_t *ndist);  for the exact fit situations returns number of observations on the hyperplane ;  ; Int_t Exact2 (TMatrixD &mstockbig, TMatrixD &cstockbig, TMatrixD &hyperplane, Double_t *deti, Int_t nbest, Int_t kgroup, TMatrixD &sscp, Double_t *ndist);  This function is called if determinant of the covariance matrix of a subset=0. ;  ; Double_t KOrdStat (Int_t ntotal, Double_t *arr, Int_t k, Int_t *work);  because I need a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:15834,clear,clear,15834,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"=true) override;  Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Overload RooAbsReal::fillTreeBranch to also fill tree branches with (asymmetric) errors if requested. ;  ; void installSharedProp (std::shared_ptr< RooRealVarSharedProperties > &&prop);  Install the shared property into the member _sharedProp. ;  ; void setExpensiveObjectCache (RooExpensiveObjectCache &) override;  variables don't need caches ;  ; void setValFast (double value) override;  ; std::shared_ptr< RooRealVarSharedProperties > sharedProp () const;  Hand out our shared property, create on the fly and register in shared map if necessary. ;  ;  Protected Member Functions inherited from RooAbsRealLValue; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ;  Protected Member Functions inherited from RooAbsReal; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:60843,usab,usable,60843,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['usab'],['usable']
Usability,"> Randomize(double alpha, double beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& ); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(double newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id$ » Last generated: 2015-03-14 16:45",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTBase_double_.html:21386,Clear,Clear,21386,root/html534/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html,1,['Clear'],['Clear']
Usability,"> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null); standard constructor. MethodKNN(TMVA::DataSetInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodKNN.html:17699,learn,learning,17699,root/html602/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodKNN.html,4,['learn'],['learning']
Usability,">& a). template <class Element> inline const TMatrixT<Element> &TMatrixT<Element> Use(const TMatrixT<float>& a) const. template <class Element> inline TMatrixT<Element> TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixT<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixT<Element> operator()(Int_t rown, Int_t coln). void Plus(const TMatrixT <Element> &a,const TMatrixT <Element> &b); Elementary constructors. void Minus(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b); { Mult(a,b); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). TMatrixT <Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixT_float_.html:26350,Clear,Clear,26350,root/html534/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixT_float_.html,1,['Clear'],['Clear']
Usability,">& a). template <class Element> inline const TMatrixT<Element> &TMatrixT<Element> Use(const TMatrixT<float>& a) const. template <class Element> inline TMatrixT<Element> TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixT<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixT<Element> operator()(Int_t rown, Int_t coln). void Plus(const TMatrixT <Element> &a,const TMatrixT <Element> &b); Elementary constructors. void Minus(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b); { Mult(a,b); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). TMatrixT <Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMatrixT_float_.html:27179,Clear,Clear,27179,root/html604/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html604/TMatrixT_float_.html,1,['Clear'],['Clear']
Usability,">& a). template <class Element> inline const TMatrixT<Element> &TMatrixT<Element> Use(const TMatrixT<float>& a) const. template <class Element> inline TMatrixT<Element> TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixT<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixT<Element> operator()(Int_t rown, Int_t coln). void Plus(const TMatrixT <Element> &a,const TMatrixT <Element> &b); Elementary constructors. void Minus(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void TMult(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixT <Element> &b). void MultT(const TMatrixT <Element> &a,const TMatrixTSym<Element> &b); { Mult(a,b); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). TMatrixT <Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixT_float_.html:27198,Clear,Clear,27198,root/html602/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixT_float_.html,1,['Clear'],['Clear']
Usability,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:3216,clear,clearValueAndShapeDirty,3216,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['clear'],['clearValueAndShapeDirty']
Usability,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2705,clear,clearValueAndShapeDirty,2705,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,2,['clear'],['clearValueAndShapeDirty']
Usability,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:3007,clear,clearValueAndShapeDirty,3007,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,5,['clear'],['clearValueAndShapeDirty']
Usability,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:2905,clear,clearValueAndShapeDirty,2905,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['clear'],['clearValueAndShapeDirty']
Usability,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:2729,clear,clearValueAndShapeDirty,2729,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,74,['clear'],['clearValueAndShapeDirty']
Usability,">(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:14538,undo,undo,14538,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,4,['undo'],['undo']
Usability,">. Function Members (Methods); public:. THnT<unsigned long>(); THnT<unsigned long>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_unsigned_long_.html:2268,Clear,Clear,2268,root/html534/THnT_unsigned_long_.html,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html,1,['Clear'],['Clear']
Usability,">>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053967,clear,clear,1053967,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,">Draw();. Function Members (Methods); public:. virtual~TF12(); voidTObject::AbstractMethod(const char* method) const; static voidTF1::AbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTF1::Browse(TBrowser* b); static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0E-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f12) const; virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTF1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*TF1::DrawDeriv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:1235,Clear,Clear,1235,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['Clear'],['Clear']
Usability,">GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:139356,clear,clear,139356,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,">PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2383 }; 2384 } else {; 2385 wminstep = wmin + 0.5*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 2444 Double_t *theEYlow = theG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86322,clear,clear,86322,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,">SetX2NDC(xlc+dxlc*i+0.8);; label->SetY2NDC(ylc+dylc*i+0.2);; pad22->Modified();; c1->Update();; }; gBenchmark->Show(""canvas"");; }; Int_tint Int_tDefinition RtypesCore.h:45; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Modifiedvoid Modified(Bool_t flag=true) overrideMark pad modified Will be repainted when TCanvas::Update() will be called next time.Definition TPad.cxx:7369; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/canvas_8C.html:4577,simpl,simple,4577,doc/master/canvas_8C.html,https://root.cern,https://root.cern/doc/master/canvas_8C.html,1,['simpl'],['simple']
Usability,"?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { _doFloorGlobal = flag ; }. Bool_t getFloorGlobal(); { return _doFloorGlobal ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. » Last changed: Tue Jun 2 15:33:27 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooRealSumPdf.html:48509,intuit,intuitively,48509,root/html604/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html604/RooRealSumPdf.html,2,['intuit'],['intuitively']
Usability,"?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { _doFloorGlobal = flag ; }. Bool_t getFloorGlobal(); { return _doFloorGlobal ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. » Last changed: Tue Jun 30 14:35:23 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:48509,intuit,intuitively,48509,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,2,['intuit'],['intuitively']
Usability,"?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. Bool_t selfNormalized() const; { return getAttribute(""BinnedLikelihoodActive"") ; }. void setFloor(Bool_t flag); { _doFloor = flag ; }. Bool_t getFloor() const; { return _doFloor ; }. void setFloorGlobal(Bool_t flag); { _doFloorGlobal = flag ; }. Bool_t getFloorGlobal(); { return _doFloorGlobal ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. » Last changed: Tue Mar 10 17:18:50 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:46847,intuit,intuitively,46847,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,2,['intuit'],['intuitively']
Usability,"@ kBlackDefinition Rtypes.h:65; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; kCanDelete@ kCanDeleteDefinition TObject.h:367; kCannotPick@ kCannotPickDefinition TObject.h:372; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TBoxCreate a Box.Definition TBox.h:22; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TTextBase class for several text objects.Definition TText.h:22; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::GetV1virtual Double_t * GetV1()Definition TTree.h:576; TTree::GetV4virtual Double_t * GetV4()Definition TTree.h:582; TTree::GetV2virtual Double_t * GetV2()Definition TTree.h:578; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; yDouble_t y[n]Definition legend1.C:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlGraph2_8C.html:4056,simpl,simple,4056,doc/master/hlGraph2_8C.html,https://root.cern,https://root.cern/doc/master/hlGraph2_8C.html,1,['simpl'],['simple']
Usability,"@cern.ch> - MPI-K Heidelberg, Germany *; 20 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 21 * Omar Zapata <Omar.Zapata@cern.ch> - UdeA/ITM Colombia *; 22 * Lorenzo Moneta <Lorenzo.Moneta@cern.ch> - CERN, Switzerland *; 23 * Sergei Gleyzer <Sergei.Gleyzer@cern.ch> - U of Florida & CERN *; 24 * Kim Albertsson <kim.albertsson@cern.ch> - LTU & CERN *; 25 * *; 26 * Copyright (c) 2005-2015: *; 27 * CERN, Switzerland *; 28 * U. of Victoria, Canada *; 29 * MPI-K Heidelberg, Germany *; 30 * U. of Bonn, Germany *; 31 * UdeA/ITM, Colombia *; 32 * U. of Florida, USA *; 33 * *; 34 * Redistribution and use in source and binary forms, with or without *; 35 * modification, are permitted according to the terms listed in LICENSE *; 36 * (see tmva/doc/LICENSE) *; 37 **********************************************************************************/; 38 ; 39/*! \class TMVA::Factory; 40\ingroup TMVA; 41 ; 42This is the main MVA steering class.; 43It creates all MVA methods, and guides them through the training, testing and; 44evaluation phases.; 45*/; 46 ; 47#include ""TMVA/Factory.h""; 48 ; 49#include ""TMVA/ClassifierFactory.h""; 50#include ""TMVA/Config.h""; 51#include ""TMVA/Configurable.h""; 52#include ""TMVA/Tools.h""; 53#include ""TMVA/Ranking.h""; 54#include ""TMVA/DataSet.h""; 55#include ""TMVA/IMethod.h""; 56#include ""TMVA/MethodBase.h""; 57#include ""TMVA/DataInputHandler.h""; 58#include ""TMVA/DataSetManager.h""; 59#include ""TMVA/DataSetInfo.h""; 60#include ""TMVA/DataLoader.h""; 61#include ""TMVA/MethodBoost.h""; 62#include ""TMVA/MethodCategory.h""; 63#include ""TMVA/ROCCalc.h""; 64#include ""TMVA/ROCCurve.h""; 65#include ""TMVA/MsgLogger.h""; 66 ; 67#include ""TMVA/VariableInfo.h""; 68#include ""TMVA/VariableTransform.h""; 69 ; 70#include ""TMVA/Results.h""; 71#include ""TMVA/ResultsClassification.h""; 72#include ""TMVA/ResultsRegression.h""; 73#include ""TMVA/ResultsMulticlass.h""; 74#include <list>; 75#include <bitset>; 76#include <set>; 77 ; 78#include ""TMVA/Types.h""; 79 ; 80#include ""TROOT.h""; 81#incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:2028,guid,guides,2028,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['guid'],['guides']
Usability,"A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148650,Simpl,Simple,148650,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"A() == TFolder::Class()) {; 1899 Branch(curname, bufsize, splitlevel - 1);; 1900 } else {; 1901 void* add = (void*) folder->GetListOfFolders()->GetObjectRef(obj);; 1902 for (Int_t i = 0; i < 1000; ++i) {; 1903 if (curname[i] == 0) {; 1904 break;; 1905 }; 1906 if (curname[i] == '/') {; 1907 curname[i] = '.';; 1908 }; 1909 }; 1910 Int_t noccur = folder->Occurence(obj);; 1911 if (noccur > 0) {; 1912 snprintf(occur,20, ""_%d"", noccur);; 1913 strlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:75119,simpl,simple,75119,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__RegressionVariance.html:2120,simpl,simple,2120,root/html604/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html604/TMVA__RegressionVariance.html,2,['simpl'],['simple']
Usability,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__RegressionVariance.html:2112,simpl,simple,2112,root/html602/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html602/TMVA__RegressionVariance.html,2,['simpl'],['simple']
Usability,"ALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:5118,clear,clearValueDirty,5118,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,6,['clear'],['clearValueDirty']
Usability,"ARN_MSG(""DataRange::SetRange"",""remove existing range and keep only the set one"");; 141 rs.resize(1);; 142 rs[0] = std::make_pair(xmin, xmax);; 143 return;; 144}; 145 ; 146bool DataRange::IsInside(double x, unsigned int icoord ) const {; 147 // check if a point is in range; 148 ; 149 if (Size(icoord) == 0) return true; // no range existing (is like -inf, +inf); 150 const RangeSet & ranges = fRanges[icoord];; 151 for (RangeSet::const_iterator itr = ranges.begin(); itr != ranges.end(); ++itr) {; 152 if ( x < (*itr).first ) return false;; 153 if ( x <= (*itr).second) return true;; 154 }; 155 return false; // point is larger than last xmax; 156}; 157 ; 158void DataRange::Clear(unsigned int icoord ) {; 159 // remove all ranges for coordinate icoord; 160 if (Size(icoord) == 0) return; // no op in this case; 161 fRanges[icoord].clear();; 162}; 163 ; 164 ; 165void DataRange::CleanRangeSet(unsigned int icoord, double xmin, double xmax) {; 166 // remove all the existing ranges between xmin and xmax; 167 // called when a new range is inserted; 168 ; 169 // loop on existing ranges; 170 RangeSet & ranges = fRanges[icoord];; 171 for (RangeSet::iterator itr = ranges.begin(); itr != ranges.end(); ++itr) {; 172 // delete included ranges; 173 if ( itr->first >= xmin && itr->second <= xmax) {; 174 itr = ranges.erase(itr);; 175 // itr goes to next element, so go back before adding; 176 --itr;; 177 }; 178 }; 179 ; 180}; 181 ; 182void DataRange::GetInfRange(double &xmin, double &xmax) {; 183 // get the full range [-inf, +inf] for xmin and xmax; 184 xmin = -std::numeric_limits<double>::infinity();; 185 xmax = std::numeric_limits<double>::infinity();; 186}; 187 ; 188 } // end namespace Fit; 189 ; 190} // end namespace ROOT; 191 ; DataRange.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8cxx_source.html:5199,clear,clear,5199,doc/master/DataRange_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8cxx_source.html,1,['clear'],['clear']
Usability,"ASSNAME)_raw$(VERSION); For example: TAxis_ver8 or TList_raw5; Second kind of tables appears, when some of class members can not be converted to; normalized form or when class has custom streamer.; For instance, for TH1 class two tables are required: TH1_ver4 and TH1_raw4; Most of memebers are stored in TH1_ver4 table columnwise, and only memeber:. Double_t* fBuffer; //[fBufferSize]. can not be represented as column while size of array is not known apriory.; Therefore, fBuffer will be written as list of values in TH1_raw4 table. All objects, stored in the DB, will be registered in table ""ObjectsTable"".; In this there are following columns:; ""key:id"" - key identifier to which belong object; ""obj:id"" - object identifier; ""Class"" - object class name; ""Version"" - object class version; Data in each ""ObjectsTable"" row uniqly identify, in which table; and which column object is stored. In normal situation all class data should be sorted columnwise.; Up to now following member are supported:; 1) Basic data types; Here is everything clear. Column SQL type will be as much as possible; close to the original type of value.; 2) Fixed array of basic data types; In this case n columns like fArr[0], fArr[1] and so on will be created.; If there is multidimensional array, names will be fArr2[1][2][1] and so on; 3) Parent class; In this case version of parent class is stored and; data of parent class will be stored with the same obj:id in corrspondent table.; There is a special case, when parent store nothing (this is for instance TQObject).; In that case just -1 is written to avoid any extra checks if table exist or not.; 4) Object as data member.; In that case object is saved in normal way to data base and column; will contain id of this object.; 5) Pointer on object; Same as before. In case if object was already stored, just its id; will be placed in the column. For NULL pointer 0 is used.; 6) TString; Now column with limited width like VARCAHR(255) in MySQL is used.; Later this wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:1579,clear,clear,1579,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,9,['clear'],['clear']
Usability,"A_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ; file  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ; file  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ; file  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ;  ; file  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ; file  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ; file  TMVA_SOFIE_RSofieReader",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:3778,simpl,simple,3778,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"AbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Deault constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Thu Sep 23 19:59:14 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChangeTracker.html:33958,clear,clearState,33958,root/html528/RooChangeTracker.html,https://root.cern,https://root.cern/root/html528/RooChangeTracker.html,4,['clear'],"['clearState', 'cleared']"
Usability,"AbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Mon Jul 4 15:22:26 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:34476,clear,clearState,34476,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,4,['clear'],"['clearState', 'cleared']"
Usability,"AbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Thu Nov 3 20:07:44 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChangeTracker.html:34855,clear,clearState,34855,root/html532/RooChangeTracker.html,https://root.cern,https://root.cern/root/html532/RooChangeTracker.html,4,['clear'],"['clearState', 'cleared']"
Usability,"AbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:6415,clear,clearEvalError,6415,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,2,['clear'],['clearEvalError']
Usability,"AbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:6415,clear,clearEvalError,6415,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,1,['clear'],['clearEvalError']
Usability,"AbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:6415,clear,clearEvalError,6415,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,1,['clear'],['clearEvalError']
Usability,"AbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:4888,clear,clearEvalErrorLog,4888,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,4,['clear'],['clearEvalErrorLog']
Usability,"AbsReal &_sigmaR);  ;  RooBifurGauss (const RooBifurGauss &other, const char *name=nullptr);  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBifurGauss.html:1744,simpl,simple,1744,doc/master/classRooBifurGauss.html,https://root.cern,https://root.cern/doc/master/classRooBifurGauss.html,1,['simpl'],['simple']
Usability,"AbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:4462,clear,clearEvalError,4462,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,2,['clear'],['clearEvalError']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:3902,clear,clearValueDirty,3902,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:3846,clear,clearValueDirty,3846,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:3918,clear,clearValueDirty,3918,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,8,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStepFunction.html:3711,clear,clearValueDirty,3711,root/html526/RooStepFunction.html,https://root.cern,https://root.cern/root/html526/RooStepFunction.html,2,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:4378,clear,clearValueDirty,4378,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,1,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:4093,clear,clearValueDirty,4093,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,2,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:4971,clear,clearValueDirty,4971,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,2,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:3836,clear,clearValueDirty,3836,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,2,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgSetcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProduct.html:3348,clear,clearValueDirty,3348,root/html528/RooProduct.html,https://root.cern,https://root.cern/root/html528/RooProduct.html,1,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:3577,clear,clearValueDirty,3577,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,90,['clear'],['clearValueDirty']
Usability,"AbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:4125,clear,clearValueDirty,4125,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,1,['clear'],['clearValueDirty']
Usability,"AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; 25.5 Widgets Overview; The word widget is a contraction of windows and gadget. Almost all GUI elements are widgets. A button is a widget, a menu item is a widget, a scrollbar is a widget, and a complete dialog box is a widget too. Some widgets may have sub widgets. For example, a dialog box can contain buttons, text fields, a combo-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1146669,guid,guidelines,1146669,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guidelines']
Usability,"AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTGX11::CloseDisplay(); virtual voidTGX11::ClosePixmap(); virtual voidTGX11::CloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGX11::ConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidTGX11::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTGX11::CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidTGX11::CopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidTGX11::CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tTGX11::CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tTGX11::CreateCursor(ECursor cursor); virtual GContext_tTGX11::CreateGC(Drawable_t id, GCV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGX11TTF.html:1874,Clear,ClearWindow,1874,root/html532/TGX11TTF.html,https://root.cern,https://root.cern/root/html532/TGX11TTF.html,1,['Clear'],['ClearWindow']
Usability,"AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Int_tTClass::AutoBrowse(TObject* obj, TBrowser* browser); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTClass::Browse(TBrowser* b); Int_tTClass::Browse(void* obj, TBrowser* b) const; voidTClass::BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidTClass::BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidTClass::CalculateStreamerOffset() const; Bool_tTClass::CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tTClass::CanIgnoreTObjectStreamer(); Bool_tTClass::CanSplit() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tTClass::ClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TClass::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; voidTClass::CopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTClass::DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); virtual voidTQObject::Destroyed()SIGNAL ; voidTClass::Destructor(void* obj, Bool_t dtorOnly =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:2930,Clear,Clear,2930,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['Clear'],['Clear']
Usability,"Alias (PyObject *, PyObject *args);  . Variables; PyObject * gRootModule = nullptr;  . Function Documentation. ◆ AddCPPInstancePickling(). PyObject * PyROOT::AddCPPInstancePickling ; (; PyObject * ; self, . PyObject * ; args . ). Set reduce attribute for CPPInstance objects. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the arguments received from Python. The C++ function op_reduce defined above is wrapped in a Python method so that it can be injected in CPPInstance ; Definition at line 123 of file CPPInstancePyz.cxx. ◆ AddPrettyPrintingPyz(). PyObject * PyROOT::AddPrettyPrintingPyz ; (; PyObject * ; self, . PyObject * ; args . ). Add pretty printing pythonization. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the arguments received from Python. This function adds the following pythonizations to print the object more user-friendly than cppyy by using the output of cling::printValue as the return value of the special method str. ; Definition at line 119 of file GenericPyz.cxx. ◆ AddTClassDynamicCastPyz(). PyObject * PyROOT::AddTClassDynamicCastPyz ; (; PyObject * ; self, . PyObject * ; args . ). Add pythonization for TClass::DynamicCast. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the arguments received from Python. TClass::DynamicCast returns a void* that the user still has to cast (it will have the proper offset, though). Fix this by providing the requested binding if the cast succeeded. ; Definition at line 68 of file TClassPyz.cxx. ◆ AddTObjectEqNePyz(). PyObject * PyROOT::AddTObjectEqNePyz ; (; PyObject * ; self, . PyObject * ; args . ). Add pythonization for equality and inequality operators in TObject. ; Parameters. [in]selfAlways null, since this is a module function. ; [in]argsPointer to a Python tuple object containing the argument",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespacePyROOT.html:2410,user-friendly,user-friendly,2410,doc/master/namespacePyROOT.html,https://root.cern,https://root.cern/doc/master/namespacePyROOT.html,1,['user-friendly'],['user-friendly']
Usability,"AlignableEntryByUID(Int_t uid) const; Retreives an existing alignable object having a preset UID. Int_t GetNAlignable(Bool_t with_uid = kFALSE) const; Retreives number of PN entries with or without UID. Bool_t InsertPNEId(Int_t uid, Int_t ientry); Insert a PN entry in the sorted array of indexes. TGeoPhysicalNode * MakeAlignablePN(const char* name); Make a physical node from the path pointed by an alignable object with a given name. TGeoPhysicalNode * MakeAlignablePN(TGeoPNEntry* entry); Make a physical node from the path pointed by a given alignable object. TGeoPhysicalNode * MakePhysicalNode(const char* path = 0); Makes a physical node corresponding to a path. If PATH is not specified,; makes physical node matching current modeller state. void RefreshPhysicalNodes(Bool_t lock = kTRUE); Refresh physical nodes to reflect the actual geometry paths after alignment; was applied. Optionally locks physical nodes (default). void ClearPhysicalNodes(Bool_t mustdelete = kFALSE); Clear the current list of physical nodes, so that we can start over with a new list.; If MUSTDELETE is true, delete previous nodes. TGeoVolumeAssembly * MakeVolumeAssembly(const char* name); Make an assembly of volumes. TGeoVolumeMulti * MakeVolumeMulti(const char* name, TGeoMedium* medium); Make a TGeoVolumeMulti handling a list of volumes. void SetExplodedView(Int_t iopt = 0); Set type of exploding view (see TGeoPainter::SetExplodedView()). void SetPhiRange(Double_t phimin = 0., Double_t phimax = 360.); Set cut phi range. void SetNsegments(Int_t nseg); Set number of segments for approximating circles in drawing. Int_t GetNsegments() const; Get number of segments approximating circles. void BuildDefaultMaterials(); Now just a shortcut for GetElementTable. TGeoElementTable * GetElementTable(); Returns material table. Creates it if not existing. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:62532,Clear,ClearPhysicalNodes,62532,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,8,['Clear'],"['Clear', 'ClearPhysicalNodes']"
Usability,"AllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18584,undo,undo,18584,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidCheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackPropagator.html:2864,Clear,ClearProjectedList,2864,root/html532/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html532/TEveTrackPropagator.html,4,['Clear'],['ClearProjectedList']
Usability,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBufferXML.html:2162,Clear,Clear,2162,root/html532/TBufferXML.html,https://root.cern,https://root.cern/root/html532/TBufferXML.html,1,['Clear'],['Clear']
Usability,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TObject*ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(const void* obj, const TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferXML.html:2162,Clear,Clear,2162,root/html534/TBufferXML.html,https://root.cern,https://root.cern/root/html534/TBufferXML.html,3,['Clear'],['Clear']
Usability,"ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBufferSQL2.html:2121,Clear,Clear,2121,root/html532/TBufferSQL2.html,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html,4,['Clear'],['Clear']
Usability,"Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Adam.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Adam.h. Constructor & Destructor Documentation. ◆ TAdam(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::TAdam ; (; DeepNet_t & ; deepNet, . Scalar_t ; learningRate = 0.001, . Scalar_t ; beta1 = 0.9, . Scalar_t ; beta2 = 0.999, . Scalar_t ; epsilon = 1e-7 . ). Constructor. ; Definition at line 102 of file Adam.h. ◆ ~TAdam(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::~TAdam ; (; ). default . Destructor. . Member Function Documentation. ◆ GetBeta1(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::GetBeta1 ; (; ); const. inline . Getters. ; Definition at line 80 of file Adam.h. ◆ GetBeta2(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::GetBeta2 ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:5098,learn,learningRate,5098,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learningRate']
Usability,"Arg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:4756,clear,clearShapeDirty,4756,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"Arg::attributes() const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:4234,clear,clearEvalErrorLog,4234,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"Arg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Definition RooAbsArg.cxx:2075; RooAbsArg::numProxiesInt_t numProxies() constReturn the number of registered proxies.Definition RooAbsArg.cxx:1457; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsArg::setAttributevoid setAttribute(const Text_t *name, bool value=true)Set (default) or clear a named boolean attribute of this object.Definition RooAbsArg.cxx:222; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::getProxyRooAbsProxy * getProxy(Int_t index) constReturn the nth proxy from the proxy list.Definition RooAbsArg.cxx:1444; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::leafNodeServerListvoid leafNodeServerList(RooAbsCollection *list, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:206202,clear,clear,206202,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['clear']
Usability,"ArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:6279,clear,clearEvalErrorLog,6279,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"ArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:4959,clear,clearValueDirty,4959,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,2,['clear'],['clearValueDirty']
Usability,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read an integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int_t max); {fMaximum = max;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafI.html:8437,simpl,simple,8437,root/html528/TLeafI.html,https://root.cern,https://root.cern/root/html528/TLeafI.html,4,['simpl'],['simple']
Usability,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read an integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int_t ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafI.html:8669,simpl,simple,8669,root/html534/TLeafI.html,https://root.cern,https://root.cern/root/html534/TLeafI.html,2,['simpl'],['simple']
Usability,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read an integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLeafI.html:9161,simpl,simple,9161,root/html602/TLeafI.html,https://root.cern,https://root.cern/root/html602/TLeafI.html,4,['simpl'],['simple']
Usability,"Assembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960780,simpl,simple,960780,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,AsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:21168,clear,clear,21168,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"At(Float_t c, Int_t i); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1K.html:2314,Clear,Clear,2314,root/html534/TH1K.html,https://root.cern,https://root.cern/root/html534/TH1K.html,1,['Clear'],['Clear']
Usability,"Attributes |; Private Member Functions |; Friends |; List of all members ; TWebPadPainter Class ReferenceWeb Display » ROOT 6 Web Display. ; Implement TVirtualPadPainter which abstracts painting operations. ; TWebPadPainter tries to support old Paint methods of the ROOT classes. Main classes (like histograms or graphs) should be painted on JavaScript side ; Definition at line 26 of file TWebPadPainter.h. Public Member Functions;  TWebPadPainter ();  ; void ClearDrawable () override;  ; void CopyDrawable (Int_t, Int_t, Int_t) override;  ; Int_t CreateDrawable (UInt_t, UInt_t) override;  ; void DestroyDrawable (Int_t) override;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2, EBoxMode mode) override;  Paint a simple box. ;  ; void DrawFillArea (Int_t n, const Double_t *x, const Double_t *y) override;  Paint filled area. ;  ; void DrawFillArea (Int_t n, const Float_t *x, const Float_t *y) override;  Paint filled area. ;  ; void DrawLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Paint a simple line. ;  ; void DrawLineNDC (Double_t u1, Double_t v1, Double_t u2, Double_t v2) override;  Paint a simple line in normalized coordinates. ;  ; void DrawPixels (const unsigned char *pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending) override;  Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ;  ; void DrawPolyLine (Int_t n, const Double_t *x, const Double_t *y) override;  Paint Polyline. ;  ; void DrawPolyLine (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polyline. ;  ; void DrawPolyLineNDC (Int_t n, const Double_t *u, const Double_t *v) override;  Paint polyline in normalized coordinates. ;  ; void DrawPolyMarker (Int_t n, const Double_t *x, const Double_t *y) override;  Paint polymarker. ;  ; void DrawPolyMarker (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polymarker. ;  ; void DrawText (Double_t x, Double_t y, const char *text, ETextMode mode) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPadPainter.html:1304,simpl,simple,1304,doc/master/classTWebPadPainter.html,https://root.cern,https://root.cern/doc/master/classTWebPadPainter.html,1,['simpl'],['simple']
Usability,"Axis::Set"", ""bins must be in increasing order"");; 816 fXmin = fXbins.fArray[0];; 817 fXmax = fXbins.fArray[fNbins];; 818 if (!fParent) SetDefaults();; 819}; 820 ; 821////////////////////////////////////////////////////////////////////////////////; 822/// Initialize axis with variable bins; 823 ; 824void TAxis::Set(Int_t nbins, const Double_t *xbins); 825{; 826 Int_t bin;; 827 fNbins = nbins;; 828 fXbins.Set(fNbins+1);; 829 for (bin=0; bin<= fNbins; bin++); 830 fXbins.fArray[bin] = xbins[bin];; 831 for (bin=1; bin<= fNbins; bin++); 832 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 833 Error(""TAxis::Set"", ""bins must be in increasing order"");; 834 fXmin = fXbins.fArray[0];; 835 fXmax = fXbins.fArray[fNbins];; 836 if (!fParent) SetDefaults();; 837}; 838 ; 839////////////////////////////////////////////////////////////////////////////////; 840/// Set axis alphanumeric; 841 ; 842void TAxis::SetAlphanumeric(Bool_t alphanumeric); 843{; 844 if (alphanumeric) fBits2 |= kAlphanumeric;; 845 else fBits2 &= ~kAlphanumeric;; 846 ; 847 // clear underflow and overflow (in an alphanumeric situation they do not make sense); 848 // NOTE: using AddBinContent instead of SetBinContent in order to not change; 849 // the number of entries; 850 //((TH1 *)fParent)->ClearUnderflowAndOverflow();; 851 // L.M. 26.1.15 Keep underflow and overflows (see ROOT-7034); 852 if (gDebug && fParent) {; 853 TH1 * h = dynamic_cast<TH1*>( fParent);; 854 if (!h) return;; 855 double s[TH1::kNstat];; 856 h->GetStats(s);; 857 if (s[0] != 0. && gDebug > 0); 858 Info(""SetAlphanumeric"",""Cannot switch axis %s of histogram %s to alphanumeric: it has non-zero content"",GetName(),h->GetName());; 859 }; 860}; 861 ; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Set axis default values (from TStyle); 865 ; 866void TAxis::SetDefaults(); 867{; 868 fFirst = 0;; 869 fLast = 0;; 870 fBits2 = 0;; 871 char name[2];; 872 strlcpy(name,GetName(),2);; 873 name[1] = 0;; 874 TAttAxis:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:28144,clear,clear,28144,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,1,['clear'],['clear']
Usability,"B.; An HypoTestCalculator (Hybrid of Frequentis) will be created using the; S+B model as the null and the B model as the alternate; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(const RooStats::HypoTestInverter& rhs); copy-constructor; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; run an automatic scan until the desired accurancy is reached; Start by default from the full interval (min,max) of the POI and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:8604,Clear,Clear,8604,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,1,['Clear'],['Clear']
Usability,"B.; An HypoTestCalculator (Hybrid of Frequentis) will be created using the; S+B model as the null and the B model as the alternate; If no variable to scan are given they are assumed to be the first variable; from the parameter of interests of the null model. HypoTestInverter(const RooStats::HypoTestInverter& rhs); copy-constructor; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; run an automatic scan until the desired accurancy is reached; Start by default from the full interval (min,m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:8724,Clear,Clear,8724,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,3,['Clear'],['Clear']
Usability,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:12480,learn,learning,12480,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,2,['learn'],['learning']
Usability,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:13166,learn,learning,13166,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,4,['learn'],['learning']
Usability,"Background; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoMediumEditor.html:23020,undo,undoing,23020,root/html604/TGeoMediumEditor.html,https://root.cern,https://root.cern/root/html604/TGeoMediumEditor.html,2,['undo'],['undoing']
Usability,"Background; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMediumEditor.html:23020,undo,undoing,23020,root/html602/TGeoMediumEditor.html,https://root.cern,https://root.cern/root/html602/TGeoMediumEditor.html,2,['undo'],['undoing']
Usability,"BarOffset(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1], d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; The following options are supported:. ""SCAT""; Draw a scatter plot (default). ""COL""; Draw a color plot. All the none empty bins are painted. Empty bins are not; painted. ""COLZ""; Same as ""COL"". In addition the color palette is also drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTN""; Draw bin names as text. ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""L""; Draw the bins boundaries as lines.; The lines attibutes are the TGraphs ones. ""P""; Draw the bins boundaries as markers.; The markers attibutes are the TGraphs ones. ""F""; Draw the bins boundaries as filled polygons.; The filled polygons attibutes are the TGraphs ones. TH2Poly can; be drawn as a color plot (option COL). TH2Poly bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t px1[] = {0, 5, 6};; Double_t py1[] = {0, 0, 5};; Double_t px2[] = {0, -1, -1, 0};; Double_t py2[] = {0, 0, -1, 3};; Double_t px3[] = {4, 3, 0, 1, 2.4};; Double_t py3[] = {4, 3.7, 1, 3.7, 2.5};; h2p->AddBin(3, px1, py1);; h2p->AddBin(4, px2, py2);; h2p->AddBin(5, px3, py3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(1);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The special version of; the AddBin method allows to define them more easily like; shown in the following example. Picture; Source. //This tutorial illustrates h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:59031,simpl,simple,59031,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,4,['simpl'],['simple']
Usability,"BarOffset(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1], d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; The following options are supported:. ""SCAT""; Draw a scatter plot (default). ""COL""; Draw a color plot. All the none empty bins are painted. Empty bins are not; painted. ""COLZ""; Same as ""COL"". In addition the color palette is also drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTN""; Draw bin names as text. ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""L""; Draw the bins boundaries as lines.; The lines attibutes are the TGraphs ones. ""P""; Draw the bins boundaries as markers.; The markers attibutes are the TGraphs ones. ""F""; Draw the bins boundaries as filled polygons.; The filled polygons attibutes are the TGraphs ones. TH2Poly can; be drawn as a color plot (option COL). TH2Poly bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(4, x3, y3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(1);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The special version of; the AddBin method allows to define them more easily like; shown in the following example. Picture; Source. //This tutorial illustrates how to create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THistPainter.html:55437,simpl,simple,55437,root/html530/THistPainter.html,https://root.cern,https://root.cern/root/html530/THistPainter.html,3,['simpl'],['simple']
Usability,"Base::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodKNN.html:16299,learn,learning,16299,root/html528/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html,1,['learn'],['learning']
Usability,"BckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd1Editor.html:22143,undo,undoing,22143,root/html604/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html604/TGeoTrd1Editor.html,2,['undo'],['undoing']
Usability,"BckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1Editor.html:22143,undo,undoing,22143,root/html602/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1Editor.html,2,['undo'],['undoing']
Usability,"BitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveQuadSet(const char* n = ""TEveQuadSet"", const char* t = """"); Constructor. TEveQuadSet(TEveQuadSet::EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize, const char* n = ""TEveQuadSet"", const char* t = """"); Constructor. Int_t SizeofAtom(TEveQuadSet::EQuadType_e qt); Return size of given atom type. void Reset(TEveQuadSet::EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize); Clear the quad-set and reset the basic parameters. void AddQuad(Float_t* verts); Add a quad specified with 4 vertices. void AddQuad(Float_t a, Float_t b); Add a quad with a and b coordinates. Defaults are applied for; c coordinate and sizes. void AddQuad(Float_t a, Float_t b, Float_t c); Add a quad with a, b and c coordinates. Defaults are applied; for sizes. void AddQuad(Float_t a, Float_t b, Float_t w, Float_t h); Add a quad with a and b coordinates and sizes. Default is applied; for c coordinate. void AddQuad(Float_t a, Float_t b, Float_t c, Float_t w, Float_t h); Add a quad with a, b and c coordinates and sizes. void AddLine(Float_t a, Float_t b, Float_t w, Float_t h); Add a line with starting coordinates and displacements. void AddHexagon(Float_t a, Float_t b, Float_t z, Float_t r); Add a hexagon with given center (a,b,c) and radius. void ComputeBBox(); Fill bounding-box information. Virtual from TAttBBox.; If member 'TEveFrameBox* fFrame' is set, frame's corners a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveQuadSet.html:31265,Clear,Clear,31265,root/html602/TEveQuadSet.html,https://root.cern,https://root.cern/root/html602/TEveQuadSet.html,2,['Clear'],['Clear']
Usability,"Blockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. virtual ~TGeoMixtureEditor(); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMixtureEditor.html:23142,undo,undo,23142,root/html534/TGeoMixtureEditor.html,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html,4,['undo'],"['undo', 'undoing']"
Usability,"Blue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignment, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interesting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLegend.html:2593,simpl,simply,2593,root/html604/TLegend.html,https://root.cern,https://root.cern/root/html604/TLegend.html,2,['simpl'],['simply']
Usability,"Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sat Jun 20 17:29:22 2015 » Last generated: 2015-06-20 17:29; This page",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsArg.html:45916,clear,clearValueAndShapeDirty,45916,root/html604/RooAbsArg.html,https://root.cern,https://root.cern/root/html604/RooAbsArg.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:44220,clear,clearValueAndShapeDirty,44220,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:45916,clear,clearValueAndShapeDirty,45916,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container. Imported; object can be retrieved by name through the obj() method. The object is cloned upon; importation and the input argument does not need to live beyond the import call. Returns kTRUE if an error has occurred. Bool_t import(TObject& object, const char* aliasName, Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container.; The imported object will be stored under the given alias name rather than its; own name. Imported object can be retrieved its alias name through the obj() method.; The object is cloned upon importation and the input argument does not need to live beyond the import call; This method is mostly useful for importing objects that do not have a settable name such as TMatrix. Returns kTRUE if an error has occurred. Bool_t addStudy(RooAbsStudy& study); Insert RooStudyManager module. void clearStudies(); Remove all RooStudyManager modules. TObject* obj(const char* name) const; Return any type of object (RooAbsArg, RooAbsData or generic object) with given name). TObject* genobj(const char* name) const; Return generic object with given name. Bool_t cd(const char* path = 0). Bool_t writeToFile(const char* fileName, Bool_t recreate = kTRUE); Save this current workspace into given file. RooFactoryWSTool& factory(); Return instance to factory tool. RooAbsArg* factory(const char* expr); Short-hand function for factory()->process(expr) ;. void Print(Option_t* opts = 0) const; Print contents of the workspace. void Streamer(TBuffer& ); Stream an object of class RooWorkspace. This is a standard ROOT streamer for the; I/O part. This custom function exists to detach all external client links; from the payload prior to writing the payload so that these client links; are not persisted. (Client links occur if external function objects use; objects contained in the workspace as input); After the actual writin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace.html:24036,clear,clearStudies,24036,root/html534/RooWorkspace.html,https://root.cern,https://root.cern/root/html534/RooWorkspace.html,6,['clear'],['clearStudies']
Usability,"Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container. Imported; object can be retrieved by name through the obj() method. The object is cloned upon; importation and the input argument does not need to live beyond the import call. Returns kTRUE if an error has occurred. Bool_t import(TObject& object, const char* aliasName, Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container.; The imported object will be stored under the given alias name rather than its; own name. Imported object can be retrieved its alias name through the obj() method.; The object is cloned upon importation and the input argument does not need to live beyond the import call; This method is mostly useful for importing objects that do not have a settable name such as TMatrix. Returns kTRUE if an error has occurred. Bool_t addStudy(RooAbsStudy& study); Insert RooStudyManager module. void clearStudies(); Remove all RooStudyManager modules. TObject* obj(const char* name) const; Return any type of object (RooAbsArg, RooAbsData or generic object) with given name). TObject* genobj(const char* name) const; Return generic object with given name. Bool_t cd(const char* path = 0). Bool_t writeToFile(const char* fileName, Bool_t recreate = kTRUE); Save this current workspace into given file. RooFactoryWSTool& factory(); Return instance to factory tool. RooAbsArg* factory(const char* expr); Short-hand function for factory()->process(expr) ;. void Print(Option_t* opts = 0) const; Print contents of the workspace. void Streamer(TBuffer& b); Stream an object of class RooWorkspace. This is a standard ROOT streamer for the; I/O part. This custom function exists to detach all external client links; from the payload prior to writing the payload so that these client links; are not persisted. (Client links occur if external function objects use; objects contained in the workspace as input); After the actual writi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace.html:20955,clear,clearStudies,20955,root/html526/RooWorkspace.html,https://root.cern,https://root.cern/root/html526/RooWorkspace.html,5,['clear'],['clearStudies']
Usability,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:2341,clear,clearValueAndShapeDirty,2341,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:2272,clear,clearValueAndShapeDirty,2272,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:2100,clear,clearValueAndShapeDirty,2100,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:1900,clear,clearValueAndShapeDirty,1900,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,16,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:1827,clear,clearValueAndShapeDirty,1827,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.; Option can contain : v - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->GetEntriesFast());}. void ClearNodes(); {fNodes = 0;}. Bool_t Contains(Double_t* point) const; {return fShape->Contains(point);}. Bool_t IsRunTime() const; {return fShape->IsRunTimeShape();}. Bool_t IsVolumeMulti() const; {return kFALSE;}. Bool_t IsActive() const; {return TGeoAtt::IsActive();}. Bool_t IsActiveDaughters() const; {return TGeoAtt::IsActiveDaughters();}. Bool_t IsAdded() const; {return TObject::TestBit(kVolumeAdded);}. Bool_t IsReplicated() const; {return TObject::TestBit(kVolumeReplicated);}. Bool_t IsSelected() const; {return TObject::TestBit(kVolumeSelected);}. Bool_t IsCylVoxels() const; {return TObject::TestBit(kVoxelsCyl);}. Bool_t IsXYZVoxels() const; {return TObject::TestBit(kVoxelsXYZ);}. Bool_t IsValid() const; {return fShape->IsValid();}. Bool_t IsVisible() const; {return TGeoAtt::IsVisible();}. Bool_t IsVisibleDaughters() const; {return TGeoAtt::IsVisDaughters();}. Bool_t IsVisContainers() const; {return TGeoAtt::IsVisContainers();}. Bool_t IsVisLeaves() const; {return TGeoAtt::IsVisLeaves();}. Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolume.html:32430,Clear,ClearNodes,32430,root/html532/TGeoVolume.html,https://root.cern,https://root.cern/root/html532/TGeoVolume.html,1,['Clear'],['ClearNodes']
Usability,"Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.; Option can contain : v - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->GetEntriesFast());}. void ClearNodes(); {fNodes = 0;}. Bool_t Contains(const Double_t* point) const; {return fShape->Contains(point);}. Bool_t IsRunTime() const; {return fShape->IsRunTimeShape();}. Bool_t IsVolumeMulti() const; {return kFALSE;}. Int_t GetRefCount() const; {return fRefCount;}. TGeoExtension * GetUserExtension() const; {return fUserExtension;}. TGeoExtension * GetFWExtension() const; {return fFWExtension;}. void Grab(); {fRefCount++;}. void Release(); {fRefCount--; if (fRefCount==0) delete this;}. Bool_t IsActive() const; {return TGeoAtt::IsActive();}. Bool_t IsActiveDaughters() const; {return TGeoAtt::IsActiveDaughters();}. Bool_t IsAdded() const; {return TObject::TestBit(kVolumeAdded);}. Bool_t IsOverlappingCandidate() const; {return TObject::TestBit(kVolumeOC);}. Bool_t IsReplicated() const; {return TObject::TestBit(kVolumeReplicated);}. Bool_t IsSelected() const; {return TObject::TestBit(kVolumeSelected);}. Bool_t IsCylVoxels() const; {return TObject::TestBit(kVoxelsCyl);}. Bool_t IsXYZVoxels() const; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:43872,Clear,ClearNodes,43872,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,3,['Clear'],['ClearNodes']
Usability,"Bool_tClassInfo_IsValid(ClassInfo_t*) const; virtual Bool_tClassInfo_IsValidMethod(ClassInfo_t*, const char*, const char*, Long_t*, ROOT::EFunctionMatchMode = ROOT::kConversionMatch) const; virtual Bool_tClassInfo_IsValidMethod(ClassInfo_t*, const char*, const char*, Bool_t, Long_t*, ROOT::EFunctionMatchMode = ROOT::kConversionMatch) const; virtual const char*ClassInfo_Name(ClassInfo_t*) const; virtual void*ClassInfo_New(ClassInfo_t*) const; virtual void*ClassInfo_New(ClassInfo_t*, int) const; virtual void*ClassInfo_New(ClassInfo_t*, void*) const; virtual void*ClassInfo_New(ClassInfo_t*, int, void*) const; virtual intClassInfo_Next(ClassInfo_t*) const; virtual Long_tClassInfo_Property(ClassInfo_t*) const; virtual intClassInfo_Size(ClassInfo_t*) const; virtual Long_tClassInfo_Tagnum(ClassInfo_t*) const; virtual const char*ClassInfo_Title(ClassInfo_t*) const; virtual const char*ClassInfo_TmpltName(ClassInfo_t*) const; virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearFileBusy(); virtual voidClearStack(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TEnum*CreateEnum(void* VD, TClass* cl) const; virtual voidCreateListOfBaseClasses(TClass* cl) const; virtual voidCreateListOfDataMembers(TClass* cl) const; virtual voidCreateListOfMethodArgs(TFunction* m) const; virtual voidCreateListOfMethods(TClass* cl) const; virtual TInterpreterValue*CreateTemporary(); virtual intDataMemberInfo_ArrayDim(DataMemberInfo_t*) const; virtual voidDataMemberInfo_Delete(DataMemberInfo_t*) const; virtual DataMemberInfo_t*DataMemberInfo_Factory(ClassInfo_t* = 0) const; virtual DataMemberInfo_t*DataMemberInfo_Factory(TInterpreter::DeclId_t declid, ClassInfo_t* clinfo) const; virtual DataMemberInfo_t*DataMemberInfo_FactoryCopy(DataMemberInfo_t*) const; virtual Bool_tDataMemberInfo_IsValid(DataMemberInfo_t*) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:7353,Clear,Clear,7353,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Clear'],['Clear']
Usability,"Box::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; static voidTEveShape::CheckAndFixBoxOrientationEv(TEveVector[8] box); static voidTEveShape::CheckAndFixBoxOrientationFv(Float_t[8][3] box); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveShape::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBox.html:2728,Clear,ClearStamps,2728,root/html602/TEveBox.html,https://root.cern,https://root.cern/root/html602/TEveBox.html,14,['Clear'],['ClearStamps']
Usability,"Branch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::TNtupleTNtuple(const TNtuple &)=delete; TNtuple::GetNvarvirtual Int_t GetNvar() constDefinition TNtuple.h:55; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::GetArgsFloat_t * GetArgs() constDefinition TNtuple.h:56; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Browsevoid Browse(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNtuple_8h_source.html:3155,simpl,simple,3155,doc/master/TNtuple_8h_source.html,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html,1,['simpl'],['simple']
Usability,"Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeSQL.html:2478,Clear,Clear,2478,root/html602/TTreeSQL.html,https://root.cern,https://root.cern/root/html602/TTreeSQL.html,2,['Clear'],['Clear']
Usability,"Brun comments extracted from the MINUIT documentation file. . Definition at line 3439 of file TMinuit.cxx. ◆ mnhes1(). void TMinuit::mnhes1 ; (; ). virtual . Calculate first derivatives (GRD) and uncertainties (DGRD) ; and appropriate step sizes GSTEP Called from MNHESS and MNGRAD ; Definition at line 4218 of file TMinuit.cxx. ◆ mnhess(). void TMinuit::mnhess ; (; ). virtual . Calculates the full second-derivative matrix of FCN. ; by taking finite differences. When calculating diagonal elements, it may iterate so that step size is nearly that which gives function change= UP/10. The first derivatives of course come as a free side effect, but with a smaller step size in order to obtain a known accuracy. ; Definition at line 3993 of file TMinuit.cxx. ◆ mnimpr(). void TMinuit::mnimpr ; (; ). virtual . Attempts to improve on a good local minimum. ; Attempts to improve on a good local minimum by finding a better one. The quadratic part of FCN is removed by MNCALF and this transformed function is minimised using the simplex method from several random starting points.; ref. – Goldstein and Price, Math.Comp. 25, 569 (1971) ; Definition at line 4295 of file TMinuit.cxx. ◆ mninex(). void TMinuit::mninex ; (; Double_t * ; pint). virtual . Transforms from internal coordinates (PINT) to external (U) ; The minimising routines which work in internal coordinates call this routine before calling FCN. ; Definition at line 4506 of file TMinuit.cxx. ◆ mninit(). void TMinuit::mninit ; (; Int_t ; i1, . Int_t ; i2, . Int_t ; i3 . ). virtual . Main initialization member function for MINUIT. ; It initializes some constants (including the logical I/O unit nos.), ; Definition at line 4526 of file TMinuit.cxx. ◆ mnlims(). void TMinuit::mnlims ; (; ). virtual . Interprets the SET LIM command, to reset the parameter limits. ; Called from MNSET ; Definition at line 4616 of file TMinuit.cxx. ◆ mnline(). void TMinuit::mnline ; (; Double_t * ; start, . Double_t ; fstart, . Double_t * ; step, . Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:54229,simpl,simplex,54229,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"Buffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofDrawListOfGraphs(); TProofDrawListOfGraphs(TProofDrawListOfGraphs&&); TProofDrawListOfGraphs(const TProofDrawListOfGraphs&); virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. static TSelector::EAbortTSelector::kAbortFile; static TSelector::EAbortTSelector::kAbortProcess; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TSelector::EAbortTSelector::kContinue; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawListOfGraphs.html:6016,Clear,ClearFormula,6016,root/html602/TProofDrawListOfGraphs.html,https://root.cern,https://root.cern/root/html602/TProofDrawListOfGraphs.html,2,['Clear'],['ClearFormula']
Usability,"Buffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofDrawPolyMarker3D(); TProofDrawPolyMarker3D(TProofDrawPolyMarker3D&&); TProofDrawPolyMarker3D(const TProofDrawPolyMarker3D&); virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. static TSelector::EAbortTSelector::kAbortFile; static TSelector::EAbortTSelector::kAbortProcess; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TSelector::EAbortTSelector::kContinue; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawPolyMarker3D.html:6009,Clear,ClearFormula,6009,root/html602/TProofDrawPolyMarker3D.html,https://root.cern,https://root.cern/root/html602/TProofDrawPolyMarker3D.html,2,['Clear'],['ClearFormula']
Usability,"Buffer(const char* buffer); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearLogView(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionLogView.html:1624,Clear,Clear,1624,root/html532/TSessionLogView.html,https://root.cern,https://root.cern/root/html532/TSessionLogView.html,4,['Clear'],['Clear']
Usability,"C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_th1.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:161677,simpl,simple,161677,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"C as more completed examples.; 5.3.3 Fitting Multiple Sub Ranges; The script for this example is $ROOTSYS/tutorials/fit/multifit.C. It shows how to use several Gaussian functions with different parameters on separate sub ranges of the same histogram. To use a Gaussian, or any other ROOT built in function, on a sub range you need to define a new TF1. Each is ‘derived’ from the canned function gaus. Fitting a histogram with several Gaussian functions. First, four TF1 objects are created - one for each sub-range:; g1 = new TF1(""m1"",""gaus"",85,95);; g2 = new TF1(""m2"",""gaus"",98,108);; g3 = new TF1(""m3"",""gaus"",110,121);; // The total is the sum of the three, each has 3 parameters; total = new TF1(""mstotal"",""gaus(0)+gaus(3)+gaus(6)"",85,125);; Next, we fill a histogram with bins defined in the array x.; // Create a histogram and set it's contents; h = new TH1F(""g1"",""Example of several fits in subranges"",; np,85,134);; h->SetMaximum(7);; for (int i=0; i<np; i++) {; h->SetBinContent(i+1,x[i]);; }; // Define the parameter array for the total function; Double_t par[9];; When fitting simple functions, such as a Gaussian, the initial values of the parameters are automatically computed by ROOT. In the more complicated case of the sum of 3 Gaussian functions, the initial values of parameters must be set. In this particular case, the initial values are taken from the result of the individual fits. The use of the “+” sign is explained below:; // Fit each function and add it to the list of functions; h->Fit(g1,""R"");; h->Fit(g2,""R+"");; h->Fit(g3,""R+"");. // Get the parameters from the fit; g1->GetParameters(&par[0]);; g2->GetParameters(&par[3]);; g3->GetParameters(&par[6]);. // Use the parameters on the sum; total->SetParameters(par);; h->Fit(total,""R+"");; 5.3.4 Adding Functions to the List; The example $ROOTSYS/tutorials/fit/multifit.C also illustrates how to fit several functions on the same histogram. By default a Fit command deletes the previously fitted function in the histogram obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:175770,simpl,simple,175770,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"C header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatistic.html:845,Clear,Clear,845,root/html534/TStatistic.html,https://root.cern,https://root.cern/root/html534/TStatistic.html,1,['Clear'],['Clear']
Usability,"C*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:21709,Undo,Undocked,21709,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,2,['Undo'],['Undocked']
Usability,"C++ member functions internally expect this pointer as first argument to have access to class members of the same instance). pthreads are made for simple C functions and do not know about Thread0 being a member function of a class. Thus, you have to pass this information by hand, if you want to access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1116503,simpl,simple,1116503,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". std::string GetTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethodArg.html:8283,learn,learn,8283,root/html534/TMethodArg.html,https://root.cern,https://root.cern/root/html534/TMethodArg.html,2,['learn'],['learn']
Usability,"CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  NTMVAGlob;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:86723,simpl,simple,86723,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['simpl'],['simple']
Usability,"Cache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:43654,learn,learning,43654,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"Cache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2251 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:43658,learn,learning,43658,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"CacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4143,clear,clearCacheOnServerRedirect,4143,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,4,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"Canvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient when executing a macro. By adding statements like:; canvas->WaitPrimitive();; You can monitor the progress of a running macro, stop it at convenient places with the possibility to interact with the canvas and resume the execution with a double click or a key press.; 9.3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more information, the class names are given and they may refer to the online developer documentation. This is especially true for functions and methods that set and get internal values of the objects described here. By default 2D graphical objects are created in User Coordinates with (0, 0) in the lower left corner.; 9.4.1 Lines, Arrows and Polylines; The simplest graphical object is a line. It is implemented in the TLine class. The line constructor is:; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); The arguments x1, y1, x2, y2 are the coordinates of the first and second point. It can be used:; root[] l = new TLine(0.2,0.2,0.8,0.3); root[] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:319047,simpl,simple,319047,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"CanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ; 743 TString opt = option;; 744 opt.ToLower();; 745 if (opt.Contains(""d"")) {; 746 // clear subpads, but do not delete pads in case the canvas; 747 // has been divided (note: option ""D"" is propagated so could cause; 748 // conflicts for primitives using option ""D"" for something else); 749 if (fPrimitives) {; 750 TIter next(fPrimitives);; 751 TObject *obj;; 752 while ((obj=next())) {; 753 obj->Clear(option);; 754 }; 755 }; 756 } else {; 757 //default, clear everything in the canvas. Subpads are deleted; 758 TPad::Clear(option); //Remove primitives from pad; 759 }; 760 ; 761 fSelected = nullptr;; 762 fClickSelected = nullptr;; 763 fSelectedPad = nullptr;; 764 fClickSelectedPad = nullptr;; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Emit pad Cleared signal.; 769 ; 770void TCanvas::Cleared(TVirtualPad *pad); 771{; 772 Emit(""Cleared(TVirtualPad*)"", (Longptr_t)pad);; 773}; 774 ; 775////////////////////////////////////////////////////////////////////////////////; 776/// Emit Closed signal.; 777 ; 778void TCanvas::Closed(); 779{; 780 Emit(""Closed()"");; 781}; 782 ; 783////////////////////////////////////////////////////////////////////////////////; 784/// Close canvas.; 785///; 786/// Delete window/pads ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:24302,clear,clear,24302,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,2,['clear'],['clear']
Usability,"Char_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveArrow.html:2088,Clear,ClearStamps,2088,root/html532/TEveArrow.html,https://root.cern,https://root.cern/root/html532/TEveArrow.html,12,['Clear'],['ClearStamps']
Usability,"Children ; (; Handle_t ; id, . TGListTreeItem * ; item, . Int_t ; x, . Int_t ; y, . Int_t ; xroot . ). protected . Draw children of item in list tree. ; Definition at line 1453 of file TGListTree.cxx. ◆ DrawItem(). void TGListTree::DrawItem ; (; Handle_t ; id, . TGListTreeItem * ; item, . Int_t ; x, . Int_t ; y, . Int_t * ; xroot, . UInt_t * ; retwidth, . UInt_t * ; retheight . ). protected . Draw list tree item. ; Definition at line 1482 of file TGListTree.cxx. ◆ DrawItemName(). void TGListTree::DrawItemName ; (; Handle_t ; id, . TGListTreeItem * ; item . ). protected . Draw name of list tree item. ; Definition at line 1630 of file TGListTree.cxx. ◆ DrawNode(). void TGListTree::DrawNode ; (; Handle_t ; id, . TGListTreeItem * ; item, . Int_t ; x, . Int_t ; y . ). protected . Draw node (little + in box). ; Definition at line 1671 of file TGListTree.cxx. ◆ DrawOutline(). void TGListTree::DrawOutline ; (; Handle_t ; id, . TGListTreeItem * ; item, . Pixel_t ; col = 0xbbbbbb, . Bool_t ; clear = kFALSE . ). virtual . Draw a outline of color 'col' around an item. ; Definition at line 1581 of file TGListTree.cxx. ◆ DrawRegion(). void TGListTree::DrawRegion ; (; Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Redraw list tree. ; Reimplemented from TGContainer.; Definition at line 1365 of file TGListTree.cxx. ◆ End(). void TGListTree::End ; (; Bool_t ; select = kFALSE). overridevirtual . Move content to the bottom. ; Reimplemented from TGContainer.; Definition at line 1199 of file TGListTree.cxx. ◆ FindChildByData(). TGListTreeItem * TGListTree::FindChildByData ; (; TGListTreeItem * ; item, . void * ; userData . ). Find child of item by userData. ; Definition at line 2297 of file TGListTree.cxx. ◆ FindChildByName(). TGListTreeItem * TGListTree::FindChildByName ; (; TGListTreeItem * ; item, . const char * ; name . ). Find child of item by name. ; Definition at line 2274 of file TGListTree.cxx. ◆ FindItem() [1/2]. void * TGListTree::FindItem ; (; const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:59004,clear,clear,59004,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['clear'],['clear']
Usability,"ClangFormat, astyle can be useful. Starting from a code like this:; int aap ( int inp ) { ; if ( inp > 0 ) { ; return 0 ; ; int a = 1 ; ; if ( inp == 0 && a == 1 ) { ; printf ( >""this is a very long line that is not yet ending"" , a, inp, a, inp, a , inp ) ; ; a + = inp ; return a ; ; } ; } else { ; return 1 ; ; } ; if ( inp == 0 ) ; return - 1 ; ; return 1 ; ; }; You will find back like this:; int aap (int inp) {; if (inp > 0) { ; return 0 ; ; int a = 1 ; ; if (inp == 0 && a == 1) { ; printf (""this is a very long line that is not yet ending"" , a, inp, a, inp, a, inp ) ; ; a + = inp ; return a ; ; } ; } ; else { ; return 1 ; ; } ; if (inp == 0) ; return - 1 ; ; return 1 ; ; }; Get at least version 2.0 and use the following ~/.astylerc:; # ROOT code formatting style; # Note that the brackets=linux option is not available starting from astyle 2.04; #brackets=linux; style=stroustrup; mode=c; align-pointer=name; indent=spaces=3; indent-switches; indent-cases; indent-namespaces; max-instatement-indent=40; indent-preprocessor; convert-tabs; pad-header; pad-oper; unpad-paren; Where to go from here; For the rest read the Taligent Guide and use common sense. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:13140,guid,guidelines,13140,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['guid'],['guidelines']
Usability,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLWidget* CreateDummy(); Static constructor for creating widget with default pixel format. TGLWidget* Create(const TGWindow* parent, Bool_t selectInput, Bool_t shareDefault, const TGLPaintDevice* shareDevice, UInt_t width, UInt_t height); Static constructor for creating widget with default pixel format. TGLWidget* Create(const TGLFormat& format, const TGWindow* parent, Bool_t selectInput, Bool_t shareDefault, const TGLPaintDevice* shareDevice, UInt_t width, UInt_t height); Static constructor for creating widget with given pixel format. TGLWidget(Window_t glw, const TGWindow* parent, Bool_t selectInput); Creates widget with default pixel format. ~TGLWidget(); Destructor. Deletes window ???? and XVisualInfo. void InitGL(); Call glEnable(... in overrider of InitGL. void PaintGL(); Do actual drawing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLWidget.html:20188,Clear,ClearCurrent,20188,root/html532/TGLWidget.html,https://root.cern,https://root.cern/root/html532/TGLWidget.html,8,['Clear'],"['Clear', 'ClearCurrent']"
Usability,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLeafD.html:9733,simpl,simple,9733,root/html604/TLeafD.html,https://root.cern,https://root.cern/root/html604/TLeafD.html,2,['simpl'],['simple']
Usability,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 15:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLeafD.html:9733,simpl,simple,9733,root/html602/TLeafD.html,https://root.cern,https://root.cern/root/html602/TLeafD.html,2,['simpl'],['simple']
Usability,"Class to manage histogram axis.Definition TAxis.h:31; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTimeFormatvoid SetTimeFormat(const char *tformat)Change the format used for time plotting.Definition TGaxis.cxx:2969; TGaxis::SetLabelFontvoid SetLabelFont(Int_t labelfont)Definition TGaxis.h:105; TGaxis::SetLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; TGaxis::SetTimeOffsetvoid SetTimeOffset(Double_t toffset, Option_t *option=""local"")Change the time offset. If option = ""gmt"", set display mode to GMT.Definition TGaxis.cxx:2993; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStringBasic string class.Definition TString.h:139; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; ttauto * ttDefinition textangle.C:16; AuthorsPhilippe Gras, Bertrand Bellenot, Olivier Couet ; Definition in file timeonaxis3.C. tutorialsgraphstimeonaxis3.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis3_8C.html:5796,simpl,simple,5796,doc/master/timeonaxis3_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html,1,['simpl'],['simple']
Usability,"Class(). static TClass * TClonesArray::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TClonesArray::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TClonesArray::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 83 of file TClonesArray.h. ◆ Clear(). void TClonesArray::Clear ; (; Option_t * ; option = """"). overridevirtual . Clear the clones array. ; Only use this routine when your objects don't allocate memory since it will not call the object dtors. However, if the class in the TClonesArray implements the function Clear(Option_t *option) and if option = ""C"" the function Clear() is called for all objects in the array. In the function Clear(), one can delete objects or dynamic arrays allocated in the class. This procedure is much faster than calling TClonesArray::Delete(). When the option starts with ""C+"", eg ""C+xyz"" the objects in the array are in turn cleared with the option ""xyz"" ; Implements TCollection.; Definition at line 420 of file TClonesArray.cxx. ◆ Compress(). void TClonesArray::Compress ; (; ). overridevirtual . Remove empty slots from array. ; Reimplemented from TObjArray.; Definition at line 332 of file TClonesArray.cxx. ◆ ConstructedAt() [1/2]. TObject * TClonesArray::ConstructedAt ; (; Int_t ; idx). Get an object at index 'idx' that is guaranteed to have been constructed. ; It might be either a freshly allocated object or one that had already been allocated (and assumingly used). In the later case, it is the callers responsibility to insure that the object is returned to a known state, usually by calling the Clear method on the TClonesArray.; Tests to see if the destructor has been called on the object. If so, or if the object has never been constructed the class constructor is called using New(). If not, return a pointer to the correct memory location. This explicitly to deal with TObject classes that al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:33676,clear,cleared,33676,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['clear'],['cleared']
Usability,"Class*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLBoxPainter(const TGLBoxPainter&); virtual voidDeInitGL() const; voidDrawCloud() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; Bool_tHasSections() const; virtual voidInitGL() const; TGLBoxPainter&operator=(const TGLBoxPainter&); voidSetPlotColor() const. Data Members; public:. enum EBoxType { kBox; kBox1; };; enum TGLPlotPainter::ESelectionBase { kHighColorSelectionBase; kTrueColorSelectionBase; };; enum TGLPlotPainter::ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLBoxPainter.html:1714,Clear,ClearBuffers,1714,root/html534/TGLBoxPainter.html,https://root.cern,https://root.cern/root/html534/TGLBoxPainter.html,1,['Clear'],['ClearBuffers']
Usability,"Class*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLLegoPainter(const TGLLegoPainter&); Bool_tClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawLegoCartesian() const; voidDrawLegoCylindrical() const; voidDrawLegoPolar() const; voidDrawLegoSpherical() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; Bool_tInitGeometryCartesian(); Bool_tInitGeometryCylindrical(); Bool_tInitGeometryPolar(); Bool_tInitGeometrySpherical(); virtual voidInitGL() const; TGLLegoPainter&operator=(const TGLLegoPainter&); Bool_tPreparePalette() const; voidSetLegoColor() const. Data Members; public:. enum ELegoType { kColorSimple; kColorLevel; kCylindricBars; };; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLegoPainter.html:1660,Clear,ClearBuffers,1660,root/html534/TGLLegoPainter.html,https://root.cern,https://root.cern/root/html534/TGLLegoPainter.html,1,['Clear'],['ClearBuffers']
Usability,"Class*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLVoxelPainter(const TGLVoxelPainter&); virtual voidDeInitGL() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFindVoxelColor(Double_t binContent, Float_t* rgba) const; Bool_tHasSections() const; virtual voidInitGL() const; TGLVoxelPainter&operator=(const TGLVoxelPainter&); voidPreparePalette() const; voidSetVoxelColor(const Float_t* rgba) const. Data Members; public:. enum TGLPlotPainter::ESelectionBase { kHighColorSelectionBase; kTrueColorSelectionBase; };; enum TGLPlotPainter::ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLVoxelPainter.html:1643,Clear,ClearBuffers,1643,root/html534/TGLVoxelPainter.html,https://root.cern,https://root.cern/root/html534/TGLVoxelPainter.html,1,['Clear'],['ClearBuffers']
Usability,"Class, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. TParticlePDG* AddAntiParticle(const char* Name, Int_t PdgCode); assuming particle has already been defined. TParticlePDG * GetParticle(const char* name) const. Get a pointer to the particle object according to the name given. TParticlePDG * GetParticle(Int_t pdgCode) const. Get a pointer to the particle object according to the MC code number. void Print(Option_t* opt = """") const; Print contents of PDG database. Int_t ConvertGeant3ToPdg(Int_t Geant3Number); Converts Geant3 particle codes to PDG convention. (Geant4 uses; PDG convention already); Source: BaBar User Guide, Neil I. Geddes,. /*; see Conversion table; */. with some fixes by PB, marked with (PB) below. Checked against; PDG listings from 2000. Paul Balm, Nov 19, 2001. Int_t ConvertPdgToGeant3(Int_t pdgNumber); Converts pdg code to geant3 id. Int_t ConvertIsajetToPdg(Int_t isaNumber). Converts the ISAJET Particle number into the PDG MC number. void ReadPDGTable(const char* filename = """"); read list of particles from a file; if the particle list does not exist, it is created, otherwise; particles are added to the existing list; See $ROOTSYS/etc/pdg_table.txt to see the file format. void Browse(TBrowser* b); browse data base. Int_t WritePDGTable(const char* filename); write contents of the particle DB into a file. TDatabasePDG(const TDatabasePDG& db); { }. TDatabasePDG& operator=(const TDatabasePDG& db). TParticleClassPDG* GetParticleClass(const char* name). const THashList * ParticleList() const; { return fParticleList; }. Bool_t IsFolder() const; { return kTRUE; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDatabasePDG.html:8865,Guid,Guide,8865,root/html532/TDatabasePDG.html,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html,1,['Guid'],['Guide']
Usability,"Class<std::array<T, N>>();; 410 Error(""Branch"",""std::array of objects not yet supported as top level branch object (the class is %s)"",; 411 arrCl ? arrCl->GetName() : cl->GetName());; 412 return nullptr;; 413 }; 414 return BranchImpArr(name, TDataType::GetType(typeid(T)), N, obj, bufsize, splitlevel);; 415 }; 416 virtual TBranch *Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 417 virtual TBranch *BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1);; 418 virtual TBranch *BranchRef();; 419 void Browse(TBrowser*) override;; 420 virtual Int_t BuildIndex(const char *majorname, const char *minorname = ""0"");; 421 TStreamerInfo *BuildStreamerInfo(TClass* cl, void *pointer = nullptr, bool canOptimize = true);; 422 virtual TFile *ChangeFile(TFile* file);; 423 virtual TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """");; 424 virtual void CopyAddresses(TTree*,bool undo = false);; 425 virtual Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t *option = """", bool needCopyAddresses = false);; 426 virtual TTree *CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0);; 427 virtual TBasket *CreateBasket(TBranch*);; 428 virtual void DirectoryAutoAdd(TDirectory *);; 429 Int_t Debug() const { return fDebug; }; 430 void Delete(Option_t* option = """") override; // *MENU*; 431 void Draw(Option_t* opt) override { Draw(opt, """", """", kMaxEntries, 0); }; 432 virtual Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0);; 433 virtual Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0); // *MENU*; 434 virtual void DropBaskets();; 435 virtual void DropBuffers(Int_t nbytes);; 436 bool EnableCache();; 437 virtual Int_t Fill();; 438 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:21963,undo,undo,21963,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['undo'],['undo']
Usability,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:38516,learn,learning,38516,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"CmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:48482,clear,clearing,48482,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['clear'],['clearing']
Usability,"CollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGenCollectionProxy.html:7461,simpl,simple,7461,root/html530/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html,3,['simpl'],['simple']
Usability,"CollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseAction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:7441,simpl,simple,7441,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,1,['simpl'],['simple']
Usability,"ColorGradient: public TColor. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TColorGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColorGradient.html:1123,Clear,Clear,1123,root/html602/TColorGradient.html,https://root.cern,https://root.cern/root/html602/TColorGradient.html,2,['Clear'],['Clear']
Usability,"Color_t lcolor); Set the line color. void SetLineStyle(Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.; Option can contain : v - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaugh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolume.html:31378,CLEAR,CLEAR,31378,root/html532/TGeoVolume.html,https://root.cern,https://root.cern/root/html532/TGeoVolume.html,4,['CLEAR'],['CLEAR']
Usability,"Color_t)""; ""SetFillColor(Color_t)"");; TQCommandThe Command design pattern is based on the idea, that all editing in an application is done by creati...Definition TQCommand.h:27. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2180,undo,undo,2180,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed bac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2976,undo,undo,2976,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"Command encapsulates the information for undo/redo a single action.; TQConnection Internal class used in the object communication mechanism; TQMimeTypes Pool of mime type objects; TQObjSender Used to ""delegate"" TQObject functionality; TQObject Base class for object communication mechanism; TQRootApplication creates Qt environment interface with the ROOT windowing system; TQRootCanvas interface to Qt eventloop to handle user input; TQRootDialog prompt for the arguments of an object's member function; TQRootGuiFactory Qt ROOT Gui factory; TQUndoManager recorder of operations for undo and redo; TQpDataBase Qp Base Data class; TQpDataDens Qp Data class for Dens formulation; TQpDataSparse Qp Data class for Sparse formulation; TQpLinSolverBase Qp linear solver base class; TQpLinSolverDens Qp linear solver class for Dens formulation; TQpLinSolverSparse Qp linear solver class for Sparse formulation; TQpProbBase Qp problem formulation base class; TQpProbDens Qp dens problem formulation class; TQpProbSparse Qp sparse problem formulation class; TQpResidual Qp Residual class; TQpSolverBase Qp Solver class; TQpVar Qp Variables class; TQtApplication Instantiate the Qt system within ROOT environment; TQtBrush create QBrush object based on the ROOT ""fill"" attributes ; TQtClientFilter Map Qt and ROOT event; TQtClientWidget QFrame implementation backing ROOT TGWindow objects; TQtMarker Convert ROOT TMarker objects on to QPointArray; TQtPadFont < Create Qt QFont object based on ROOT TAttText attributes; TQtRootSlot ; TQtTimer QTimer to awake the ROOT event loop from Qt event loop; TQtWidget QWidget to back ROOT TCanvas (Can be used with Qt designer); TQuaternion a quaternion class; TQueryDescription Query description; TQueryResult Class describing a query; TQueryResultManager PROOF query result manager; TROOT Top level (or root) structure for all classes; TRWLock Reader/writer lock; TRadialGradient Radial gradient fill.; TRandom Simple Random number generator (periodicity = 10**9); TRa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:125411,undo,undo,125411,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['undo'],['undo']
Usability,"CompOpt == 0);; 3001 ; 3002 ; 3003 Int_t ndata = fElements->GetEntriesFast();; 3004 ; 3005 ; 3006 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 3007 else fReadObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3017 ; 3018 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 3019 else fWriteMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3020 ; 3021 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 3022 else fReadMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table); 3033 if (fClass->GetState() == TClass::kEmulated && fNVirtualInfoLoc!=0) {; 3034 fSize = sizeof(TStreamerInfo*);; 3035 }; 3036 fComp = new TCompInfo[1];; 3037 fCompFull = new TCompInfo*[1];; 3038 fCompOpt = new TCompInfo*[1];; 3039 fCompOpt[0] = fCompFull[0] = &(fComp[0]);; 3040 SetIsCompiled();; 3041 return;; 3042 }; 3043 ; 3044 // At most half of the elements can be used to hold optimized versions.; 3045 // We use the bottom to hold the optimized-into elements and the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:132386,clear,clear,132386,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['clear'],['clear']
Usability,"CompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContainer::CurrentChanged(Int_t x, Int_t y)SIGNAL ; const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTVLVContainer.html:1645,Clear,ClearViewPort,1645,root/html532/TTVLVContainer.html,https://root.cern,https://root.cern/root/html532/TTVLVContainer.html,4,['Clear'],['ClearViewPort']
Usability,"Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit parameters (initial values, bounds, etc..), ROOT::Fit::FitResult for storing the result of the fit.; Data classes containing the data sets used in the fitting. These classes are theROOT::Fit::BinDatafor describing bin data sets, thus data points containing both coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:188079,Simpl,Simplex,188079,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simplex']
Usability,"ConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:9596,simpl,simple,9596,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['simpl'],['simple']
Usability,"Container& layers, PassThrough& settingsAndBatch,; 1220 ItWeight itWeightBegin, ItWeight itWeightEnd,; 1221 ItGradient itGradientBegin, ItGradient itGradientEnd,; 1222 size_t trainFromLayer,; 1223 OutContainer& outputContainer, bool fetchOutput) const;; 1224 ; 1225 ; 1226 ; 1227 double E ();; 1228 void dE ();; 1229 ; 1230 ; 1231 /*! \brief computes the error of the DNN; 1232 *; 1233 *; 1234 */; 1235 template <typename Container, typename ItWeight>; 1236 double errorFunction (LayerData& layerData,; 1237 Container truth,; 1238 ItWeight itWeight,; 1239 ItWeight itWeightEnd,; 1240 double patternWeight,; 1241 double factorWeightDecay,; 1242 EnumRegularization eRegularization) const;; 1243 ; 1244 ; 1245 const std::vector<Layer>& layers () const { return m_layers; } ///< returns the layers (structure); 1246 std::vector<Layer>& layers () { return m_layers; } ///< returns the layers (structure); 1247 ; 1248 void removeLayer () { m_layers.pop_back (); } ///< remove one layer; 1249 ; 1250 ; 1251 void clear () ///< clear one layer; 1252 {; 1253 m_layers.clear ();; 1254 m_eErrorFunction = ModeErrorFunction::SUMOFSQUARES;; 1255 }; 1256 ; 1257 ; 1258 template <typename OutIterator>; 1259 void initializeWeights (WeightInitializationStrategy eInitStrategy,; 1260 OutIterator itWeight); ///< initialize the weights with the given strategy; 1261 ; 1262 protected:; 1263 ; 1264 void fillDropContainer (DropContainer& dropContainer, double dropFraction, size_t numNodes) const; ///< prepare the drop-out-container (select the nodes which are to be dropped out); 1265 ; 1266 ; 1267 private:; 1268 ; 1269 ModeErrorFunction m_eErrorFunction; ///< denotes the error function; 1270 size_t m_sizeInput; ///< input size of this DNN; 1271 size_t m_sizeOutput; ///< output size of this DNN; 1272 std::vector<Layer> m_layers; ///< layer-structure-data; 1273 ; 1274 protected:; 1275 // variables for JsMVA (interactive training in jupyter notebook); 1276 IPythonInteractive *fInteractive = nullptr;; 1277 bool * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:45920,clear,clear,45920,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['clear'],['clear']
Usability,"ContextIdentity*fIdentity; TGLContextPrivate*fPimpl; Bool_tfValid; static Bool_tfgGlewInitDone. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContext(TGLWidget* glWidget, Bool_t shareDefault = kTRUE, const TGLContext* shareList = 0); TGLContext ctor ""from"" TGLWidget.; Is shareDefault is true, the shareList is set from default; context-identity. Otherwise the given shareList is used (can be; null).; Makes thread switching. void GlewInit(); Initialize GLEW - static private function.; Called immediately after creation of the first GL context. void SetContext(TGLWidget* widget, const TGLContext* shareList); WIN32 gl-context creation. Defined as a member-function (this code removed from ctor); to make WIN32/X11 separation cleaner.; This function is public only for calls via gROOT and called from ctor. Bool_t MakeCurrent(); If context is valid (TGLPaintDevice, for which context was created still exists),; make it current. Bool_t ClearCurrent(); Reset current context. void SwapBuffers(); If context is valid (TGLPaintDevice, for which context was created still exists),; swap buffers (in case of P-buffer call glFinish()). void Release(); Make the context invalid and (do thread switch, if needed); free resources. ~TGLContext(); TGLContext dtor. If it's called before TGLPaintDevice's dtor; (context is valid) resource will be freed and context; un-registered. TGLContextIdentity * GetIdentity() const; We can have several shared contexts,; and gl-scene wants to know, if some context; (defined by its identity) can be used. TGLContext * GetCurrent(); Ask TGLContextPrivate to lookup context in its internal map. TGLContext(TGLWidget* glWidget, Bool_t shareDefault = kTRUE, const TGLContext* shareList = 0); TGLContext(TGLPBuffer *glPbuf, const TGLContext *shareList = 0);. Bool_t IsValid() const; { return fValid; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLContext.html:2152,Clear,ClearCurrent,2152,root/html532/TGLContext.html,https://root.cern,https://root.cern/root/html532/TGLContext.html,4,['Clear'],['ClearCurrent']
Usability,Context_tkSYS_UserName; static TTabCom::EContext_tkUNKNOWN_CONTEXT. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:7829,Clear,ClearGlobalFunctions,7829,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['Clear'],['ClearGlobalFunctions']
Usability,"CoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;; 239 fpTmpBinEdgeVector= nullptr;; 240 }; 241 ; 242 if ( fpTmpCoordErrorVector ); 243 {; 244 delete[] fpTmpCoordErrorVector;; 245 fpTmpCoordErrorVector = nullptr;; 246 }; 247 ; 248 fDataPtr = nullptr;; 249 fDataErrorPtr= fDataErrorHighPtr= fDataErrorLowPtr= nullptr;; 250 ; 251 fErrorType = rhs.fErrorType;; 252 fRefVolume = rhs.fRefVolume;; 253 fBinEdge = rhs.fBinEdge;; 254 ; 255 if ( fWrapped ); 256 {; 257 fData.clear();; 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:7105,clear,clear,7105,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X axis of the master frame with angle expressed in degrees. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoRotation.html:16426,Clear,Clear,16426,root/html532/TGeoRotation.html,https://root.cern,https://root.cern/root/html532/TGeoRotation.html,4,['Clear'],['Clear']
Usability,"Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send progress and feedback to client. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects and progress messages. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if reque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:20365,feedback,feedback,20365,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"Ctub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCtub.html:1931,Clear,ClearThreadData,1931,root/html532/TGeoCtub.html,https://root.cern,https://root.cern/root/html532/TGeoCtub.html,1,['Clear'],['ClearThreadData']
Usability,"D because the concept; of a cumulative distribution is much trickier to define; make sure you; understand the order of summation before you use this method with; histograms of dimension >= 2. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibilit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:62030,simpl,simple,62030,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['simpl'],['simple']
Usability,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:2616,simpl,simply,2616,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['simpl'],['simply']
Usability,"D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1005908,simpl,simple,1005908,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"DInt_t fCanvasID! Canvas identifierDefinition TCanvas.h:48; TCanvas::SetGrayscalevoid SetGrayscale(Bool_t set=kTRUE)Set whether this canvas should be painted in grayscale, and re-paint it if necessary.Definition TCanvas.cxx:2576; TCanvas::SetTitlevoid SetTitle(const char *title="""") overrideSet canvas title.Definition TCanvas.cxx:2155; TCanvas::fChUInt_t fChHeight of the canvas along Y (pixels)Definition TCanvas.h:44; TCanvas::fContextMenuTContextMenu * fContextMenu! Context menu pointerDefinition TCanvas.h:58; TCanvas::fCattTAttCanvas fCattCanvas attributes.Definition TCanvas.h:31; TCanvas::SetNamevoid SetName(const char *name="""") overrideSet canvas name.Definition TCanvas.cxx:2047; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::fRetainedBool_t fRetainedRetain structure flag.Definition TCanvas.h:61; TCanvas::DisconnectWidgetvoid DisconnectWidget()Used by friend class TCanvasImp.Definition TCanvas.cxx:2558; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::lsvoid ls(Option_t *option="""") const overrideList all pads.Definition TCanvas.cxx:1504; TCanvas::RaiseWindowvoid RaiseWindow()Raise canvas window.Definition TCanvas.cxx:1744; TCanvas::Buildvoid Build()Build a canvas. Called by all constructors.Definition TCanvas.cxx:587; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TCanvas::fWindowTopYInt_t fWindowTopYTop Y position of window (in pixels)Definition TCanvas.h:40; TCanvas::Paintvoid Paint(Option_t *option="""") overridePaint canvas.Definition TCanvas.cxx:1543; TCanvas::kResizeOpaque@ kResizeOpaqueDefinition TCanvas.h:95; TCanvas::kShowToolTips@ kShowToolTipsDefinition TCanvas.h:97; TCanvas::kShowToolBar@ kShowToolBarDefinition TCanvas.h:92; TCanvas::kMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:111211,feedback,feedback,111211,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['feedback'],['feedback']
Usability,"Data.h:56; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::Addvoid Add(double x)add one dim data with only coordinate and valuesDefinition FitData.h:254; ROOT::Fit::FitData::UnWrapvoid UnWrap()Definition FitData.h:336; ROOT::Fit::FitData::Appendvoid Append(unsigned int newPoints, unsigned int dim=1)Definition FitData.cxx:251; ROOT::Fit::FitData::fMaxPointsunsigned int fMaxPointsDefinition FitData.h:384; ROOT::Fit::FitData::VectorPaddingstatic constexpr unsigned VectorPadding(const unsigned)If VecCore is not defined, there is no vectorization available and the SIMD vector size will always b...Definition FitData.h:372; ROOT::Fit::FitData::fWrappedbool fWrappedDefinition FitData.h:376; ROOT::Fit::FitData::fDimunsigned int fDimDefinition FitData.h:386; ROOT::Fit::FitData::operator=FitData & operator=(const FitData &rhs)Definition FitData.cxx:218; ROOT::Fit::FitData::fNPointsunsigned int fNPointsDefinition FitData.h:385; ROOT::Fit::FitData::Coordsconst double * Coords(unsigned int ipoint) constreturn a pointer to the coordinates data for the given fit pointDefinition FitData.h:236; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ValueDefinition functioncalls.h:15. mathmathcoresrcBinData.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:32383,simpl,simple,32383,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['simpl'],['simple']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:4277,clear,clearValueAndShapeDirty,4277,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:4232,clear,clearValueAndShapeDirty,4232,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:4304,clear,clearValueAndShapeDirty,4304,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,30,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:4213,clear,clearValueAndShapeDirty,4213,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:4168,clear,clearValueAndShapeDirty,4168,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsHiddenReal.html:3672,clear,clearValueAndShapeDirty,3672,root/html532/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html532/RooAbsHiddenReal.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:4240,clear,clearValueAndShapeDirty,4240,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStepFunction.html:3938,clear,clearValueAndShapeDirty,3938,root/html532/RooStepFunction.html,https://root.cern,https://root.cern/root/html532/RooStepFunction.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:4097,clear,clearValueAndShapeDirty,4097,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:4886,clear,clearValueAndShapeDirty,4886,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, RooFit::MPSplit, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:4492,clear,clearValueAndShapeDirty,4492,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:5418,clear,clearValueAndShapeDirty,5418,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t = kFALSE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:4259,clear,clearValueAndShapeDirty,4259,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLink",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:4713,clear,clearValueAndShapeDirty,4713,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:4333,clear,clearValueAndShapeDirty,4333,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:5211,clear,clearValueAndShapeDirty,5211,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:4076,clear,clearValueAndShapeDirty,4076,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgListcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:3597,clear,clearValueAndShapeDirty,3597,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgSetcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:3543,clear,clearValueAndShapeDirty,3543,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:3570,clear,clearValueAndShapeDirty,3570,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,72,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:3690,clear,clearValueAndShapeDirty,3690,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,354,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:3619,clear,clearValueAndShapeDirty,3619,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,13,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:3959,clear,clearValueAndShapeDirty,3959,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; voidcopyCacheFast(const RooRealVar& other, Bool_t setValDirty = kTRUE); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:3895,clear,clearValueAndShapeDirty,3895,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:4551,clear,clearValueAndShapeDirty,4551,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:4447,clear,clearValueAndShapeDirty,4447,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"DataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddElement(const char* path, TTable::EColumnType type); voidTDataSet::AddMain(TDataSet* set); voidAddResponse(const char* chit); voidAddVolumePath(const char* path); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*TGenericTable::GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); virtual voidTGenericTable::SetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); voidTGenericTable::SetGenericType(); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char*const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3); static const char*TTable::TableDictionary(const char* className, const char* structName, TTableDescriptor*& ColDescriptors). Data Members; public:. static const char*TTable::fgTypeName[13]; static TDataSet::EDataSetPassTDataSet::kAll; static TDataSet::ESetBitsTDataSet::kArray; static TObject::(anonymous)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TResponseTable.html:11972,Clear,Clear,11972,root/html602/TResponseTable.html,https://root.cern,https://root.cern/root/html602/TResponseTable.html,2,['Clear'],['Clear']
Usability,"Def(name, id)Definition Rtypes.h:342; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TMatrixDfwd.h; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TMVA::BinarySearchTreeA simple Binary search tree including a volume search method.Definition BinarySearchTree.h:65; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::IFitterTargetInterface for a fitter 'target'.Definition IFitterTarget.h:44; TMVA::IMethodInterface for all concrete MVA method implementations.Definition IMethod.h:53; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodBase::MethodCutsfriend class MethodCutsDefinition MethodBase.h:603; TMVA::MethodBase::ReadWeightsFromStreamvirtual void ReadWeightsFromStream(std::istream &)=0; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::fRandomTRandom * fRandomrandom generator for MC optimisation methodDefinition MethodCuts.h:194; TMVA::MethodCuts::fEffRefDouble_t fEffRefreference efficiencyDefinition MethodCuts.h:192; TMVA::MethodCuts::fFitMethodSTString fFitMethodSc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:10999,simpl,simple,10999,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['simpl'],['simple']
Usability,"Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::SetWidthvoid SetWidth(int width)Set canvas width.Definition RCanvas.hxx:105; ROOT::Experimental::RCanvas::GetCanvasconst RCanvas * GetCanvas() const overrideAccess to the top-most canvas, if any (const version).Definition RCanvas.hxx:92; ROOT::Experimental::RCanvas::RCanvasRCanvas()Create a temporary RCanvas; for long-lived ones please use Create().Definition RCanvas.hxx:88; ROOT::Experimental::RCanvas::Modifiedvoid Modified(std::shared_ptr< RDrawable > drawable)Set newest version to specified drawable.Definition RCanvas.hxx:152; ROOT::Experimental::RCanvas::Modifiedvoid Modified()Definition RCanvas.hxx:149; ROOT::Experimental::RCanvas::GetWidthint GetWidth() constGet canvas width.Definition RCanvas.hxx:111; ROOT::Experimental::RCanvas::AddPanelbool AddPanel(std::shared_ptr< PANEL > &panel)Insert panel into the canvas, canvas should be shown at this moment.Definition RCanvas.hxx:139; ROOT::Experimental::RCanvas::ClearUpdatedvoid ClearUpdated()clear IsUpdated() flagDefinition RCanvas.hxx:169; ROOT::Experimental::RCanvas::~RCanvas~RCanvas() override=default; ROOT::Experimental::RCanvas::Hidevoid Hide()Hide all canvas displays.Definition RCanvas.cxx:171; ROOT::Experimental::RChangeAttrRequestDefinition RCanvas.hxx:24; ROOT::Experimental::RChangeAttrRequest::valuesstd::vector< std::unique_ptr< RAttrMap::Value_t > > valuesarray of valuesDefinition RCanvas.hxx:27; ROOT::Experimental::RChangeAttrRequest::namesstd::vector< std::string > namesarray of attribute namesDefinition RCanvas.hxx:26; ROOT::Experimental::RChangeAttrRequest::idsstd::vector< std::string > idsarray of idsDefinition RCanvas.hxx:25; ROOT::Experimental::RChangeAttrRequest::~RChangeAttrRequest~RChangeAttrRequest() override=default; ROOT::Experimental::RChangeAttrRequest::NeedCanvasUpdatebool NeedCanvasUpdate() const overrideDefinition RCanvas.hxx:36; ROOT::Experimental::RChangeAttrRequest::RChangeAttrRequestRChangeAttrRequest()=default; ROOT::Experime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:13522,clear,clear,13522,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,1,['clear'],['clear']
Usability,"Definition at line 682 of file TCanvas.cxx. ◆ Build(). void TCanvas::Build ; (; ). private . Build a canvas. Called by all constructors. ; Definition at line 584 of file TCanvas.cxx. ◆ cd(). TVirtualPad * TCanvas::cd ; (; Int_t ; subpadnumber = 0). overridevirtual . Set current canvas & pad. ; Returns the new current pad, or 0 in case of failure. See TPad::cd() for an explanation of the parameter. ; Implements TVirtualPad.; Definition at line 716 of file TCanvas.cxx. ◆ Class(). static TClass * TCanvas::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCanvas::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCanvas::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 238 of file TCanvas.h. ◆ Clear(). void TCanvas::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all primitives from the canvas. ; If option ""D"" is specified, direct sub-pads are cleared but not deleted. This option is not recursive, i.e. pads in direct sub-pads are deleted. ; Implements TVirtualPad.; Definition at line 734 of file TCanvas.cxx. ◆ Cleared(). void TCanvas::Cleared ; (; TVirtualPad * ; pad). virtual . Emit pad Cleared signal. ; Definition at line 767 of file TCanvas.cxx. ◆ ClearPadSave(). void TCanvas::ClearPadSave ; (; ). inline . Definition at line 140 of file TCanvas.h. ◆ Close(). void TCanvas::Close ; (; Option_t * ; option = """"). overridevirtual . Close canvas. ; Delete window/pads data structure ; Implements TVirtualPad.; Definition at line 785 of file TCanvas.cxx. ◆ Closed(). void TCanvas::Closed ; (; ). overridevirtual . Emit Closed signal. ; Reimplemented from TPad.; Definition at line 775 of file TCanvas.cxx. ◆ Constructor() [1/4]. void TCanvas::Constructor ; (; ). Canvas default constructor. ; Definition at line 188 of file TCanvas.cxx. ◆ Constructor() [2/4]. void TCanvas::Constructor ; (; const char * ; name, . const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:66342,clear,cleared,66342,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['clear'],['cleared']
Usability,"Definition at line 685 of file TCanvas.cxx. ◆ Build(). void TCanvas::Build ; (; ). private . Build a canvas. Called by all constructors. ; Definition at line 587 of file TCanvas.cxx. ◆ cd(). TVirtualPad * TCanvas::cd ; (; Int_t ; subpadnumber = 0). overridevirtual . Set current canvas & pad. ; Returns the new current pad, or 0 in case of failure. See TPad::cd() for an explanation of the parameter. ; Implements TVirtualPad.; Definition at line 719 of file TCanvas.cxx. ◆ Class(). static TClass * TCanvas::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCanvas::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCanvas::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 238 of file TCanvas.h. ◆ Clear(). void TCanvas::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all primitives from the canvas. ; If option ""D"" is specified, direct sub-pads are cleared but not deleted. This option is not recursive, i.e. pads in direct sub-pads are deleted. ; Implements TVirtualPad.; Definition at line 737 of file TCanvas.cxx. ◆ Cleared(). void TCanvas::Cleared ; (; TVirtualPad * ; pad). virtual . Emit pad Cleared signal. ; Definition at line 770 of file TCanvas.cxx. ◆ ClearPadSave(). void TCanvas::ClearPadSave ; (; ). inline . Definition at line 140 of file TCanvas.h. ◆ Close(). void TCanvas::Close ; (; Option_t * ; option = """"). overridevirtual . Close canvas. ; Delete window/pads data structure ; Implements TVirtualPad.; Definition at line 788 of file TCanvas.cxx. ◆ Closed(). void TCanvas::Closed ; (; ). overridevirtual . Emit Closed signal. ; Reimplemented from TPad.; Definition at line 778 of file TCanvas.cxx. ◆ Constructor() [1/4]. void TCanvas::Constructor ; (; ). Canvas default constructor. ; Definition at line 191 of file TCanvas.cxx. ◆ Constructor() [2/4]. void TCanvas::Constructor ; (; const char * ; name, . const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:66718,clear,cleared,66718,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['clear'],['cleared']
Usability,Definition at line 87 of file TGLViewer.h. ◆ fPerspectiveCameraXOZ. TGLPerspectiveCamera TGLViewer::fPerspectiveCameraXOZ. protected . Definition at line 85 of file TGLViewer.h. ◆ fPerspectiveCameraYOZ. TGLPerspectiveCamera TGLViewer::fPerspectiveCameraYOZ. protected . Definition at line 86 of file TGLViewer.h. ◆ fPictureFileName. TString TGLViewer::fPictureFileName. protected . Definition at line 158 of file TGLViewer.h. ◆ fPointScale. Float_t TGLViewer::fPointScale. protected . color-set with light background ; Definition at line 142 of file TGLViewer.h. ◆ fPShapeWrap. TGLPShapeObj* TGLViewer::fPShapeWrap. protected . GED editor. ; Definition at line 121 of file TGLViewer.h. ◆ fPushAction. EPushAction TGLViewer::fPushAction. protected . Definition at line 131 of file TGLViewer.h. ◆ fRedrawTimer. TGLRedrawTimer* TGLViewer::fRedrawTimer. protected . Definition at line 135 of file TGLViewer.h. ◆ fReferenceOn. Bool_t TGLViewer::fReferenceOn. protected . remove guides hidden-lines ; Definition at line 148 of file TGLViewer.h. ◆ fReferencePos. TGLVertex3 TGLViewer::fReferencePos. protected . reference marker on? ; Definition at line 149 of file TGLViewer.h. ◆ fResetCamerasOnNextUpdate. Bool_t TGLViewer::fResetCamerasOnNextUpdate. protected . Definition at line 192 of file TGLViewer.h. ◆ fResetCamerasOnUpdate. Bool_t TGLViewer::fResetCamerasOnUpdate. protected . Definition at line 191 of file TGLViewer.h. ◆ fSecSelRec. TGLSelectRecord TGLViewer::fSecSelRec. protected . select record from last select (should go to context) ; Definition at line 113 of file TGLViewer.h. ◆ fSelectedPShapeRef. TGLManipSet* TGLViewer::fSelectedPShapeRef. protected . select record from last secondary select (should go to context) ; Definition at line 114 of file TGLViewer.h. ◆ fSelRec. TGLSelectRecord TGLViewer::fSelRec. protected . select record in use as selected ; Definition at line 112 of file TGLViewer.h. ◆ fSmartRefresh. Bool_t TGLViewer::fSmartRefresh. protected . markup size of viewport ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:78241,guid,guides,78241,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['guid'],['guides']
Usability,"Deleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:59124,clear,clearEvalErrorLog,59124,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['clear'],['clearEvalErrorLog']
Usability,"Dev ; (; ); const. inline . Definition at line 228 of file TGLViewer.h. ◆ GetDragAction(). EDragAction TGLViewer::GetDragAction ; (; ); const. inline . Definition at line 300 of file TGLViewer.h. ◆ GetDrawCameraCenter(). Bool_t TGLViewer::GetDrawCameraCenter ; (; ). inline . Definition at line 279 of file TGLViewer.h. ◆ GetEventHandler(). TGEventHandler * TGLViewer::GetEventHandler ; (; ); const. inline . Definition at line 378 of file TGLViewer.h. ◆ GetFader(). Float_t TGLViewer::GetFader ; (; ); const. inline . Definition at line 349 of file TGLViewer.h. ◆ GetGedEditor(). TGedEditor * TGLViewer::GetGedEditor ; (; ); const. inline . Definition at line 381 of file TGLViewer.h. ◆ GetGLWidget(). TGLWidget * TGLViewer::GetGLWidget ; (; ). inline . Definition at line 223 of file TGLViewer.h. ◆ GetGuideState(). void TGLViewer::GetGuideState ; (; Int_t & ; axesType, . Bool_t & ; axesDepthTest, . Bool_t & ; referenceOn, . Double_t * ; referencePos . ); const. Fetch the state of guides (axes & reference markers) into arguments. ; Definition at line 2055 of file TGLViewer.cxx. ◆ GetIgnoreSizesOnUpdate(). Bool_t TGLViewer::GetIgnoreSizesOnUpdate ; (; ); const. inline . Definition at line 355 of file TGLViewer.h. ◆ GetLightSet(). TGLLightSet * TGLViewer::GetLightSet ; (; ); const. inline . Definition at line 262 of file TGLViewer.h. ◆ GetLineScale(). Float_t TGLViewer::GetLineScale ; (; ); const. inline . Definition at line 254 of file TGLViewer.h. ◆ GetMaxSceneDrawTimeHQ(). Float_t TGLViewer::GetMaxSceneDrawTimeHQ ; (; ); const. inline . Definition at line 308 of file TGLViewer.h. ◆ GetMaxSceneDrawTimeLQ(). Float_t TGLViewer::GetMaxSceneDrawTimeLQ ; (; ); const. inline . Definition at line 309 of file TGLViewer.h. ◆ GetOvlSelRec(). TGLOvlSelectRecord & TGLViewer::GetOvlSelRec ; (; ). inline . Definition at line 391 of file TGLViewer.h. ◆ GetPictureFileName(). const char * TGLViewer::GetPictureFileName ; (; ); const. inline . Definition at line 347 of file TGLViewer.h. ◆ GetPic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:47631,guid,guides,47631,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['guid'],['guides']
Usability,"Dir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-25 16:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:34594,resume,resume,34594,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['resume'],['resume']
Usability,"Directory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTNamed::fNameobject identifier; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Bool_tTDirectoryFile::fWritabletrue if directory is writable; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InternalAppend(TObject* obj); Internal access to TDirectory append method. void Add(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. void Append(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. WSDir(const char* name, const char* title, RooWorkspace* wspace). virtual ~WSDir(); { Clear(""nodelete"") ; }. » Last changed: Sat Jun 20 17:31:22 2015 » Last generated: 2015-06-20 17:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooWorkspace__WSDir.html:13666,Clear,Clear,13666,root/html604/RooWorkspace__WSDir.html,https://root.cern,https://root.cern/root/html604/RooWorkspace__WSDir.html,1,['Clear'],['Clear']
Usability,"Directory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTNamed::fNameobject identifier; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Bool_tTDirectoryFile::fWritabletrue if directory is writable; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InternalAppend(TObject* obj); Internal access to TDirectory append method. void Add(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. void Append(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. WSDir(const char* name, const char* title, RooWorkspace* wspace). virtual ~WSDir(); { Clear(""nodelete"") ; }. » Last changed: Tue Jun 30 14:38:17 2015 » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooWorkspace__WSDir.html:13666,Clear,Clear,13666,root/html602/RooWorkspace__WSDir.html,https://root.cern,https://root.cern/root/html602/RooWorkspace__WSDir.html,1,['Clear'],['Clear']
Usability,"Directory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTNamed::fNameobject identifier; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Bool_tTDirectoryFile::fWritabletrue if directory is writable; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InternalAppend(TObject* obj); Internal access to TDirectory append method. void Add(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. void Append(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. WSDir(const char* name, const char* title, RooWorkspace* wspace). virtual ~WSDir(); { Clear(""nodelete"") ; }. » Last changed: Tue Mar 10 17:21:17 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace__WSDir.html:13294,Clear,Clear,13294,root/html534/RooWorkspace__WSDir.html,https://root.cern,https://root.cern/root/html534/RooWorkspace__WSDir.html,1,['Clear'],['Clear']
Usability,"Double_t & ; xmin, . Double_t & ; xmax, . Int_t ; signalClass, . Bool_t ; norm = kFALSE . ). sanity check ; Definition at line 202 of file Tools.cxx. ◆ ComputeVariance(). Double_t TMVA::Tools::ComputeVariance ; (; Double_t ; sumx2, . Double_t ; sumx, . Int_t ; nx . ). inline . compute variance from given sums ; Definition at line 358 of file Tools.h. ◆ ContainsRegularExpression(). Bool_t TMVA::Tools::ContainsRegularExpression ; (; const TString & ; s). check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ; Definition at line 784 of file Tools.cxx. ◆ DestroyInstance(). void TMVA::Tools::DestroyInstance ; (; ). static . Definition at line 82 of file Tools.cxx. ◆ FormattedOutput() [1/3]. void TMVA::Tools::FormattedOutput ; (; const std::vector< Double_t > & ; values, . const std::vector< TString > & ; V, . const TString ; titleVars, . const TString ; titleValues, . MsgLogger & ; logger, . TString ; format = ""%+1.3f"" . ). formatted output of simple table ; Definition at line 887 of file Tools.cxx. ◆ FormattedOutput() [2/3]. void TMVA::Tools::FormattedOutput ; (; const TMatrixD & ; M, . const std::vector< TString > & ; V, . MsgLogger & ; logger . ). formatted output of matrix (with labels) ; Definition at line 937 of file Tools.cxx. ◆ FormattedOutput() [3/3]. void TMVA::Tools::FormattedOutput ; (; const TMatrixD & ; M, . const std::vector< TString > & ; vert, . const std::vector< TString > & ; horiz, . MsgLogger & ; logger . ). formatted output of matrix (with labels) ; Definition at line 985 of file Tools.cxx. ◆ GetChild(). void * TMVA::Tools::GetChild ; (; void * ; parent, . const char * ; childname = nullptr . ). get child node ; Definition at line 1150 of file Tools.cxx. ◆ GetContent(). const char * TMVA::Tools::GetContent ; (; void * ; node). XML helpers. ; Definition at line 1174 of file Tools.cxx. ◆ GetCorrelationMatrix(). const TMatrixD * TMVA::Tools::GetCorrelationMatrix ; (; const TMatrixD * ; covMat). turns covariance into corre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:14408,simpl,simple,14408,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['simpl'],['simple']
Usability,"Double_t xmax, Double_t ymin, Double_t ymax); RooPlot(const char* name, const char* title, const RooAbsRealLValue& var, Double_t xmin, Double_t xmax, Int_t nBins); RooPlot(const RooAbsRealLValue& var1, const RooAbsRealLValue& var2, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual~RooPlot(); voidTObject::AbstractMethod(const char* method) const; static Bool_taddDirectoryStatus(); voidaddObject(TObject* obj, Option_t* drawOptions = """", Bool_t invisible = kFALSE); voidaddPlotable(RooPlotable* plotable, Option_t* drawOptions = """", Bool_t invisible = kFALSE, Bool_t refreshNorm = kFALSE); voidaddTH1(TH1* hist, Option_t* drawOptions = """", Bool_t invisible = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tchiSquare(int nFitParam = 0) const; Double_tchiSquare(const char* pdfname, const char* histname, int nFitParam = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = 0); Bool_tdrawAfter(const char* after, const char* target); Bool_tdrawBefore(const char* before, const char* target); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; RooPlot*emptyClone(const char* name); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPlot.html:2604,Clear,Clear,2604,root/html534/RooPlot.html,https://root.cern,https://root.cern/root/html534/RooPlot.html,1,['Clear'],['Clear']
Usability,"Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a polynom. Int_t InsertPoint(); Insert a new point at the mouse position. Double_t Integral(Int_t first = 0, Int_t last = -1) const; Integrate the TGraph data within a given (index) range; NB: if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken.; : The graph segments should not intersect.; Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data; you have to deal with. The most evident solution would be to divide the polygon in triangles and; calculate the surface of them. But this can quickly become complicated as you will have to test; every segments of every triangles and check if they are intersecting with a current polygon's; segment or if it goes outside the polygon. Many calculations that would lead to many problems...; The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; segments don't intersect.; It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; Sources; http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon. Int_t IsInside(Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside the polygon defined by; the graph vertices 0 otherwise. Algorithm:; The loop is executed with the end-point coordinates of a line segment; (X1,Y1)-(X2,Y2) and the Y-coordinate of a horizontal line.; The counter inter is incremented if the line (X1,Y1)-(X2,Y2) intersects; the horizontal line. In this case XINT is set to the X-coordinate of the; intersection point. If inter is an odd number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:34842,simpl,simple,34842,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,4,['simpl'],['simple']
Usability,"Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3750,clear,clearEvalErrorLog,3750,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,6,['clear'],['clearEvalErrorLog']
Usability,"Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:3991,clear,clearEvalErrorLog,3991,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,12,['clear'],['clearEvalErrorLog']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cann",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:13136,Clear,Clear,13136,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:13091,Clear,Clear,13091,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a data member just by name or create it if its not already in the list. TDictionary * Find(TListOfDataMembers::DeclId_t id) const; Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:13192,Clear,Clear,13192,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a data member just by name or create it if its not already in the list. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = false); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:13109,Clear,Clear,13109,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:12600,Clear,Clear,12600,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,2,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctions.html:12929,Clear,Clear,12929,root/html604/TListOfFunctions.html,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function correspon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctions.html:12876,Clear,Clear,12876,root/html602/TListOfFunctions.html,https://root.cern,https://root.cern/root/html602/TListOfFunctions.html,1,['Clear'],['Clear']
Usability,"Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:13050,Clear,Clear,13050,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['Clear'],['Clear']
Usability,"DtorOnly(void* obj); static voidTSQLServer::SetFloatFormat(const char* fmt = ""%e""); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tShutdown(); virtual Bool_tStartTransaction(); virtual TSQLStatement*Statement(const char* sql, Int_t = 100); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTSQLServer::ClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTSQLServer::SetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TSQLServer::ESQLDataTypes { kSQL_NONE; kSQL_CHAR; kSQL_VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMySQLServer.html:7382,Clear,ClearError,7382,root/html532/TMySQLServer.html,https://root.cern,https://root.cern/root/html532/TMySQLServer.html,1,['Clear'],['ClearError']
Usability,"E ;  glplot_geom.CDemonstrates how to combine Timur's GL plots with other scene elements ;  hierarchical_scene.C;  histobrowser.CDemonstates how to use EVE as a histogram browser ;  jetcone.CDemonstrates usage of TEveJetCone class ;  lineset.CDemonstrates usage of class TEveStraightLineSet ;  lineset.py;  MultiView.CMulti-view (3d, rphi, rhoz) service class using EVE Window Manager ;  overlay_palette.C;  pack.CDemonstrates usage of class TGPack ;  paramlist.CDemonstrates usage of simple configuration via TEveParamList class ;  pointset.CDemonstrates usage of class TEvePointSet ;  projection.CDemonstrates usage of automatic 2D projections - class TEveProjectionManager ;  projection_prescale.CDemonstrates usage pre-scaling for automatic 2D projections ;  pythia_display.CDemo showing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► eve7;  collection.CThis example display collection of ??? in web browser ;  compound.C;  csgdemo.CCombinatorial Solid Geometry example ;  event_demo.CThis example display geometry, tracks and hits in web browser ;  geom_cms.C;  points.CThis example display only points in web browser ;  projection_prescale.C;  show_extract.CHelper script for showing of extracted / simplified geometries ;  table.CThis example display table in web browser ;  tracks.CThis example display only points in web browser ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:105487,simpl,simplified,105487,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simplified']
Usability,E and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_RSofieReader.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ;  ;  TMVAClassification.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ;  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ;  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ;  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ;  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ;  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ;  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ;  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ;  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ;  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5426,simpl,simple,5426,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"E) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:7483,clear,clearShapeDirty,7483,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,6,['clear'],['clearShapeDirty']
Usability,"E); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:59585,Clear,ClearData,59585,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,1,['Clear'],['ClearData']
Usability,"E); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:2261,Clear,Clear,2261,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['Clear'],['Clear']
Usability,"E); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:2192,Clear,Clear,2192,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['Clear'],['Clear']
Usability,"E); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:2020,Clear,Clear,2020,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['Clear'],['Clear']
Usability,"E); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:2060,Clear,Clear,2060,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,5,['Clear'],['Clear']
Usability,"E); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:1915,Clear,Clear,1915,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,1,['Clear'],['Clear']
Usability,"E, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0); RooCurve(const RooAbsReal& func, RooAbsRealLValue& x, Double_t xlo, Double_t xhi, Int_t xbins, Double_t scaleFactor = 1, const RooArgSet* normVars = 0, Double_t prec = 1e-3, Double_t resolution = 1e-3, Bool_t shiftToZero = kFALSE, RooCurve::WingMode wmode = Extended, Int_t nEvalError = -1, Int_t doEEVal = kFALSE, Double_t eeVal = 0, Bool_t showProgress = kFALSE); virtual~RooCurve(); voidTObject::AbstractMethod(const char* method) const; voidaddPoint(Double_t x, Double_t y); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraph::Apply(TF1* f); Double_taverage(Double_t lo, Double_t hi) const; virtual voidTGraph::Browse(TBrowser* b); Double_tchiSquare(const RooHist& hist, int nFitParam) const; virtual Double_tTGraph::Chisquare(const TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareY(const TGraph* gr, Int_t left, Int_t right); virtual voidTGraph::ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTNamed::Copy(TObject& named) const; TObject*RooPlotable::crossCast(); virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCurve.html:2242,Clear,Clear,2242,root/html534/RooCurve.html,https://root.cern,https://root.cern/root/html534/RooCurve.html,1,['Clear'],['Clear']
Usability,"E, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:2193,Clear,ClearInput,2193,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Clear'],['ClearInput']
Usability,"ED; » TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:1228,simpl,simple,1228,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,24,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveJetConeGL.html:4584,Clear,Clear,4584,root/html604/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html604/TEveJetConeGL.html,1,['Clear'],['Clear']
Usability,"ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveJetConeGL.html:4584,Clear,Clear,4584,root/html602/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html602/TEveJetConeGL.html,1,['Clear'],['Clear']
Usability,"ELearningMethod { ;   kStochastic; , kBatch; , kSteepestDescent; , kRibierePolak; , ;   kFletcherReeves; , kBFGS. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiLayerPerceptron ();  Default constructor. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:10299,simpl,simple,10299,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"ENU ; voidRaytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(Option_t* option = """"); voidRelease(); voidRemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidSaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidSelectVolume(Bool_t clear = kFALSE); voidSetActiveDaughters(Bool_t flag = kTRUE); voidSetActivity(Bool_t flag = kTRUE); voidSetAdded(); voidSetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidSetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); voidSetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFinder(TGeoPatternFinder* finder); voidSetFWExtension(TGeoExtension* ext); voidSetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:26166,clear,clear,26166,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,6,['clear'],['clear']
Usability,EParUnzipMode { kEnable; kDisable; kForce; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. queue<Int_t>fActiveBlksThe blocks which are active now; Bool_tfActiveThreadUsed to terminate gracefully the unzippers; Bool_tfAsyncReading; Bool_tTFileCacheRead::fAsyncReading; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Int_tfCycle; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:9001,learn,learning,9001,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,1,['learn'],['learning']
Usability,"EPruneMethod fPruneMethod;  method used for pruning ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be adjusted ;  ; Bool_t fRandomisedTree;  choose at each node splitting a random set of variables ;  ; RegressionVariance * fRegType;  the separation criteria used in Regression ;  ; SeparationBase * fSepType;  the separation criteria ;  ; UInt_t fSigClass;  class which is treated as signal when building the tree ;  ; Int_t fTreeID;  just an ID number given to the tree.. makes debugging easier as tree knows who he is. ;  ; Bool_t fUseExclusiveVars;  individual variables already used in fisher criterium are not anymore analysed individually for node splitting ;  ; Bool_t fUseFisherCuts;  use multivariate splits using the Fisher criterium ;  ; Int_t fUseNvars;  the number of variables used in randomised trees; ;  ; Bool_t fUsePoissonNvars;  use ""fUseNvars"" not as fixed number but as mean of a poisson distr. in each split ;  ; Bool_t fUseSearchTree;  cut scan done with binary trees or simple event loop. ;  ; std::vector< Double_t > fVariableImportance;  the relative importance of the different variables ;  . Static Private Attributes; static const Int_t fgDebugLevel = 0;  debug level determining some printout/control plots etc. ;  ; static const Int_t fgRandomSeed = 0;  . Additional Inherited Members;  Protected Member Functions inherited from TMVA::BinaryTree; void DeleteNode (Node *);  protected, recursive, function used by the class destructor and when Pruning ;  ; MsgLogger & Log () const;  ;  Protected Attributes inherited from TMVA::BinaryTree; UInt_t fDepth;  maximal depth in tree reached ;  ; UInt_t fNNodes;  total number of nodes in the tree (counted) ;  ; Node * fRoot;  the root node of the tree the tree only has it's root node, the ""daughters"" are taken care of by the ""node"" properties of the ""root"" ;  . #include <TMVA/DecisionTree.h>. Inheritance diagram for TMVA::DecisionTree:. This browser is not able to show SVG: try Fire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:12043,simpl,simple,12043,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['simpl'],['simple']
Usability,"Eff (Double_t sigEff=0.5);  calculate the background efficiency for a given signal efficiency ;  ; Double_t GetBkgRejAtSigEff (Double_t sigEff=0.5);  calculate the background rejection for a given signal efficiency ;  ; Double_t GetFOM ();  Return the Figure of Merit (FOM) used in the parameter optimization process. ;  ; MethodBase * GetMethod ();  ; void GetMVADists ();  fill the private histograms with the mva distributions for sig/bkg ;  ; Double_t GetROCIntegral ();  calculate the area (integral) under the ROC curve as a overall quality measure of the classification ;  ; std::vector< int > GetScanIndices (int val, std::vector< int > base);  helper function to scan through the all the combinations in the parameter space ;  ; Double_t GetSeparation ();  return the separation between the signal and background MVA ouput distribution ;  ; Double_t GetSigEffAtBkgEff (Double_t bkgEff=0.1);  calculate the signal efficiency for a given background efficiency ;  ; MsgLogger & Log () const;  ; void optimizeFit ();  ; void optimizeScan ();  do the actual optimization using a simple scan method, i.e. ;  . Private Attributes; std::map< std::vector< Double_t >, Double_t > fAlreadyTrainedParCombination;  save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ;  ; TString fFOMType;  the FOM type (Separation, ROC integra.. whatever you implemented.. ;  ; std::vector< Float_t > fFOMvsIter;  graph showing the development of the Figure Of Merit values during the fit ;  ; MsgLogger * fLogger;  ! message logger ;  ; MethodBase *const fMethod;  The MVA method to be evaluated. ;  ; TH1D * fMvaBkg;  MVA distribution for bakgr. events, used for spline fit. ;  ; TH1D * fMvaBkgFineBin;  MVA distribution for bakgr. events. ;  ; TH1D * fMvaSig;  MVA distribution for signal events, used for spline fit. ;  ; TH1D * fMvaSigFineBin;  MVA distribution for signal events. ;  ; Bool_t fNotDoneYet;  flat to indicate of Method Transformations have been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:2977,simpl,simple,2977,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['simpl'],['simple']
Usability,"Efficiency object does not; belong to any directory and will not be written to file during the; next TFile::Write() command. void SetName(const char* name); sets the name. Note: The names of the internal histograms are set to ""name + _total"" or; ""name + _passed"" respectively. Bool_t SetPassedEvents(Int_t bin, Int_t events); sets the number of passed events in the given global bin. returns ""true"" if the number of passed events has been updated; otherwise ""false"" ist returned. Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin). Bool_t SetPassedHistogram(const TH1& rPassed, Option_t* opt); sets the histogram containing the passed events. The given histogram is cloned and stored internally as histogram containing; the passed events. The given histogram has to be consistent with the current; fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fPassedHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fTotalHistogram is replaced by a; consistent one (with respect to rPassed) as well. void SetStatisticOption(TEfficiency::EStatOption option); sets the statistic option which affects the calculation of the confidence interval. Options:; - kFCP (=0)(default): using the Clopper-Pearson interval (recommended by PDG); sets kIsBayesian = false; see also ClopperPearson; - kFNormal (=1) : using the normal approximation; sets kIsBayesian = false; see also Normal; - kFWilson (=2) : using the Wilson interval; sets kIsBayesian = false; see also Wilson; - kFAC (=3) : using the Agresti-Coull interval; sets kIsBayesian = false; see also AgrestiCoull; - kFFC (=4) : using the Feldman-Cousins frequent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:60689,clear,cleared,60689,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,2,['clear'],['cleared']
Usability,"Element* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently visible; scenes. void Render(); Render all scenes. This is done in four passes:; - render opaque objects from all scenes; - render transparent objects from all scenes; - clear depth buffer; - render opaque selected objects from all scenes (with highlight); - render transparent selected objects from all scenes (with highlight). void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Render selected objects from all scenes. void RenderOverlay(Int_t state, Bool_t selection); Render overlay objects. void PostRender(); Function called after rendering is finished.; Here we just unlock the scenes. void PreRenderOverlaySelection(); Perform minimal initialization for overlay selection.; Here we assume that scene has already been drawn and that; camera and overall bounding box are ok.; Scenes are not locked. void PostRenderOverlaySelection(); Perform cleanup after overlay selection. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t recIdx); Process selection record on buffer-position 'recIdx' and; fill the data into 'rec'. Returns TRUE if scene was demangled and an object identified.; When FALSE is returned it is still possible that scene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewerBase.html:5926,clear,clear,5926,root/html528/TGLViewerBase.html,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html,4,['clear'],['clear']
Usability,"Element::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; TGLEmbeddedViewer*SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); TGLSAViewer*SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; voidSwitchStereo(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveViewer.html:17937,Undo,UndockWindow,17937,root/html534/TEveViewer.html,https://root.cern,https://root.cern/root/html534/TEveViewer.html,2,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVectorT_float_.html:18873,Clear,Clear,18873,root/html604/TVectorT_float_.html,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html,1,['Clear'],['Clear']
Usability,"Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_float_.html:18873,Clear,Clear,18873,root/html602/TVectorT_float_.html,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html,1,['Clear'],['Clear']
Usability,"Entries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum number of lines to be shown before <CR> when calling Scan().Definition TTree.h:691; TTree::TTreeTTree(const TTree &tt)=delete; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::SetBranchAddressInt_t SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)Definition TTree.h:628; TTree::BranchTBranch * Branch(const char *name, char *address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:379; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:84510,undo,undo,84510,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['undo'],['undo']
Usability,"Entry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. Function Members (Methods); public:. TGTextBuffer(); TGTextBuffer(Int_t length); virtual~TGTextBuffer(); voidAddText(Int_t pos, const char* text); voidAddText(Int_t pos, const char* text, Int_t length); static TClass*Class(); voidClear(); UInt_tGetBufferLength() const; const char*GetString() const; UInt_tGetTextLength() const; virtual TClass*IsA() const; voidRemoveText(Int_t pos, Int_t length); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGTextBuffer(const TGTextBuffer& tb); TGTextBuffer&operator=(const TGTextBuffer& tb). Data Members; private:. TString*fBuffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextBuffer(const TGTextBuffer& tb); { }. TGTextBuffer& operator=(const TGTextBuffer& tb); {if(this!=&tb) fBuffer=tb.fBuffer; return *this;}. TGTextBuffer(); { }. TGTextBuffer(Int_t length); { }. virtual ~TGTextBuffer(); { delete fBuffer; }. UInt_t GetTextLength() const; { return fBuffer->Length(); }. UInt_t GetBufferLength() const; { return fBuffer->Capacity(); }. const char * GetString() const; { return fBuffer->Data(); }. void AddText(Int_t pos, const char* text); { fBuffer->Insert(pos, text); }. void AddText(Int_t pos, const char* text, Int_t length); { fBuffer->Insert(pos, text, length); }. void RemoveText(Int_t pos, Int_t length); { fBuffer->Remove(pos, length); }. void Clear(); { fBuffer->Remove(0, fBuffer->Length()); }. » Author: Fons Rademakers 05/05/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextBuffer.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextBuffer.html:1928,Clear,Clear,1928,root/html532/TGTextBuffer.html,https://root.cern,https://root.cern/root/html532/TGTextBuffer.html,1,['Clear'],['Clear']
Usability,"EntryThe first entry of the range that the task will process. This method might be called multiple times per thread per event-loop. . Reimplemented in ROOT::RDF::RArrowDS, ROOT::Experimental::RNTupleDS, and ROOT::Internal::RDF::RRootDS.; Definition at line 210 of file RDataSource.hxx. ◆ SetEntry(). virtual bool ROOT::RDF::RDataSource::SetEntry ; (; unsigned int ; slot, . ULong64_t ; entry . ). pure virtual . Advance the ""cursors"" returned by GetColumnReaders to the selected entry for a particular slot. ; Parameters. [in]slotThe data processing slot that needs to be considered ; [in]entryThe entry which needs to be pointed to by the reader pointers Slots are adopted to accommodate parallel data processing. Different workers will loop over different ranges and will be labelled by different ""slot"" values. Returns true if the entry has to be processed, false otherwise. . Implemented in ROOT::Internal::RDF::RVecDS< ColumnTypes >, ROOT::RDF::RArrowDS, ROOT::RDF::RCsvDS, ROOT::RDF::RLazyDS< ColumnTypes >, ROOT::Internal::RDF::RRootDS, ROOT::RDF::RSqliteDS, ROOT::RDF::RTrivialDS, and ROOT::Experimental::RNTupleDS. ◆ SetNSlots(). virtual void ROOT::RDF::RDataSource::SetNSlots ; (; unsigned int ; nSlots). pure virtual . Inform RDataSource of the number of processing slots (i.e. ; worker threads) used by the associated RDataFrame. Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always pass different slot values when calling methods concurrently. ; Implemented in ROOT::Internal::RDF::RVecDS< ColumnTypes >, ROOT::RDF::RArrowDS, ROOT::RDF::RCsvDS, ROOT::RDF::RLazyDS< ColumnTypes >, ROOT::Experimental::RNTupleDS, ROOT::Internal::RDF::RRootDS, ROOT::RDF::RSqliteDS, and ROOT::RDF::RTrivialDS. The documentation for this class was generated from the following file:; tree/dataframe/inc/ROOT/RDataSource.hxx. ROOTRDFRDataSource. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html:13783,simpl,simplify,13783,doc/master/classROOT_1_1RDF_1_1RDataSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html,1,['simpl'],['simplify']
Usability,"EnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tTProof::CancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* send",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:2091,Clear,Clear,2091,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,6,['Clear'],['Clear']
Usability,"Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Detail::TCollectionProxyInfo::Type::fgLargeIteratorstatic const bool fgLargeIteratorDefinition TCollectionProxyInfo.h:359; ROOT::Detail::TCollectionProxyInfo::Type::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:314; ROOT::Detail::TCollectionProxyInfo::Type::destructstatic void destruct(void *what, size_t size)Definition TCollectionProxyInfo.h:353; ROOT::Detail::TCollectionProxyInfo::Type::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:318; ROOT::Detail::TCollectionProxyInfo::Type::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:309; ROOT::Detail::TCollectionProxyInfo::Type::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:297; ROOT::Detail::TCollectionProxyInfo::Type::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:296; ROOT::Detail::TCollectionProxyInfo::Type::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:302; ROOT::Detail::TCollectionProxyInfo::Type::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:301; ROOT::Detail::TCollectionProxyInfo::Type::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:331; ROOT::Detail::TCollectionProxyInfo::Type::Valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:52850,clear,clearstatic,52850,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,2,['clear'],"['clear', 'clearstatic']"
Usability,"Equal(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooStats::SimpleInterval::IsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); Double_tLowerLimitEstimatedError(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&RooStats::SimpleInterval::operator=(const RooStats::SimpleInterval&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html:5507,Simpl,SimpleInterval,5507,root/html532/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleInterval']
Usability,"Error (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE: Only active branches are copied. See TTree::SetBranchStatus for more information and usage regarding the (de)activation of branches. More examples are provided in the tut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:102998,usab,usable,102998,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['usab'],['usable']
Usability,"Error (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 705 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE: Only active branches are copied. See TTree::SetBranchStatus for more information and usage regarding the (de)activation of branches. More examples are provided in the tut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:103171,usab,usable,103171,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['usab'],['usable']
Usability,"Error(""ReadFile"",""Cannot open file: %s"",filename);; 7576 return 0;; 7577 }; 7578 const char* ext = strrchr(filename, '.');; 7579 if(ext && ((strcmp(ext, "".csv"") == 0) || (strcmp(ext, "".CSV"") == 0)) && delimiter == ' ') {; 7580 delimiter = ',';; 7581 }; 7582 return ReadStream(in, branchDescriptor, delimiter);; 7583}; 7584 ; 7585////////////////////////////////////////////////////////////////////////////////; 7586/// Determine which newline this file is using.; 7587/// Return '\\r' for Windows '\\r\\n' as that already terminates.; 7588 ; 7589char TTree::GetNewlineValue(std::istream &inputStream); 7590{; 7591 Long_t inPos = inputStream.tellg();; 7592 char newline = '\n';; 7593 while(true) {; 7594 char c = 0;; 7595 inputStream.get(c);; 7596 if(!inputStream.good()) {; 7597 Error(""ReadStream"",""Error reading stream: no newline found."");; 7598 return 0;; 7599 }; 7600 if(c == newline) break;; 7601 if(c == '\r') {; 7602 newline = '\r';; 7603 break;; 7604 }; 7605 }; 7606 inputStream.clear();; 7607 inputStream.seekg(inPos);; 7608 return newline;; 7609}; 7610 ; 7611////////////////////////////////////////////////////////////////////////////////; 7612/// Create or simply read branches from an input stream.; 7613///; 7614/// \see reference information for TTree::ReadFile; 7615 ; 7616Long64_t TTree::ReadStream(std::istream& inputStream, const char *branchDescriptor, char delimiter); 7617{; 7618 char newline = 0;; 7619 std::stringstream ss;; 7620 std::istream *inTemp;; 7621 Long_t inPos = inputStream.tellg();; 7622 if (!inputStream.good()) {; 7623 Error(""ReadStream"",""Error reading stream"");; 7624 return 0;; 7625 }; 7626 if (inPos == -1) {; 7627 ss << std::cin.rdbuf();; 7628 newline = GetNewlineValue(ss);; 7629 inTemp = &ss;; 7630 } else {; 7631 newline = GetNewlineValue(inputStream);; 7632 inTemp = &inputStream;; 7633 }; 7634 std::istream& in = *inTemp;; 7635 Long64_t nlines = 0;; 7636 ; 7637 TBranch *branch = nullptr;; 7638 Int_t nbranches = fBranches.GetEntries();; 7639 if (nbranch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:299369,clear,clear,299369,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['clear'],['clear']
Usability,"Error.h>; 16 ; 17namespace ROOT {; 18 ; 19namespace Fit {; 20 ; 21/// set a double side limit,; 22/// if low == up the parameter is fixed if low > up the limits are removed; 23/// The current parameter value should be within the given limits [low,up].; 24/// If the value is outside the limits, then a new parameter value is set to = (up+low)/2; 25void ParameterSettings::SetLimits(double low, double up); 26{; 27 ; 28 if (low > up) {; 29 RemoveLimits();; 30 return;; 31 }; 32 if (low == up && low == fValue) {; 33 Fix();; 34 return;; 35 }; 36 if (low > fValue || up < fValue) {; 37 MATH_INFO_MSG(""ParameterSettings"",; 38 ""lower/upper bounds outside current parameter value. The value will be set to (low+up)/2 "");; 39 fValue = 0.5 * (up + low);; 40 }; 41 fLowerLimit = low;; 42 fUpperLimit = up;; 43 fHasLowerLimit = true;; 44 fHasUpperLimit = true;; 45}; 46 ; 47} // end namespace Fit; 48 ; 49} // end namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; ParameterSettings.h; ROOT::Fit::ParameterSettings::RemoveLimitsvoid RemoveLimits()remove all limitDefinition ParameterSettings.h:140; ROOT::Fit::ParameterSettings::fLowerLimitdouble fLowerLimitlower parameter limitDefinition ParameterSettings.h:152; ROOT::Fit::ParameterSettings::fUpperLimitdouble fUpperLimitupper parameter limitDefinition ParameterSettings.h:153; ROOT::Fit::ParameterSettings::fHasUpperLimitbool fHasUpperLimitflag to control upper parameter limitDefinition ParameterSettings.h:155; ROOT::Fit::ParameterSettings::fHasLowerLimitbool fHasLowerLimitflag to control lower parameter limitDefinition ParameterSettings.h:154; ROOT::Fit::ParameterSettings::SetLimitsvoid SetLimits(double low, double up)set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The c...Definition ParameterSettings.cxx:25; ROOT::Fit::ParameterSettings::fValuedouble fVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ParameterSettings_8cxx_source.html:1692,simpl,simply,1692,doc/master/ParameterSettings_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ParameterSettings_8cxx_source.html,1,['simpl'],['simply']
Usability,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:12084,simpl,simple,12084,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['simpl'],['simple']
Usability,"EtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch). Set the event weight. ; Definition at line 606 of file TMultiLayerPerceptron.cxx. ◆ SetGammaDelta(). void TMultiLayerPerceptron::SetGammaDelta ; (; TMatrixD & ; gamma, . TMatrixD & ; delta, . Double_t * ; buffer . ). protected . Sets the gamma \((g_{(t+1)}-g_{(t)})\) and delta \((w_{(t+1)}-w_{(t)})\) vectors Gamma is computed here, so ComputeDEDw cannot have been called before, and delta is a direct translation of buffer into a TMatrixD. ; Definition at line 2431 of file TMultiLayerPerceptron.cxx. ◆ SetLearningMethod(). void TMultiLayerPerceptron::SetLearningMethod ; (; TMultiLayerPerceptron::ELearningMethod ; method). Sets the learning method. ; Available methods are: kStochastic, kBatch, kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 690 of file TMultiLayerPerceptron.cxx. ◆ SetReset(). void TMultiLayerPerceptron::SetReset ; (; Int_t ; reset). Sets number of epochs between two resets of the search direction to the steepest descent. ; (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 751 of file TMultiLayerPerceptron.cxx. ◆ SetTau(). void TMultiLayerPerceptron::SetTau ; (; Double_t ; tau). Sets Tau - used in line search (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 740 of file TMultiLayerPerceptron.cxx. ◆ SetTestDataSet() [1/2]. void TMultiLayerPerceptron::SetTestDataSet ; (; const char * ; test). Sets the Test dataset. ; Those events will not be used for the minimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:46320,learn,learning,46320,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"EvalLikeMod7 ; (; Double_t ; mu, . Int_t ; x, . Double_t ; em, . Double_t ; sde, . Double_t ; b, . Int_t ; what . ). private . Calculates the Profile Likelihood for MODEL 7: background known/Efficiency Gauss. . what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned otherwise parameters as described in the beginning of the class) . Definition at line 1366 of file TRolke.cxx. ◆ EvalMonomial(). Double_t TRolke::EvalMonomial ; (; Double_t ; x, . const Int_t ; coef[], . Int_t ; N . ). staticprivate . Evaluate mononomial. ; Definition at line 1430 of file TRolke.cxx. ◆ EvalPolynomial(). Double_t TRolke::EvalPolynomial ; (; Double_t ; x, . const Int_t ; coef[], . Int_t ; N . ). staticprivate . Evaluate polynomial. ; Definition at line 1413 of file TRolke.cxx. ◆ GetBackground(). Double_t TRolke::GetBackground ; (; ). private . Return a simple background value (estimate/truth) given the pre-specified model. ; Definition at line 418 of file TRolke.cxx. ◆ GetBounding(). bool TRolke::GetBounding ; (; ); const. inline . Definition at line 178 of file TRolke.h. ◆ GetCL(). Double_t TRolke::GetCL ; (; ); const. inline . Definition at line 121 of file TRolke.h. ◆ GetCriticalNumber(). bool TRolke::GetCriticalNumber ; (; Int_t & ; ncrit, . Int_t ; maxtry = -1 . ). get the value of x corresponding to rejection of the null hypothesis. ; This means a lower limit >0 with the pre-specified Confidence Level. Optionally give maxtry; the maximum value of x to try. Of not, or if maxtry<0 an automatic mode is used. ; Definition at line 547 of file TRolke.cxx. ◆ GetLimits(). bool TRolke::GetLimits ; (; Double_t & ; low, . Double_t & ; high . ). Calculate and get the upper and lower limits for the pre-specified model. ; Definition at line 374 of file TRolke.cxx. ◆ GetLimitsML(). bool TRolke::GetLimitsML ; (; Double_t & ; low, . Double_t & ; high, . Int_t & ; out_x . ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRolke.html:29845,simpl,simple,29845,doc/master/classTRolke.html,https://root.cern,https://root.cern/doc/master/classTRolke.html,1,['simpl'],['simple']
Usability,"EveCaloViz::AssertCellIdCache() const; TEveRGBAPalette*TEveCaloViz::AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; Bool_tTEveCaloViz::CellInEtaPhiRng(TEveCaloData::CellData_t&) const; virtual voidTEveCaloViz::CellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCalo3D.html:2471,Clear,ClearProjectedList,2471,root/html532/TEveCalo3D.html,https://root.cern,https://root.cern/root/html532/TEveCalo3D.html,8,['Clear'],['ClearProjectedList']
Usability,"EveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms = kFALSE, Bool_t cols = kFALSE); Constructor. ~TEveTriangleSet(); Destructor. void GenerateTriangleNormals(); Generate triangle normals via cross product of triangle edges. void GenerateRandomColors(); Assign random colors to all triangles. void GenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Generate triangle colors by the z-component of the normal.; Current palette is taken from gStyle. void ComputeBBox(); Compute bounding box.; Virtual from TAttBBox. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TEveTriangleSet* ReadTrivialFile(const char* file); Read a simple ascii input file describing vertices and triangles. TEveTriangleSet(const TEveTriangleSet& ). TEveTriangleSet& operator=(const TEveTriangleSet& ). Bool_t CanEditMainTransparency() const; { return kTRUE; }. Int_t GetNVerts() const; { return fNVerts; }. Int_t GetNTrings() const; { return fNTrings; }. Float_t* Vertex(Int_t i); { return &(fVerts[3*i]); }. Int_t* Triangle(Int_t i); { return &(fTrings[3*i]); }. Float_t* TriangleNormal(Int_t i); { return &(fTringNorms[3*i]); }. UChar_t* TriangleColor(Int_t i); { return &(fTringCols[3*i]); }. void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z); { Float_t* v = Vertex(i); v[0] = x; v[1] = y; v[2] = z; }. void SetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); { Int_t* t = Triangle(i); t[0] = v0; t[1] = v1; t[2] = v2; }. void SetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); { UChar_t* c = TriangleColor(i); c[0] = r; c[1] = g; c[2] = b; c[3] = a; }. void SetTransparency(Char_t tr); { SetMainTransparency(tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTriangleSet.html:22924,simpl,simple,22924,root/html602/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html602/TEveTriangleSet.html,4,['simpl'],['simple']
Usability,"EveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tCalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLine.html:2746,Clear,ClearStamps,2746,root/html534/TEveLine.html,https://root.cern,https://root.cern/root/html534/TEveLine.html,3,['Clear'],['ClearStamps']
Usability,"EveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); TGCompositeFrame*StartEmbedding(); TEveWindowFrame*StopEmbedding(const char* name = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveWindowSlot(const char* n = ""TEveWindowSlot"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindowSlot.html:17241,Undo,UndockWindow,17241,root/html602/TEveWindowSlot.html,https://root.cern,https://root.cern/root/html602/TEveWindowSlot.html,4,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"EveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_tfgCurrentBackgroundColor; static UInt_tfgMainFrameDefHeight; static UInt_tfgMainFrameDefWidth; static Pixel_tfgMiniBarBackgroundColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveWindow(); Destructor. void PreDeleteElement(); Called before the element is deleted, thus offering the last chance; to detach from acquired resources and from the framework itself.; Here the request is just passed to TEveManager.; If you override it, make sure to call base-class version. void PreUndock(); Virtual function called before a window is undocked. void PostDock(); Virtual function called after a window is docked. void NameTitleChanged(); Name or title of the window changed - propagate to frames.; Virtual from TEveElement. void PopulateEmptyFrame(TEveCompositeFrame* ef); Populate given frame-slot - intended for initial population; of a new slot or low-level window-swapping.; No layout or window-mapping is done. void SwapWindow(TEveWindow* w); Swap frames with the given window. void SwapWindowWithCurrent(); Swap frames with the current window. void UndockWindow(); Undock the window - put it into a dedicated main-frame. void UndockWindowDestroySlot(); Undock the window - put it into a dedicated main-frame.; The old window slot is destroyed. void ReplaceWindow(TEveWindow* w); Replace this window with the passed one.; Eve parentship is properly handled.; This will most likely lead to the destruction of this window.; Layout is called on the frame. void DestroyWindow(); Destroy eve-window - replace i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveWindow.html:21147,undo,undocked,21147,root/html528/TEveWindow.html,https://root.cern,https://root.cern/root/html528/TEveWindow.html,6,['undo'],['undocked']
Usability,"EveManager::TExceptionHandler*fExcHandler; Bool_tfFullRedraw; TMap*fGeometries; TMap*fGeometryAliases; TEveScene*fGlobalScene; Bool_tfKeepEmptyCont; TEveGListTreeEditorFrame*fLTEFrame; TFolder*fMacroFolder; Int_tfRedrawDisabled; TTimerfRedrawTimer; Bool_tfResetCameras; TEveSceneList*fScenes; Bool_tfTimerActive; TEveViewerList*fViewers; TMap*fVizDB; Bool_tfVizDBReplace; Bool_tfVizDBUpdate; TEveWindowManager*fWindowManager. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveManager(UInt_t w, UInt_t h, Bool_t map_window = kTRUE, Option_t* opt = ""FI""); Constructor.; If map_window is true, the TEveBrowser window is mapped. Option string is first parsed for the following characters:; V - spawn a default GL viewer. The consumed characters are removed from the options and they; are passed to TEveBrowser for creation of additional plugins. Default options: ""FIV"" - file-browser, command-line, GL-viewer. ~TEveManager(); Destructor. void ClearOrphanage(); Clear the orphanage. TGWindow* GetMainWindow() const; Get the main window, i.e. EVE-browser. TEveViewer* GetDefaultViewer() const; Returns the default viewer - the first one in the fViewers list. TGLViewer* GetDefaultGLViewer() const; Get TGLViewer of the default TEveViewer. TEveGedEditor* GetEditor() const; Returns main object editor. TGStatusBar* GetStatusBar() const; Returns main window status bar. TCanvas* AddCanvasTab(const char* name); Add a new canvas tab. TEveViewer* SpawnNewViewer(const char* name, const char* title = """", Bool_t embed = kTRUE); Create a new GL viewer. TEveScene* SpawnNewScene(const char* name, const char* title = """"); Create a new scene. TMacro* GetMacro(const char* name) const; Find macro in fMacroFolder by name. void EditElement(TEveElement* element); Show element in default editor. void RegisterRedraw3D(); Register a request for 3D redraw. void DoRedraw3D(); Perform 3D redraw of scenes and viewers whose contents has; changed. void FullRedraw3D(Bool_t rese",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveManager.html:5024,Clear,ClearOrphanage,5024,root/html532/TEveManager.html,https://root.cern,https://root.cern/root/html532/TEveManager.html,4,['Clear'],"['Clear', 'ClearOrphanage']"
Usability,"Event(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLSurfacePainter(const TGLSurfacePainter&); TGLSurfacePainter(TGLSurfacePainter&&); TGLSurfacePainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. voidClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawContoursProjection() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; voidDrawProjections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidGenTexMap() const; Bool_tHasProjections() const; Bool_tHasSections() const; Bool_tInitGeometryCartesian(); Bool_tInitGeometryCylindrical(); Bool_tInitGeometryPolar(); Bool_tInitGeometrySpherical(); virtual voidInitGL() const; Bool_tPreparePalette() const; voidSetNormals(); voidSetSurfaceColor() const; Bool_tTextured() const; char*WindowPointTo3DPoint(Int_t px, Int_t py) const. Data Members; public:. static TGLPlotPainter::ECutAxisIDT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSurfacePainter.html:1810,Clear,ClearBuffers,1810,root/html602/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html602/TGLSurfacePainter.html,2,['Clear'],['ClearBuffers']
Usability,"Event.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; Now, let’s see how the tree looks like in the tree viewer. The tree viewer with tree4 example. You can see the two branches in the tree in the left panel: the event branch is split and hence expands when clicked on. The other branch event not split is not expandable and we can not browse the data members.; The TClonesArray of tracks fTracks is also split because we set the split level to 2. The output on the command line is the result of tree4->Show(). It shows the first entry with more than 587 tracks:; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueID = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ...; 12.18 Example 5: I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:581794,clear,clear,581794,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Evolution(). void TMVA::GeneticAlgorithm::Evolution ; (; ). virtual . this function is called from ""init"" and controls the evolution of the individuals. ; The function can be overridden to change the parameters for mutation rate sexual reproduction and so on. ; Definition at line 190 of file GeneticAlgorithm.cxx. ◆ GetGeneticPopulation(). GeneticPopulation & TMVA::GeneticAlgorithm::GetGeneticPopulation ; (; ). inline . Definition at line 67 of file GeneticAlgorithm.h. ◆ GetMakeCopies(). Bool_t TMVA::GeneticAlgorithm::GetMakeCopies ; (; ). inline . Definition at line 73 of file GeneticAlgorithm.h. ◆ GetSpread(). Double_t TMVA::GeneticAlgorithm::GetSpread ; (; ); const. inline . Definition at line 69 of file GeneticAlgorithm.h. ◆ HasConverged(). Bool_t TMVA::GeneticAlgorithm::HasConverged ; (; Int_t ; steps = 10, . Double_t ; improvement = 0.1 . ). virtual . gives back true if the last ""steps"" steps have lead to an improvement of the ""fitness"" of the ""individuals"" of at least ""improvement"" ; this gives a simple measure of if the fitness of the individuals is converging and no major improvement is to be expected soon. ; Definition at line 260 of file GeneticAlgorithm.cxx. ◆ Init(). void TMVA::GeneticAlgorithm::Init ; (; ). calls evolution, but if it is not the first time. ; If it's the first time, the random population created by the constructor is still not evaluated, .. therefore we wait for the second time init is called. ; Definition at line 101 of file GeneticAlgorithm.cxx. ◆ IsA(). virtual TClass * TMVA::GeneticAlgorithm::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 104 of file GeneticAlgorithm.h. ◆ Log(). MsgLogger & TMVA::GeneticAlgorithm::Log ; (; ); const. inlineprotected . message logger ; Definition at line 102 of file GeneticAlgorithm.h. ◆ NewFitness(). Double_t TMVA::GeneticAlgorithm::NewFitness ; (; Double_t ; oldValue, . Double_t ; newValue . ). virtual . if the ""fitnessFunction"" is called multiple time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html:5512,simpl,simple,5512,doc/master/classTMVA_1_1GeneticAlgorithm.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html,1,['simpl'],['simple']
Usability,"Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticAlgorithm.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-26 20:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html:5154,simpl,simple,5154,root/html528/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html,1,['simpl'],['simple']
Usability,"Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ; file  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ; file  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ; file  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ;  ; file  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ; file  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:3597,simpl,simple,3597,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the comman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:23376,Undo,UndoName,23376,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,4,['Undo'],['UndoName']
Usability,"ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:87127,guid,guide,87127,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"Extend() && fXaxis->IsAlphanumeric()) fH->LabelsDeflate(""X"");; 4498 if (fYaxis->CanExtend() && fYaxis->IsAlphanumeric()) fH->LabelsDeflate(""Y"");; 4499 if (fZaxis->CanExtend() && fZaxis->IsAlphanumeric()) fH->LabelsDeflate(""Z"");; 4500 ; 4501 if (Hoption.Pie) {; 4502 if (fH->GetDimension() == 1) {; 4503 if (!fPie); 4504 fPie = std::make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:172269,clear,clear,172269,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"F, 1, V >Struct to solve a linear system using its Cholesky decomposition (N=1) ;  C_solver< F, 2, V >Struct to solve a linear system using its Cholesky decomposition (N=2) ;  C_solver< F, 3, V >Struct to solve a linear system using its Cholesky decomposition (N=3) ;  C_solver< F, 4, V >Struct to solve a linear system using its Cholesky decomposition (N=4) ;  C_solver< F, 5, V >Struct to solve a linear system using its Cholesky decomposition (N=5) ;  C_solver< F, 6, V >Struct to solve a linear system using its Cholesky decomposition (N=6) ;  C_solverGenDimStruct to solve a linear system using its Cholesky decomposition (generalised dimensionality) ;  CPackedArrayAdapterAdapter for packed arrays (to SMatrix indexing conventions) ;  ►Ndetail;  Cmanipulator;  ►NGenVector_detail;  ►CBitReproducible;  CDB8;  CBitReproducibleException;  ►Ngv_detail;  CERROR_This_Rotation_Conversion_is_NOT_Supported;  ►NImpl;  CPlane3DClass describing a geometrical plane in 3 dimensions ;  CTransform3DBasic 3D Transformation class describing a rotation and then a translation The internal data are a 3D rotation data (represented as a 3x3 matrix) and a 3D vector data ;  CTranslation3DClass describing a 3 dimensional translation ;  ►NRootsRoot-Finding Algorithms ;  CBisectionRoots::Bisection Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one ;  CBrentBrent-Dekker algorithm which combines an interpolation strategy with the bisection algorithm See the GSL manual for more information ;  CFalsePosFalse Position algorithm based on linear interpolation ;  CNewtonNewton algorithm, which computes the derivative at each iteration See the GSL manual for more information ;  CSecantSecant algorithm, simplified version of Newton method, which does not require the derivative at every step ;  CSteffensonSteffenson method, providing the fastes convergence ;  ►NrowOffsetsUtils;  Cindices;  Cmake_indices;  Cmake_indices_impl;  Cmake_indices_impl< I, indices< Indices.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:24651,simpl,simplest,24651,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,8,['simpl'],"['simplest', 'simplified']"
Usability,"F, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:769413,guid,guide,769413,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"F1.h"" // we'll need this later...; #include ""TFile.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TTreeReader.h""; #include ""TTreeReaderArray.h"". void effX() {; TEfficiency* eff; = new TEfficiency(""eff"", ""Moun trigger efficiency"", 100, 0., 10.);. TFile* file; = TFile::Open(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; TTreeReader reader(""MyTree"", file);. TTreeReaderArray<double> raPt(reader, ""muons.fPt"");; TTreeReaderArray<bool> raTriggered(reader, ""muons.fTriggered"");. while (reader.Next()) {; // Select a tag muon between [0..numberOfMuons[.; int tagMuon = gRandom->Integer(raPt.GetSize());; if (raTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = raPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; // Fill the efficiency object with; // - whether this muon has triggered; // - the pT of this muon.; eff->Fill(???);; }; }; }; }. eff->Draw();; }. . ‹ 7. Using the TTreeReader; up; 9. Fitting By Coding ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/8-efficiency-calculation.html:5857,guid,guidelines,5857,d/8-efficiency-calculation.html,https://root.cern,https://root.cern/d/8-efficiency-calculation.html,1,['guid'],['guidelines']
Usability,"FALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooThresholdCategory.html:2062,clear,clearValueDirty,2062,root/html526/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html526/RooThresholdCategory.html,1,['clear'],['clearValueDirty']
Usability,"FALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34199,simpl,simple,34199,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['simpl'],['simple']
Usability,"FATAL << ""Cannot parse number \"""" << fValidationSize << ""\"". Expected string like \""0.2\"" or \""100\"".""; 642 << Endl;; 643 }; 644 ; 645 // Value validation; 646 // ----------------; 647 if (nValidationSamples < 0) {; 648 Log() << kFATAL << ""Validation size \"""" << fValidationSize << ""\"" is negative."" << Endl;; 649 }; 650 ; 651 if (nValidationSamples == 0) {; 652 Log() << kFATAL << ""Validation size \"""" << fValidationSize << ""\"" is zero."" << Endl;; 653 }; 654 ; 655 if (nValidationSamples >= (Int_t)trainingSetSize) {; 656 Log() << kFATAL << ""Validation size \"""" << fValidationSize; 657 << ""\"" is larger than or equal in size to training set (size=\"""" << trainingSetSize << ""\"")."" << Endl;; 658 }; 659 ; 660 return nValidationSamples;; 661}; 662 ; 663////////////////////////////////////////////////////////////////////////////////; 664 ; 665void TMVA::MethodDNN::Train(); 666{; 667 if (fInteractive && fInteractive->NotInitialized()){; 668 std::vector<TString> titles = {""Error on training set"", ""Error on test set""};; 669 fInteractive->Init(titles);; 670 // JsMVA progress bar maximum (100%); 671 fIPyMaxIter = 100;; 672 }; 673 ; 674 for (TTrainingSettings & settings : fTrainingSettings) {; 675 size_t nValidationSamples = GetNumValidationSamples();; 676 size_t nTrainingSamples = GetEventCollection(Types::kTraining).size() - nValidationSamples;; 677 size_t nTestSamples = nValidationSamples;; 678 ; 679 if (nTrainingSamples < settings.batchSize ||; 680 nValidationSamples < settings.batchSize ||; 681 nTestSamples < settings.batchSize) {; 682 Log() << kFATAL << ""Number of samples in the datasets are train: ""; 683 << nTrainingSamples << "" valid: "" << nValidationSamples; 684 << "" test: "" << nTestSamples << "". ""; 685 << ""One of these is smaller than the batch size of ""; 686 << settings.batchSize << "". Please increase the batch""; 687 << "" size to be at least the same size as the smallest""; 688 << "" of these values."" << Endl;; 689 }; 690 }; 691 ; 692 if (fArchitectureString == ""GPU"") {; 693 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:23312,progress bar,progress bar,23312,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"FUMILI will fail if one tries minimize \(\chi^2 = g^2(\vec\theta)\) where g is arbitrary function.; Approximate value is: ; \[{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\tag{5}; \]. Then the equations for parameter increments are ; \[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\tag{6}; \]. Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form: ; \[; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\tag{7}; \]. They form parallelepiped \(P\) ( \(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument. ; Definition at line 11 of file TFumili.h. Public Member Functions;  TFumili (Int_t maxpar=25);  ;  ~TFumili () override;  TFumili destructor. ;  ; void BuildArrays ();  Allocates memory for internal arrays. ;  ; Double_t Chisquare (Int_t npar, Double_t *params) const override;  return a chisquare equivalent ;  ; void Clear (Option_t *opt="""") override;  Resets all parameter names, values and errors to zero. ;  ; void DeleteArrays ();  Deallocates memory. Called from destructor TFumili::~TFumili. ;  ; void Derivatives (Double_t *, Double_t *);  Calculates partial derivatives of theoretical function. ;  ; Int_t Eval (Int_t &npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag);  Evaluate the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:3225,simpl,simple,3225,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['simpl'],['simple']
Usability,"Feedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:5548,feedback,feedback,5548,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,2,['feedback'],['feedback']
Usability,FileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:10623,learn,learning,10623,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,3,['learn'],['learning']
Usability,"FitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParametricFunctionMultiDim*fModelFunc; ROOT::Math::IBaseFunctionMultiDim*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); data are own here; if (fFitData) delete fFitData;. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBackCompFitter.html:12635,clear,clear,12635,root/html526/TBackCompFitter.html,https://root.cern,https://root.cern/root/html526/TBackCompFitter.html,9,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadPainter.html:5109,simpl,simple,5109,root/html528/TPadPainter.html,https://root.cern,https://root.cern/root/html528/TPadPainter.html,4,['simpl'],['simple']
Usability,"Float_t*fPhysicalShapeColor; Int_tfSelectedPart; TGLSelectionBufferfSelection; Int_tfSelectionBase; Bool_tfSelectionPass; Bool_tfUpdateSelection; TAxis*fXAxis; Double_tfXOYSectionPos; Double_tfXOZSectionPos; TAxis*fYAxis; Double_tfYOZSectionPos; TAxis*fZAxis; vector<Double_t>fZLevels. private:. const TColor*fPadColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. const TGLPlotBox& RefBackBox() const; { return fBackBox; }. void SetPhysicalShapeColor(const Float_t* rgba). void InitGL() const. void DeInitGL() const. void DrawPlot() const. Bool_t InitGeometry(); Init geometry does plot's specific initialization. void StartPan(Int_t px, Int_t py); Pan function is already declared in TVirtualGLPainter. void AddOption(const TString& stringOption); Add string option, it can be a digit in ""lego"" or ""surf"". void ProcessEvent(Int_t event, Int_t px, Int_t py); Function to process additional events (key presses, mouse clicks.). Bool_t CutAxisSelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPlotPainter.html:3492,Clear,Clear,3492,root/html532/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html532/TGLPlotPainter.html,2,['Clear'],['Clear']
Usability,"Fold 1: ROC int: 0.96584, BkgEff@SigEff=0.3: 0.975; ==> Wrote root file: TMVACV.root; ==> TMVACrossValidation is done!; (int) 0; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/CrossValidation.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Factory.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; // Helper function to load data into TTrees.; TTree *genTree(Int_t nPoints, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom3 rng(seed);; Float_t x = 0;; Float_t y = 0;; UInt_t eventID = 0;; ; TTree *data = new TTree();; data->Branch(""x"", &x, ""x/F"");; data->Branch(""y"", &y, ""y/F"");; data->Branch(""eventID"", &eventID, ""eventID/I"");; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Gaus(offset, scale);; y = rng.Gaus(offset, scale);; ; // For our simple example it is enough that the id's are uniformly; // distributed and independent of the data.; ++eventID;; ; data->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; data->ResetBranchAddresses();; return data;; }; ; int TMVACrossValidation(bool useRandomSplitting = false); {; // This loads the library; TMVA::Tools::Instance();; ; // --------------------------------------------------------------------------; ; // Load the data into TTrees. If you load data from file you can use a; // variant of; // ```; // TString filename = ""/path/to/file"";; // TFile * input = TFile::Open( filename );; // TTree * signalTree = (TTree*)input->Get(""TreeName"");; // ```; TTree *sigTree = genTree(1000, 1.0, 1.0, 100);; TTree *bkgTree = genTree(1000, -1.0, 1.0, 101);; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVACV.root"");; TFile *outputFile = TFile::Open(outfileName, ""RECREATE"");; ; // DataLoader definitions; We declare variables in the t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:19490,simpl,simple,19490,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['simpl'],['simple']
Usability,"Frame d5(""myTree"", files);; RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; RDataFrame d7(chain);; f#define f(i)Definition RSha256.hxx:104; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that will be generated by this RDataFrame. RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate Pythia events and write them to disk in parallel (with the Snapshot action).; For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):; auto df = ROOT::RDF::FromCSV(""input.csv"");; // use df as usual; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558. Filling a histogram; Let's now tackle a very common task, filling a histogram: // Fill a TH1D with the ""MET"" branch; RDataFrame d(""myTree"", ""file.root"");; auto h = d.Histo1D(""MET"");; h->Draw();; The first line creates an RDataFrame associated to the TTree ""myTree"". ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:15824,simpl,simple,15824,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"Frame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidChangeCursor(Event_t* event); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static voidFixBounds(Float_t& min, Float_t& max); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringGetSString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGDoubleSlider&operator=(const TGDoubleSlider&); TGDoubleSlider(const TGDoubleSlider&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditMod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDoubleSlider.html:15553,Clear,ClearFlags,15553,root/html602/TGDoubleSlider.html,https://root.cern,https://root.cern/root/html602/TGDoubleSlider.html,2,['Clear'],['ClearFlags']
Usability,"Frame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPgonEditor.html:23015,undo,undoing,23015,root/html604/TGeoPgonEditor.html,https://root.cern,https://root.cern/root/html604/TGeoPgonEditor.html,2,['undo'],['undoing']
Usability,"Frame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgonEditor.html:23015,undo,undoing,23015,root/html602/TGeoPgonEditor.html,https://root.cern,https://root.cern/root/html602/TGeoPgonEditor.html,2,['undo'],['undoing']
Usability,"Frame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHypeEditor.html:21468,undo,undoing,21468,root/html534/TGeoHypeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoHypeEditor.html,2,['undo'],['undoing']
Usability,"Frame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd2Editor.html:22228,undo,undoing,22228,root/html604/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html604/TGeoTrd2Editor.html,2,['undo'],['undoing']
Usability,"Frame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd2Editor.html:22228,undo,undoing,22228,root/html602/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html602/TGeoTrd2Editor.html,2,['undo'],['undoing']
Usability,"Frame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300). » Author: Anna Kreshuk 18/07/2008 » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressMemoryPlot.html:24338,Clear,Clear,24338,root/html602/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html602/TProofProgressMemoryPlot.html,4,['Clear'],['Clear']
Usability,"Fs into a series of variations that are joined together into a RooSimultaneous PDF. . Splitting a single PDF; The simplest use case is to take a workspace PDF as prototype and ""split"" a parameter of that PDF into two specialized parameters depending on a category in the dataset.; For example, given a Gaussian PDF \( G(x \,|\, m,s) \) we want to construct a \( G_a(x \,|\, m_a,s) \) and a \( G_b(x \,|\, m_b,s) \) with different mean parameters to be fit to a dataset with observables \( (x,c) \) where \( c \) is a category with states 'a' and 'b'.; Using RooSimWSTool, one can create a simultaneous PDF from \( G_a \) and \( G_b \) from \( G \) with the following commands: RooSimWSTool wst(wspace);; wst.build(""G_sim"", ""G"", SplitParam(""m"",""c""));; RooSimWSToolThe RooSimWSTool is a tool operating on RooWorkspace objects that can clone PDFs into a series of var...Definition RooSimWSTool.h:38; Splitting using a product category; From this simple example one can go to builds of arbitrary complexity by specifying multiple SplitParam arguments on multiple parameters involving multiple splitting categories. Splits can also be performed in the product of multiple categories, i.e., wst.build(""G_sim"", ""G"", SplitParam(""m"",""c,d""));; splits the parameter \( m \) in the product of the states of \( c \) and \( d \).; Constrained split; Another possibility is the ""constrained"" split, which clones the parameter for all but one state and inserts a formula specialization in a chosen state that evaluates to \( 1 - \sum_i(a_i) \) where \( a_i \) are all other specializations. For example, given a category \( c \) with the states ""A"",""B"",""C"",""D"", the specification SplitParamConstrained(""m"",""c"",""D""); will create the parameters \( m_A,m_B,m_C \) and a formula expression \( m_D \) that evaluates to \( (1-(m_A+m_B+m_C)) \). Constrained splits can also be specified in the product of categories. In that case, the name of the remainder state follows the syntax ""{State1;State2}"", where State1 and State2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:1309,simpl,simple,1309,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,1,['simpl'],['simple']
Usability,"Function Members (Methods); public:. THnT<unsigned short>(); THnT<unsigned short>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned short>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_unsigned_short_.html:2275,Clear,Clear,2275,root/html534/THnT_unsigned_short_.html,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html,1,['Clear'],['Clear']
Usability,"Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. RooAbsArg(); Default constructor. RooAbsArg(const char* name, const char* title); Create an object with the specified name and descriptive title.; The newly created object has no clients or servers and has its; dirty flags set. RooAbsArg(const RooAbsArg& other, const char* name = 0); Copy constructor transfers all boolean and string properties of the original; object. Transient properties and client-server links are not copied. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:21347,clear,clear,21347,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,4,['clear'],['clear']
Usability,"Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; NCycles <integer> Number of training cycles (too many cycles could overtrain the network); HiddenLayers <string> Layout of the hidden layers (nodes per layer); * specifiactions for each hidden layer are separated by commata; * for each layer the number of nodes can be either absolut (simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weigh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:19179,simpl,simply,19179,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,4,['simpl'],['simply']
Usability,"Function documentation; TGLFont(); Constructor. TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); Constructor. TGLFont(const TGLFont& o); Assignment operator. ~TGLFont(); Destructor. void CopyAttributes(const TGLFont& o); Assignment operator. Float_t GetAscent() const; Get font's ascent. Float_t GetDescent() const; Get font's descent. The returned value is positive. Float_t GetLineHeight() const; Get font's line-height. void MeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Measure font's base-line parameters from the passed text.; Note that the measured parameters are not the same as the ones; returned by get-functions - those were set by the font designer. void BBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; Get bounding box. void Render(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; mgn is simply ignored, because ROOT's TVirtualX TGX11 are complete mess with; painting attributes. void Render(const TString& txt) const; Render text. void PreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; Set-up GL state before FTFont rendering. void PostRender() const; Reset GL state after FTFont rendering. TGLFont& operator=(const TGLFont& o). Int_t GetSize() const; { return fSize;}. Int_t GetFile() const; { return fFile;}. EMode GetMode() const; { return fMode;}. Int_t GetTrashCount() const; { return fTrashCount; }. void SetTrashCount(Int_t c) const; { fTrashCount = c; }. Int_t IncTrashCount() const; { return ++fTrashCount; }. void SetFont(FTFont* f); { fFont =f;}. const FTFont* GetFont() const; { return fFont; }. void SetManager(TGLFontManager* mng); { fManager = mng; }. const TGLFontManager* GetManager() const; { return fManager; }. Float_t GetDepth() const; { return fDepth; }. void SetDepth(Float_t d); { fDepth = d; }. void Render(const char* txt, Double_t x, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLFont.html:3491,simpl,simply,3491,root/html528/TGLFont.html,https://root.cern,https://root.cern/root/html528/TGLFont.html,4,['simpl'],['simply']
Usability,"FunctionMinimizerBase common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CQuad12F;  CQuad1F;  CQuad4F;  CQuad4FGrad;  CQuad8F;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) ;  CVaria",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:63858,simpl,simplex,63858,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['simpl'],['simplex']
Usability,"G). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all the subtasks of a task. void ls(Option_t* option = ""*"") const; List the tree of tasks.; Indentation is used to identify the task tree. void Add(TTask* task); {fTasks->Add(task);}. Int_t GetBreakin() const; { return fBreakin; }. Int_t GetBreakout() const; { return fBreakout; }. Bool_t IsActive() const; { return fActive; }. Bool_t IsFolder() const; { return kTRUE; }. void SetActive(Bool_t active = kTRUE); { fActive = active; }. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTask.html:10350,Resume,Resume,10350,root/html532/TTask.html,https://root.cern,https://root.cern/root/html532/TTask.html,4,['Resume'],['Resume']
Usability,"GBAPalette*TEveCaloViz::AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; Bool_tTEveCaloViz::CellInEtaPhiRng(TEveCaloData::CellData_t&) const; virtual voidTEveCaloViz::CellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCalo3D.html:2518,Clear,ClearStamps,2518,root/html532/TEveCalo3D.html,https://root.cern,https://root.cern/root/html532/TEveCalo3D.html,8,['Clear'],['ClearStamps']
Usability,"GC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrapEditor.html:21872,undo,undoing,21872,root/html528/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTrapEditor.html,1,['undo'],['undoing']
Usability,"GC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTrapEditor.html:21972,undo,undoing,21972,root/html530/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTrapEditor.html,1,['undo'],['undoing']
Usability,"GC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrapEditor.html:21972,undo,undoing,21972,root/html532/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTrapEditor.html,2,['undo'],['undoing']
Usability,"GC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Create progress bar. void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGProgressBar.html:21007,progress bar,progress bar,21007,root/html602/TGProgressBar.html,https://root.cern,https://root.cern/root/html602/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"GC; static const TGGC*fgDefaultSelectedGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEntry(const TGWindow* p, TGTextBuffer* text, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a text entry widget. It will adopt the TGTextBuffer object; (i.e. the text buffer will be deleted by the text entry widget). TGTextEntry(const TGWindow* parent = 0, const char* text = 0, Int_t id = -1); Simple text entry constructor. TGTextEntry(const TString& contents, const TGWindow* parent, Int_t id = -1); Simple test entry constructor. Notice TString argument comes before the; parent argument (to make this ctor different from the first one taking a; const char*). ~TGTextEntry(); Delete a text entry widget. void Init(); Do default initialization. TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void ReturnPressed(); This signal is emitted when the return or enter key is pressed. void ShiftTabPressed(); This signal is emitted when <SHIFT> and <TAB> keys are pressed. void TabPressed(); This signal is emitted when the <TAB> key is pressed. void TextChanged(const char* text = 0); This signal is emitted every time the text has changed. void CursorOutLeft(); This signal is emitted when cursor is going out of left side. void CursorOutRight(); This signal is emitted when cursor is going out of right side. void CursorOutUp(); This signal is emitted whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEntry.html:27652,Simpl,Simple,27652,root/html602/TGTextEntry.html,https://root.cern,https://root.cern/root/html602/TGTextEntry.html,2,['Simpl'],['Simple']
Usability,"GCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGSplitFrame*fSecondPointer to the second child (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGSplitTool*fSplitToolSplitFrame Tool; TGSplitter*fSplitterPointer to the (H/V) Splitter (if any); TGTransientFrame*fUndockedMain frame used when ""undocking"" frame; Float_tfWRatioWidth ratio between the first child and this; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSplitFrame.html:18671,undo,undocking,18671,root/html528/TGSplitFrame.html,https://root.cern,https://root.cern/root/html528/TGSplitFrame.html,10,['undo'],['undocking']
Usability,"GFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidValueChanged(Long_t val)SIGNAL ; virtual voidValueSet(Long_t val)SIGNAL ; Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGNumberEntry(const TGNumberEntry&); TGNumberEntry&operator=(const TGNumberEntry&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGNumberEntry.html:19385,Clear,ClearFlags,19385,root/html532/TGNumberEntry.html,https://root.cern,https://root.cern/root/html532/TGNumberEntry.html,2,['Clear'],['ClearFlags']
Usability,"GFrame::UnmapWindow(); virtual voidUpdate(const char* path); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGComboBox::Init(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; static TGWindow::EEditModeTGWindow::kEditDisableHeig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFSComboBox.html:16958,Clear,ClearFlags,16958,root/html602/TGFSComboBox.html,https://root.cern,https://root.cern/root/html602/TGFSComboBox.html,2,['Clear'],['ClearFlags']
Usability,"GFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1Editor.html:21285,undo,undoing,21285,root/html534/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html,2,['undo'],['undoing']
Usability,"GFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoRotationEditor.html:22902,undo,undoing,22902,root/html604/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html604/TGeoRotationEditor.html,2,['undo'],['undoing']
Usability,"GFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoRotationEditor.html:22902,undo,undoing,22902,root/html602/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html602/TGeoRotationEditor.html,2,['undo'],['undoing']
Usability,"GFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:49; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGDockableFrame.html:22260,undo,undock,22260,root/html604/TGDockableFrame.html,https://root.cern,https://root.cern/root/html604/TGDockableFrame.html,2,['undo'],['undock']
Usability,"GFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:50; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDockableFrame.html:22291,undo,undock,22291,root/html602/TGDockableFrame.html,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html,2,['undo'],['undock']
Usability,"GGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHProgressBar.html:21848,progress bar,progress bar,21848,root/html602/TGHProgressBar.html,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html,6,"['Simpl', 'progress bar']","['Simple', 'progress bar']"
Usability,"GHtmlElement *pEnd, int width, int minX, int *actualWidth);  This routine gathers as many tokens as will fit on one line. ;  ; int InWrapAround ();  Return TRUE (non-zero) if we are currently wrapping text around one or more images. ;  ; void Paragraph (TGHtmlElement *p);  Increase the headroom to create a paragraph break at the current token. ;  ; void PopExpiredMargins (SHtmlMargin_t **ppMarginStack, int y);  Pop all expired margins from the stack. ;  ; void PopMargin (SHtmlMargin_t **ppMargin, int tag);  Pop as many margins as necessary until the margin that was created with ""tag"" is popped off. ;  ; void PopOneMargin (SHtmlMargin_t **ppMargin);  Pop one margin off of the given margin stack. ;  ; void PushMargin (SHtmlMargin_t **ppMargin, int indent, int bottom, int tag);  Push a new margin onto the given margin stack. ;  ; TGHtmlElement * TableLayout (TGHtmlTable *p);  Do all layout for a single table. ;  ; void WidenLine (int reqWidth, int *pX, int *pY, int *pW);  Move past obstacles until a linewidth of reqWidth is obtained, or until all obstacles are cleared. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlLayoutContext.html:10519,clear,cleared,10519,doc/master/classTGHtmlLayoutContext.html,https://root.cern,https://root.cern/doc/master/classTGHtmlLayoutContext.html,1,['clear'],['cleared']
Usability,"GLSavePNG; kGLSaveGIF; kGLSaveAnimGIF; kGLSaveJPG; kGLSaveAS; kGLCloseViewer; kGLQuitROOT; kGLEditObject; kGLHideMenus; };; enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSAViewer.html:20193,guid,guides,20193,root/html528/TGLSAViewer.html,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html,6,['guid'],['guides']
Usability,"GLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0); Constructor. ~TSceneInfo(); Destructor. void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearAfterRebuild(); Clear DrawElementVector fVisibleElement and optionally resize it; so that it doesn't take more space then required by all the; elements in the scene's draw-list. void ClearAfterUpdate(); Clear DrawElementPtrVectors and optionally resize them so that; they don't take more space then required by all the elements in; the scene's draw-list. void Lodify(TGLRnrCtx& ctx); Quantize LODs for gice render-context. void PreDraw(); Prepare for drawing - fill DrawElementPtrVectors from the; contents of fVisibleElements if there was some change. void PostDraw(); Clean-up after drawing, nothing to be done here. void ResetDrawStats(); Reset draw statistics. void UpdateDrawStats(const TGLPhysicalShape& shape, Short_t lod); Update draw stats, for newly drawn 'shape'. void DumpDrawStats(); Output draw stats to Info stream. TGLScene& operator=(const TGLScene::TSceneInfo& ). Bool_t CmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0). » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene__TSceneInfo.html:6803,Clear,ClearAfterUpdate,6803,root/html602/TGLScene__TSceneInfo.html,https://root.cern,https://root.cern/root/html602/TGLScene__TSceneInfo.html,2,['Clear'],"['Clear', 'ClearAfterUpdate']"
Usability,"GLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0); Constructor. ~TSceneInfo(); Destructor. void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearAfterRebuild(); Clear DrawElementVector fVisibleElement and optionally resize it; so that it doesn't take more space then required by all the; elements in the scene's draw-list. void ClearAfterUpdate(); Clear DrawElementPtrVectors and optionally resize them so that; they don't take more space then required by all the elements in; the scene's draw-list. void Lodify(TGLRnrCtx& ctx); Quantize LODs for gice render-context. void PreDraw(); Prepare for drawing - fill DrawElementPtrVectors from the; contents of fVisibleElements if there was some change. void PostDraw(); Clean-up after drawing, nothing to be done here. void ResetDrawStats(); Reset draw statistics. void UpdateDrawStats(const TGLPhysicalShape& shape, Short_t lod); Update draw stats, for newly drawn 'shape'. void DumpDrawStats(); Output draw stats to Info stream. TGLScene& operator=(const TGLScene::TSceneInfo& ). Bool_t CmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0). » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLScene__TSceneInfo.html:6803,Clear,ClearAfterUpdate,6803,root/html604/TGLScene__TSceneInfo.html,https://root.cern,https://root.cern/root/html604/TGLScene__TSceneInfo.html,2,['Clear'],"['Clear', 'ClearAfterUpdate']"
Usability,"GWindow* parent, Int_t w, Int_t h); virtual~TSessionFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidCheckAutoEnPack(Bool_t checked = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionFrame.html:1492,Clear,Clear,1492,root/html532/TSessionFrame.html,https://root.cern,https://root.cern/root/html532/TSessionFrame.html,2,['Clear'],['Clear']
Usability,"Generator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, const RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return kTRUE ; }. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; { return _pdfList ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Mon Dec 7 13:48:43 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:53032,intuit,intuitively,53032,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['intuit'],['intuitively']
Usability,"Geo objects. Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together.; ; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the “Apply” button only if the check button “Delayed draw” is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “Undo” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1036699,Undo,Undo,1036699,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Undo'],['Undo']
Usability,"GeoGenTrans(const char *name) : TGeoCombiTrans(name); 2244{; 2245 SetBit(kGeoGenTrans);; 2246 for (Int_t i = 0; i < 3; i++); 2247 fTranslation[i] = 0.0;; 2248 for (Int_t j = 0; j < 3; j++); 2249 fScale[j] = 1.0;; 2250 fRotation = nullptr;; 2251}; 2252 ; 2253////////////////////////////////////////////////////////////////////////////////; 2254/// constructor; 2255 ; 2256TGeoGenTrans::TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz,; 2257 TGeoRotation *rot); 2258 : TGeoCombiTrans(""""); 2259{; 2260 SetBit(kGeoGenTrans);; 2261 SetTranslation(dx, dy, dz);; 2262 SetScale(sx, sy, sz);; 2263 SetRotation(rot);; 2264}; 2265 ; 2266////////////////////////////////////////////////////////////////////////////////; 2267/// constructor; 2268 ; 2269TGeoGenTrans::TGeoGenTrans(const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy,; 2270 Double_t sz, TGeoRotation *rot); 2271 : TGeoCombiTrans(name); 2272{; 2273 SetBit(kGeoGenTrans);; 2274 SetTranslation(dx, dy, dz);; 2275 SetScale(sx, sy, sz);; 2276 SetRotation(rot);; 2277}; 2278 ; 2279////////////////////////////////////////////////////////////////////////////////; 2280/// destructor; 2281 ; 2282TGeoGenTrans::~TGeoGenTrans() {}; 2283 ; 2284////////////////////////////////////////////////////////////////////////////////; 2285/// clear the fields of this transformation; 2286 ; 2287void TGeoGenTrans::Clear(Option_t *); 2288{; 2289 memset(&fTranslation[0], 0, kN3);; 2290 memset(&fScale[0], 0, kN3);; 2291 if (fRotation); 2292 fRotation->Clear();; 2293}; 2294 ; 2295////////////////////////////////////////////////////////////////////////////////; 2296/// set the scale; 2297 ; 2298void TGeoGenTrans::SetScale(Double_t sx, Double_t sy, Double_t sz); 2299{; 2300 if (sx < 1.E-5 || sy < 1.E-5 || sz < 1.E-5) {; 2301 Error(""ctor"", ""Invalid scale"");; 2302 return;; 2303 }; 2304 fScale[0] = sx;; 2305 fScale[1] = sy;; 2306 fScale[2] = sz;; 2307}; 2308 ; 2309/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:79168,clear,clear,79168,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['clear'],['clear']
Usability,"GeoGtra&); TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:2260,Clear,Clear,2260,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,1,['Clear'],['Clear']
Usability,GeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector&); voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoIterator.html:4338,resume,resume,4338,root/html534/TGeoIterator.html,https://root.cern,https://root.cern/root/html534/TGeoIterator.html,2,['resume'],['resume']
Usability,"GeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 40116 2011-07-04 12:00:32Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGenTrans.html:15721,clear,clear,15721,root/html532/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"GetColor(volume->GetLineColor());; 1170 ; 1171 if (volume->GetMedium() && (volume->GetMedium() != TGeoVolume::DummyMedium()) &&; 1172 volume->GetMedium()->GetMaterial()) {; 1173 auto material = volume->GetMedium()->GetMaterial();; 1174 ; 1175 node.material = material->GetName();; 1176 ; 1177 auto fillstyle = material->GetFillStyle();; 1178 if ((fillstyle >= 3000) && (fillstyle <= 3100)); 1179 node.opacity = (3100 - fillstyle) / 100.;; 1180 if (!col); 1181 col = gROOT->GetColor(material->GetFillColor());; 1182 } else {; 1183 node.material.clear();; 1184 }; 1185 ; 1186 if (col) {; 1187 TString colbuf;; 1188 colbuf.Form(""#%02x%02x%02x"", (int)(col->GetRed() * 255), (int)(col->GetGreen() * 255),; 1189 (int)(col->GetBlue() * 255));; 1190 node.color = colbuf.Data();; 1191 if (node.opacity == 1.); 1192 node.opacity = col->GetAlpha();; 1193 } else {; 1194 node.color.clear();; 1195 }; 1196}; 1197 ; 1198/////////////////////////////////////////////////////////////////////; 1199/// Reset shape info, which used to pack binary data; 1200 ; 1201void RGeomDescription::ResetRndrInfos(); 1202{; 1203 for (auto &s : fShapes); 1204 s.reset();; 1205}; 1206 ; 1207/////////////////////////////////////////////////////////////////////; 1208/// Produce JSON string which can be directly used with `build`; 1209/// function from JSROOT to create three.js model of configured geometry; 1210///; 1211/// Collect all information required to draw geometry on the client; 1212/// This includes list of each visible nodes, meshes and matrixes; 1213/// If @param all_nodes is true, all existing nodes will be provided,; 1214/// which allows to create complete nodes hierarchy on client side; 1215///; 1216/// Example of usage:; 1217///; 1218/// void geom() {; 1219/// auto f = TFile::Open(""file_name.root"");; 1220/// auto vol = f->Get<TGeoVolume>(""object_name"");; 1221/// ROOT::RGeomDescription desc;; 1222/// desc.Build(vol);; 1223/// std::ofstream fout(""geom.json"");; 1224/// fout << desc.ProduceJson();; 1225/// }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:35979,clear,clear,35979,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3929,simpl,simple,3929,doc/master/df017__vecOpsHEP_8C.html,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html,1,['simpl'],['simple']
Usability,"GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 5504 // pixel = eta * log10(V) - alpha; 5505 // where eta = nPixels/(log10(Vmax)-log10(Vmin)); 5506 // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); 5507 // and V is axis value; 5508 Double_t eta = (nPixels-1.0)/(TMath::Log10(xMax) - TMath::Log10(xMin));; 5509 Double_t offset = -1.0 * eta * TMath::Log10(xMin);; 5510 ; 5511 for (Int_t bin=pAxis->GetFirst()+binOffset; bin<=pAxis->GetLast(); bin++) {; 5512 ; 5513 // linear plot. we simply need to find the appropriate bin; 5514 // for the; 5515 Double_t xLowValue = pAxis->GetBinLowEdge(bin);; 5516 Double_t xUpValue = pAxis->GetBinUpEdge(bin);; 5517 Int_t xPx0 = eta*TMath::Log10(xLowValue)+ offset;; 5518 Int_t xPx1 = eta*TMath::Log10(xUpValue) + offset;; 5519 THistRenderingRegion region = {std::make_pair(xPx0, xPx1),; 5520 std::make_pair(bin, bin+1)};; 5521 regions.push_back(region);; 5522 }; 5523 ; 5524 } else {; 5525 ; 5526 // loop over pixels; 5527 ; 5528 Double_t beta = (TMath::Log10(xMax) - TMath::Log10(xMin))/(nPixels-1.0);; 5529 ; 5530 for (Int_t pixelIndex=0; pixelIndex<(nPixels-1); pixelIndex++) {; 5531 // linear plot; 5532 Int_t binLow = pAxis->FindBin(xMin*TMath::Power(10.0, beta*pixelIndex));; 5533 Int_t binHigh = pAxis->FindBin(xMin*TMath::Power(10.0, beta*(pixelIndex+1)));; 5534 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5535 std::make_pair(binLow, binHigh)};; 5536 regions.push_back(region);; 5537 }; 5538 }; 5539 } else {; 5540 // standard linear plot; 5541 ; 5542 if (strategy == Bins) {; 5543 // loop over bins; 5544 for (Int_t bin=pAxis->GetFirst(); bin<=pAxis->GetLast(); bin++) {; 5545 ; 5546 // linear plot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:206189,simpl,simply,206189,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simply']
Usability,"GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. TStructViewerGUI(TStructViewer* parent, TStructNode* nodePtr, TList* colors, const TGWindow* p = __null, UInt_t w = 800, UInt_t h = 600). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStructViewerGUI.html:29194,Clear,Clear,29194,root/html604/TStructViewerGUI.html,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html,4,"['Clear', 'Undo']","['Clear', 'Undo', 'UndoButton', 'UndoButtonSlot']"
Usability,"GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. TStructViewerGUI(TStructViewer* parent, TStructNode* nodePtr, TList* colors, const TGWindow* p = __null, UInt_t w = 800, UInt_t h = 600). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStructViewerGUI.html:29194,Clear,Clear,29194,root/html602/TStructViewerGUI.html,https://root.cern,https://root.cern/root/html602/TStructViewerGUI.html,4,"['Clear', 'Undo']","['Clear', 'Undo', 'UndoButton', 'UndoButtonSlot']"
Usability,"GetSessionTag(). const char * TProofServ::GetSessionTag ; (; ); const. inline . Definition at line 245 of file TProofServ.h. ◆ GetSocket(). TSocket * TProofServ::GetSocket ; (; ); const. inline . Definition at line 257 of file TProofServ.h. ◆ GetTopSessionTag(). const char * TProofServ::GetTopSessionTag ; (; ); const. inline . Definition at line 246 of file TProofServ.h. ◆ GetTotSessions(). Int_t TProofServ::GetTotSessions ; (; ); const. inline . Definition at line 262 of file TProofServ.h. ◆ GetUser(). const char * TProofServ::GetUser ; (; ); const. inline . Definition at line 241 of file TProofServ.h. ◆ GetVirtMemMax(). Long_t TProofServ::GetVirtMemMax ; (; ). static . VirtMemMax getter. ; Definition at line 6920 of file TProofServ.cxx. ◆ GetWorkDir(). const char * TProofServ::GetWorkDir ; (; ); const. inline . Definition at line 243 of file TProofServ.h. ◆ GetWorkers(). TProofServ::EQueryAction TProofServ::GetWorkers ; (; TList * ; workers, . Int_t & ; prioritychange, . Bool_t ; resume = kFALSE . ). virtual . Get list of workers to be used from now on. ; The list must be provided by the caller. ; Definition at line 5692 of file TProofServ.cxx. ◆ HandleArchive(). void TProofServ::HandleArchive ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle archive request. ; Definition at line 3597 of file TProofServ.cxx. ◆ HandleCache(). Int_t TProofServ::HandleCache ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here all cache and package requests. ; Definition at line 5280 of file TProofServ.cxx. ◆ HandleCheckFile(). void TProofServ::HandleCheckFile ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle file checking request. ; Definition at line 5129 of file TProofServ.cxx. ◆ HandleDataSets(). Int_t TProofServ::HandleDataSets ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here requests about datasets. ; Definition at line 6087 of file TProofServ.cxx. ◆ HandleException",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:43589,resume,resume,43589,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['resume'],['resume']
Usability,"Getter;  Helper to get the contents of a given column. More...;  ; class  RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  RInterface;  The public interface to the RDataFrame federation of classes. More...;  ; class  RInterfaceBase;  ; class  RLazyDS;  A RDataSource implementation which is built on top of result proxies. More...;  ; class  RResultHandle;  A type-erased version of RResultPtr and RResultMap. More...;  ; class  RResultPtr;  Smart pointer for the return type of actions. More...;  ; class  RSampleInfo;  This type represents a sample identifier, to be used in conjunction with RDataFrame features such as DefinePerSample() and per-sample callbacks. More...;  ; struct  RSnapshotOptions;  A collection of options to steer the creation of the dataset on file. More...;  ; class  RSqliteDS;  RSqliteDS is an RDF data source implementation for SQL result sets from sqlite3 files. More...;  ; class  RTrivialDS;  A simple data-source implementation, for demo purposes. More...;  ; class  RVariationsDescription;  A descriptor for the systematic variations known to a given RDataFrame node. More...;  ; class  TCutInfo;  ; class  TH1DModel;  A struct which stores the parameters of a TH1D. More...;  ; class  TH2DModel;  A struct which stores the parameters of a TH2D. More...;  ; class  TH3DModel;  A struct which stores the parameters of a TH3D. More...;  ; class  THnDModel;  A struct which stores the parameters of a THnD. More...;  ; class  TProfile1DModel;  A struct which stores the parameters of a TProfile. More...;  ; class  TProfile2DModel;  A struct which stores the parameters of a TProfile2D. More...;  ; class  VerifyValidColumnType;  Helper to determine if a given Column is a supported type. More...;  . Typedefs; using ColumnNames_t = std::vector< std::string >;  ; using RNode = RInterface<::ROOT::Detail::RDF::RNodeBase, void >;  ; using SampleCallback_t = std::function< void(unsigned int, const ROOT::RDF::R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:1715,simpl,simple,1715,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['simpl'],['simple']
Usability,"Getting the right parameter errors with limits. 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.5.1 Statistical interpretation; 6.5.2 The reliability of M error estimates. 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:6082,guid,guidance,6082,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['guid'],['guidance']
Usability,"GraphPolar example"");; ; grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);; ; grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");; ; // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37. Colors automatically picked in palette; SinceROOT version 6.09/01; When several graphs are painted in the same canvas or when a multi-graph is drawn, it might be useful to have an easy and automatic way to choose their color. The simplest way is to pick colors in the current active color palette. Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and PMC (Palette Marker Color). When one of these options is given to TGraph::Draw the graph get its color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of objects having palette coloring in the current pad.; ; void graphpalettecolor () {; ; gStyle->SetOptTitle(kFALSE);; gStyle->SetPalette(kSolar);; ; double x[5] = {1,2,3,4,5};; double y1[5] = {1.0,2.0,1.0,2.5,3.0};; double y2[5] = {1.1,2.1,1.1,2.6,3.1};; double y3[5] = {1.2,2.2,1.2,2.7,3.2};; double y4[5] = {1.3,2.3,1.3,2.8,3.3};; double y5[5] = {1.4,2.4,1.4,2.9,3.4};; ; TGraph *g1 = new TGraph(5,x,y1); g1->SetTitle(""Graph with a red star"");; TGraph *g2 = new TGraph(5,x,y2); g2->SetTitle(""Graph with a circular marker"");; TGraph *g3 = new TGraph(5,x,y3); g3->SetTitle(""Graph with an open square marker"");; TGraph *g4 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:20386,simpl,simplest,20386,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['simpl'],['simplest']
Usability,"GraphPolar::GetYpolDouble_t * GetYpol()Return points in polar coordinates.Definition TGraphPolar.cxx:128; TGraphPolar::GetPolargramTGraphPolargram * GetPolargram()Definition TGraphPolar.h:39; TGraphPolar::GetOptionAxisBool_t GetOptionAxis()Definition TGraphPolar.h:42; TGraphPolar::SetPolargramvoid SetPolargram(TGraphPolargram *p)Definition TGraphPolar.h:50; TGraphPolar::SetOptionAxisvoid SetOptionAxis(Bool_t opt)Definition TGraphPolar.h:49; TGraphPolar::GetXpolDouble_t * GetXpol()Return points in polar coordinates.Definition TGraphPolar.cxx:119; TGraphPolargramTo draw polar axis.Definition TGraphPolargram.h:20; TGraphPolargram::GetRMinDouble_t GetRMin()Definition TGraphPolargram.h:77; TGraphPolargram::GetRMaxDouble_t GetRMax()Definition TGraphPolargram.h:78; TGraphPolargram::IsGradBool_t IsGrad()Definition TGraphPolargram.h:92; TGraphPolargram::IsDegreeBool_t IsDegree()Definition TGraphPolargram.h:90; TGraphPolargram::PaintCirclevoid PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta)This is simplified from TEllipse::PaintEllipse.Definition TGraphPolargram.cxx:373; TGraphPolargram::Drawvoid Draw(Option_t *options="""") overrideDraw Polargram.Definition TGraphPolargram.cxx:182; TGraphPolargram::kLabelOrtho@ kLabelOrthoDefinition TGraphPolargram.h:61; TGraphPolargram::GetTMinDouble_t GetTMin()Definition TGraphPolargram.h:80; TGraphPolargram::GetTMaxDouble_t GetTMax()Definition TGraphPolargram.h:81; TGraphQQThis class allows to draw quantile-quantile plots.Definition TGraphQQ.h:18; TGraphQQ::GetXq1Double_t GetXq1() constDefinition TGraphQQ.h:40; TGraphQQ::GetYq2Double_t GetYq2() constDefinition TGraphQQ.h:43; TGraphQQ::Classstatic TClass * Class(); TGraphQQ::GetXq2Double_t GetXq2() constDefinition TGraphQQ.h:41; TGraphQQ::GetFTF1 * GetF() constDefinition TGraphQQ.h:44; TGraphQQ::GetYq1Double_t GetYq1() constDefinition TGraphQQ.h:42; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:203440,simpl,simplified,203440,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simplified']
Usability,"GraphPolargram. ; Definition at line 327 of file TGraphPolargram.cxx. ◆ IsA(). TClass * TGraphPolargram::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 119 of file TGraphPolargram.h. ◆ IsDegree(). Bool_t TGraphPolargram::IsDegree ; (; ). inline . Definition at line 90 of file TGraphPolargram.h. ◆ IsGrad(). Bool_t TGraphPolargram::IsGrad ; (; ). inline . Definition at line 92 of file TGraphPolargram.h. ◆ IsRadian(). Bool_t TGraphPolargram::IsRadian ; (; ). inline . Definition at line 91 of file TGraphPolargram.h. ◆ Paint(). void TGraphPolargram::Paint ; (; Option_t * ; options = """"). overrideprivatevirtual . Paint TGraphPolargram. ; Reimplemented from TObject.; Definition at line 349 of file TGraphPolargram.cxx. ◆ PaintCircle(). void TGraphPolargram::PaintCircle ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; r, . Double_t ; phimin, . Double_t ; phimax, . Double_t ; theta . ). This is simplified from TEllipse::PaintEllipse. ; Draw this ellipse with new coordinates. ; Definition at line 373 of file TGraphPolargram.cxx. ◆ PaintPolarDivisions(). void TGraphPolargram::PaintPolarDivisions ; (; Bool_t ; optionLabels). private . Draw Polar divisions. ; Check for editable pad or create default. ; Definition at line 408 of file TGraphPolargram.cxx. ◆ PaintRadialDivisions(). void TGraphPolargram::PaintRadialDivisions ; (; Bool_t ; drawaxis). private . Paint radial divisions. ; Check for editable pad or create default. ; Definition at line 625 of file TGraphPolargram.cxx. ◆ ReduceFraction(). void TGraphPolargram::ReduceFraction ; (; Int_t ; Num, . Int_t ; Denom, . Int_t & ; rnum, . Int_t & ; rden . ). private . Reduce fractions. ; Definition at line 739 of file TGraphPolargram.cxx. ◆ SetAxisAngle(). void TGraphPolargram::SetAxisAngle ; (; Double_t ; angle = 0). Set axis angle. ; Definition at line 765 of file TGraphPolargram.cxx. ◆ SetNdivPolar(). void TGraphPolargram::SetNdivPolar ; (; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolargram.html:27142,simpl,simplified,27142,doc/master/classTGraphPolargram.html,https://root.cern,https://root.cern/doc/master/classTGraphPolargram.html,1,['simpl'],['simplified']
Usability,"H1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayC::AddAt(Char_t c, Int_t i); virtual voidTH3C::AddBinContent(Int_t bin); virtual voidTH3C::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidAddTH3(const TH3* hist, TGLTH3Composition::ETH3BinShape shape = kBox); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidTH3C::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH3C::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLTH3Composition.html:1508,Clear,Clear,1508,root/html532/TGLTH3Composition.html,https://root.cern,https://root.cern/root/html532/TGLTH3Composition.html,1,['Clear'],['Clear']
Usability,"H1Editor.h. ◆ f8. TGCompositeFrame* TH1Editor::f8. protected . Contains the Bar Chart CheckBox. ; Definition at line 63 of file TH1Editor.h. ◆ f9. TGCompositeFrame* TH1Editor::f9. protected . Contains the Bar Option CheckBox. ; Definition at line 64 of file TH1Editor.h. ◆ fAdd. TGCheckButton* TH1Editor::fAdd. protected . Activate more Options. ; Definition at line 53 of file TH1Editor.h. ◆ fAddB. TGCheckButton* TH1Editor::fAddB. protected . Draw a Bar Chart. ; Definition at line 51 of file TH1Editor.h. ◆ fAddBar. TGCheckButton* TH1Editor::fAddBar. protected . Bar Option. ; Definition at line 52 of file TH1Editor.h. ◆ fAddCombo. TGComboBox* TH1Editor::fAddCombo. protected . Add Lines, Bars, Fill. ; Definition at line 58 of file TH1Editor.h. ◆ fAddMarker. TGCheckButton* TH1Editor::fAddMarker. protected . Draw a Marker on top of each bin. ; Definition at line 50 of file TH1Editor.h. ◆ fAddSimple. TGCheckButton* TH1Editor::fAddSimple. protected . Draw a simple histogram (==HIST draw option) ; Definition at line 55 of file TH1Editor.h. ◆ fApply. TGTextButton* TH1Editor::fApply. protected . Apply-Button to accept the rebinned histogram. ; Definition at line 81 of file TH1Editor.h. ◆ fBarOffset. TGNumberEntry* TH1Editor::fBarOffset. protected . Change the Bar Offset. ; Definition at line 57 of file TH1Editor.h. ◆ fBarWidth. TGNumberEntry* TH1Editor::fBarWidth. protected . Change the Bar Width. ; Definition at line 56 of file TH1Editor.h. ◆ fBin. TGCompositeFrame* TH1Editor::fBin. protected . Contains the Binning Widgets. ; Definition at line 38 of file TH1Editor.h. ◆ fBinCont. TGCompositeFrame* TH1Editor::fBinCont. protected . Contains the Rebin Widgets for case 1. ; Definition at line 69 of file TH1Editor.h. ◆ fBinCont1. TGCompositeFrame* TH1Editor::fBinCont1. protected . Contains the Rebin Widgets for case 2. ; Definition at line 70 of file TH1Editor.h. ◆ fBinHist. TH1* TH1Editor::fBinHist. private . Definition at line 113 of file TH1Editor.h. ◆ fBinNumberEntry. TGNumber",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:55985,simpl,simple,55985,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"Handler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  Cclient_cert;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:91720,simpl,simple,91720,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['simpl'],['simple']
Usability,"Helper;  CVectorHelper< _M128 >;  CVectorHelper< _M128D >;  CVectorHelper< _M128I >;  CVectorHelper< double >;  CVectorHelper< float >;  CVectorHelper< float8 >;  CVectorHelper< int >;  CVectorHelper< M256 >;  CVectorHelper< signed short >;  CVectorHelper< unsigned int >;  CVectorHelper< unsigned short >;  CVectorHelperSize;  CVectorTraits;  CVectorTypeHelper;  CVectorTypeHelper< double >;  CVectorTypeHelper< float >;  CVectorTypeHelper< sfloat >;  CWriteMaskedVector;  C_MemorySizeCalculation;  CBinaryOperation;  CCpuIdThis class is available for x86 / AMD64 systems to read and interpret information about the CPU's capabilities ;  CDetermineEntryType;  CDetermineEntryType< sfloat >;  CImplementationT;  CMath;  CMath< double >;  CMath< float >;  CMemoryA helper class for fixed-size two-dimensional arrays ;  CMemory< V, 0u, 0u >A helper class that is very similar to Memory<V, Size> but with dynamically allocated memory and thus dynamic size ;  CMemory< V, Size, 0u >A helper class to simplify usage of correctly aligned and padded memory, allowing both vector and scalar access ;  CMemoryBaseCommon interface to all Memory classes, independent of allocation on the stack or heap ;  CMemoryDimensionBase;  CMemoryDimensionBase< V, Parent, 1, RowMemory >;  CMemoryDimensionBase< V, Parent, 2, RowMemory >;  CNegateTypeHelper;  CNegateTypeHelper< unsigned char >;  CNegateTypeHelper< unsigned int >;  CNegateTypeHelper< unsigned short >;  COperand;  Csfloat;  CTrigonometric;  CVectorPointerHelperHelper class for the Memory::vector(size_t) class of functions ;  CVectorPointerHelperConstHelper class for the Memory::vector(size_t) class of functions ;  C_ConfigurationConfiguration ------------------------------------------------------------— ;  C_ExpandMacroFunctionPut std namespace directly onto ROOT ----------------------------------—— ;  CModuleFacadeAllow loading ROOT classes as attributes ---------------------------------— ;  CRootNameCompleter;  ►CTAxisBaseHistogram axis base cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:68162,simpl,simplify,68162,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simplify']
Usability,"Helper~ProgressHelper()=default; ROOT::RDF::Experimental::ProgressHelper::fIsTTYbool fIsTTYDefinition RDFHelpers.hxx:347; ROOT::RDF::Experimental::ProgressHelper::fPrintMutexstd::mutex fPrintMutexDefinition RDFHelpers.hxx:346; ROOT::RDF::Experimental::ProgressHelper::fTotalFilesunsigned int fTotalFilesDefinition RDFHelpers.hxx:344; ROOT::RDF::Experimental::ProgressHelper::RecordEvtCountAndTimestd::pair< std::size_t, std::chrono::seconds > RecordEvtCountAndTime()Record current event counts and time stamp, populate evts/s statistics array.Definition RDFHelpers.cxx:174; ROOT::RDF::Experimental::ProgressHelper::registerNewSamplevoid registerNewSample(unsigned int, const ROOT::RDF::RSampleInfo &id)Register a new sample for completion statistics.Definition RDFHelpers.hxx:378; ROOT::RDF::Experimental::ProgressHelper::fUseShellColoursbool fUseShellColoursDefinition RDFHelpers.hxx:348; ROOT::RDF::Experimental::ProgressHelper::PrintProgressBarvoid PrintProgressBar(std::ostream &stream, std::size_t currentEventCount) constPrint a progress bar of width ProgressHelper::fBarWidth if fGetNEventsOfCurrentFile is known.Definition RDFHelpers.cxx:303; ROOT::RDF::Experimental::ProgressHelper::operator()void operator()(unsigned int, T &value)Thread-safe callback for RDataFrame.Definition RDFHelpers.hxx:389; ROOT::RDF::Experimental::ProgressHelper::PrintStatsvoid PrintStats(std::ostream &stream, std::size_t currentEventCount, std::chrono::seconds totalElapsedSeconds) constPrint event and time statistics.Definition RDFHelpers.cxx:225; ROOT::RDF::Experimental::ProgressHelper::fSampleNameToEventEntriesstd::map< std::string, ULong64_t > fSampleNameToEventEntriesDefinition RDFHelpers.hxx:338; ROOT::RDF::Experimental::ProgressHelper::fTreestd::shared_ptr< TTree > fTreeDefinition RDFHelpers.hxx:350; ROOT::RDF::Experimental::ProgressHelper::fIncrementstd::size_t fIncrementDefinition RDFHelpers.hxx:335; ROOT::RDF::Experimental::ProgressHelper::fLastProcessedEventsstd::size_t fLastProcessedEventsDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:23279,progress bar,progress bar,23279,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['progress bar'],['progress bar']
Usability,"Hintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2). void CloseWindow(). TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). virtual ~TUploadDataSetDlg(). void AddFiles(const char* fileName). void AddFiles(TList* fileList). void BrowseFiles(). void ClearFiles(). void RemoveFile(). void UploadDataSet(). void OnOverwriteDataset(Bool_t on). void OnOverwriteFiles(Bool_t on). void OnAppendFiles(Bool_t on). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUploadDataSetDlg.html:23122,Clear,ClearFiles,23122,root/html534/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html534/TUploadDataSetDlg.html,1,['Clear'],['ClearFiles']
Usability,"Histogram->GetYaxis()->GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:139335,clear,clear,139335,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['clear'],['clear']
Usability,"Hook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3509,Clear,Clear,3509,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,1,['Clear'],['Clear']
Usability,"I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. TProfile3D(); TProfile3D(const TProfile3D& profile); TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); TProfile3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup, Option_t* option = """"); virtual~TProfile3D(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH3D::AddBinContent(Int_t bin); virtual voidTH3D::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:2028,simpl,simple,2028,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,2,['simpl'],['simple']
Usability,"I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. virtual~TProfile3D(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH3D::AddBinContent(Int_t bin); virtual voidTH3D::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); static voidApproximate(Bool_t approx = kTRUE); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile3D.html:2028,simpl,simple,2028,root/html602/TProfile3D.html,https://root.cern,https://root.cern/root/html602/TProfile3D.html,4,['simpl'],['simple']
Usability,"ID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts"" ; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Timer.h 31458 2009-11-30 13:58:20Z stelzer $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Timer.html:7538,progress bar,progress bar,7538,root/html528/TMVA__Timer.html,https://root.cern,https://root.cern/root/html528/TMVA__Timer.html,2,['progress bar'],['progress bar']
Usability,"ID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts"" ; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Timer.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Timer.html:7607,progress bar,progress bar,7607,root/html532/TMVA__Timer.html,https://root.cern,https://root.cern/root/html532/TMVA__Timer.html,4,['progress bar'],['progress bar']
Usability,"IE_GNN_Parser.py;  ;  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ;  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ;  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ;  ;  TMVA_SOFIE_RDataFrame.py;   Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ;  ;  TMVA_SOFIE_RDataFrame_JIT.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_RSofieReader.C;   This macro pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3671,simpl,simple,3671,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability,"IOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Long_t size, void *arena);  ; typedef void *(* NewFunc_t) (voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:2844,simpl,simple,2844,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['simpl'],['simple']
Usability,"Impl_t::IsCudnn()); 2292 Warning(""ReadWeightsFromXML"",; 2293 ""Cannot use a reset gate after to false with CudNN - use implementation with resetgate=true"");; 2294 ; 2295 fNet->AddBasicGRULayer(stateSize, inputSize, timeSteps, rememberState, returnSequence, resetGateAfter);; 2296 }; 2297 // BatchNorm Layer; 2298 else if (layerName == ""BatchNormLayer"") {; 2299 // use some dammy value which will be overwrittem in BatchNormLayer::ReadWeightsFromXML; 2300 fNet->AddBatchNormLayer(0., 0.0);; 2301 }; 2302 // read weights and biases; 2303 fNet->GetLayers().back()->ReadWeightsFromXML(layerXML);; 2304 ; 2305 // read next layer; 2306 layerXML = gTools().GetNextChild(layerXML);; 2307 }; 2308 ; 2309 fBuildNet = false;; 2310 // create now the input and output matrices; 2311 //int n1 = batchHeight;; 2312 //int n2 = batchWidth;; 2313 // treat case where batchHeight is the batchSize in case of first Dense layers (then we need to set to fNet batch size); 2314 //if (fXInput.size() > 0) fXInput.clear();; 2315 //fXInput.emplace_back(MatrixImpl_t(n1,n2));; 2316 fXInput = ArchitectureImpl_t::CreateTensor(fNet->GetBatchSize(), GetInputDepth(), GetInputHeight(), GetInputWidth() );; 2317 if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1); 2318 // make here a ColumnMajor tensor; 2319 fXInput = TensorImpl_t( fNet->GetBatchSize(), GetInputWidth(),TMVA::Experimental::MemoryLayout::ColumnMajor );; 2320 fXInputBuffer = HostBufferImpl_t( fXInput.GetSize());; 2321 ; 2322 // create pointer to output matrix used for the predictions; 2323 fYHat = std::unique_ptr<MatrixImpl_t>(new MatrixImpl_t(fNet->GetBatchSize(), fNet->GetOutputWidth() ) );; 2324 ; 2325 ; 2326}; 2327 ; 2328 ; 2329////////////////////////////////////////////////////////////////////////////////; 2330void MethodDL::ReadWeightsFromStream(std::istream & /*istr*/); 2331{; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335const Ranking *TMVA::MethodDL::CreateRanking(); 233",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:92460,clear,clear,92460,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['clear'],['clear']
Usability,"In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPNEntry(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPNEntry.html:1854,Guid,Guide,1854,root/html532/TGeoPNEntry.html,https://root.cern,https://root.cern/root/html532/TGeoPNEntry.html,2,['Guid'],['Guide']
Usability,"In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhysicalNode(); voidTObject::AbstractMethod(const char* method) const; Bool_tAlign(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPhysicalNode.html:1886,Guid,Guide,1886,root/html534/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html,1,['Guid'],['Guide']
Usability,"In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhysicalNode(); voidTObject::AbstractMethod(const char* method) const; voidAlign(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPhysicalNode.html:1886,Guid,Guide,1886,root/html532/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html532/TGeoPhysicalNode.html,1,['Guid'],['Guide']
Usability,"In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPNEntry.html:1854,Guid,Guide,1854,root/html602/TGeoPNEntry.html,https://root.cern,https://root.cern/root/html602/TGeoPNEntry.html,2,['Guid'],['Guide']
Usability,"In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPhysicalNode(); voidTObject::AbstractMethod(const char* method) const; Bool_tAlign(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPhysicalNode.html:1886,Guid,Guide,1886,root/html602/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html602/TGeoPhysicalNode.html,2,['Guid'],['Guide']
Usability,IndirectMember; kCXX_Global; kCXX_GlobalProto; kNUM_PAT; };. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. co,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTabCom.html:7088,Clear,ClearEnvVars,7088,root/html532/TTabCom.html,https://root.cern,https://root.cern/root/html532/TTabCom.html,2,['Clear'],['ClearEnvVars']
Usability,"Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] = headers;; 3290 }; 3291 ; 3292 // The same for the enums:; 3293 for (auto & en : enumDecls) {; 3294 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*en, interp)};; 3295 head",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:130159,clear,clear,130159,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"Info;  CTMonaLisaText;  CTMonaLisaValue;  CTMonaLisaWriter;  CTMonitor;  CTMPClientBase class for multiprocess applications' clients ;  CTMPWorkerThis class works in conjuction with TMPClient, reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:171860,simpl,simple,171860,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"InitTime(). void TProofPlayerRemote::SetInitTime ; (; ). overridevirtual . Set init time. ; Reimplemented from TProofPlayer.; Definition at line 4306 of file TProofPlayer.cxx. ◆ SetLastMergingMsg(). void TProofPlayerRemote::SetLastMergingMsg ; (; TObject * ; obj). protected . Set the message to be notified in case of exception. ; Definition at line 3613 of file TProofPlayer.cxx. ◆ SetMerging(). void TProofPlayerRemote::SetMerging ; (; Bool_t ; on = kTRUE). overridevirtual . Switch on/off merge timer. ; Reimplemented from TProofPlayer.; Definition at line 1814 of file TProofPlayer.cxx. ◆ SetSelectorDataMembersFromOutputList(). void TProofPlayerRemote::SetSelectorDataMembersFromOutputList ; (; ). protected . Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:36789,feedback,feedback,36789,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"Initialize X11 system. Returns kFALSE in case of failure. Bool_t AllocColor(Colormap cmap, RXColor* color); Allocate color in colormap. If we are on an <= 8 plane machine; we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; true color machine we will calculate the pixel value using:; for 15 and 16 bit true colors have 6 bits precision per color however; only the 5 most significant bits are used in the color index.; Except for 16 bits where green uses all 6 bits. I.e.:; 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits. Since all colors are set with a max of 65535 (16 bits) per r, g, b; we just right shift them by 10, 11 and 10 bits for 16 planes, and; (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(Colormap cmap, RXColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(Drawable* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delete current pixmap. void CloseWindow(); Delete current window. void CloseWindow1(); Delete current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wid at the position xpos, ypos in the current window. void CopyWindowtoPixmap(Drawable* pix, Int_t xpos, Int_t ypos); Copy area of current window in the pixmap pix. void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draw a box.; mode=0 hollow (kHollow); mode=1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array. Draw a cell array. The drawing is done with the pixel presicion; if (X2-X1)/NX (or Y) is not a exact pixel number the position of; the top rigth corner may be wrong. void DrawFillArea(Int_t n, TPoint* xy); Fill area described by pol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:27562,Clear,ClearPixmap,27562,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,4,['Clear'],"['Clear', 'ClearPixmap']"
Usability,"Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1I.html:1795,Clear,ClearUnderflowAndOverflow,1795,root/html602/TH1I.html,https://root.cern,https://root.cern/root/html602/TH1I.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2I.html:1782,Clear,ClearUnderflowAndOverflow,1782,root/html602/TH2I.html,https://root.cern,https://root.cern/root/html602/TH2I.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3I.html:1782,Clear,ClearUnderflowAndOverflow,1782,root/html602/TH3I.html,https://root.cern,https://root.cern/root/html602/TH3I.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Double_tfConfidenceLevelconfidence level; Double_tfLowerLimitlower interval limit; RooArgSetfParametersset containing the parameter of interest; Double_tfUpperLimitupper interval limit. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleInterval.html:6673,Simpl,SimpleInterval,6673,root/html534/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleInterval.html,2,['Simpl'],['SimpleInterval']
Usability,"Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLBoxPainter(TH1* hist, TPolyMarker3D* pm, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; voidDrawCloud() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; Bool_tHasSections() const; virtual voidInitGL() const; TGLBoxPainter&operator=(const TGLBoxPainter&); voidSetPlotColor() const; TGLBoxPainter(const TGLBoxPainter&). Data Members; public:. static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kXAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kYAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kZAxis. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLBoxPainter.html:1732,Clear,ClearBuffers,1732,root/html602/TGLBoxPainter.html,https://root.cern,https://root.cern/root/html602/TGLBoxPainter.html,2,['Clear'],['ClearBuffers']
Usability,"Int_t id, Int_t pdgcode, TObject* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. TGeoNavigator * AddNavigator(); Add a navigator in the list of navigators. If it is the first one make it; current navigator. TGeoNavigator * GetCurrentNavigator() const; Returns current navigator for the calling thread. TGeoNavigatorArray * GetListOfNavigators() const; Get list of navigators for the calling thread. Bool_t SetCurrentNavigator(Int_t index); Switch to another existing navigator for the calling thread. void SetNavigatorsLock(Bool_t flag); Set the lock for navigators. void ClearNavigators(); Clear all navigators. void RemoveNavigator(const TGeoNavigator* nav); Clear a single navigator. void SetMaxThreads(Int_t nthreads); Set maximum number of threads for navigation. void ClearThreadData() const. void CreateThreadData() const; Create thread private data for all geometry objects. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread.; static __thread Int_t tid = -1;; if (tid > -1) return tid;. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:39105,Clear,ClearThreadData,39105,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['Clear'],['ClearThreadData']
Usability,"Int_t includeError=3, Bool_t clearHist=kTRUE) const;  get background into a histogram ;  ; TSortedList * GetBgrSources (void) const;  Get a new list of all background sources. ;  ; Double_t GetChi2Sys (void);  calculate total chi**2 including all systematic errors ;  ; Bool_t GetDeltaSysBackgroundScale (TH1 *delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts from background normalisation uncertainty ;  ; Bool_t GetDeltaSysSource (TH1 *hist_delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts correspinding to a given systematic uncertainty ;  ; Bool_t GetDeltaSysTau (TH1 *delta, const Int_t *binMap=nullptr);  correlated one-sigma shifts from shifting tau ;  ; void GetEmatrixInput (TH2 *ematrix, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance matrix contribution from input measurement uncertainties ;  ; void GetEmatrixSysBackgroundScale (TH2 *ematrix, const char *source, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance contribution from background normalisation uncertainty ;  ; void GetEmatrixSysBackgroundUncorr (TH2 *ematrix, const char *source, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance contribution from background uncorrelated uncertainty ;  ; void GetEmatrixSysSource (TH2 *ematrix, const char *source, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance contribution from a systematic variation of the response matrix ;  ; void GetEmatrixSysTau (TH2 *ematrix, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance matrix contribution from error on regularisation parameter ;  ; void GetEmatrixSysUncorr (TH2 *ematrix, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  Covariance contribution from uncorrelated uncertainties of the response matrix. ;  ; void GetEmatrixTotal (TH2 *ematrix, const Int_t *binMap=nullptr);  Get total error matrix, summing up all contributions. ;  ; void GetRhoItotal (TH1 *rhoi, const Int_t *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:15510,clear,clearEmat,15510,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,12,['clear'],['clearEmat']
Usability,"Int_t index) const;  Return pointer to parameter at given index. ;  ; TClass * IsA () const override;  ; size_t nParameters () const;  Return the number of parameters. ;  ; bool ok () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Add formula expression as meta argument in printing interface. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from given stream. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to given stream. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:4598,simpl,simple,4598,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['simpl'],['simple']
Usability,"Int_t lastChar) const; Use the information in the TGTextLayout object to display a multi-line,; justified string of text. This procedure is useful for simple widgets that need to display; single-font, multi-line text and want TGFont to handle the details. dst -- Window or pixmap in which to draw.; gc -- Graphics context to use for drawing text.; x, y -- Upper-left hand corner of rectangle in which to draw; (pixels).; firstChar -- The index of the first character to draw from the given; text item. 0 specfies the beginning.; lastChar -- The index just after the last character to draw from the; given text item. A number < 0 means to draw all characters. void UnderlineChar(Drawable_t dst, GContext_t gc, Int_t x, Int_t y, Int_t underline) const; Use the information in the TGTextLayout object to display an underline; below an individual character. This procedure does not draw the text,; just the underline. This procedure is useful for simple widgets that need to display; single-font, multi-line text with an individual character underlined; and want TGFont to handle the details. To display larger amounts of; underlined text, construct and use an underlined font. dst -- Window or pixmap in which to draw.; gc -- Graphics context to use for drawing text.; x, y -- Upper-left hand corner of rectangle in which to draw; (pixels).; underline -- Index of the single character to underline, or -1 for; no underline. Int_t PointToChar(Int_t x, Int_t y) const; Use the information in the TGTextLayout token to determine the character; closest to the given point. The point must be specified with respect to; the upper-left hand corner of the text layout, which is considered to be; located at (0, 0). Any point whose y-value is less that 0 will be considered closest to the; first character in the text layout; any point whose y-value is greater; than the height of the text layout will be considered closest to the last; character in the text layout. Any point whose x-value is less than 0 will be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextLayout.html:7190,simpl,simple,7190,root/html528/TGTextLayout.html,https://root.cern,https://root.cern/root/html528/TGTextLayout.html,10,['simpl'],['simple']
Usability,"Int_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; UseNTrainEvents number of training events used in randomised (and bagged) trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:26988,simpl,simply,26988,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,3,['simpl'],['simply']
Usability,"Int_t numberClasses, UInt_t numberTargets); BDT can handle classification with multiple classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; nTrees number of trees in the forest to be created; BoostType the boosting type for the trees in the forest (AdaBoost e.t.c..); known: AdaBoost; AdaBoostR2 (Adaboost for regression); Bagging; GradBoost; AdaBoostBeta the boosting parameter, beta, for AdaBoost; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; UseNTrainEvents number of training events used in randomised (and bagged) trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterium; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:25583,simpl,simply,25583,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['simpl'],['simply']
Usability,"Int_t secOffset); voidSetNanoSec(Int_t nsec); voidSetSec(Int_t sec); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0). private:. voidNormalizeNanoSec(). Data Members; private:. Int_tfNanoSecnanoseconds; Int_tfSecseconds. Class Charts. Inheritance Chart:. TTimeStamp. Function documentation; TTimeStamp(); Default ctor. Create a TTimeStamp and set it to the current time; (as best possible). The nanosecond part is faked so that subsequenct; calls simply add 1 to ensure that sequential calls are distinct; (and sortable). TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified year, month,; day, time, hour, minute, second and nanosec.; If !isUTC then it is assumed to be the standard local time zone. If local time is PST then one can use; TTimeStamp(year,month,day,hour,min,sec,nsec,kFALSE,0);; or; Int_t secOffset = 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimeStamp.html:3707,simpl,simply,3707,root/html602/TTimeStamp.html,https://root.cern,https://root.cern/root/html602/TTimeStamp.html,4,['simpl'],['simply']
Usability,"Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TEveGValuatorBase&operator=(const TEveGValuatorBase&); TEveGValuatorBase(const TEveGValuatorBase&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGValuatorBase.html:15486,Clear,ClearFlags,15486,root/html602/TEveGValuatorBase.html,https://root.cern,https://root.cern/root/html602/TEveGValuatorBase.html,2,['Clear'],['ClearFlags']
Usability,"Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGShutterItem&operator=(const TGShutterItem&); TGShutterItem(const TGShutterItem&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGShutterItem.html:15329,Clear,ClearFlags,15329,root/html602/TGShutterItem.html,https://root.cern,https://root.cern/root/html602/TGShutterItem.html,2,['Clear'],['ClearFlags']
Usability,"Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); virtual voidConnectSignals2Slots(); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; static TGWindow::EEditModeTGWindow::kEditDisableHe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPconSection.html:15413,Clear,ClearFlags,15413,root/html602/TGeoPconSection.html,https://root.cern,https://root.cern/root/html602/TGeoPconSection.html,2,['Clear'],['ClearFlags']
Usability,"Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); voidChangePartition(Int_t n, Int_t m); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidClearBinContents(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidTH2::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2Poly.html:6877,Clear,Clear,6877,root/html534/TH2Poly.html,https://root.cern,https://root.cern/root/html534/TH2Poly.html,1,['Clear'],['Clear']
Usability,Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19639,learn,learning,19639,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['learn'],['learning']
Usability,"Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; Int_tTProof::DeactivateWorker(const char* ord, Bool_t save = kTRUE); static voidTProof::DelEnvVar(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:2490,Clear,ClearPackages,2490,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['Clear'],['ClearPackages']
Usability,"Introduction; The fitting method; The fit is performed using the Normal Equations method with Cholesky decomposition.; Why should it be used?; The linear fitter is considerably faster than general non-linear fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?. There are 2 options in the constructor - to store or not store the input data. The advantages of storing the data are that you'll be able to reset the fitting model without adding all the points again, and that for very large sets of points the chisquare is calculated more precisely. The obvious disadvantage is the amount of memory used to keep all the points.; Before you start adding the points, you can change the store/not store option by StoreData() method. 1.2 The data can be added:. simply point by point - AddPoint() method; an array of points at once: If the data is already stored in some arrays, this data can be assigned to the linear fitter without physically coping bytes, thanks to the Use() method of TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signs ""++"" –for example ""1 ++ x"" - for fitting a straight line -All standard functions, undrestood by TFormula, can be used as additive parts –TMath functions can be used too -Functions, used as additive parts, shouldn't have any parameters, even if those parameters are set. –for example, if normalizing a sum of a gaus(0, 1) and a gaus(0, 2), don't use the built-in ""gaus"" of TFormula, because it has parameters, take TMath::Gaus(x, 0, 1) instead. -Polynomials can be used like ""pol3"", ..""polN"" -If fitting a more than 3-dimensional formula, variables should be numbered as follows: – x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional formula, one can create a; TF123 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:2021,simpl,simply,2021,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['simpl'],['simply']
Usability,"InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&operator=(const RooStats::SimpleInterval& other); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleInterval.html:4005,Simpl,SimpleInterval,4005,root/html602/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleInterval.html,2,['Simpl'],['SimpleInterval']
Usability,"IsImplicitMTEnabled; 13#include ""TError.h"" // Warning; 14#include ""TStopwatch.h""; 15#include ""RConfigure.h"" // R__USE_IMT; 16#include ""ROOT/RLogger.hxx""; 17#include ""ROOT/RDF/RLoopManager.hxx"" // for RLoopManager; 18#include ""ROOT/RDF/Utils.hxx""; 19#include ""ROOT/RResultHandle.hxx"" // for RResultHandle, RunGraphs; 20#ifdef R__USE_IMT; 21#include ""ROOT/TThreadExecutor.hxx""; 22#endif // R__USE_IMT; 23 ; 24#include <algorithm>; 25#include <iostream>; 26#include <set>; 27#include <cstdio>; 28 ; 29// TODO, this function should be part of core libraries; 30#include <numeric>; 31#if (!defined(_WIN32)) && (!defined(_WIN64)); 32#include <unistd.h>; 33#endif; 34 ; 35#if defined(_WIN32) || defined(_WIN64); 36#define WIN32_LEAN_AND_MEAN; 37#define VC_EXTRALEAN; 38#include <io.h>; 39#include <Windows.h>; 40#else; 41#include <sys/ioctl.h>; 42#endif; 43 ; 44// Get terminal size for progress bar; 45int get_tty_size(); 46{; 47#if defined(_WIN32) || defined(_WIN64); 48 if (!_isatty(_fileno(stdout))); 49 return 0;; 50 int width = 0;; 51 CONSOLE_SCREEN_BUFFER_INFO csbi;; 52 if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)); 53 width = (int)(csbi.srWindow.Right - csbi.srWindow.Left + 1);; 54 return width;; 55#else; 56 int width = 0;; 57 struct winsize w;; 58 ioctl(fileno(stdout), TIOCGWINSZ, &w);; 59 width = (int)(w.ws_col);; 60 return width;; 61#endif; 62}; 63 ; 64using ROOT::RDF::RResultHandle;; 65 ; 66unsigned int ROOT::RDF::RunGraphs(std::vector<RResultHandle> handles); 67{; 68 if (handles.empty()) {; 69 Warning(""RunGraphs"", ""Got an empty list of handles, now quitting."");; 70 return 0u;; 71 }; 72 ; 73 // Check that there are results which have not yet been run; 74 const unsigned int nToRun =; 75 std::count_if(handles.begin(), handles.end(), [](const auto &h) { return !h.IsReady(); });; 76 if (nToRun < handles.size()) {; 77 Warning(""RunGraphs"", ""Got %zu handles from which %zu link to results which are already ready."", handles.size(),; 78 handles.size() - nToRun)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8cxx_source.html:1564,progress bar,progress bar,1564,doc/master/RDFHelpers_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15224,simpl,simply,15224,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15225,simpl,simply,15225,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"Iterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:36748,clear,clear,36748,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['clear'],['clear']
Usability,Iterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp) const; voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next(); TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoIterator.html:4349,resume,resume,4349,root/html602/TGeoIterator.html,https://root.cern,https://root.cern/root/html602/TGeoIterator.html,4,['resume'],['resume']
Usability,"Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Contribute Collaborate With Us. We warmly welcome external contributions to the ROOT! By providing code, you agree to transfer your copyright on the code to the ""ROOT project"". Of course you will be duly credited and your name will appear on the contributors page and in the CREDITS file shipped with every binary and source distribution. The copyright transfer is necessary for us to be able to effectively defend the project in case of litigation.; Presently, there are two ways in which you can contribute:; 1. Via the Users' contribution section in the Forum; The Users' Forum has a section which describes how to submit contributions. It is the easiest way to make your code known to the community, even if it will not be automatically integrated in ROOT. Of course the most successful contributions will become part of the repository!; 2. Sending Patches; You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the ROOT coding conventions in your code; Make sure you provide a set of tests for your feature/bug fix. Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix.; Picking up an Idea; We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" is a sketch of a development project, a functionality a missing feature we would like to see in our tool, in your ROOT! You can inspect the ideas in the following list. Ideas. ; 30-01-2019 ; Transform GNU-makefile tests to CMake; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake. ; 30-01-2019 ; Better argument parsing; Use a C++ command line argument library for defining and parsing ROOT's options. ; 30-01-2019 ; More tests, more benchmarks!; ROOT relies on testing, including performance testing - and we need to improve both.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/collaborate-with-us.html:2808,simpl,simple,2808,d/collaborate-with-us.html,https://root.cern,https://root.cern/d/collaborate-with-us.html,1,['simpl'],['simple']
Usability,"JoinProcess(TList* workers); Prepares the given list of new workers to join a progressing process.; Returns kTRUE on success, kFALSE otherwise. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(Bool_t savememvalues = kFALSE); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:19529,Feedback,Feedback,19529,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,4,['Feedback'],['Feedback']
Usability,"L (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; bool fFlattening;  Whether the layer is doing flattening. ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::VGeneralLayer< Architecture_t >; Tensor_t fActivationGradients;  Gradients w.r.t. the activations of this layer. ;  ; size_t fBatchSize;  Batch size used for training and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html:6222,learn,learningRate,6222,doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"L argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/engine.h>; 1748#include <openssl/err.h>; 1749#include <openssl/opensslv.h>; 1750#include <openssl/pem.h>; 1751#include <openssl/ssl.h>; 1752#include <openssl/tls1.h>; 1753#include <openssl/x509.h>; 1754 ; 1755#if defined(WOLFSSL_VERSION); 1756/* Additional defines for WolfSSL, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767 * the standard memory functions.; 1768 *; 1769 * #define OPENSSL_free free */; 1770#define free free; 1771// disable for boringssl; 1772#define CONF_modules_unload(a) ((void)0); 1773#define ENGINE_cleanup() ((void)0); 1774#endif; 1775 ; 1776/* If OpenSSL headers are included, automatically select the API version */; 1777#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1778#if !defined(OPENSSL_API_3_0); 1779#define OPENSSL_API_3_0; 1780#endif; 1781#define OPENSSL_REMOVE_THREAD_STATE(); 1782#else; 1783#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1784#if !defined(OPENSSL_API_1_1); 1785#define OPENSSL_API_1_1; 1786#endif; 1787#define OPENSSL_REMOVE_THREAD_STATE(); 1788#else; 1789#if !defined(OPENSSL_API_1_0); 1790#define OPENSSL_API_1_0; 1791#endif; 1792#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1793#endif; 1794#endif; 1795 ; 1796 ; 1797#else; 1798/* SSL loaded dynamically from DLL / shared object */; 1799/* Add all prototypes here,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:54226,simpl,simply,54226,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['simpl'],['simply']
Usability,"LL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGTextEntry (const TGWindow *p, TGTextBuffer *text, Int_t id=-1, GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t option=kSunkenFrame|kDoubleBorder, Pixel_t back=GetWhitePixel());  Create a text entry widget. ;  ;  TGTextEntry (const TGWindow *parent=nullptr, const char *text=nullptr, Int_t id=-1);  Simple text entry constructor. ;  ;  TGTextEntry (const TString &contents, const TGWindow *parent, Int_t id=-1);  Simple test entry constructor. ;  ;  ~TGTextEntry () override;  Delete a text entry widget. ;  ; virtual void AppendText (const char *text);  Appends text to the end of text entry, clears the selection and moves the cursor to the end of the line. ;  ; void Backspace ();  Deletes the character on the left side of the text cursor and moves the cursor one position to the left. ;  ; void Clear (Option_t *option="""") override;  Clears up the text entry. ;  ; void CursorLeft (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor leftwards one or more characters. ;  ; virtual void CursorOutDown ();  This signal is emitted when cursor is going out of bottom side. ;  ; virtual void CursorOutLeft ();  This signal is emitted when cursor is going out of left side. ;  ; virtual void CursorOutRight ();  This signal is emitted when cursor is going out of right side. ;  ; virtual void CursorOutUp ();  This signal is emitted when cursor is going out of upper side. ;  ; void CursorRight (Bool_t mark=kFALSE, Int_t steps=1);  Moves the cursor rightwards one or more characters. ;  ; void CursorWordBackward (Bool_t mark=kFALSE);  Moves the cursor one word to the left. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:6206,clear,clears,6206,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"LPainter&); virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; virtual voidTGLPlotPainter::DrawPaletteAxis() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; voidDrawDefaultPlot() const; voidDrawMaplePlot() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidDrawToSelectionBuffer() const; Bool_tHasSections() const; virtual voidInitGL() const; voidSetSurfaceColor() const. Data Members; public:. enum ETF3Style { kDefault; kMaple0; kMaple1; kMaple2; };; enum TGLPlotPainter::ESelectionBase { kHighColorSelectionBase; kTrueColorSelectionBase; };; enum TGLPlotPainter::ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLTF3Painter.html:1632,Clear,ClearBuffers,1632,root/html532/TGLTF3Painter.html,https://root.cern,https://root.cern/root/html532/TGLTF3Painter.html,1,['Clear'],['ClearBuffers']
Usability,"LSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3874,clear,clearValueDirty,3874,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,6,['clear'],['clearValueDirty']
Usability,"LSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooThresholdCategory.html:2177,clear,clearValueDirty,2177,root/html528/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html528/RooThresholdCategory.html,2,['clear'],['clearValueDirty']
Usability,"LSE); Constructor p.d.f implementing sum_i [ coef_i * func_i ], if N_coef==N_func; or sum_i [ coef_i * func_i ] + (1 - sum_i [ coef_i ] )* func_N if Ncoef==N_func-1. All coefficients and functions are allowed to be negative; but the sum is not, which is enforced at runtime. RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const; try something simple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Sat Oct 9 06:58:41 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealSumPdf.html:42530,simpl,simple,42530,root/html528/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html528/RooRealSumPdf.html,2,"['intuit', 'simpl']","['intuitively', 'simple']"
Usability,"LayerPerceptron & ; ). private . Member Function Documentation. ◆ AttachData(). void TMultiLayerPerceptron::AttachData ; (; ). protected . Connects the TTree to Neurons in input and output layers. ; The formulas associated to each neuron are created and reported to the network formula manager. By default, the branch is not normalised since this would degrade performance for classification jobs. Normalisation can be requested by putting '@' in front of the formula. ; Definition at line 1266 of file TMultiLayerPerceptron.cxx. ◆ BFGSDir(). void TMultiLayerPerceptron::BFGSDir ; (; TMatrixD & ; bfgsh, . Double_t * ; dir . ). protected . Computes the direction for the BFGS algorithm as the product between the Hessian estimate (bfgsh) and the dir. ; Definition at line 2494 of file TMultiLayerPerceptron.cxx. ◆ BuildFirstLayer(). void TMultiLayerPerceptron::BuildFirstLayer ; (; TString & ; input). private . Instantiates the neurons in input Inputs are normalised and the type is set to kOff (simple forward of the formula value) ; Definition at line 1401 of file TMultiLayerPerceptron.cxx. ◆ BuildHiddenLayers(). void TMultiLayerPerceptron::BuildHiddenLayers ; (; TString & ; hidden). private . Builds hidden layers. ; Definition at line 1419 of file TMultiLayerPerceptron.cxx. ◆ BuildLastLayer(). void TMultiLayerPerceptron::BuildLastLayer ; (; TString & ; output, . Int_t ; prev . ). private . Builds the output layer Neurons are linear combinations of input, by default. ; If the structure ends with ""!"", neurons are set up for classification, ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. ; Definition at line 1483 of file TMultiLayerPerceptron.cxx. ◆ BuildNetwork(). void TMultiLayerPerceptron::BuildNetwork ; (; ). protected . Instantiates the network from the description. ; Definition at line 1370 of file TMultiLayerPerceptron.cxx. ◆ BuildOneHiddenLayer(). void TMultiLayerPerceptron::BuildOneHiddenLayer ; (; const TString & ; sNumNodes, . Int_t & ; layer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:34683,simpl,simple,34683,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"LayerPerceptron.cxx. ◆ SetDelta(). void TMultiLayerPerceptron::SetDelta ; (; Double_t ; delta). Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 720 of file TMultiLayerPerceptron.cxx. ◆ SetEpsilon(). void TMultiLayerPerceptron::SetEpsilon ; (; Double_t ; eps). Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 710 of file TMultiLayerPerceptron.cxx. ◆ SetEta(). void TMultiLayerPerceptron::SetEta ; (; Double_t ; eta). Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 700 of file TMultiLayerPerceptron.cxx. ◆ SetEtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch). Set the event weight. ; Definition at line 606 of file TMultiLayerPerceptron.cxx. ◆ SetGammaDelta(). void TMultiLayerPerceptron::SetGammaDelta ; (; TMatrixD & ; gamma, . TMatrixD & ; delta, . Double_t * ; buffer . ). protected . Sets the gamma \((g_{(t+1)}-g_{(t)})\) and delta \((w_{(t+1)}-w_{(t)})\) vectors Gamma is computed here, so ComputeDEDw cannot have been called before, and delta is a direct translation of buffer into a TMatrixD. ; Definition at line 2431 of file TMultiLayerPerceptron.cxx. ◆ SetLearningMethod(). void TMultiLayerPerceptron::SetLearningMethod ; (; TMultiLayerPerceptron::ELearningMethod ; method). Sets the learning method. ; Available methods are: kStochastic, kBatch, kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. (look at the constructor for the complete descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:45499,learn,learning,45499,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"LayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:33222,clear,clear,33222,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,6,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBinomialEfficiencyFitter.html:9624,simpl,simply,9624,root/html526/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html526/TBinomialEfficiencyFitter.html,7,['simpl'],['simply']
Usability,"License along with this library; if not, write to the Free; 20Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,; 21MA 02110-1301 USA; 22******************************************************************************/; 23 ; 24/*******************************************************************************; 25* *; 26* Simple RSA public key code. *; 27* Adaptation in library for ROOT by G. Ganis, July 2003 *; 28* (gerardo.ganis@cern.ch) *; 29* *; 30*******************************************************************************/; 31 ; 32#include <stdio.h>; 33#include <string.h>; 34#include <ctype.h>; 35#include <stdlib.h>; 36#include <errno.h>; 37 ; 38#include ""rsaaux.h""; 39#include ""rsalib.h""; 40 ; 41static int g_clear_siz; /* clear-text blocksize */; 42static int g_enc_siz; /* encoded blocksize */; 43 /* g_clear_siz < g_enc_siz */; 44 ; 45int gLog = 0;; 46int kMAXT = 100;; 47 ; 48rsa_NUMBER rsa_genprim(int len, int prob); 49{; 50 rsa_NUMBER a_three,a_four;; 51 rsa_NUMBER prim;; 52 int i;; 53 ; 54 a_add( &a_one, &a_two, &a_three );; 55 a_add( &a_two, &a_two, &a_four );; 56 ; 57 /* This is done elsewhere to allow different initialization of; 58 rand seed (GGa - Sep 15, 2003) */; 59 /* init_rnd(); */; 60 ; 61 do {; 62 gen_number( len, &prim );; 63 } while ( !prim.n_len );; 64 ; 65 a_mult( &prim, &a_two, &prim );; 66 a_mult( &prim, &a_three, &prim );; 67 a_add( &prim, &a_one, &prim );; 68 ; 69 for (i=1 ;; i++) {; 70 ; 71 if (p_prim( &prim, prob )); 72 break;; 73 if (i % 2); 74 a_add( &prim, &a_four, &prim );; 75 else; 76 a_add( &prim, &a_two, &prim );; 77 }; 78 ; 79 return prim;; 80}; 81 ; 82int rsa_genrsa(rsa_NUMBER p1, rsa_NUMBER p2, rsa_NUMBER *n, rsa_NUMBER *e, rsa_NUMBER *d); 83{; 84 rsa_NUMBER phi, *max_p;; 85 int len;; 86 int ii, jj;; 87 ; 88 if ( !a_cmp( &p1, &p2) ) return 1;; 89 ; 90 if (a_cmp( &p1, &p2) > 0); 91 max_p = &p1;; 92 else; 93 max_p = &p2;; 94 ; 95 ; 96 a_mult( &p1, &p2, n );; 97 a_sub( &p1, &a_one, &phi );; 98 a_sub( &p2, &a_one, e );; 99",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rsalib_8cxx_source.html:1735,clear,clear-text,1735,doc/master/rsalib_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html,1,['clear'],['clear-text']
Usability,LinTransBinning. RooParamBinning. RooRangeBinning. RooUniformBinning. RooAbsData; ←. RooDataHist. RooDataSet. RooTreeData. RooAbsDataStore; ←. RooCompositeDataStore. RooTreeDataStore. RooVectorDataStore. RooAbsGenContext; ←. RooAddGenContext. RooBinnedGenContext. RooConvGenContext. RooEffGenContext. RooGenContext. RooProdGenContext. RooSimGenContext. RooSimSplitGenContext. RooAbsMCStudyModule; ←. RooChi2MCSModule. RooDLLSignificanceMCSModule. RooRandomizeParamMCSModule. RooStats::UpperLimitMCSModule. RooAbsNumGenerator; ←. RooAcceptReject. RooFoamGenerator. RooAbsStudy; ←. RooGenFitStudy. RooStats::ToyMCStudy. RooArgProxy; ←. RooCategoryProxy. RooRealProxy. RooClassFactory. RooCmdArg. RooCustomizer. RooDouble. RooFactoryWSTool. RooFitResult. RooInt. RooMCStudy. RooMapCatEntry. RooNameReg. RooPlot. RooSimWSTool. RooSimWSTool::SplitRule. RooStats::BayesianCalculator. RooStats::ConfInterval; ←. RooStats::LikelihoodInterval. RooStats::MCMCInterval. RooStats::PointSetInterval. RooStats::SimpleInterval; ←. RooStats::HypoTestInverterResult. RooStats::ConfidenceBelt. RooStats::HLFactory. RooStats::HistFactory::Measurement. RooStats::HybridCalculatorOriginal. RooStats::HybridPlot. RooStats::HypoTestInverterOriginal. RooStats::HypoTestInverterPlot. RooStats::HypoTestResult; ←. RooStats::HybridResult. RooStats::LikelihoodIntervalPlot. RooStats::MCMCCalculator. RooStats::MCMCIntervalPlot. RooStats::MarkovChain. RooStats::ModelConfig. RooStats::SPlot. RooStats::SamplingDistPlot; ←. RooStats::HypoTestPlot. RooStats::SamplingDistribution. RooStats::ToyMCPayload. RooStudyManager. RooStudyPackage. RooTObjWrap. RooTable; ←. Roo1DTable. RooUnitTest. RooWorkspace. TAttParticle. TAxis. TAxis3D. TBenchmark. TBranch; ←. TBranchClones. TBranchElement. TBranchObject. TBranchRef. TBranchSTL. THbookBranch. TBrowser. TBrowserPlugin. TChainElement. TClassTree. TColor; ←. TColorGradient; ←. TLinearGradient. TRadialGradient. TColorWheel. TContextMenu; ←. TEveContextMenu. TControlBarButton; ←. TCon,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:84494,Simpl,SimpleInterval,84494,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,3,['Simpl'],['SimpleInterval']
Usability,"LinePad->Delete();; 6389 tmpGuideLinePad = nullptr;; 6390 if (guidePadClicked) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox = cur->GetBBox();; 6435 center = cur->GetBBoxCenter();; 6436 }; 6437 L = new TLine(MX, gPad->GetY1(), MX, gPad->GetY2());; 6438 L->SetBit(kCanDelete);; 6439 L->SetLineColor(lineColor);; 6440 L->Draw();; 6441 }; 6442 if (TMath::Abs(pMY-center.GetY())<threshold) {; 6443 if (cling && (!resize)) {; 6444 cur->SetBBoxCenterY(pMY);; 6445 center = cur->GetBBoxCenter();; 6446 BBox = cur->GetBBox();; 6447 center = cur->GetBBoxCenter();; 6448 }; 6449 L = new TLine(gPad->GetX1(), MY, gPad->GetX2(), MY);; 6450 L->SetBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:211445,clear,clear,211445,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['clear']
Usability,"LinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 2 15:27:00 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCollection.html:22627,clear,clearStructureTags,22627,root/html604/RooAbsCollection.html,https://root.cern,https://root.cern/root/html604/RooAbsCollection.html,2,['clear'],['clearStructureTags']
Usability,"List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » First Steps With ROOT ROOT I/O. The ROOT framework consists of many classes, grouped into several categories. Finally, the latter are grouped into few top-level categories. Each top-level category comes with a basic description of the framework design and of the purpose of its categories, which also have more detailed documentation about their use. The most complete documentation is the Reference Guide, that contains the automatically generated documentation of each class.; This document is about the top-level categories related to input/output. . ‹ Tracks; up; ROOT files ›. Navigate through this book; Processing data with ROOT; Showing results with ROOT; Simulation in ROOT; ROOT I/OROOT files; ROOT trees; Parallel processing. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-io.html:2818,guid,guidelines,2818,d/root-io.html,https://root.cern,https://root.cern/d/root-io.html,1,['guid'],['guidelines']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:3862,clear,clearShapeDirty,3862,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidconstOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:3806,clear,clearShapeDirty,3806,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:3878,clear,clearShapeDirty,3878,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,8,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStepFunction.html:3671,clear,clearShapeDirty,3671,root/html526/RooStepFunction.html,https://root.cern,https://root.cern/root/html526/RooStepFunction.html,2,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:4338,clear,clearShapeDirty,4338,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,1,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet&, const char*, const char*, Int_t, Bool_t, Bool_t, Bool_t); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:4053,clear,clearShapeDirty,4053,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,2,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:4931,clear,clearShapeDirty,4931,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,2,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsOptTestStatistic::combinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*create(const char* name, const char* title, RooAbsReal& real, RooAbsData& adata, const RooArgSet& projDeps, const char* = 0, const char* = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:3796,clear,clearShapeDirty,3796,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,2,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; RooArgSetcomponents(); virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProduct.html:3308,clear,clearShapeDirty,3308,root/html528/RooProduct.html,https://root.cern,https://root.cern/root/html528/RooProduct.html,1,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:3537,clear,clearShapeDirty,3537,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,90,['clear'],['clearShapeDirty']
Usability,"List& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:4085,clear,clearShapeDirty,4085,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,1,['clear'],['clearShapeDirty']
Usability,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Jun 2 15:32:20 2015 » Last generated: 2015-06-02 15:32; This p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMultiVarGaussian.html:46943,Clear,Clear,46943,root/html604/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html604/RooMultiVarGaussian.html,1,['Clear'],['Clear']
Usability,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Jun 30 14:34:14 2015 » Last generated: 2015-06-30 14:34; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:46943,Clear,Clear,46943,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,1,['Clear'],['Clear']
Usability,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Mar 10 17:18:02 2015 » Last generated: 2015-03-10 17:18; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:45206,Clear,Clear,45206,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,1,['Clear'],['Clear']
Usability,"List* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:2003,Clear,ClearCache,2003,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,2,['Clear'],['ClearCache']
Usability,"ListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TQCommand; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TQCommand * GetCommand ();  Return a command which is doing redo/undo action. ;  ;  Static Public Member Functions inherited from TList; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSeqCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:19792,undo,undo,19792,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"Long64_t value); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Bool_tStoreResult(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. void*BeforeSet(const char* method, Int_t npar, Int_t sqltype, Bool_t sig = kTRUE, ULong_t size = 0); voidTSQLStatement::ClearError(); long doubleConvertToNumeric(Int_t npar); const char*ConvertToString(Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFreeBuffers(); Bool_tIsResultSetMode() const; Bool_tIsSetParsMode() const; voidTObject::MakeZombie(); voidSetBuffersNumber(Int_t n); voidTSQLStatement::SetError(Int_t code, const char* msg, const char* method = 0); Bool_tSetSQLParamType(Int_t npar, int sqltype, Bool_t sig, ULong_t sqlsize = 0). private:. TMySQLStatement(const TMySQLStatement&); TMySQLStatement&operator=(const TMySQLStatement&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MYSQL_BIND*fBind! array of bind data; TMySQLStatement::TParamData*fBuffer! parameter definition structures; Int_tTSQLStatement::fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output ; Int_tfIterationCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMySQLStatement.html:7649,Clear,ClearError,7649,root/html534/TMySQLStatement.html,https://root.cern,https://root.cern/root/html534/TMySQLStatement.html,1,['Clear'],['ClearError']
Usability,"MENU ; virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:1908,Clear,ClearUnderflowAndOverflow,1908,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,4,['Clear'],['ClearUnderflowAndOverflow']
Usability,"MTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; Calculations are expressed in terms of a type-safe functional chain of actions and transformations, RDataFrame takes care of their execution. The implementation automatically puts in place several low level optimisations such as multi-thread parallelization and caching. For the impatient user; You can directly see RDataFrame in action in our tutorials, in C++ or Python. Table of Contents. Cheat sheet; Introduction; Crash course; Working with collections; Transformations: manipulating data; Actions: getting results; Distributed execution in Python; Performance tips and parallel execution; More features; Systematic variations; RDataFrame objects as function arguments and return values; Storing RDataFrame objects in collections; Executing callbacks every N events; Default column lists; Special helper columns: `rdfentry_` and `rdfslot_`; Just-in-time compilation: column type inference and explicit declaration of column types; User-defined custom actions; Dataset joins with friend trees; Reading data formats other than ROOT trees; Computation graphs (storing and reusing sets of transformations); Visualizing the computation graph; Activating RDataFrame execution logs; Creating an RDataFrame from a dataset specification file; Adding a progress bar. Efficient analysis in Python; Class reference. Cheat sheet; These are the operations which can be performed with RDataFrame. Transformations; Transformations are a way to manipulate the data. Transformation Description . Alias() Introduce an alias for a particular column name. . Define() Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the pts of ""good"" muons). . DefinePerSample() Define a new column that is updated when the input sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:2568,progress bar,progress bar,2568,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['progress bar'],['progress bar']
Usability,"MVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; after every event the new chi-square (newValue) has to be simply; added to the oldValue. this function has to be overridden eventually; it might contain only the following return statement.; return oldValue + newValue;. Double_t CalculateFitness(); starts the evaluation of the fitness of all different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html:3598,simpl,simply,3598,root/html528/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html,10,['simpl'],['simply']
Usability,"MainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGUndockedFrame.html:23603,undo,undocked,23603,root/html604/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html604/TGUndockedFrame.html,8,['undo'],['undocked']
Usability,"MainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGUndockedFrame.html:23603,undo,undocked,23603,root/html602/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html602/TGUndockedFrame.html,8,['undo'],['undocked']
Usability,"MakeZombie(); virtual voidTDataSet::SetMother(TObject* mother); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user). Data Members; public:. enum TDataSet::EDataSetPass { kContinue; kPrune; kStop; kUp; kStruct; kAll; kRefs; kMarked; };; enum TDataSet::ESetBits { kMark; kArray; };; enum TDataSet::EBitOpt { kSet; kReset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. ULong_tTChair::fLastIndxindex pof the last used table row;; void*TChair::fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*TChair::fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColumnView(const char* colName = """", TTable* table = 0); constructor. ~TColumnView(); destructor. void Browse(TBrowser* b); Create a column histogram for the simple column. TH1 * Histogram(const char* selection = """"); Create a histogram from the context menu. Bool_t IsFolder() const; Treat the column with the pointer to the ""Ptr"" as a ""folder"". TColumnView(const char* colName = """", TTable* table = 0). » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColumnView.html:11087,simpl,simple,11087,root/html534/TColumnView.html,https://root.cern,https://root.cern/root/html534/TColumnView.html,2,['simpl'],['simple']
Usability,"Manager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPgonEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgonEditor.html:22039,undo,undoing,22039,root/html528/TGeoPgonEditor.html,https://root.cern,https://root.cern/root/html528/TGeoPgonEditor.html,1,['undo'],['undoing']
Usability,"Manager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPgonEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPgonEditor.html:22139,undo,undoing,22139,root/html530/TGeoPgonEditor.html,https://root.cern,https://root.cern/root/html530/TGeoPgonEditor.html,1,['undo'],['undoing']
Usability,"Manager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPgonEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPgonEditor.html:22139,undo,undoing,22139,root/html532/TGeoPgonEditor.html,https://root.cern,https://root.cern/root/html532/TGeoPgonEditor.html,2,['undo'],['undoing']
Usability,"Manager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4104,clear,clearCacheOnServerRedirect,4104,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,2,['clear'],['clearCacheOnServerRedirect']
Usability,"MatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfEpsMatrixmachine accuracy for eingenvalue analysis; Int_tfIgnoredBinsnumber of input bins which are dropped because they have error=0; Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixDSparse*fVyyInvResult: inverse of covariance matrix on y; TMatrixD*fXResult: x. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←. TUnfoldSys; ←. TUnfoldDensity. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:19916,Clear,ClearResults,19916,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,2,['Clear'],['ClearResults']
Usability,"Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdadelta (DeepNet_t &deepNet, Scalar_t learningRate=1.0, Scalar_t rho=0.95, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdadelta ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2023,learn,learningRate,2023,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:1741,learn,learning,1741,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,4,['learn'],['learning']
Usability,"MemStatInfoStamp information about stamps; TMemStatManager a manager of memstat sessions.; TMemStatStackInfo a stack information structure; TMemStatViewerGUI a GUI class of memstat; TMemberInspector ABC for inspecting class data members; TMemberStreamer ; TMergerInfo Basic info on merger, i.e. worker serving as merger; TMessage Message buffer class; TMessageHandler Generic message handler; TMethod Dictionary for a class member function (method); TMethodArg Dictionary for a method argument; TMethodBrowsable Helper object to browse methods; TMethodCall Method calling interface; TMinuit The MINUIT minimisation package; TMinuitMinimizer Implementation of Minimizer interface using TMinuit ; TMixture Mixtures used in the Geometry Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:106095,simpl,simple,106095,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['simpl'],['simple']
Usability,"Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:46545,clear,clearing,46545,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,139,['clear'],['clearing']
Usability,"Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void ClearResults (void) override;  Clear all data members which depend on the unfolding results. ;  ; void DoBackgroundSubtraction (void);  perform background subtraction ;  ; void GetEmatrixFromVyy (const TMatrixDSparse *vyy, TH2 *ematrix, const Int_t *binMap, Bool_t clearEmat);  propagate an error matrix on the input vector to the unfolding result ;  ; TMatrixDSparse * GetSummedErrorMatrixXX (void);  determine total error matrix on the vector x ;  ; TMatrixDSparse * GetSummedErrorMatrixYY (void);  determine total error matrix on the vector Ax ;  ; virtual TMatrixDSparse * PrepareCorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixDSparse *dsys);  propagate correlated systematic shift to an output vector ;  ; virtual void PrepareSysError (void);  Matrix calculations required to propagate systematic errors. ;  ; virtual TMatrixDSparse * PrepareUncorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2);  propagate uncorrelated systematic errors to a covariance matrix ;  ; void ScaleColumnsByVector (TMatrixDSparse *m, const TMatrixTBase< Double_t > *v) const;  scale columns of a matrix by the corresponding rows of a vector ;  ; void VectorMapToHist (TH1 *hist_delta, const TMatrixDSparse *delta, const Int_t *binMap);  map delta to hist_delta, possibly summing up bins ;  ;  Protected Member Functions inherited from TUnfold; void AddMSparse (TMatrixDSparse *dest, Double_t f, const TMatrixDSparse *src) const;  add a sparse ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:23040,clear,clearEmat,23040,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQRootCanvas.html:4884,Clear,Clear,4884,root/html532/TQRootCanvas.html,https://root.cern,https://root.cern/root/html532/TQRootCanvas.html,2,['Clear'],['Clear']
Usability,"Merger class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through hadd.; Zero-copy bulk reading has been added, with extra optimizations for ROOT::RVec fields.; It is now possible to use the RNTupleView with an external address with type erasure, e.g.:; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; Further integration with RDataFrame: it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotically correct uncertainties for extended unbinned likelihood fits; A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:7651,feedback,feedback,7651,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['feedback'],['feedback']
Usability,"Min, Float_t etaMax, Float_t phiMin, Float_t phiMax); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveCaloData::CellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCaloDataVec.html:2024,Clear,Clear,2024,root/html532/TEveCaloDataVec.html,https://root.cern,https://root.cern/root/html532/TEveCaloDataVec.html,4,['Clear'],['Clear']
Usability,MinimumSeed.h;  MinimumSeedGenerator.h;  MinimumState.h;  MinosError.h;  Minuit2Minimizer.h;  MinuitParameter.h;  MnApplication.h;  MnConfig.h;  MnContours.h;  MnCovarianceSqueeze.h;  MnCross.h;  MnEigen.h;  MnFcn.h;  MnFumiliMinimize.h;  MnFunctionCross.h;  MnGlobalCorrelationCoeff.h;  MnHesse.h;  MnLineSearch.h;  MnMachinePrecision.h;  MnMatrix.h;  MnMigrad.h;  MnMinimize.h;  MnMinos.h;  MnParabola.h;  MnParabolaFactory.h;  MnParabolaPoint.h;  MnParameterScan.h;  MnPlot.h;  MnPosDef.h;  MnPrint.h;  MnRefCountedPointer.h;  MnReferenceCounter.h;  MnScan.h;  MnSeedGenerator.h;  MnSimplex.h;  MnStrategy.h;  MnTiny.h;  MnTraceObject.h;  MnUserCovariance.h;  MnUserFcn.h;  MnUserParameters.h;  MnUserParameterState.h;  MnUserTransformation.h;  MnVectorTransform.h;  ModularFunctionMinimizer.h;  MPIProcess.h;  NegativeG2LineSearch.h;  Numerical2PGradientCalculator.h;  ParametricFunction.h;  ScanBuilder.h;  ScanMinimizer.h;  SimplexBuilder.h;  SimplexMinimizer.h;  SimplexParameters.h;  SimplexSeedGenerator.h;  SinParameterTransformation.h;  SqrtLowParameterTransformation.h;  SqrtUpParameterTransformation.h;  StackAllocator.h;  VariableMetricBuilder.h;  VariableMetricEDMEstimator.h;  VariableMetricMinimizer.h;  VectorOuterProduct.h;  LinkDef.h;  TMinuit2TraceObject.h;  ► src;  AnalyticalGradientCalculator.cxx;  BasicMinimumError.cxx;  CombinedMinimumBuilder.cxx;  DavidonErrorUpdator.cxx;  FitterUtil.h;  FumiliBuilder.cxx;  FumiliErrorUpdator.cxx;  FumiliGradientCalculator.cxx;  FumiliMinimizer.cxx;  FumiliStandardChi2FCN.cxx;  FumiliStandardMaximumLikelihoodFCN.cxx;  HessianGradientCalculator.cxx;  InitialGradientCalculator.cxx;  LaEigenValues.cxx;  LaInnerProduct.cxx;  LaInverse.cxx;  LaOuterProduct.cxx;  LaSumOfElements.cxx;  LaVtMVSimilarity.cxx;  MinimumBuilder.cxx;  Minuit2Minimizer.cxx;  MnApplication.cxx;  mnbins.cxx;  MnContours.cxx;  MnCovarianceSqueeze.cxx;  mndasum.cxx;  mndaxpy.cxx;  mnddot.cxx;  mndscal.cxx;  mndspmv.cxx;  mndspr.cxx;  MnEigen.cxx;  MnFcn.cxx;  Mn,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:52561,Simpl,SimplexSeedGenerator,52561,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimplexSeedGenerator']
Usability,"Monitoring; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work packets for parallel processing; TPacketizerAdaptive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:111376,simpl,simple,111376,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['simpl'],['simple']
Usability,"MsgService that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooMsgService::addStream. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, ROOT.RooFit.Topic(ROOT.RooFit.Tracing), ROOT.RooFit.ClassName(""RooGaussian"")); ; # With keyword arguments:; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic = ROOT.RooFit.Tracing, ClassName = ""RooGaussian""). Definition at line 110 of file RooMsgService.h. Classes; struct  StreamConfig;  . Public Member Functions;  ~RooMsgService () override;  ; Int_t addStream (RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Add a message logging stream for message with given RooFit::MsgLevel or higher. ;  ; void clearErrorCount ();  ; Int_t & debugCode ();  ; RooWorkspace * debugWorkspace ();  ; void deleteStream (Int_t id);  Delete stream with given unique ID code. ;  ; Int_t errorCount () const;  ; StreamConfig & getStream (Int_t id);  ; bool getStreamStatus (Int_t id) const;  Get activation status of stream with given unique ID. ;  ; RooFit::MsgLevel globalKillBelow () const;  ; TClass * IsA () const override;  ; template<class T > ; bool isActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level);  Check if logging is active for given object/topic/RooFit::MsgLevel combination. ;  ; std::ostream & log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with RooAbsArg object self at given level and topic. ;  ; std::ostream & log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with TObject object self at given level and topic. ;  ; std::ostream & log (std::nullptr_t, RooFit::MsgLevel level, RooF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:2875,clear,clearErrorCount,2875,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"MultB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0); Elementary constructors. void AMultB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr=0). void AMultB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). void APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data); { memmove(fRowIndex,data,(this->fNrows+1)*sizeof(Int_t)); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* data); { memmove(fColIndex,data,this->fNelems*sizeof(Int_t)); return *this; }. TMatrixTSparse<Element> & SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b). TMatrixTBase<Element> & SetMatrixArray(const float* data, Option_t* = """"); { memcpy(fElements,data,this->fNelems*sizeof(Element)); return *this; }. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). void Clear(Option_t* = """"). TMatrixTSparse<Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). Bool_t IsSymmetric() const; { return (*this == TMatrixTSparse<Element>(kTransposed,*this)); }. void Mult(const TMatrixTSparse<float>& a, const TMatrixTSparse<float>& b); { AMultB(a,b,0); }. Int_t NonZeros() const; { return this->fNelems; }. TMatrixTBase<Element> & NormByDiag(const TVectorT<float>& , Option_t* ); { MayNotUse(""NormByDiag""); return *this; }. const TMatrixTSparseRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTSparseRow_const<Element>(*this,rown); }. TMatrixTSparseRow <Element> operator[](Int_t rown); { return TMatrixTSparseRow <Element>(*this,rown); }. TMatrixTSparse<Element> & operator-=(Element val). TMatrixTSparse<Element> & operator+=(Element val). TMatrixTSparse<Element> & operator*=(Element val). TMatrixTSparse<Element> & operator+=(const TMatrixTSparse<Element> ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTSparse_float_.html:26722,Clear,Clear,26722,root/html532/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_float_.html,4,['Clear'],['Clear']
Usability,"MultiRootFinder();; 140 ; 141 // usually copying is non trivial, so we delete this; 142 GSLMultiRootFinder(const GSLMultiRootFinder &) = delete;; 143 GSLMultiRootFinder & operator = (const GSLMultiRootFinder &) = delete;; 144 GSLMultiRootFinder(GSLMultiRootFinder &&) = delete;; 145 GSLMultiRootFinder & operator = (GSLMultiRootFinder &&) = delete;; 146 ; 147 /// set the type for an algorithm without derivatives; 148 void SetType(EType type) {; 149 fType = type; fUseDerivAlgo = false;; 150 }; 151 ; 152 /// set the type of algorithm using derivatives; 153 void SetType(EDerivType type) {; 154 fType = type; fUseDerivAlgo = true;; 155 }; 156 ; 157 /// set the type using a string; 158 void SetType(const char * name);; 159 ; 160 /*; 161 add the list of functions f1(x1,..xn),...fn(x1,...xn). The list must contain pointers of; 162 ROOT::Math::IMultiGenFunctions. The method requires the; 163 the begin and end of the list iterator.; 164 The list can be any stl container or a simple array of ROOT::Math::IMultiGenFunctions* or; 165 whatever implementing an iterator.; 166 If using a derivative type algorithm the function pointers must implement the; 167 ROOT::Math::IMultiGradFunction interface; 168 */; 169 template<class FuncIterator>; 170 bool SetFunctionList( FuncIterator begin, FuncIterator end) {; 171 bool ret = true;; 172 for (FuncIterator itr = begin; itr != end; ++itr) {; 173 const ROOT::Math::IMultiGenFunction * f = *itr;; 174 // Using bitwise operator &= require the operand to be a bool; 175 // to have the intended effect here.; 176 ret &= (AddFunction( *f) != 0);; 177 }; 178 return ret;; 179 }; 180 ; 181 /*; 182 add (set) a single function fi(x1,...xn) which is part of the system of; 183 specifying the begin and end of the iterator.; 184 If using a derivative type algorithm the function must implement the; 185 ROOT::Math::IMultiGradFunction interface; 186 Return the current number of function in the list and 0 if failed to add the function; 187 */; 188 int AddFunction( co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html:6354,simpl,simple,6354,doc/master/GSLMultiRootFinder_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html,1,['simpl'],['simple']
Usability,"N::EInitialization::kUniform;; 320 } else if (fWeightInitializationString == ""ZERO"") {; 321 fWeightInitialization = DNN::EInitialization::kZero;; 322 } else if (fWeightInitializationString == ""IDENTITY"") {; 323 fWeightInitialization = DNN::EInitialization::kIdentity;; 324 } else {; 325 fWeightInitialization = DNN::EInitialization::kGlorotUniform;; 326 }; 327 ; 328 // Training settings.; 329 ; 330 KeyValueVector_t strategyKeyValues = ParseKeyValueString(fTrainingStrategyString, TString(""|""), TString("",""));; 331 for (auto &block : strategyKeyValues) {; 332 TTrainingSettings settings;; 333 ; 334 settings.convergenceSteps = fetchValueTmp(block, ""ConvergenceSteps"", 100);; 335 settings.batchSize = fetchValueTmp(block, ""BatchSize"", 30);; 336 settings.maxEpochs = fetchValueTmp(block, ""MaxEpochs"", 2000);; 337 settings.testInterval = fetchValueTmp(block, ""TestRepetitions"", 7);; 338 settings.weightDecay = fetchValueTmp(block, ""WeightDecay"", 0.0);; 339 settings.learningRate = fetchValueTmp(block, ""LearningRate"", 1e-5);; 340 settings.momentum = fetchValueTmp(block, ""Momentum"", 0.3);; 341 settings.dropoutProbabilities = fetchValueTmp(block, ""DropConfig"", std::vector<Double_t>());; 342 ; 343 TString regularization = fetchValueTmp(block, ""Regularization"", TString(""NONE""));; 344 if (regularization == ""L1"") {; 345 settings.regularization = DNN::ERegularization::kL1;; 346 } else if (regularization == ""L2"") {; 347 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:13034,learn,learningRate,13034,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learningRate']
Usability,"N::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtMatrix_t & GetWeightGradientsAt(size_t i)Definition GeneralLayer.h:188; TMVA::DNN::VGeneralLayer::ReadMatrixXMLvoid ReadMatrixXML(void *node, const char *name, Matrix_t &matrix)Definition GeneralLayer.h:544; TMVA::DNN::VGeneralLayer::Forwardvirtual void Forward(Tensor_t &input, bool applyDropout=false)=0Computes activation of the layer for the given input.; TMVA::DNN::VGeneralLayer::GetOutputAtMatrix_t GetOutputAt(size_t i)Definition GeneralLayer.h:202; TMVA::DNN::VGeneralLayer::GetWidthsize_t GetWidth() constDefinition GeneralLayer.h:169; TMVA::DNN::VGeneralLayer::GetHeightsize_t GetHeight() constDefinition GeneralLayer.h:168; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtconst Matrix_t & GetWeightGradientsAt(size_t i) constDefinition GeneralLayer.h:187; TMVA::DNN::VGeneralLayer::UpdateBiasesvoid UpdateBiases(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the biases, given the gradients and the learning rate.Definition GeneralLayer.h:428; TMVA::DNN::VGeneralLayer::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition GeneralLayer.h:53; TMVA::DNN::VGeneralLayer::IsTrainingbool IsTraining() constDefinition GeneralLayer.h:170; TMVA::DNN::VGeneralLayer::GetOutputTensor_t & GetOutput()Definition GeneralLayer.h:197; TMVA::DNN::VGeneralLayer::~VGeneralLayervirtual ~VGeneralLayer()Virtual Destructor.Definition GeneralLayer.h:388; TMVA::DNN::VGeneralLayer::GetOutputAtconst Matrix_t & GetOutputAt(size_t i) constDefinition GeneralLayer.h:203; TMVA::DNN::VGeneralLayer::VGeneralLayerVGeneralLayer(size_t BatchSize, size_t InputDepth, size_t InputHeight, size_t InputWidth, size_t Depth, size_t Height, size_t Width, size_t WeightsNSlices, size_t WeightsNRows, size_t WeightsNCols, size_t BiasesNSlices, size_t BiasesNRows, size_t BiasesNCols, size_t OutputNSlices, size_t OutputNRows, size_t OutputNCols,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:36746,learn,learningRate,36746,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"NCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNCalls(unsigned int calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorMultiDimOptions.html:2470,Clear,ClearExtra,2470,root/html532/ROOT__Math__IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorMultiDimOptions.html,2,['Clear'],['ClearExtra']
Usability,"NN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54375,learn,learningRate,54375,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learningRate']
Usability,"NO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Linear feedback shift register */; 5882 static uint64_t lcg = 0; /* Linear congruential generator */; 5883 uint64_t now = mg_get_current_time_ns();; 5884 ; 5885 if (lfsr == 0) {; 5886 /* lfsr will be only 0 if has not been initialized,; 5887 * so this code is called only once. */; 5888 lfsr = mg_get_current_time_ns();; 5889 lcg = mg_get_current_time_ns();; 5890 } else {; 5891 /* Get the next step of both random number generators. */; 5892 lfsr = (lfsr >> 1); 5893 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5894 << 63);; 5895 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5896 }; 5897 ; 5898 /* Combining two pseudo-random number generators and a high resolution; 5899 * part; 5900 * of the current server time will make it hard (impossible?) to guess; 5901 * the; 5902 * next number. */; 5903 return (lfsr ^ lcg ^ now);; 5904}; 5905 ; 5906 ; 5907static int; 5908mg_poll(struct mg_pollfd *pfd,; 5909 unsigned int n,; 5910 int milliseconds,; 5911 const stop_flag_t *stop_flag); 5912{; 5913 /* Call poll, but only fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:172502,feedback,feedback,172502,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['feedback'],['feedback']
Usability,"NO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Linear feedback shift register */; 5883 static uint64_t lcg = 0; /* Linear congruential generator */; 5884 uint64_t now = mg_get_current_time_ns();; 5885 ; 5886 if (lfsr == 0) {; 5887 /* lfsr will be only 0 if has not been initialized,; 5888 * so this code is called only once. */; 5889 lfsr = mg_get_current_time_ns();; 5890 lcg = mg_get_current_time_ns();; 5891 } else {; 5892 /* Get the next step of both random number generators. */; 5893 lfsr = (lfsr >> 1); 5894 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5895 << 63);; 5896 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5897 }; 5898 ; 5899 /* Combining two pseudo-random number generators and a high resolution; 5900 * part; 5901 * of the current server time will make it hard (impossible?) to guess; 5902 * the; 5903 * next number. */; 5904 return (lfsr ^ lcg ^ now);; 5905}; 5906 ; 5907 ; 5908static int; 5909mg_poll(struct mg_pollfd *pfd,; 5910 unsigned int n,; 5911 int milliseconds,; 5912 const stop_flag_t *stop_flag); 5913{; 5914 /* Call poll, but only fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:172534,feedback,feedback,172534,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['feedback'],['feedback']
Usability,"NTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of templates, and the ownership is well-defined through the use of smart pointers. For instance tree->Branch(""px"", &Category, ""px/F"");; becomes auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>; The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on most modern architectures. Combined with a clear separation of offset/index data and payload data for collections, uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; RNTuple shall investigate improvements of the TTree I/O in the following ways. More speed; Improve mapping to vectorized and parallel hardware; For types known at compile / JIT time: generate optimized code; Optimized for simple types (float, int, and vectors of them); Better memory control: work with a fixed budget of pre-defined I/O buffers; Naturally thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:1119,simpl,simple,1119,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['simpl'],['simple']
Usability,"NTupleModel & ; ). friend . ◆ Internal::GetProjectedFieldsOfModel. Internal::RProjectedFields & Internal::GetProjectedFieldsOfModel ; (; RNTupleModel & ; ). friend . Member Data Documentation. ◆ fDefaultEntry. std::unique_ptr<REntry> ROOT::Experimental::RNTupleModel::fDefaultEntry. private . Contains field values corresponding to the created top-level fields, as well as registered subfields. ; Definition at line 200 of file RNTupleModel.hxx. ◆ fDescription. std::string ROOT::Experimental::RNTupleModel::fDescription. private . Free text set by the user. ; Definition at line 204 of file RNTupleModel.hxx. ◆ fFieldNames. std::unordered_set<std::string> ROOT::Experimental::RNTupleModel::fFieldNames. private . Keeps track of which field names are taken, including projected field names. ; Definition at line 202 of file RNTupleModel.hxx. ◆ fFieldZero. std::unique_ptr<RFieldZero> ROOT::Experimental::RNTupleModel::fFieldZero. private . Hierarchy of fields consisting of simple types and collections (sub trees) ; Definition at line 198 of file RNTupleModel.hxx. ◆ fIsFrozen. bool ROOT::Experimental::RNTupleModel::fIsFrozen = false. private . Changed by Freeze() / Unfreeze() and by the RUpdater. ; Definition at line 215 of file RNTupleModel.hxx. ◆ fModelId. std::uint64_t ROOT::Experimental::RNTupleModel::fModelId = 0. private . Every model has a unique ID to distinguish it from other models. ; Entries are linked to models via the ID. Cloned models get a new model ID. ; Definition at line 211 of file RNTupleModel.hxx. ◆ fProjectedFields. std::unique_ptr<Internal::RProjectedFields> ROOT::Experimental::RNTupleModel::fProjectedFields. private . The set of projected top-level fields. ; Definition at line 206 of file RNTupleModel.hxx. ◆ fRegisteredSubfields. std::unordered_set<std::string> ROOT::Experimental::RNTupleModel::fRegisteredSubfields. private . Keeps track of which subfields have been registered to be included in entries belonging to this model. ; Definition at line 208 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:20493,simpl,simple,20493,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['simpl'],['simple']
Usability,"NVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsRealLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, const RooAbsBinning **bins);  Create a 1,2, or 3D-histogram with appropriate scale and labels. ;  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, double *xlo, double *xhi, Int_t *nBins);  Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:54395,clear,clearEvalErrorLog,54395,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,2,['clear'],['clearEvalErrorLog']
Usability,"Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; const char * ElementGetter (TClass *cl, const char *membername, int specials=0);  produce code to access member of given class. ;  ; const char * ElementSetter (TClass *cl, const char *membername, char *endch);  Produce code to set value to given data member. ;  ; TString GetBasicTypeName (TStreamerElement *el);  return simple data types for given TStreamerElement object ;  ; TString GetBasicTypeReaderMethodName (Int_t type, const char *realname);  return functions name to read simple data type from xml file ;  ; TString GetMemberTypeName (TDataMember *member);  returns name of simple data type for given data member ;  ; TString GetStreamerName (TClass *cl);  returns streamer function name for given class ;  ; Bool_t ProduceSTLstreamer (std::ostream &fs, TClass *cl, TStreamerSTL *el, Bool_t isWriting);  Produce code of xml streamer for data member of stl type. ;  ; void ProduceStreamerSource (std::ostream &fs, TClass *cl, TList *cllist);  Produce source code of streamer function for specified class. ;  ; void ReadSTLarg (std::ostream &fs, TString &argname, int argtyp, Bool_t isargptr, TClass *argcl, TString &tname, TString &ifcond);  Produce code to read argument of stl container from xml file. ;  ; void WriteSTLarg (std::ostream &fs, const char *accname, int argtyp, Bool_t isargptr, TClass *argcl);  Produce code to write argument of stl container to xml file. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:9480,simpl,simple,9480,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,3,['simpl'],['simple']
Usability,"Name());; 2606 fElements->Add( el );; 2607 }; 2608 ; 2609 Compile();; 2610}; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105421,clear,clear,105421,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"Name=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; double getNominal (Int_t ibin) const;  ; double getNominalError (Int_t ibin) const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setActual (Int_t ibin, double newVal);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:3109,simpl,simple,3109,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['simpl'],['simple']
Usability,"Named type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside the class definition. The syntax is:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:496568,simpl,simple,496568,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,NewProto; kCXX_ConstructorProto; kCXX_ScopeProto; kCXX_DirectProto; kCXX_IndirectProto; kCXX_ScopeMember; kCXX_DirectMember; kCXX_IndirectMember; kCXX_Global; kCXX_GlobalProto; kNUM_PAT; };. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTabCom.html:6960,Clear,ClearClasses,6960,root/html532/TTabCom.html,https://root.cern,https://root.cern/root/html532/TTabCom.html,4,['Clear'],"['Clear', 'ClearClasses']"
Usability,"No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Friends |; List of all members ; RooMappedCategory Class Reference. ; RooMappedCategory provides a category-to-category mapping defined by pattern matching on their state labels. ; The mapping function consists of a series of wild card regular expressions. Each expression is matched to the input categories' state labels, and an associated output state label. ; Definition at line 27 of file RooMappedCategory.h. Classes; class  Entry;  . Public Member Functions;  RooMappedCategory ();  ;  RooMappedCategory (const char *name, const char *title, RooAbsCategory &inputCat, const char *defCatName=""NotMapped"", Int_t defCatIdx=NoCatIdx);  ;  RooMappedCategory (const RooMappedCategory &other, const char *name=nullptr);  ;  ~RooMappedCategory () override;  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; bool map (const char *inKeyRegExp, const char *outKeyName, Int_t outKeyNum=NoCatIdx);  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the product operator construction. ;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to ostream. ;  ;  Public Member Functions inherited from RooAbsCategory;  RooAbsCategory ();  ;  RooAbsCategor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:1387,intuit,intuitively,1387,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Double_t rate); decay the learning rate. { fLearnRate *= (1-rate); }. void SetPreNeuron(TMVA::TNeuron* pre); set the pre-neuron. { fPreNeuron = pre; }. void SetPostNeuron(TMVA::TNeuron* post); set hte post-neuron. { fPostNeuron = post; }. void InitDelta(); initialize the error field of the synpase to 0. { fDelta = 0.0; fCount = 0; }. void SetDEDw(Double_t DEDw); { fDEDw = DEDw; }. Double_t GetDEDw(); { return fDEDw; }. Double_t GetDelta(); { return fDelta; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TSynapse.html:6679,learn,learning,6679,root/html534/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html534/TMVA__TSynapse.html,6,['learn'],['learning']
Usability,"Notify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:28135,learn,learning,28135,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,2,['learn'],['learning']
Usability,"Ntuple; 13#define ROOT_TNtuple; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TNtuple //; 19// //; 20// A simple tree with branches of floats. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TTree.h""; 25 ; 26class TBrowser;; 27 ; 28class TNtuple : public TTree {; 29 ; 30protected:; 31 Int_t fNvar; ///< Number of columns; 32 Float_t *fArgs; ///<! [fNvar] Array of variables; 33 ; 34 Int_t Fill() override;; 35 ; 36private:; 37 TNtuple(const TNtuple&) = delete;; 38 TNtuple& operator=(const TNtuple&) = delete;; 39 ; 40public:; 41 TNtuple();; 42 TNtuple(const char *name,const char *title, const char *varlist, Int_t bufsize=32000);; 43 ~TNtuple() override;; 44 ; 45 void Browse(TBrowser *b) override;; 46 TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """") override;; 47 virtual Int_t Fill(const Float_t *x);; 48 Int_t Fill(Int_t x0) { return Fill((Float_t)x0); }; 49 Int_t Fill(Double_t x0) { return Fill((Float_t)x0); }; 50 virtual Int_t Fill(Float_t x0, Float_t x1=0, Float_t x2=0, Float_t x3=0,; 51 Float_t x4=0, Float_t x5=0, Float_t x6=0, Float_t x7=0,; 52 Float_t x8=0, Float_t x9=0, Float_t x10=0,; 53 Float_t x11=0, Float_t x12=0, Float_t x13=0,; 54 Float_t x14=0);; 55 virtual Int_t GetNvar() const { return fNvar; }; 56 Float_t *GetArgs() const { return fArgs; }; 57 Long64_t ReadStream(std::istream& inputStream, const char *branchDescriptor="""", char delimiter = ' ') override;; 58 void ResetBranchAddress(TBranch *) override;; 59 void ResetBranchAddresses() override;; 60 ; 61 ClassDefOverride(TNtuple,2); //A simple tree with branches of floats.; 62};; 63 ; 64#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNtuple_8h_source.html:2280,simpl,simple,2280,doc/master/TNtuple_8h_source.html,https://root.cern,https://root.cern/doc/master/TNtuple_8h_source.html,1,['simpl'],['simple']
Usability,"Nuclides.C It demonstrates also the decay of a mixture made of radionuclides. Concentracion of elements derived fromCa53+Sr78. 18.2.3 Tracking Media; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary cros",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:896055,simpl,simple,896055,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242682,simpl,simple,242682,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['simpl'],['simple']
Usability,"OMParser & operator= (const TDOMParser &)=delete;  ; Int_t ParseContext ();  Creates a XML document for the parser. ;  . Private Attributes; TXMLDocument * fTXMLDoc;  xmlDoc ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TXMLParser; virtual void InitializeContext ();  Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ;  ; virtual void OnValidateError (const TString &message);  This function is called when an error from the parser has occurred. ;  ; virtual void OnValidateWarning (const TString &message);  This function is called when a warning from the parser has occurred. ;  ; virtual void SetParseCode (Int_t code);  Set the parse code: ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDOMParser.html:14829,clear,clear,14829,doc/master/classTDOMParser.html,https://root.cern,https://root.cern/doc/master/classTDOMParser.html,1,['clear'],['clear']
Usability,"ONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as color boxes; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box; Iso; Parametric plot. Introduction; Histograms are drawn via the THistPainter class. Each histogram has a; pointer to its own painter (to be usable in a multithreaded program). When the; canvas has to be redrawn, the Paint function of each objects in the; pad is called. In case of histograms, TH1::Paint invokes directly; THistPainter::Paint.; To draw a histogram ""h"" is enough to do:. h->Draw();. ""h"" can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a cen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:2143,usab,usable,2143,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['usab'],['usable']
Usability,"OOT: math/mathcore/inc/Fit/DataOptions.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. DataOptions.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Wed Aug 30 11:04:59 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class DataOptions; 12 ; 13#ifndef ROOT_Fit_DataOptions; 14#define ROOT_Fit_DataOptions; 15 ; 16 ; 17namespace ROOT {; 18 ; 19 namespace Fit {; 20 ; 21 ; 22//___________________________________________________________________________________; 23/**; 24 DataOptions : simple structure holding the options on how the data are filled; 25 ; 26 @ingroup FitData; 27*/; 28struct DataOptions {; 29 ; 30 ; 31 /**; 32 Default constructor: use the default options; 33 */; 34 DataOptions () :; 35 fIntegral(false),; 36 fBinVolume(false),; 37 fNormBinVolume(false),; 38 fUseEmpty(false),; 39 fUseRange(false),; 40 fErrors1(false),; 41 fExpErrors(false),; 42 fCoordErrors(true),; 43 fAsymErrors(true); 44 {}; 45 ; 46 ; 47 bool fIntegral; ///< use integral of bin content instead of bin center (default is false); 48 bool fBinVolume; ///< normalize data by the bin volume (it is used in the Poisson likelihood fits); 49 bool fNormBinVolume; ///< normalize data by a normalized the bin volume (bin volume divided by a reference value); 50 bool fUseEmpty; ///< use empty bins (default is false) with a fixed error of 1; 51 bool fUseRange; ///< use the function range when creating the fit data (default is false); 52 bool fErrors1; ///< use all errors equal to 1, i.e. fit without errors (default is false); 53 bool fExpErrors; ///< use expected errors from the function and not from the data; 54 bool fCoordErrors; ///< use errors on the x coordinates when available (default is true); 55 bool f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataOptions_8h_source.html:791,simpl,simple,791,doc/master/DataOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/DataOptions_8h_source.html,1,['simpl'],['simple']
Usability,"OOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; ROOT::Minuit2::SimplexMinimizer&operator=(const ROOT::Minuit2::SimplexMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const; ROOT::Minuit2::SimplexMinimizerSimplexMinimizer(); ROOT::Minuit2::SimplexMinimizerSimplexMinimizer(const ROOT::Minuit2::SimplexMinimizer&). Data Members; private:. ROOT::Minuit2::SimplexBuilderfBuilder; ROOT::Minuit2::SimplexSeedGeneratorfSeedGenerator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimplexMinimizer(); {}. ~SimplexMinimizer(); {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__SimplexMinimizer.html:3549,Simpl,SimplexMinimizer,3549,root/html534/ROOT__Minuit2__SimplexMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__SimplexMinimizer.html,9,['Simpl'],"['SimplexBuilderfBuilder', 'SimplexMinimizer', 'SimplexMinimizerSimplexMinimizer', 'SimplexSeedGeneratorfSeedGenerator']"
Usability,"OStream & ; prn, . const Descriptor ; usage[], . int ; width = 80, . int ; last_column_min_percent = 50, . int ; last_column_own_line_max_percent = 75 . ). Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ; printUsage() takes the help texts of a Descriptor[] array and formats them into a usage message, wrapping lines to achieve the desired output width.; Table formatting:; Aside from plain strings which are simply line-wrapped, the usage may contain tables. Tables are used to align elements in the output.; // Without a table. The explanatory texts are not aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; ; // With table formatting. The explanatory texts are aligned.; -c, --create |Creates something.; -k, --kill |Destroys something.; c#define c(i)Definition RSha256.hxx:101; Table formatting removes the need to pad help texts manually with spaces to achieve alignment. To create a table, simply insert \t (tab) characters to separate the cells within a row.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""-k, --kill \tDestroys something."" }, ...; Note that you must include the minimum amount of space desired between cells yourself. Table formatting will insert further spaces as needed to achieve alignment.; You can insert line breaks within cells by using \v (vertical tab).; const option::Descriptor usage[] = {; {..., ""-c,\v--create \tCreates\vsomething."" },; {..., ""-k,\v--kill \tDestroys\vsomething."" }, ...; ; // results in; ; -c, Creates; --create something.; -k, Destroys; --kill something.; You can mix lines that do not use \t or \v with those that do. The plain lines will not mess up the table layout. Alignment of the table columns will be maintained even across these interjections.; const option::Descriptor usage[] = {; {..., ""-c, --create \tCreates something."" },; {..., ""----------------------------------"" },; {..., ""-k, --kill \tDestroys somethi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1option.html:6982,simpl,simply,6982,doc/master/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1option.html,1,['simpl'],['simply']
Usability,"OT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120455,simpl,simpleTableTest,120455,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simpleTableTest']
Usability,"OT team in 1996. He developed the first version of the HTML documentation system (THtml) and worked on the first version of the 3D graphics system. Nenad left in 1997.; Paul Russo; Paul joined the ROOT team at Fermilab in 2005 and has been focusing on support and developing CINT.; Pere Mato; Pere Mato was the project leader from 2014 to 2017. He was the driving force behind ROOT's migration to CMake and has contributed to PyROOT.; Richard Maunder; Richard worked as project associate on the 3D graphics OpenGL based system.; Susan Panacek; Susan wrote the first ROOT User's Guide and developed a number of ROOT tutorials.; Timur Pocheptsov; Timur worked as a project associate on many different aspects of ROOT, but mostly on the OpenGL accelerated 3D graphics and the native macOS Cocoa based GUI. Timur also ported ROOT to the iPad. He continues to maintain the OpenGL and Cocoa code till this day.; Valeri Fine; Valeri was a member of the ROOT team from 1998-2000. He made the initial port to Windows. Currently he is the maintainer of the ROOT-Qt interface.; Valeri Onuchin; Valeri worked as a project associate on many different aspects of ROOT, but mostly in the GUI and graphics area. He did develop the signal/slot functionality and the GUI builder. He also developed the Carrot ROOT enabled web server. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:6874,guid,guidelines,6874,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['guid'],['guidelines']
Usability,"OT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TRootCanvas Class ReferenceGUI » Low level GUI widgets. ; This class creates a main window with menubar, scrollbars and a drawing area. ; The widgets used are the new native ROOT GUI widgets. ; Definition at line 34 of file TRootCanvas.h. Public Member Functions;  TRootCanvas (TCanvas *c, const char *name, Int_t x, Int_t y, UInt_t width, UInt_t height);  Create a basic ROOT canvas. ;  ;  TRootCanvas (TCanvas *c=nullptr, const char *name=""ROOT Canvas"", UInt_t width=500, UInt_t height=300);  Create a basic ROOT canvas. ;  ;  ~TRootCanvas () override;  Delete ROOT basic canvas. ;  ; void Activated (Int_t id);  Slot handling tab switching in the browser, to properly set the canvas and the model to the editor. ;  ; void AdjustSize ();  Keep the same canvas size while docking/undocking toolbar. ;  ; void Close () override;  Called via TCanvasImp interface by TCanvas. ;  ; void CloseWindow () override;  In case window is closed via WM we get here. ;  ; void EventInfo (Int_t event, Int_t px, Int_t py, TObject *selected);  Display a tooltip with infos about the primitive below the cursor. ;  ; void FitCanvas ();  Fit canvas container to current window size. ;  ; void ForceUpdate () override;  ; UInt_t GetCheight () const;  Return height of canvas container. ;  ; UInt_t GetCwidth () const;  Return width of canvas container. ;  ; TGMenuBar * GetMenuBar () const;  ; TGLayoutHints * GetMenuBarItemLayout () const;  ; TGStatusBar * GetStatusBar () const;  ; TGDockableFrame * GetToolDock () const;  ; UInt_t GetWindowGeometry (Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) override;  Gets the size and position of the window containing the canvas. ;  ; Bool_t HasEditor () const override;  Returns kTRUE if the editor is shown. ;  ; Bool_t HasMenuBar (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:1066,undo,undocking,1066,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['undo'],['undocking']
Usability,"OT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  Nroot-argparse;  Nrootmarks;  ►NROOTwriter;  CROOTwriter;  Nshapes;  Nsqlcreatedb;  Nsqlfilldb;  Nsqlio;  Nsqlselect;  Nstaff;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  Nsurfaces;  Ntbb;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:83227,simpl,simple,83227,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['simpl'],['simple']
Usability,"OT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declaration into fReturnType fScopeName::fFunctionName<fFunctionTemplateArguments>(fFunctionParameters) ;  CTInterpreterLook",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:79547,simpl,simple,79547,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"OT::EnableImplicitMT(); // Enable ROOT's implicit multi-threading; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto histoA = d.Histo1D(""Branch_A""); // Book the filling of a histogram; auto histoB = d.Histo1D(""Branch_B""); // Book the filling of another histogram; // Data processing is triggered by the next line, which accesses a booked result for the first time; // All booked results are evaluated during the same parallel event loop.; histoA->Draw(); // <-- event loop runs here!; histoB->Draw(); // HistoB has already been filled, no event loop is run here; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; Explore the examples below or go to RDataFrame's user guide. . Files; file  df000_simple.C;   Simple RDataFrame example in C++. ;  ; file  df000_simple.py;   Simple RDataFrame example in Python. ;  ; file  df001_introduction.C;   Basic RDataFrame usage. ;  ; file  df001_introduction.py;   Basic usage of RDataFrame from python. ;  ; file  df002_dataModel.C;   Show how to work with non-flat data models, e.g. ;  ; file  df002_dataModel.py;   Show how to work with non-flat data models, e.g. ;  ; file  df003_profiles.C;   Use TProfiles with RDataFrame. ;  ; file  df003_profiles.py;   Use TProfiles with RDataFrame. ;  ; file  df004_cutFlowReport.C;   Display cut/Filter efficiencies with RDataFrame. ;  ; file  df004_cutFlowReport.py;   Display cut/Filter efficiencies with RDataFrame. ;  ; file  df005_fillAnyObject.C;   Using the generic Fill action. ;  ; file  df006_ranges.C;   Use Range to limit the amount of data processed. ;  ; file  df006_ranges.py;   Use Range to limit the amount of data processed. ;  ; file  df0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__dataframe.html:1556,guid,guide,1556,doc/master/group__tutorial__dataframe.html,https://root.cern,https://root.cern/doc/master/group__tutorial__dataframe.html,1,['guid'],['guide']
Usability,"OT::Experimental::RCanvas::RCanvas ; (; ). inline . Create a temporary RCanvas; for long-lived ones please use Create(). ; Definition at line 88 of file RCanvas.hxx. ◆ ~RCanvas(). ROOT::Experimental::RCanvas::~RCanvas ; (; ). overridedefault . Member Function Documentation. ◆ AddPanel(). template<class PANEL > . bool ROOT::Experimental::RCanvas::AddPanel ; (; std::shared_ptr< PANEL > & ; panel). inline . Insert panel into the canvas, canvas should be shown at this moment. ; Definition at line 139 of file RCanvas.hxx. ◆ ClearOnClose(). void ROOT::Experimental::RCanvas::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed. ; Definition at line 239 of file RCanvas.cxx. ◆ ClearShown(). void ROOT::Experimental::RCanvas::ClearShown ; (; ). inline . clear IsShown() flag ; Definition at line 123 of file RCanvas.hxx. ◆ ClearUpdated(). void ROOT::Experimental::RCanvas::ClearUpdated ; (; ). inline . clear IsUpdated() flag ; Definition at line 169 of file RCanvas.hxx. ◆ Create(). std::shared_ptr< ROOT::Experimental::RCanvas > ROOT::Experimental::RCanvas::Create ; (; const std::string & ; title). static . Create new canvas instance. ; Definition at line 89 of file RCanvas.cxx. ◆ CreateJSON(). std::string ROOT::Experimental::RCanvas::CreateJSON ; (; ). Provide JSON which can be used for offline display. ; Create JSON data for the canvas Can be used of offline display with JSROOT. ; Definition at line 211 of file RCanvas.cxx. ◆ GetCanvas() [1/2]. const RCanvas * ROOT::Experimental::RCanvas::GetCanvas ; (; ); const. inlineoverridevirtual . Access to the top-most canvas, if any (const version). ; Implements ROOT::Experimental::RPadBase.; Definition at line 92 of file RCanvas.hxx. ◆ GetCanvas() [2/2]. RCanvas * ROOT::Experimental::RCanvas::GetCanvas ; (; ). inlineoverridevirtual . Access to the top-most canvas, if any (non-const version). ; Implements ROOT::Experimental::RPadBase.; Definition at line 95 of file RCanvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:10656,clear,clear,10656,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['clear'],['clear']
Usability,"OT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; ROOT::Minuit2::ScanMinimizer&operator=(const ROOT::Minuit2::ScanMinimizer&); ROOT::Minuit2::ScanMinimizerScanMinimizer(); ROOT::Minuit2::ScanMinimizerScanMinimizer(const ROOT::Minuit2::ScanMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Data Members; private:. ROOT::Minuit2::ScanBuilderfBuilder; ROOT::Minuit2::SimplexSeedGeneratorfSeedGenerator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ScanMinimizer(); {}. ~ScanMinimizer(); {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__ScanMinimizer.html:3868,Simpl,SimplexSeedGeneratorfSeedGenerator,3868,root/html534/ROOT__Minuit2__ScanMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__ScanMinimizer.html,1,['Simpl'],['SimplexSeedGeneratorfSeedGenerator']
Usability,"OT::RGeomDescription Class Reference. . Definition at line 210 of file RGeomData.hxx. Classes; class  ShapeDescr;  . Public Member Functions;  RGeomDescription ()=default;  ; void AddSignalHandler (const void *handler, RGeomSignalFunc_t func);  Add signal handler. ;  ; void Build (TGeoManager *mgr, const std::string &volname="""");  Collect information about geometry hierarchy into flat list like it done in JSROOT ClonedNodes.createClones. ;  ; void Build (TGeoVolume *vol);  Collect information about geometry from single volume like it done in JSROOT ClonedNodes.createClones. ;  ; bool ChangeConfiguration (const std::string &json);  Change configuration by client Returns true if any parameter was really changed. ;  ; bool ChangeNodeVisibility (const std::vector< std::string > &path, bool on);  Change visibility for specified element Returns true if changes was performed. ;  ; bool ClearAllPhysVisibility ();  Reset all custom visibility settings. ;  ; void ClearCache ();  Clear cached data, need to be clear when connection broken. ;  ; void ClearDrawData ();  Clear raw data. Will be rebuild when next connection will be established. ;  ; bool ClearPhysNodeVisibility (const std::vector< std::string > &path);  Reset custom visibility of physical node by path. ;  ; int FindNodeId (const std::vector< int > &stack);  Returns nodeid for given stack array, returns -1 in case of failure. ;  ; std::string GetActiveItem () const;  ; std::vector< int > GetClickedItem () const;  ; std::string GetDrawJson () const;  ; std::string GetDrawOptions () const;  Returns draw options, used for JSROOT TGeoPainter. ;  ; std::vector< int > GetHighlightedItem () const;  ; int GetJsonComp () const;  Returns JSON compression level for data transfer. ;  ; int GetMaxVisFaces () const;  Returns maximal visible number of faces, ignored when non-positive. ;  ; int GetMaxVisNodes () const;  Returns maximal visible number of nodes, ignored when non-positive. ;  ; TVirtualMutex * GetMutex () const;  Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:1288,clear,clear,1288,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['clear'],['clear']
Usability,"OT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:1286,undo,undo,1286,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,10,['undo'],['undo']
Usability,"Obj, int siz). protected:. voidTGenCollectionProxy::CheckFunctions() const; virtual voidTGenCollectionProxy::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize() const; virtual TGenCollectionProxy*InitializeEx(); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:4284,clear,clear,4284,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,2,['clear'],['clear']
Usability,"ObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:16823,undo,undo,16823,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"Object* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); TGeoNavigator*AddNavigator(); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigatorArray.html:2063,Clear,Clear,2063,root/html532/TGeoNavigatorArray.html,https://root.cern,https://root.cern/root/html532/TGeoNavigatorArray.html,2,['Clear'],['Clear']
Usability,"Object* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTCollection::Browse(TBrowser* b); virtual Bool_tCanCompress(TQCommand* c) const; virtual Bool_tCanMerge(TQCommand* c) const; virtual Bool_tCanRedo() const; virtual Bool_tCanUndo() const; Int_tTCollection::Capacity() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(TQCommand* c); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:4935,Clear,Clear,4935,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,2,['Clear'],['Clear']
Usability,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentNodeIndex(Int_t index); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolumeAssembly.html:17408,clear,clear,17408,root/html528/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html,4,['clear'],['clear']
Usability,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolumeMulti.html:17586,clear,clear,17586,root/html528/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html,4,['clear'],['clear']
Usability,"Object::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:7034,Simpl,SimpleInterval,7034,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,9,['Simpl'],"['SimpleInterval', 'SimpleIntervalRooStats']"
Usability,"Object::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGScrollBar&operator=(const TGScrollBar&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGScrollBar.html:14876,Clear,ClearFlags,14876,root/html532/TGScrollBar.html,https://root.cern,https://root.cern/root/html532/TGScrollBar.html,2,['Clear'],['ClearFlags']
Usability,"Object::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTDataSet::AddMain(TDataSet* set); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); static TTableDescriptor*CreateDescriptor(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); virtual voidSetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char *const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3); static const char*TTable::TableDictionary(const char* className, const char* structName, TTableDescriptor*& ColDescriptors). Data Members; public:. enum TTable::EColumnType { kNAN; kFloat; kInt; kLong; kShort; kDouble; kUInt; kULong; kUShort; kUChar; kChar; kPtr; kBool; kEndColumnType; };; enum TTable::ETableBits { kIsNotOwn; };; enum TDataSet::EDataSetPass { kContinue; kPrune; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TIndexTable.html:12551,Clear,Clear,12551,root/html532/TIndexTable.html,https://root.cern,https://root.cern/root/html532/TIndexTable.html,2,['Clear'],['Clear']
Usability,"Object::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTDataSet::AddMain(TDataSet* set); Bool_tTTable::BoundsOk(const char* where, Int_t at) const; virtual voidTTable::Clear(Option_t* opt = """"); voidTTable::CopyStruct(Char_t* dest, const Char_t* src); Char_t*TTable::Create(); static TTableDescriptor*CreateDescriptor(); virtual voidTTable::Delete(Option_t* opt = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tTTable::EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"); virtual TTableDescriptor*GetDescriptorPointer() const; TDataSet*TDataSet::GetRealParent(); voidTDataSet::MakeCollection(); voidTObject::MakeZombie(); Bool_tTTable::OutOfBoundsError(const char* where, Int_t i) const; voidTTable::ReAlloc(Int_t newsize); virtual voidSetDescriptorPointer(TTableDescriptor* list); Int_tTTable::SetfN(Long_t len); virtual voidTDataSet::SetMother(TObject* mother); voidTTable::SetTablePointer(void* table); virtual voidTTable::SetType(const char*const type); voidTTable::SetUsedRows(Int_t n); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user); voidTTable::StreamerHeader(TBuffer& b, Version_t version = 3); voidTTable::StreamerTable(TBuffer& b, Version_t version = 3); static const char*TTable::TableDictionary(const char* className, const char* structName, TTableDescriptor*& ColDescriptors). Data Members; public:. static const char*TTable::fgTypeName[13]; static TDataSet::EDataSetPassTDataSet::kAll; static TDataSet::ESetBitsTDataSet::kArray; static TObject::(anonymous)TObject::kBitMask; static TTable::EColumnTypeTTable::kBool; static TObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIndexTable.html:12670,Clear,Clear,12670,root/html602/TIndexTable.html,https://root.cern,https://root.cern/root/html602/TIndexTable.html,2,['Clear'],['Clear']
Usability,"Object::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoGenTrans.html:16764,clear,clear,16764,root/html604/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html604/TGeoGenTrans.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Object::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGenTrans.html:16764,clear,clear,16764,root/html602/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"Object::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TVirtualPerfStats::EEventTypekNumEventType; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TVirtualPerfStats::EEventTypekPacket; static TVirtualPerfStats::EEventTypekRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypekStart; static TVirtualPerfStats::EEventTypekStop; static TVirtualPerfStats::EEventTypekUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←. TPerfStats. TTreePerfStats. Function documentation; TVirtualPerfStats *& CurrentPerfStats(); Return the current ROOT perf stats if any. const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualPerfStats.html:7602,Simpl,SimpleEvent,7602,root/html604/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html604/TVirtualPerfStats.html,1,['Simpl'],['SimpleEvent']
Usability,"Object::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TVirtualPerfStats::EEventTypekNumEventType; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TVirtualPerfStats::EEventTypekPacket; static TVirtualPerfStats::EEventTypekRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypekStart; static TVirtualPerfStats::EEventTypekStop; static TVirtualPerfStats::EEventTypekUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←. TPerfStats. TTreePerfStats. Function documentation; TVirtualPerfStats *& CurrentPerfStats(); Return the current ROOT perf stats if any. const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPerfStats.html:7602,Simpl,SimpleEvent,7602,root/html602/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html602/TVirtualPerfStats.html,1,['Simpl'],['SimpleEvent']
Usability,"Object; TStreamerObjectPointer Streamer element of type pointer to a TObject; TStreamerSTL Streamer element of type STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringRef ; TStringToken String tokenizer using PCRE for finding next tokens.; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTVLVContainer A dragging-capable LVContainer; TTVLVEntry Item that goes into the tree list view widget; TTVRecord A draw record for TTreeViewer; TTVSession A tree viewer session; TTabCom Perform comand line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns since EPOCH; TTimer Handle timer event; TToggle Facility for toggling datamembers on/off; TToggleGroup Group of con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:120181,simpl,simple,120181,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['simpl'],['simple']
Usability,"Object; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:14488,Clear,Clear,14488,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,1,['Clear'],['Clear']
Usability,"ObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3017 ; 3018 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 3019 else fWriteMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3020 ; 3021 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 3022 else fReadMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table); 3033 if (fClass->GetState() == TClass::kEmulated && fNVirtualInfoLoc!=0) {; 3034 fSize = sizeof(TStreamerInfo*);; 3035 }; 3036 fComp = new TCompInfo[1];; 3037 fCompFull = new TCompInfo*[1];; 3038 fCompOpt = new TCompInfo*[1];; 3039 fCompOpt[0] = fCompFull[0] = &(fComp[0]);; 3040 SetIsCompiled();; 3041 return;; 3042 }; 3043 ; 3044 // At most half of the elements can be used to hold optimized versions.; 3045 // We use the bottom to hold the optimized-into elements and the non-optimized elements; 3046 // and the top to hold the original copy of the optimized out elements.; 3047 fNslots = ndata + ndata/2 + 1;; 3048 Int_t optiOut = 0;; 3049 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:132567,clear,clear,132567,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['clear'],['clear']
Usability,"Observables(). bool RooAbsArg::checkObservables ; (; const RooArgSet * ; nset); const. virtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented in RooLagrangianMorphFunc, RooAddModel, RooAddPdf, RooRealSumFunc, and RooRealSumPdf.; Definition at line 817 of file RooAbsArg.cxx. ◆ cleanBranchName(). TString RooAbsArg::cleanBranchName ; (; ); const. protected . Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ; Definition at line 2075 of file RooAbsArg.cxx. ◆ clearShapeDirty(). void RooAbsArg::clearShapeDirty ; (; ); const. inlineprotected . Definition at line 579 of file RooAbsArg.h. ◆ clearValueAndShapeDirty(). void RooAbsArg::clearValueAndShapeDirty ; (; ); const. inlineprotected . Definition at line 571 of file RooAbsArg.h. ◆ clearValueDirty(). void RooAbsArg::clearValueDirty ; (; ); const. inlineprotected . Definition at line 576 of file RooAbsArg.h. ◆ clients(). const RefCountList_t & RooAbsArg::clients ; (; ); const. inline . List of all clients of this object. ; Definition at line 166 of file RooAbsArg.h. ◆ clone(). virtual TObject * RooAbsArg::clone ; (; const char * ; newname = nullptr); const. pure virtual . Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:50834,clear,clearValueDirty,50834,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearValueDirty']
Usability,"Option_t *option) const; 2499{; 2500 if (!func) {; 2501 Error(""Chisquare"",""Function pointer is Null - return -1"");; 2502 return -1;; 2503 }; 2504 ; 2505 TString opt(option); opt.ToUpper();; 2506 bool useRange = opt.Contains(""R"");; 2507 ROOT::Fit::EChisquareType type = ROOT::Fit::EChisquareType::kNeyman; // default chi2 with observed error; 2508 if (opt.Contains(""L"")) type = ROOT::Fit::EChisquareType::kPLikeRatio;; 2509 else if (opt.Contains(""P"")) type = ROOT::Fit::EChisquareType::kPearson;; 2510 ; 2511 return ROOT::Fit::Chisquare(*this, *func, useRange, type);; 2512}; 2513 ; 2514////////////////////////////////////////////////////////////////////////////////; 2515/// Remove all the content from the underflow and overflow bins, without changing the number of entries; 2516/// After calling this method, every undeflow and overflow bins will have content 0.0; 2517/// The Sumw2 is also cleared, since there is no more content in the bins; 2518 ; 2519void TH1::ClearUnderflowAndOverflow(); 2520{; 2521 for (Int_t bin = 0; bin < fNcells; ++bin); 2522 if (IsBinUnderflow(bin) || IsBinOverflow(bin)) {; 2523 UpdateBinContent(bin, 0.0);; 2524 if (fSumw2.fN) fSumw2.fArray[bin] = 0.0;; 2525 }; 2526}; 2527 ; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// Compute integral (normalized cumulative sum of bins) w/o under/overflows; 2530/// The result is stored in fIntegral and used by the GetRandom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:99962,clear,cleared,99962,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['clear'],['cleared']
Usability,"Output. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassDocOutput.html:1249,Clear,Clear,1249,root/html602/TClassDocOutput.html,https://root.cern,https://root.cern/root/html602/TClassDocOutput.html,2,['Clear'],['Clear']
Usability,"Overwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiLayerPerceptron ();  Default constructor. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, const char *weight, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data, TEventList *training, TEventList *test, TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  TMultiLayerPerceptron (const char *layout, TTree *data=nullptr, const char *training=""Entry$%2==0"", const char *test="""", TNeuron::ENeuronType type=TNeuron::kSigmoid, const char *extF="""", const char *extD="""");  The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ;  ;  ~TMultiLayerPerceptron () override;  Destructor. ;  ; void ComputeDEDw () const;  Compute the DEDw = sum on all training events of dedw for each wei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:10663,simpl,simple,10663,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,PAT; };. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Retu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTabCom.html:7155,Clear,ClearFiles,7155,root/html532/TTabCom.html,https://root.cern,https://root.cern/root/html532/TTabCom.html,2,['Clear'],['ClearFiles']
Usability,"PROOF cluster. If logtomacro is TRUE the text result of the action is saved in the fMacroLog TMacro, accessible via TMacro::GetMacroLog(); Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6589 of file TProof.cxx. ◆ Exec() [3/3]. Int_t TProof::Exec ; (; const char * ; cmd, . ESlaves ; list, . Bool_t ; plusMaster . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6533 of file TProof.cxx. ◆ ExistsDataSet(). Bool_t TProof::ExistsDataSet ; (; const char * ; dataset). virtual . Returns kTRUE if 'dataset' exists, kFALSE otherwise. ; Reimplemented in TProofLite.; Definition at line 10868 of file TProof.cxx. ◆ Feedback(). void TProof::Feedback ; (; TList * ; objs). Get list of feedback objects. ; Connect a slot to this signal to monitor the feedback object. ; Definition at line 9268 of file TProof.cxx. ◆ FinalizationDone(). void TProof::FinalizationDone ; (; ). inlineprivate . Definition at line 694 of file TProof.h. ◆ Finalize() [1/2]. Long64_t TProof::Finalize ; (; const char * ; ref, . Bool_t ; force = kFALSE . ). Finalize query with reference ref. ; If force, force retrieval if the query is found in the local list but has already been finalized (default kFALSE). If ref = 0, finalize current query. Return 0 on success, -1 on error ; Definition at line 5908 of file TProof.cxx. ◆ Finalize() [2/2]. Long64_t TProof::Finalize ; (; Int_t ; qry = -1, . Bool_t ; force = kFALSE . ). Finalize the qry-th query in fQueries. ; If force, force retrieval if the query is found in the local list but has already been finalized (default kFALSE). If query < 0, finalize current query. Return 0 on success, -1 on error ; Definition at line 5883 of file TProof.cxx. ◆ FindDataSets(). TList * TProof::FindDataSets ; (; const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:89819,feedback,feedback,89819,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,Pad. TVirtualPad* TASPaletteEditor::fImagePad. protected . Definition at line 70 of file TASPaletteEditor.h. ◆ fLimitLine. LimitLine* TASPaletteEditor::fLimitLine[2]. protected . Definition at line 72 of file TASPaletteEditor.h. ◆ fMaxValue. Double_t TASPaletteEditor::fMaxValue. protected . max value of image ; Definition at line 63 of file TASPaletteEditor.h. ◆ fMinValue. Double_t TASPaletteEditor::fMinValue. protected . min value of image ; Definition at line 62 of file TASPaletteEditor.h. ◆ fPaintPalette. PaintPalette* TASPaletteEditor::fPaintPalette. protected . Definition at line 71 of file TASPaletteEditor.h. ◆ fPalette. TImagePalette* TASPaletteEditor::fPalette. protected . current palette ; Definition at line 69 of file TASPaletteEditor.h. ◆ fPaletteCanvas. TRootEmbeddedCanvas* TASPaletteEditor::fPaletteCanvas. protected . canvas to draw the current palette ; Definition at line 66 of file TASPaletteEditor.h. ◆ fPaletteList. TList* TASPaletteEditor::fPaletteList. protected . list of palettes for undo and redo ; Definition at line 68 of file TASPaletteEditor.h. ◆ fRampFactor. Int_t TASPaletteEditor::fRampFactor. protected . Definition at line 80 of file TASPaletteEditor.h. ◆ fRamps. TGRadioButton* TASPaletteEditor::fRamps[3]. protected . Definition at line 79 of file TASPaletteEditor.h. ◆ fReDoButton. TGTextButton* TASPaletteEditor::fReDoButton. protected . Definition at line 75 of file TASPaletteEditor.h. ◆ fStepButton. TGCheckButton* TASPaletteEditor::fStepButton. protected . Definition at line 78 of file TASPaletteEditor.h. ◆ fUnDoButton. TGTextButton* TASPaletteEditor::fUnDoButton. protected . Definition at line 74 of file TASPaletteEditor.h. Libraries for TASPaletteEditor:. [legend]; The documentation for this class was generated from the following files:; graf2d/asimage/inc/TASPaletteEditor.h; graf2d/asimage/src/TASPaletteEditor.cxx. TASPaletteEditor. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:15 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPaletteEditor.html:44191,undo,undo,44191,doc/master/classTASPaletteEditor.html,https://root.cern,https://root.cern/doc/master/classTASPaletteEditor.html,1,['undo'],['undo']
Usability,"Pad;; 1083 prevSelObj->ExecuteEvent(kMouseLeave, fEventX, fEventY);; 1084 fEvent = kMouseLeave;; 1085 RunAutoExec();; 1086 ProcessedEvent(kMouseLeave, fEventX, fEventY, prevSelObj); // emit signal; 1087 }; 1088 ; 1089 gPad = fSelectedPad;; 1090 ; 1091 if (fSelected) {; 1092 fSelected->ExecuteEvent(kMouseEnter, fEventX, fEventY);; 1093 fEvent = kMouseEnter;; 1094 RunAutoExec();; 1095 ProcessedEvent(kMouseEnter, fEventX, fEventY, fSelected); // emit signal; 1096 }; 1097 ; 1098 fEvent = sevent;; 1099}; 1100 ; 1101////////////////////////////////////////////////////////////////////////////////; 1102/// Execute action corresponding to one event.; 1103///; 1104/// This member function must be implemented to realize the action; 1105/// corresponding to the mouse click on the object in the canvas; 1106///; 1107/// Only handle mouse motion events in TCanvas, all other events are; 1108/// ignored for the time being; 1109 ; 1110void TCanvas::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1111{; 1112 if (gROOT->GetEditorMode()) {; 1113 TPad::ExecuteEvent(event,px,py);; 1114 return;; 1115 }; 1116 ; 1117 switch (event) {; 1118 ; 1119 case kMouseMotion:; 1120 SetCursor(kCross);; 1121 break;; 1122 }; 1123}; 1124 ; 1125////////////////////////////////////////////////////////////////////////////////; 1126/// Turn rubberband feedback mode on or off.; 1127 ; 1128void TCanvas::FeedbackMode(Bool_t set); 1129{; 1130 if (IsWeb()); 1131 return;; 1132 ; 1133 if (set) {; 1134 SetDoubleBuffer(0); // turn off double buffer mode; 1135 gVirtualX->SetDrawMode(TVirtualX::kInvert); // set the drawing mode to XOR mode; 1136 } else {; 1137 SetDoubleBuffer(1); // turn on double buffer mode; 1138 gVirtualX->SetDrawMode(TVirtualX::kCopy); // set drawing mode back to normal (copy) mode; 1139 }; 1140}; 1141 ; 1142////////////////////////////////////////////////////////////////////////////////; 1143/// Flush canvas buffers.; 1144 ; 1145void TCanvas::Flush(); 1146{; 1147 if ((fCanvasID == -1) || IsWeb()) ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:36257,feedback,feedback,36257,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['feedback'],['feedback']
Usability,"Painter.; Definition at line 463 of file RCanvasPainter.cxx. ◆ ProduceJSON(). std::string RCanvasPainter::ProduceJSON ; (; ). finalvirtual . Produce JSON for the canvas. ; Implements ROOT::Experimental::Internal::RVirtualCanvasPainter.; Definition at line 494 of file RCanvasPainter.cxx. ◆ Run(). void RCanvasPainter::Run ; (; double ; tm = 0.). finalvirtual . Run canvas functionality for specified period of time Required when canvas used not from the main thread. ; Implements ROOT::Experimental::Internal::RVirtualCanvasPainter.; Definition at line 894 of file RCanvasPainter.cxx. ◆ SaveCreatedFile(). void RCanvasPainter::SaveCreatedFile ; (; std::string & ; reply). private . Method called when GUI sends file to save on local disk File data coded with base64 coding beside SVG format. ; Definition at line 827 of file RCanvasPainter.cxx. ◆ SetClearOnClose(). void RCanvasPainter::SetClearOnClose ; (; const std::shared_ptr< void > & ; handle). finalvirtual . Set handle to window which will be cleared when connection is closed. ; Reimplemented from ROOT::Experimental::Internal::RVirtualCanvasPainter.; Definition at line 757 of file RCanvasPainter.cxx. Member Data Documentation. ◆ fCanvas. RCanvas& ROOT::Experimental::RCanvasPainter::fCanvas. private . ! Canvas we are painting, *this will be owned by canvas ; Definition at line 109 of file RCanvasPainter.cxx. ◆ fCmds. std::list<std::shared_ptr<WebCommand> > ROOT::Experimental::RCanvasPainter::fCmds. private . ! list of submitted commands ; Definition at line 114 of file RCanvasPainter.cxx. ◆ fCmdsCnt. uint64_t ROOT::Experimental::RCanvasPainter::fCmdsCnt {0}. private . ! commands counter ; Definition at line 115 of file RCanvasPainter.cxx. ◆ fHelpHandles. std::vector<std::unique_ptr<ROOT::RWebDisplayHandle> > ROOT::Experimental::RCanvasPainter::fHelpHandles. private . ! array of handles for help widgets ; Definition at line 122 of file RCanvasPainter.cxx. ◆ fJsonComp. int ROOT::Experimental::RCanvasPainter::fJsonComp {23}. p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html:11515,clear,cleared,11515,doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvasPainter.html,1,['clear'],['cleared']
Usability,"Palette() any more after a call of this function!. void Slice(UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight); Another method of enlarging images where corners remain unchanged,; but middle part gets tiled. void Tile(UInt_t width, UInt_t height); Tile the original image. void Zoom(UInt_t offX, UInt_t offY, UInt_t width, UInt_t height); The area of an image displayed in a pad is defined by this function.; Note: the size on the screen is defined by the size of the pad.; The original image is not modified by this function.; If width or height is larger than the original image they are reduced to; the width and height of the image.; If the off values are too large (off + width > image width) than the off; values are decreased. For example: offX = image width - width; Note: the parameters are always relative to the original image not to the; size of an already zoomed image. void UnZoom(); Un-zoom the image to original size.; UnZoom() - performs undo for Zoom,Crop,Scale actions. void Flip(Int_t flip = 180); Flip image in place.; Flip is either 90, 180, 270, 180 is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel values would be; destroyed. void Mirror(Bool_t vert = kTRUE); Mirror image in place.; If vert is true mirror in vertical axis, horizontal otherwise.; Vertical is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:27842,undo,undo,27842,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,11,['undo'],['undo']
Usability,"Partitioning Algorithm"" section for details). The partitioning algorithm divides the histogram into regions called cells. The bins that each cell intersects are recorded in an array of TLists. When a coordinate in the histogram is to be filled; the method (quickly) finds which cell the coordinate belongs. It then only loops over the bins intersecting that cell to find the bin the input coordinate corresponds to. The partitioning of the histogram is updated continuously as each bin is added. The default number of cells on each axis is 25. This number could be set to another value in the constructor or adjusted later by calling the ChangePartition(Int_t, Int_t) method. The partitioning algorithm is considerably faster than the brute force algorithm (i.e. checking if each bin contains the input coordinates), especially if the histogram is to be filled many times.; The following very simple macro shows how to build and fill a TH2Poly: {; auto h2p = new TH2Poly();; ; Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; ; h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(5, x3, y3);; ; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; }; Double_tdouble Double_tDefinition RtypesCore.h:59; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TH2Poly::TH2PolyTH2Poly()Default Constructor. No boundaries specified.Definition TH2Poly.cxx:148; double; More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C and th2polyUSA.C. Partitioning Algorithm; The partition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:2740,simpl,simple,2740,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['simpl'],['simple']
Usability,"PaveText(4,11,6,12);; p6->SetTextAlign(12);; p6->SetFillColor(42);; p6->AddText(""10 bytes"");; p6->Draw();; TText text;; text.SetTextAlign(12);; text.SetTextSize(0.04);; text.SetTextFont(72);; text.DrawText(6.2,11.5,""Header:Event_flag"");; text.DrawText(7.2,9.5,""Trigger_Info"");; text.DrawText(8.2,7.5,""Muon_Detector: TOF"");; text.DrawText(9.2,5.5,""Calorimeters"");; text.DrawText(10.2,3.5,""Forward_Detectors"");; text.DrawText(11.2,1.5,""TPCs"");; }; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TTextBase class for several text objects.Definition TText.h:22; lineTLine * lineDefinition entrylistblock_figure1.C:235; c1return c1Definition legend1.C:41; arrowDefinition RArrowDS.hxx:17; AuthorRene Brun ; Definition in file event.C. tutorialsgraphicsevent.C. ROOT master - Refere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/event_8C.html:2747,simpl,simple,2747,doc/master/event_8C.html,https://root.cern,https://root.cern/doc/master/event_8C.html,1,['simpl'],['simple']
Usability,"Pdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysReuseNLL(Bool_t flag); { fgAlwaysReuseNll = flag ; }. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void EnableDetailedOutput(bool e = true); { fDetailedOutputEnabled = e; fDetailedOutput = NULL; }. const RooArgSet* GetDetailedOutput(void); { return fDetailedOutput; }. const TString GetVarName() const. » Author: Kyle Cranmer and Sven Kreiss June 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleLikelihoodRatioTestStat.html:2558,Simpl,SimpleLikelihoodRatioTestStat,2558,root/html602/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleLikelihoodRatioTestStat.html,2,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"Pdf::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . If all components that depend on obs are binned, so is their sum. ; Reimplemented from RooAbsReal.; Definition at line 929 of file RooAddPdf.cxx. ◆ materializeRefCoefNormFromAttribute(). void RooAddPdf::materializeRefCoefNormFromAttribute ; (; ); const. private . Definition at line 345 of file RooAddPdf.cxx. ◆ pdfList(). const RooArgList & RooAddPdf::pdfList ; (; ); const. inline . Definition at line 70 of file RooAddPdf.h. ◆ plotSamplingHint(). std::list< double > * RooAddPdf::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Loop over components for plot sampling hints and merge them if there are multiple. ; Reimplemented from RooAbsReal.; Definition at line 912 of file RooAddPdf.cxx. ◆ printMetaArgs(). void RooAddPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 949 of file RooAddPdf.cxx. ◆ redirectServersHook(). bool RooAddPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . The cache manager. ; Hook function intercepting redirectServer calls.; Discard current normalization object if any server is redirected ; Reimplemented from RooAbsPdf.; Definition at line 955 of file RooAddPdf.cxx. ◆ resetErrorCounters(). void RooAddPdf::resetErrorCounters ; (; Int_t ; resetValue = 10). overridevirtual . Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ; Reimplemented from RooAbsPdf.; Definition at line 602 of file RooAddPdf.cxx. ◆ selectNormalization(). void RooAddPdf::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:91710,intuit,intuitively,91710,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['intuit'],['intuitively']
Usability,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:29421,learn,learning,29421,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['learn'],['learning']
Usability,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCondor.html:6915,Resume,Resume,6915,root/html534/TCondor.html,https://root.cern,https://root.cern/root/html534/TCondor.html,2,['Resume'],['Resume']
Usability,"Picture* bpic = 0, const TGPicture* blpic = 0, const TGPicture* spic = 0, const TGPicture* slpic = 0, TGString* name = 0, Int_t type = 0, Long64_t size = 1, Int_t uid = 0, Int_t gid = 0, Long_t modtime = 0, EListViewMode viewMode = kLVList, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); virtual~TGFileItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLVEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFileItem.html:1729,Clear,Clear,1729,root/html532/TGFileItem.html,https://root.cern,https://root.cern/root/html532/TGFileItem.html,2,['Clear'],['Clear']
Usability,"Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& ). TGViewPort * GetViewPort() const; { return fVport; }. Int_t GetScrolling() const; { return fScrolling; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGCanvas.html:20903,Clear,ClearViewPort,20903,root/html604/TGCanvas.html,https://root.cern,https://root.cern/root/html604/TGCanvas.html,2,['Clear'],"['Clear', 'ClearViewPort']"
Usability,"Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& ). TGViewPort * GetViewPort() const; { return fVport; }. Int_t GetScrolling() const; { return fScrolling; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-04 16:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGCanvas.html:19976,Clear,ClearViewPort,19976,root/html534/TGCanvas.html,https://root.cern,https://root.cern/root/html534/TGCanvas.html,2,['Clear'],"['Clear', 'ClearViewPort']"
Usability,"Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& ). TGViewPort * GetViewPort() const; { return fVport; }. Int_t GetScrolling() const; { return fScrolling; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGCanvas.html:20903,Clear,ClearViewPort,20903,root/html602/TGCanvas.html,https://root.cern,https://root.cern/root/html602/TGCanvas.html,2,['Clear'],"['Clear', 'ClearViewPort']"
Usability,PointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:8757,simpl,simply,8757,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['simpl'],['simply']
Usability,"Pointer_t parent, const char* comment); Bool_tAddDocComment(XMLDocPointer_t xmldoc, const char* comment); Bool_tAddDocRawLine(XMLDocPointer_t xmldoc, const char* line); Bool_tAddDocStyleSheet(XMLDocPointer_t xmldoc, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); voidAddNodeContent(XMLNodePointer_t xmlnode, const char* content, Int_t len = 0); Bool_tAddRawLine(XMLNodePointer_t parent, const char* line); Bool_tAddStyleSheet(XMLNodePointer_t parent, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); voidAssignDtd(XMLDocPointer_t xmldoc, const char* dtdname, const char* rootname); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanNode(XMLNodePointer_t xmlnode); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); XMLNodePointer_tDocGetRootElement(XMLDocPointer_t xmldoc); voidDocSetRootElement(XMLDocPointer_t xmldoc, XMLNodePointer_t xmlnode); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLEngine.html:1941,Clear,Clear,1941,root/html534/TXMLEngine.html,https://root.cern,https://root.cern/root/html534/TXMLEngine.html,3,['Clear'],['Clear']
Usability,"Product(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Mon Jul 4 15:23:44 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProduct.html:34894,intuit,intuitively,34894,root/html530/RooProduct.html,https://root.cern,https://root.cern/root/html530/RooProduct.html,1,['intuit'],['intuitively']
Usability,"Product(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Oct 9 20:48:34 2010 » Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProduct.html:34377,intuit,intuitively,34377,root/html528/RooProduct.html,https://root.cern,https://root.cern/root/html528/RooProduct.html,1,['intuit'],['intuitively']
Usability,"ProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfSmartRefresh; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveScene(const char* n = ""TEveScene"", const char* t = """"); Constructor. TEveScene(TGLScenePad* gl_scene, const char* n = ""TEveScene"", const char* t = """"); Constructor. ~TEveScene(); Destructor. void CollectSceneParents(TEveElement::List_t& scenes); Virtual from TEveElement; here we simply append this scene to; the list. void Repaint(Bool_t dropLogicals = kFALSE); Repaint the scene. void RetransHierarchically(); Entry point for hierarchical transformation update.; Calls the recursive variant on all children. void RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp); Set transformation matrix for physical shape of element el in; the GL-scene and recursively descend into children (if enabled). void SetName(const char* n); Set scene's name. void Paint(Option_t* option = """"); Paint the scene. Iterate over children and calls PadPaint(). void DestroyElementRenderers(TEveElement* element); Remove element from the scene.; It is not an error if the element is not found in the scene. void DestroyElementRenderers(TObject* rnrObj); Remove element represented by object rnrObj from the scene.; It is not an error if the element is not found in the scene. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return icon for scene. TEveSce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveScene.html:20697,simpl,simply,20697,root/html534/TEveScene.html,https://root.cern,https://root.cern/root/html534/TEveScene.html,2,['simpl'],['simply']
Usability,"Projection* p) const; virtual voidPropagateMainColor(Color_t color, Color_t old_color); virtual voidPropagateMainTransparency(Char_t t, Char_t old_t); virtual voidPropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); virtual voidPropagateVizParams(TEveElement* el = 0); virtual voidRemoveProjected(TEveProjected* p); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TEveProjectable&operator=(const TEveProjectable&). Data Members; protected:. list<TEveProjected*>fProjectedListreferences to projected instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjectable(); Destructor.; Force projected replicas to unreference *this, then destroy them. void AnnihilateProjecteds(); Optimized destroy of projected elements with condition; there is only one parent for projected element. Method is; called from TEveElement::Annihilate(). void ClearProjectedList(). void AddProjectedsToSet(set<TEveElement*>& set); Add the projected elements to the set, dyn-casting them to; TEveElement. void PropagateVizParams(TEveElement* el = 0); Set visualization parameters of projecteds.; Use element el as model. If el == 0 (default), this casted to; TEveElement is used. void PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); Set render state of projecteds. void PropagateMainColor(Color_t color, Color_t old_color); Set main color of projecteds if their color is the same as old_color. void PropagateMainTransparency(Char_t t, Char_t old_t); Set main transparency of projecteds if their transparecy is the; same as the old one. TEveProjectable& operator=(const TEveProjectable& ). TClass* ProjectedClass(const TEveProjection* p) const. Bool_t HasProjecteds() const; { return ! fProjectedList.empty(); }. ProjList_i BeginProjecteds(); { return fProjectedList.begin(); }. ProjList_i EndProjecteds(); { return fProjectedList.end(); }. void AddProjected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveProjectable.html:2223,Clear,ClearProjectedList,2223,root/html534/TEveProjectable.html,https://root.cern,https://root.cern/root/html534/TEveProjectable.html,1,['Clear'],['ClearProjectedList']
Usability,"Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia6 Interface to Pythia6.1 Event Generator; TPythia6Decayer Particle Decayer Base Class; TPythia8 Interface class of Pythia8; TPythia8Decayer Particle Decayer using Pythia8; TPython Access to the python interpreter; TQClass Class with connections; TQCommand encapsulates the information for undo/redo a single action.; TQConnection Internal class used in the object communication mechanism; TQObjSender Used to ""delegate"" TQObject functionality; TQObject Base class for object communication mechanism; TQUndoManager recorder of operations for undo and redo; TQpDataBase Qp Base Data class; TQpDataDens Qp Data class for Dens formulation; TQpDataSparse Qp Data class for Sparse formulation; TQpLinSolverBase Qp linear solver base class; TQpLinSolverDens Qp linear solver class for Dens formulation; TQpLinSolverSparse Qp linear solver class for Sparse formulation; TQpProbBase Qp problem formulation base class; TQpProbDens Qp dens problem formulation class; TQpProbSparse Qp sparse problem formulation class; TQpResidual Qp Residual class; TQpSolverBase Qp Solver class; TQpVar Qp Variables class; TQuaternion a quaternion class; TQueryDescription Query description; TQue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:118729,undo,undo,118729,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['undo'],['undo']
Usability,"ProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame; static TProofProgressLog::ETextTypekGrep; static TProofProgressLog::ETextTypekRaw; static TProofProgressLog::ETextTypekStd. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:25318,Clear,Clear,25318,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,4,['Clear'],['Clear']
Usability,"ProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42013,feedback,feedback,42013,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,ProofProgressStatus::SetBytesRead ; (; Long64_t ; bytesRead). inline . Definition at line 60 of file TProofProgressStatus.h. ◆ SetCPUTime(). void TProofProgressStatus::SetCPUTime ; (; Double_t ; procTime). inline . Definition at line 67 of file TProofProgressStatus.h. ◆ SetEntries(). void TProofProgressStatus::SetEntries ; (; Long64_t ; entries). inline . Definition at line 57 of file TProofProgressStatus.h. ◆ SetLastEntries(). void TProofProgressStatus::SetLastEntries ; (; Long64_t ; entries). inline . Definition at line 56 of file TProofProgressStatus.h. ◆ SetLastProcTime(). void TProofProgressStatus::SetLastProcTime ; (; Double_t ; procTime). inline . Definition at line 64 of file TProofProgressStatus.h. ◆ SetLastUpdate(). void TProofProgressStatus::SetLastUpdate ; (; Double_t ; updtTime = 0). Update time stamp either with the passed value (if > 0) or with the current time. ; Definition at line 104 of file TProofProgressStatus.cxx. ◆ SetLearnTime(). void TProofProgressStatus::SetLearnTime ; (; Double_t ; learnTime). inline . Definition at line 63 of file TProofProgressStatus.h. ◆ SetProcTime(). void TProofProgressStatus::SetProcTime ; (; Double_t ; procTime). inline . Definition at line 65 of file TProofProgressStatus.h. ◆ SetReadCalls(). void TProofProgressStatus::SetReadCalls ; (; Long64_t ; readCalls). inline . Definition at line 62 of file TProofProgressStatus.h. ◆ Streamer(). void TProofProgressStatus::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TProofProgressStatus::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file TProofProgressStatus.h. Member Data Documentation. ◆ fBytesRead. Long64_t TProofProgressStatus::fBytesRead. private . Definition at line 33 of file TProofProgressStatus.h. ◆ fCPUTime. Double_t TProofProgressStatus::fCPUTime. private . Definition at line 38 of file TProofProgressStatus.h. ◆ fEntrie,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressStatus.html:17206,learn,learnTime,17206,doc/master/classTProofProgressStatus.html,https://root.cern,https://root.cern/doc/master/classTProofProgressStatus.html,1,['learn'],['learnTime']
Usability,"Prop = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:2068,clear,clearShapeDirty,2068,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['clear'],['clearShapeDirty']
Usability,"Prop = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:2068,clear,clearShapeDirty,2068,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,2,['clear'],['clearShapeDirty']
Usability,"QObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGProgressBar.h>. Inheritance diagram for TGHProgressBar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGHProgressBar() [1/2]. TGHProgressBar::TGHProgressBar ; (; const TGWindow * ; p = nullptr, . UInt_t ; w = 4, . UInt_t ; h = kProgressBarTextWidth, . Pixel_t ; back = GetWhitePixel(), . Pixel_t ; barcolor = GetDefaultSelectedBackground(), . GContext_t ; norm = GetDefaultGC()(), . FontStruct_t ; font = GetDefaultFontStruct(), . UInt_t ; options = kDoubleBorder | kSunkenFrame . ). Horizontal progress bar constructor. ; Definition at line 223 of file TGProgressBar.cxx. ◆ TGHProgressBar() [2/2]. TGHProgressBar::TGHProgressBar ; (; const TGWindow * ; p, . EBarType ; type, . UInt_t ; w . ). Simple constructor allow you to create either a standard progress bar, or a more fancy progress bar (fancy means: double sized border, white background and a bit wider to allow for text to be printed in the bar. ; Definition at line 238 of file TGProgressBar.cxx. ◆ ~TGHProgressBar(). TGHProgressBar::~TGHProgressBar ; (; ). inlineoverride . Definition at line 108 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGHProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGHProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGHProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 118 of file TGProgressBar.h. ◆ DeclFileName(). static const char * TGHProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGProgressBar.h. ◆ DoRedraw(). void TGHProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw hori",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:32049,progress bar,progress bar,32049,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"Quartz graphics backend (MacOS X only). davix; *; DavIx library for HTTP/WEBDAV access. dcache; ON; dCache support, requires libdcap from DESY. exceptions; ON; Turn on compiler exception handling capability. explicit link; *; Explicitly link with all dependent libraries. fail-on-missing; OFF; Fail the configure step if a required external package is missing. fftw3; ON; Fast Fourier Transform support, requires libfftw3. fitsio; ON; Read images and data from FITS files, requires cfitsio. fortran; *; Enable the Fortran components of ROOT. gdml; *; GDML writer and reader. geocad; OFF; ROOT-CAD Interface. genvector; ON; Build the new libGenVector library. gfal; ON; GFAL support, requires libgfal. glite; ON; gLite support, requires libglite-api-wrapper v.3 from GSI (https://subversion.gsi.de/trac/dgrid/wiki). globus; OFF; Globus authentication support, requires Globus toolkit. gminimal; OFF; Do not automatically search for support libraries, but include X11. gnuinstall; OFF; Perform installation following the GNU guidelines. gsl_shared; OFF; Enable linking against shared libraries for GSL (default no). gviz; ON; Graphs visualization support, requires graphviz. hdfs; ON; HDFS support; requires libhdfs from HDFS >= 0.19.1. http; *; HTTP Server support. imt; ON; Enable ROOT Multithreading Capabilities (default ON from version 6.10). jemalloc; OFF; Using the jemalloc allocator. krb5; ON; Kerberos5 support, requires Kerberos libs. ldap; ON; LDAP support, requires (Open)LDAP libs. mathmore; ON; Build the new libMathMore extended math library, requires GSL (vers. >= 1.8). memstat; *; A memory statistics utility, helps to detect memory leaks. minimal; OFF; Do not automatically search for support libraries. minuit2; *; Build the new libMinuit2 minimizer library. monalisa; ON; Monalisa monitoring support, requires libapmoncpp. mt; OFF; Multi-threading support (deprecated and unused since ROOT v6.12). mysql; ON; MySQL support, requires libmysqlclient. odbc; ON; ODBC support, require",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:10042,guid,guidelines,10042,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['guid'],['guidelines']
Usability,"QueryDefault; static TProofProgressDialog::EQueryStatuskAborted; static TProofProgressDialog::EQueryStatuskDone; static TProofProgressDialog::EQueryStatuskIncomplete; static TProofProgressDialog::EQueryStatuskRunning; static TProofProgressDialog::EQueryStatuskStopped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:4144,progress bar,progress bar,4144,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,"QueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; virtual void ShowCache (Bool_t all=kFALSE);  List contents of file cache. ;  ; virtual void ShowData ();  List contents of the data directory in the sandbox. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; virtual void ShowDataSetCache (const char *dataset=0);  Display the content of the dataset cache, if any (matching 'dataset', if defined). ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; virtual void ShowDataSets (const char *uri="""", const char *optStr="""");  Shows datasets in locations that match the uri. ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALSE);  List contents of package directory. ;  ; void ShowParameters (const char *wildcard=""PROOF_*"") const;  Show the input list parameters specified by the wildcard. ;  ; void ShowQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; virtual void ShowStagingStatusDataSet (const char *dataset, const char *optStr=""filter:SsCc"");  Like GetStagingStatusDataSet, but displays results immediately. ;  ; void StartupMessage (const char *msg, Bool_t status, Int_t done, Int_t total);  Send startup message. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:20065,feedback,feedback,20065,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"R of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:59932,clear,clearEvalErrorLog,59932,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"R of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:56013,clear,clearEvalErrorLog,56013,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,52,['clear'],['clearEvalErrorLog']
Usability,"RATOR > ; void add (ITERATOR itBegin, ITERATOR itEnd);  ; template<typename T > ; void add (T value, double weight=1.0);  ; void clear ();  ; int count () const;  ; double mean () const;  ; double stdDev () const;  ; double stdDev_corr () const;  ; double var () const;  ; double var_corr () const;  ; double weights () const;  . Private Attributes; double m_mean;  ; size_t m_n;  ; double m_squared;  ; double m_sumWeights;  . #include <TMVA/NeuralNet.h>; Constructor & Destructor Documentation. ◆ MeanVariance(). TMVA::DNN::MeanVariance::MeanVariance ; (; ). inline . Definition at line 77 of file NeuralNet.h. Member Function Documentation. ◆ add() [1/2]. template<typename ITERATOR > . void TMVA::DNN::MeanVariance::add ; (; ITERATOR ; itBegin, . ITERATOR ; itEnd . ). inline . Definition at line 116 of file NeuralNet.h. ◆ add() [2/2]. template<typename T > . void TMVA::DNN::MeanVariance::add ; (; T ; value, . double ; weight = 1.0 . ). inline . Definition at line 93 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::MeanVariance::clear ; (; ). inline . Definition at line 84 of file NeuralNet.h. ◆ count(). int TMVA::DNN::MeanVariance::count ; (; ); const. inline . Definition at line 124 of file NeuralNet.h. ◆ mean(). double TMVA::DNN::MeanVariance::mean ; (; ); const. inline . Definition at line 126 of file NeuralNet.h. ◆ stdDev(). double TMVA::DNN::MeanVariance::stdDev ; (; ); const. inline . Definition at line 145 of file NeuralNet.h. ◆ stdDev_corr(). double TMVA::DNN::MeanVariance::stdDev_corr ; (; ); const. inline . Definition at line 144 of file NeuralNet.h. ◆ var(). double TMVA::DNN::MeanVariance::var ; (; ); const. inline . Definition at line 127 of file NeuralNet.h. ◆ var_corr(). double TMVA::DNN::MeanVariance::var_corr ; (; ); const. inline . Definition at line 136 of file NeuralNet.h. ◆ weights(). double TMVA::DNN::MeanVariance::weights ; (; ); const. inline . Definition at line 125 of file NeuralNet.h. Member Data Documentation. ◆ m_mean. double TMVA::DNN::MeanVaria",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1MeanVariance.html:1375,clear,clear,1375,doc/master/classTMVA_1_1DNN_1_1MeanVariance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1MeanVariance.html,1,['clear'],['clear']
Usability,"RDF::RInterfaceBase::GetNFilesunsigned int GetNFiles()Definition RInterfaceBase.cxx:27; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::BookRResultPtr< typename std::decay_t< Helper >::Result_t > Book(Helper &&helper, const ColumnNames_t &columns={})Book execution of a custom action using a user-defined helper object.Definition RInterface.hxx:2984; ROOT::RDF::RResultHandleA type-erased version of RResultPtr and RResultMap.Definition RResultHandle.hxx:33; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::Foreachvoid Foreach(F func, unsigned nTimes, unsigned nChunks=0)Execute a function without arguments several times in parallel, dividing the execution in nChunks.Definition TThreadExecutor.hxx:146; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::RealTimeDouble_t RealTime()Stop the stopwatch (if it is running) and return the realtime (in seconds) passed between the start a...Definition TStopwatch.cxx:110; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::CpuTimeDouble_t CpuTime()Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start an...Definition TStopwatch.cxx:125; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8cxx_source.html:21162,simpl,simple,21162,doc/master/RDFHelpers_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html,1,['simpl'],['simple']
Usability,"RNTupleWriter.hxx:138; ROOT::Experimental::RNTupleWriter::GetLastCommittedClusterGroupNTupleSize_t GetLastCommittedClusterGroup() constReturn the entry number that was last committed in a cluster group.Definition RNTupleWriter.hxx:133; ROOT::Experimental::RNTupleWriter::fZipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasksThe page sink's parallel page compression scheduler if IMT is on.Definition RNTupleWriter.hxx:68; ROOT::Experimental::RNTupleWriter::FillNoFlushvoid FillNoFlush(REntry &entry, RNTupleFillStatus &status)Fill an entry into this ntuple, but don't commit the cluster.Definition RNTupleWriter.hxx:112; ROOT::Experimental::RNTupleWriter::GetModelconst RNTupleModel & GetModel() constDefinition RNTupleWriter.hxx:140; ROOT::Experimental::RNTupleWriter::FlushColumnsvoid FlushColumns()Flush column data, preparing for CommitCluster or to reduce memory usage.Definition RNTupleWriter.hxx:115; ROOT::Experimental::RNTupleWriter::Fillstd::size_t Fill()The simplest user interface if the default entry that comes with the ntuple model is used.Definition RNTupleWriter.hxx:105; ROOT::Experimental::RNTupleWriter::GetLastFlushedNTupleSize_t GetLastFlushed() constReturn the entry number that was last flushed in a cluster.Definition RNTupleWriter.hxx:129; ROOT::Experimental::RNTupleWriter::CreateEntrystd::unique_ptr< REntry > CreateEntry()Definition RNTupleWriter.hxx:126; ROOT::Experimental::RNTupleWriter::Createstatic std::unique_ptr< RNTupleWriter > Create(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::GetUpdatableModelRNTupleModel & GetUpdatableModel()Definition RNTupleWriter.hxx:76; ROOT::Experimental::RNTupleWriter::GetLastCommittedNTupleSize_t GetLastCommitted() constReturn the entry number that was last committed in a cluster.Definition RNTupleW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:12621,simpl,simplest,12621,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['simpl'],['simplest']
Usability,"RN_MSG(loc, str)Definition Error.h:80; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; ROOT::Fit::DataRange::GetInfRangestatic void GetInfRange(double &x1, double &x2)Definition DataRange.cxx:182; ROOT::Fit::DataRange::RangeSetstd::vector< std::pair< double, double > > RangeSetDefinition DataRange.h:39; ROOT::Fit::DataRange::fRangesRangeIntervals fRangeslist of all rangesDefinition DataRange.h:232; ROOT::Fit::DataRange::CleanRangeSetvoid CleanRangeSet(unsigned int icoord, double xmin, double xmax)internal function to remove all the existing ranges between xmin and xmax called when a new range is ...Definition DataRange.cxx:165; ROOT::Fit::DataRange::IsInsidebool IsInside(double x, unsigned int icoord=0) constcheck if a point is inside the range for the given coordinateDefinition DataRange.cxx:146; ROOT::Fit::DataRange::Clearvoid Clear(unsigned int icoord=0)clear all ranges in one coordinate (is now -inf, +inf)Definition DataRange.cxx:158; ROOT::Fit::DataRange::AddRangevoid AddRange(unsigned int icoord, double xmin, double xmax)add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one,...Definition DataRange.cxx:94; ROOT::Fit::DataRange::DataRangeDataRange(unsigned int dim=1)Default constructor (infinite range)Definition DataRange.h:45; ROOT::Fit::DataRange::Sizeunsigned int Size(unsigned int icoord=0) constreturn range size for coordinate icoord (starts from zero) Size == 0 indicates no range is present [-...Definition DataRange.h:71; ROOT::Fit::DataRange::operator()std::pair< double, double > operator()(unsigned int icoord=0, unsigned int irange=0) constreturn the i-th range for the coordinate icoord.Definition DataRange.cxx:78; ROOT::Fit::DataRange::SetRangevoid SetRange(unsigned int icoord, double xmin, double xmax)set a range [xmin,xmax] for the new coordinate icoord If more range exists for other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataRange_8cxx_source.html:7218,clear,clear,7218,doc/master/DataRange_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataRange_8cxx_source.html,1,['clear'],['clear']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . . Getting Started. . Reference Guide. . Forum. . Gallery.  ; ROOT is ...; A modular scientific software toolkit. It provides all the functionalities needed to deal with big data processing, statistical analysis, visualisation and storage. It is mainly written in C++ but integrated with other languages such as Python and R.Start from examples or try it in your brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/index.html:1218,guid,guidelines,1218,d/index.html,https://root.cern,https://root.cern/d/index.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome About ROOT. ROOT is a framework for data processing, born at CERN, at the heart of the research on high-energy physics. Every day, thousands of physicists use ROOT applications to analyze their data or to perform simulations. With ROOT you can:. Save data You can save your data (and any C++ object) in a compressed binary form in a ROOT file. The ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:1198,guid,guidelines,1198,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Development. The links in this menu and in the block on your right are intended for the ROOT developers and for people who want to contribute to the ROOT system. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sign in. Sitemap. DownloadDownload ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/development.html:1199,guid,guidelines,1199,d/development.html,https://root.cern,https://root.cern/d/development.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Documentation. ROOT provides different types of documentation:. The Reference Guide, which is generated by doxygen provides an up-to-date full code documentation. This is mainly for software developers of ROOT and using ROOT to build the applications.; A general Users Guide is provided for a more in depth explanation of concepts and functionality a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/documentation.html:1201,guid,guidelines,1201,d/documentation.html,https://root.cern,https://root.cern/d/documentation.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome First Steps With ROOT. The ROOT framework provides a number of classes, grouped into several class cathegories. To start using ROOT, you may find useful to browse the following documents:. Processing data with ROOT (to learn about the interactive and batch use of ROOT); Analyzing data with ROOT (about histograms and trees; mathematical and statisti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/first-steps-root-1.html:1209,guid,guidelines,1209,d/first-steps-root-1.html,https://root.cern,https://root.cern/d/first-steps-root-1.html,2,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome How to create a ROOTbook?. ROOT 6.07 Onwards; The minimal version of Jupyter required in this case is 4.0.; Note that the sudo command might not be necessary on some platforms.; Provided that ROOT is installed on your machine, these are the steps to follow to use a ROOT-flavoured C++ notebook:; # Install dependencies; sudo pip install jupyter metak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how/how-create-rootbook.html:1213,guid,guidelines,1213,d/how/how-create-rootbook.html,https://root.cern,https://root.cern/d/how/how-create-rootbook.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome News. 02-02-2019 ; Full Totem Analysis based on RDataFrame and distributed on a big Spark cluster with PyRDF! ; Milosz Blaszkiewicz and Aleksandra Mnich (AGH University of Science and Technology - Poland) wanted to evaluate a set of Big Data tools for the analysis of the data from the TOTEM experiment which will enable interactive or semi-interacti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/news.html:1192,guid,guidelines,1192,d/news.html,https://root.cern,https://root.cern/d/news.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome ROOT 6 Analysis Workshop. Abstract; This tutorial will guide you through an example analysis with ROOT 6. It shows the recommended practices for analyzing data stored in ROOT TTrees - the most common format for High Energy Physics data.; It requires ROOT 6 as it uses several of its features.; . 0. Setting up ROOT ›. Navigate through this book; 0. S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-6-analysis-workshop-1.html:1212,guid,guidelines,1212,d/root-6-analysis-workshop-1.html,https://root.cern,https://root.cern/d/root-6-analysis-workshop-1.html,2,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Support. Top level support is what makes ROOT a success. We do our utmost to solve any issues as soon as possible. To make this task as efficient as possible for us follow these few simple rules. In case you think you have found a bug, please first search the forum and roottalk digests to see if the issue has already been discussed. If not then ple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/support.html:1195,guid,guidelines,1195,d/support.html,https://root.cern,https://root.cern/d/support.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Contact Us. You can contact the ROOT developers in the following ways, in order of preference:. Via the RootTalk web forum. Use this forum to post your questions. ROOT team members are actively reading this forum and answering the questions. And if the developers don't happen to be online your question might be answered by a fellow user. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/contact-us.html:1198,guid,guidelines,1198,d/contact-us.html,https://root.cern,https://root.cern/d/contact-us.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About License. The ROOT system is being made available under the LGPL 2.1 or (at your option) any later version, which allows ROOT to be used in a wide range of open and closed environments. The LGPL is copied verbatim below.; The optional MathMore library uses the GSL library which is licensed under the GPL and hence the MathMore library is only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:1195,guid,guidelines,1195,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['guid'],['guidelines']
Usability,"ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git PrimerCreating a Pull Request; A suggested work flow for distributed projects: NoSY; Git How Tos; Git Tips and Tricks; Github ssh key. Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. . Enter your keywords . ; View the results at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Previous Developers. The following people have been working on ROOT for some time in their career and ROOT would not be what it is without their contributions:; Andrei Gheata; Andrei works since 2001 in the offline group of the ALICE experiment. He is an experimental nuclear physicist who worked before ALICE on data analysis for heavy-ion e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:1207,guid,guidelines,1207,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['guid'],['guidelines']
